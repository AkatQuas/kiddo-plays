{
  "version": 3,
  "sources": ["../../../../../../front_end/core/protocol_client/InspectorBackend.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport {NodeURL} from './NodeURL.js';\nimport type * as Platform from '../platform/platform.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport const DevToolsStubErrorCode = -32015;\n// TODO(dgozman): we are not reporting generic errors in tests, but we should\n// instead report them and just have some expected errors in test expectations.\nconst GenericError = -32000;\nconst ConnectionClosedErrorCode = -32001;\n\ntype MessageParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any,\n};\n\ntype ProtocolDomainName = ProtocolProxyApi.ProtocolDomainName;\n\nexport interface MessageError {\n  code: number;\n  message: string;\n  data?: string|null;\n}\n\nexport type Message = {\n  sessionId?: string,\n  url?: Platform.DevToolsPath.UrlString,\n  id?: number,\n  error?: MessageError|null,\n  result?: Object|null,\n  method?: QualifiedName,\n  params?: MessageParams|null,\n};\n\ninterface EventMessage extends Message {\n  method: QualifiedName;\n  params?: MessageParams|null;\n}\n\n/** A qualified name, e.g. Domain.method */\nexport type QualifiedName = string&{qualifiedEventNameTag: string | undefined};\n/** A qualified name, e.g. method */\nexport type UnqualifiedName = string&{unqualifiedEventNameTag: string | undefined};\n\nexport const splitQualifiedName = (string: QualifiedName): [string, UnqualifiedName] => {\n  const [domain, eventName] = string.split('.');\n  return [domain, eventName as UnqualifiedName];\n};\n\nexport const qualifyName = (domain: string, name: UnqualifiedName): QualifiedName => {\n  return `${domain}.${name}` as QualifiedName;\n};\n\ntype EventParameterNames = Map<QualifiedName, string[]>;\ntype ReadonlyEventParameterNames = ReadonlyMap<QualifiedName, string[]>;\n\ninterface CommandParameter {\n  name: string;\n  type: string;\n  optional: boolean;\n}\n\ntype Callback = (error: MessageError|null, arg1: Object|null) => void;\n\ninterface CallbackWithDebugInfo {\n  callback: Callback;\n  method: string;\n}\n\nexport class InspectorBackend {\n  readonly agentPrototypes: Map<ProtocolDomainName, _AgentPrototype> = new Map();\n  #initialized: boolean = false;\n  #eventParameterNamesForDomain = new Map<ProtocolDomainName, EventParameterNames>();\n\n  private getOrCreateEventParameterNamesForDomain(domain: ProtocolDomainName): EventParameterNames {\n    let map = this.#eventParameterNamesForDomain.get(domain);\n    if (!map) {\n      map = new Map();\n      this.#eventParameterNamesForDomain.set(domain, map);\n    }\n    return map;\n  }\n\n  getOrCreateEventParameterNamesForDomainForTesting(domain: ProtocolDomainName): EventParameterNames {\n    return this.getOrCreateEventParameterNamesForDomain(domain);\n  }\n\n  getEventParamterNames(): ReadonlyMap<ProtocolDomainName, ReadonlyEventParameterNames> {\n    return this.#eventParameterNamesForDomain;\n  }\n\n  static reportProtocolError(error: string, messageObject: Object): void {\n    console.error(error + ': ' + JSON.stringify(messageObject));\n  }\n\n  static reportProtocolWarning(error: string, messageObject: Object): void {\n    console.warn(error + ': ' + JSON.stringify(messageObject));\n  }\n\n  isInitialized(): boolean {\n    return this.#initialized;\n  }\n\n  private agentPrototype(domain: ProtocolDomainName): _AgentPrototype {\n    let prototype = this.agentPrototypes.get(domain);\n    if (!prototype) {\n      prototype = new _AgentPrototype(domain);\n      this.agentPrototypes.set(domain, prototype);\n    }\n    return prototype;\n  }\n\n  registerCommand(method: QualifiedName, parameters: CommandParameter[], replyArgs: string[]): void {\n    const [domain, command] = splitQualifiedName(method);\n    this.agentPrototype(domain as ProtocolDomainName).registerCommand(command, parameters, replyArgs);\n    this.#initialized = true;\n  }\n\n  registerEnum(type: QualifiedName, values: Object): void {\n    const [domain, name] = splitQualifiedName(type);\n    // @ts-ignore globalThis global namespace pollution\n    if (!globalThis.Protocol[domain]) {\n      // @ts-ignore globalThis global namespace pollution\n      globalThis.Protocol[domain] = {};\n    }\n\n    // @ts-ignore globalThis global namespace pollution\n    globalThis.Protocol[domain][name] = values;\n    this.#initialized = true;\n  }\n\n  registerEvent(eventName: QualifiedName, params: string[]): void {\n    const domain = eventName.split('.')[0];\n    const eventParameterNames = this.getOrCreateEventParameterNamesForDomain(domain as ProtocolDomainName);\n    eventParameterNames.set(eventName, params);\n    this.#initialized = true;\n  }\n}\n\nlet connectionFactory: () => Connection;\n\nexport class Connection {\n  onMessage!: ((arg0: Object) => void)|null;\n  constructor() {\n  }\n\n  setOnMessage(_onMessage: (arg0: (Object|string)) => void): void {\n  }\n\n  setOnDisconnect(_onDisconnect: (arg0: string) => void): void {\n  }\n\n  sendRawMessage(_message: string): void {\n  }\n\n  disconnect(): Promise<void> {\n    throw new Error('not implemented');\n  }\n\n  static setFactory(factory: () => Connection): void {\n    connectionFactory = factory;\n  }\n\n  static getFactory(): () => Connection {\n    return connectionFactory;\n  }\n}\n\ntype SendRawMessageCallback = (...args: unknown[]) => void;\n\nexport const test = {\n  /**\n   * This will get called for every protocol message.\n   * ProtocolClient.test.dumpProtocol = console.log\n   */\n  dumpProtocol: null as ((arg0: string) => void) | null,\n\n  /**\n   * Runs a function when no protocol activity is present.\n   * ProtocolClient.test.deprecatedRunAfterPendingDispatches(() => console.log('done'))\n   */\n  deprecatedRunAfterPendingDispatches: null as ((arg0: () => void) => void) | null,\n\n  /**\n   * Sends a raw message over main connection.\n   * ProtocolClient.test.sendRawMessage('Page.enable', {}, console.log)\n   */\n  sendRawMessage: null as ((method: QualifiedName, args: Object|null, arg2: SendRawMessageCallback) => void) | null,\n\n  /**\n   * Set to true to not log any errors.\n   */\n  suppressRequestErrors: false as boolean,\n\n  /**\n   * Set to get notified about any messages sent over protocol.\n   */\n  onMessageSent: null as\n          ((message: {domain: string, method: string, params: Object, id: number, sessionId?: string},\n            target: TargetBase|null) => void) |\n      null,\n\n  /**\n   * Set to get notified about any messages received over protocol.\n   */\n  onMessageReceived: null as ((message: Object, target: TargetBase|null) => void) | null,\n};\n\nconst LongPollingMethods = new Set<string>(['CSS.takeComputedStyleUpdates']);\n\nexport class SessionRouter {\n  readonly #connectionInternal: Connection;\n  #lastMessageId: number;\n  #pendingResponsesCount: number;\n  readonly #pendingLongPollingMessageIds: Set<number>;\n  readonly #sessions: Map<string, {\n    target: TargetBase,\n    callbacks: Map<number, CallbackWithDebugInfo>,\n    proxyConnection: ((Connection | undefined)|null),\n  }>;\n  #pendingScripts: (() => void)[];\n\n  constructor(connection: Connection) {\n    this.#connectionInternal = connection;\n    this.#lastMessageId = 1;\n    this.#pendingResponsesCount = 0;\n    this.#pendingLongPollingMessageIds = new Set();\n\n    this.#sessions = new Map();\n\n    this.#pendingScripts = [];\n\n    test.deprecatedRunAfterPendingDispatches = this.deprecatedRunAfterPendingDispatches.bind(this);\n    test.sendRawMessage = this.sendRawMessageForTesting.bind(this);\n\n    this.#connectionInternal.setOnMessage(this.onMessage.bind(this));\n\n    this.#connectionInternal.setOnDisconnect(reason => {\n      const session = this.#sessions.get('');\n      if (session) {\n        session.target.dispose(reason);\n      }\n    });\n  }\n\n  registerSession(target: TargetBase, sessionId: string, proxyConnection?: Connection|null): void {\n    // Only the Audits panel uses proxy connections. If it is ever possible to have multiple active at the\n    // same time, it should be tested thoroughly.\n    if (proxyConnection) {\n      for (const session of this.#sessions.values()) {\n        if (session.proxyConnection) {\n          console.error('Multiple simultaneous proxy connections are currently unsupported');\n          break;\n        }\n      }\n    }\n\n    this.#sessions.set(sessionId, {target, callbacks: new Map(), proxyConnection});\n  }\n\n  unregisterSession(sessionId: string): void {\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      return;\n    }\n    for (const callback of session.callbacks.values()) {\n      SessionRouter.dispatchUnregisterSessionError(callback);\n    }\n    this.#sessions.delete(sessionId);\n  }\n\n  private getTargetBySessionId(sessionId: string): TargetBase|null {\n    const session = this.#sessions.get(sessionId ? sessionId : '');\n    if (!session) {\n      return null;\n    }\n    return session.target;\n  }\n\n  private nextMessageId(): number {\n    return this.#lastMessageId++;\n  }\n\n  connection(): Connection {\n    return this.#connectionInternal;\n  }\n\n  sendMessage(sessionId: string, domain: string, method: QualifiedName, params: Object|null, callback: Callback): void {\n    const messageId = this.nextMessageId();\n    const messageObject: Message = {\n      id: messageId,\n      method: method,\n    };\n\n    if (params) {\n      messageObject.params = params;\n    }\n    if (sessionId) {\n      messageObject.sessionId = sessionId;\n    }\n\n    if (test.dumpProtocol) {\n      test.dumpProtocol('frontend: ' + JSON.stringify(messageObject));\n    }\n\n    if (test.onMessageSent) {\n      const paramsObject = JSON.parse(JSON.stringify(params || {}));\n      test.onMessageSent(\n          {domain, method, params: (paramsObject as Object), id: messageId, sessionId},\n          this.getTargetBySessionId(sessionId));\n    }\n\n    ++this.#pendingResponsesCount;\n    if (LongPollingMethods.has(method)) {\n      this.#pendingLongPollingMessageIds.add(messageId);\n    }\n\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      return;\n    }\n    session.callbacks.set(messageId, {callback, method});\n    this.#connectionInternal.sendRawMessage(JSON.stringify(messageObject));\n  }\n\n  private sendRawMessageForTesting(method: QualifiedName, params: Object|null, callback: Callback|null): void {\n    const domain = method.split('.')[0];\n    this.sendMessage('', domain, method, params, callback || ((): void => {}));\n  }\n\n  private onMessage(message: string|Object): void {\n    if (test.dumpProtocol) {\n      test.dumpProtocol('backend: ' + ((typeof message === 'string') ? message : JSON.stringify(message)));\n    }\n\n    if (test.onMessageReceived) {\n      const messageObjectCopy = JSON.parse((typeof message === 'string') ? message : JSON.stringify(message));\n      test.onMessageReceived(messageObjectCopy, this.getTargetBySessionId(messageObjectCopy.sessionId));\n    }\n\n    const messageObject = ((typeof message === 'string') ? JSON.parse(message) : message) as Message;\n\n    // Send all messages to proxy connections.\n    let suppressUnknownMessageErrors = false;\n    for (const session of this.#sessions.values()) {\n      if (!session.proxyConnection) {\n        continue;\n      }\n\n      if (!session.proxyConnection.onMessage) {\n        InspectorBackend.reportProtocolError(\n            'Protocol Error: the session has a proxyConnection with no _onMessage', messageObject);\n        continue;\n      }\n\n      session.proxyConnection.onMessage(messageObject);\n      suppressUnknownMessageErrors = true;\n    }\n\n    const sessionId = messageObject.sessionId || '';\n    const session = this.#sessions.get(sessionId);\n    if (!session) {\n      if (!suppressUnknownMessageErrors) {\n        InspectorBackend.reportProtocolError('Protocol Error: the message with wrong session id', messageObject);\n      }\n      return;\n    }\n\n    // If this message is directly for the target controlled by the proxy connection, don't handle it.\n    if (session.proxyConnection) {\n      return;\n    }\n\n    if (session.target.getNeedsNodeJSPatching()) {\n      NodeURL.patch(messageObject);\n    }\n\n    if (messageObject.id !== undefined) {  // just a response for some request\n      const callback = session.callbacks.get(messageObject.id);\n      session.callbacks.delete(messageObject.id);\n      if (!callback) {\n        if (messageObject.error?.code === ConnectionClosedErrorCode) {\n          // Ignore the errors that are sent as responses after the session closes.\n          return;\n        }\n        if (!suppressUnknownMessageErrors) {\n          InspectorBackend.reportProtocolError('Protocol Error: the message with wrong id', messageObject);\n        }\n        return;\n      }\n\n      callback.callback(messageObject.error || null, messageObject.result || null);\n      --this.#pendingResponsesCount;\n      this.#pendingLongPollingMessageIds.delete(messageObject.id);\n\n      if (this.#pendingScripts.length && !this.hasOutstandingNonLongPollingRequests()) {\n        this.deprecatedRunAfterPendingDispatches();\n      }\n    } else {\n      if (messageObject.method === undefined) {\n        InspectorBackend.reportProtocolError('Protocol Error: the message without method', messageObject);\n        return;\n      }\n      // This cast is justified as we just checked for the presence of messageObject.method.\n      const eventMessage = messageObject as EventMessage;\n      session.target.dispatch(eventMessage);\n    }\n  }\n\n  private hasOutstandingNonLongPollingRequests(): boolean {\n    return this.#pendingResponsesCount - this.#pendingLongPollingMessageIds.size > 0;\n  }\n\n  private deprecatedRunAfterPendingDispatches(script?: (() => void)): void {\n    if (script) {\n      this.#pendingScripts.push(script);\n    }\n\n    // Execute all promises.\n    window.setTimeout(() => {\n      if (!this.hasOutstandingNonLongPollingRequests()) {\n        this.executeAfterPendingDispatches();\n      } else {\n        this.deprecatedRunAfterPendingDispatches();\n      }\n    }, 0);\n  }\n\n  private executeAfterPendingDispatches(): void {\n    if (!this.hasOutstandingNonLongPollingRequests()) {\n      const scripts = this.#pendingScripts;\n      this.#pendingScripts = [];\n      for (let id = 0; id < scripts.length; ++id) {\n        scripts[id]();\n      }\n    }\n  }\n\n  static dispatchConnectionError(callback: Callback, method: string): void {\n    const error = {\n      message: `Connection is closed, can\\'t dispatch pending call to ${method}`,\n      code: ConnectionClosedErrorCode,\n      data: null,\n    };\n    window.setTimeout(() => callback(error, null), 0);\n  }\n\n  static dispatchUnregisterSessionError({callback, method}: CallbackWithDebugInfo): void {\n    const error = {\n      message: `Session is unregistering, can\\'t dispatch pending call to ${method}`,\n      code: ConnectionClosedErrorCode,\n      data: null,\n    };\n    window.setTimeout(() => callback(error, null), 0);\n  }\n}\n\n/**\n  * Make sure that `Domain` in get/set is only ever instantiated with one protocol domain\n  * name, because if `Domain` allows multiple domains, the type is unsound.\n  */\ninterface AgentsMap extends Map<ProtocolDomainName, ProtocolProxyApi.ProtocolApi[ProtocolDomainName]> {\n  get<Domain extends ProtocolDomainName>(key: Domain): ProtocolProxyApi.ProtocolApi[Domain]|undefined;\n  set<Domain extends ProtocolDomainName>(key: Domain, value: ProtocolProxyApi.ProtocolApi[Domain]): this;\n}\n\n/**\n  * Make sure that `Domain` in get/set is only ever instantiated with one protocol domain\n  * name, because if `Domain` allows multiple domains, the type is unsound.\n  */\ninterface DispatcherMap extends Map<ProtocolDomainName, ProtocolProxyApi.ProtocolDispatchers[ProtocolDomainName]> {\n  get<Domain extends ProtocolDomainName>(key: Domain): DispatcherManager<Domain>|undefined;\n  set<Domain extends ProtocolDomainName>(key: Domain, value: DispatcherManager<Domain>): this;\n}\n\nexport class TargetBase {\n  needsNodeJSPatching: boolean;\n  readonly sessionId: string;\n  routerInternal: SessionRouter|null;\n  #agents: AgentsMap = new Map();\n  #dispatchers: DispatcherMap = new Map();\n\n  constructor(\n      needsNodeJSPatching: boolean, parentTarget: TargetBase|null, sessionId: string, connection: Connection|null) {\n    this.needsNodeJSPatching = needsNodeJSPatching;\n    this.sessionId = sessionId;\n\n    if ((!parentTarget && connection) || (!parentTarget && sessionId) || (connection && sessionId)) {\n      throw new Error('Either connection or sessionId (but not both) must be supplied for a child target');\n    }\n\n    let router: SessionRouter;\n    if (sessionId && parentTarget && parentTarget.routerInternal) {\n      router = parentTarget.routerInternal;\n    } else if (connection) {\n      router = new SessionRouter(connection);\n    } else {\n      router = new SessionRouter(connectionFactory());\n    }\n\n    this.routerInternal = router;\n\n    router.registerSession(this, this.sessionId);\n\n    for (const [domain, agentPrototype] of inspectorBackend.agentPrototypes) {\n      const agent = Object.create((agentPrototype as _AgentPrototype));\n      agent.target = this;\n      this.#agents.set(domain, agent);\n    }\n\n    for (const [domain, eventParameterNames] of inspectorBackend.getEventParamterNames().entries()) {\n      this.#dispatchers.set(domain, new DispatcherManager(eventParameterNames));\n    }\n  }\n\n  dispatch(eventMessage: EventMessage): void {\n    const [domainName, method] = splitQualifiedName(eventMessage.method);\n    const dispatcher = this.#dispatchers.get(domainName as ProtocolDomainName);\n    if (!dispatcher) {\n      InspectorBackend.reportProtocolError(\n          `Protocol Error: the message ${eventMessage.method} is for non-existing domain '${domainName}'`,\n          eventMessage);\n      return;\n    }\n    dispatcher.dispatch(method, eventMessage);\n  }\n\n  dispose(_reason: string): void {\n    if (!this.routerInternal) {\n      return;\n    }\n    this.routerInternal.unregisterSession(this.sessionId);\n    this.routerInternal = null;\n  }\n\n  isDisposed(): boolean {\n    return !this.routerInternal;\n  }\n\n  markAsNodeJSForTest(): void {\n    this.needsNodeJSPatching = true;\n  }\n\n  router(): SessionRouter|null {\n    return this.routerInternal;\n  }\n\n  // Agent accessors, keep alphabetically sorted.\n\n  /**\n   * Make sure that `Domain` is only ever instantiated with one protocol domain\n   * name, because if `Domain` allows multiple domains, the type is unsound.\n   */\n  private getAgent<Domain extends ProtocolDomainName>(domain: Domain): ProtocolProxyApi.ProtocolApi[Domain] {\n    const agent = this.#agents.get<Domain>(domain);\n    if (!agent) {\n      throw new Error('Accessing undefined agent');\n    }\n    return agent;\n  }\n\n  accessibilityAgent(): ProtocolProxyApi.AccessibilityApi {\n    return this.getAgent('Accessibility');\n  }\n\n  animationAgent(): ProtocolProxyApi.AnimationApi {\n    return this.getAgent('Animation');\n  }\n\n  auditsAgent(): ProtocolProxyApi.AuditsApi {\n    return this.getAgent('Audits');\n  }\n\n  browserAgent(): ProtocolProxyApi.BrowserApi {\n    return this.getAgent('Browser');\n  }\n\n  backgroundServiceAgent(): ProtocolProxyApi.BackgroundServiceApi {\n    return this.getAgent('BackgroundService');\n  }\n\n  cacheStorageAgent(): ProtocolProxyApi.CacheStorageApi {\n    return this.getAgent('CacheStorage');\n  }\n\n  cssAgent(): ProtocolProxyApi.CSSApi {\n    return this.getAgent('CSS');\n  }\n\n  databaseAgent(): ProtocolProxyApi.DatabaseApi {\n    return this.getAgent('Database');\n  }\n\n  debuggerAgent(): ProtocolProxyApi.DebuggerApi {\n    return this.getAgent('Debugger');\n  }\n\n  deviceOrientationAgent(): ProtocolProxyApi.DeviceOrientationApi {\n    return this.getAgent('DeviceOrientation');\n  }\n\n  domAgent(): ProtocolProxyApi.DOMApi {\n    return this.getAgent('DOM');\n  }\n\n  domdebuggerAgent(): ProtocolProxyApi.DOMDebuggerApi {\n    return this.getAgent('DOMDebugger');\n  }\n\n  domsnapshotAgent(): ProtocolProxyApi.DOMSnapshotApi {\n    return this.getAgent('DOMSnapshot');\n  }\n\n  domstorageAgent(): ProtocolProxyApi.DOMStorageApi {\n    return this.getAgent('DOMStorage');\n  }\n\n  emulationAgent(): ProtocolProxyApi.EmulationApi {\n    return this.getAgent('Emulation');\n  }\n\n  eventBreakpointsAgent(): ProtocolProxyApi.EventBreakpointsApi {\n    return this.getAgent('EventBreakpoints');\n  }\n\n  fetchAgent(): ProtocolProxyApi.FetchApi {\n    return this.getAgent('Fetch');\n  }\n\n  heapProfilerAgent(): ProtocolProxyApi.HeapProfilerApi {\n    return this.getAgent('HeapProfiler');\n  }\n\n  indexedDBAgent(): ProtocolProxyApi.IndexedDBApi {\n    return this.getAgent('IndexedDB');\n  }\n\n  inputAgent(): ProtocolProxyApi.InputApi {\n    return this.getAgent('Input');\n  }\n\n  ioAgent(): ProtocolProxyApi.IOApi {\n    return this.getAgent('IO');\n  }\n\n  inspectorAgent(): ProtocolProxyApi.InspectorApi {\n    return this.getAgent('Inspector');\n  }\n\n  layerTreeAgent(): ProtocolProxyApi.LayerTreeApi {\n    return this.getAgent('LayerTree');\n  }\n\n  logAgent(): ProtocolProxyApi.LogApi {\n    return this.getAgent('Log');\n  }\n\n  mediaAgent(): ProtocolProxyApi.MediaApi {\n    return this.getAgent('Media');\n  }\n\n  memoryAgent(): ProtocolProxyApi.MemoryApi {\n    return this.getAgent('Memory');\n  }\n\n  networkAgent(): ProtocolProxyApi.NetworkApi {\n    return this.getAgent('Network');\n  }\n\n  overlayAgent(): ProtocolProxyApi.OverlayApi {\n    return this.getAgent('Overlay');\n  }\n\n  pageAgent(): ProtocolProxyApi.PageApi {\n    return this.getAgent('Page');\n  }\n\n  profilerAgent(): ProtocolProxyApi.ProfilerApi {\n    return this.getAgent('Profiler');\n  }\n\n  performanceAgent(): ProtocolProxyApi.PerformanceApi {\n    return this.getAgent('Performance');\n  }\n\n  runtimeAgent(): ProtocolProxyApi.RuntimeApi {\n    return this.getAgent('Runtime');\n  }\n\n  securityAgent(): ProtocolProxyApi.SecurityApi {\n    return this.getAgent('Security');\n  }\n\n  serviceWorkerAgent(): ProtocolProxyApi.ServiceWorkerApi {\n    return this.getAgent('ServiceWorker');\n  }\n\n  storageAgent(): ProtocolProxyApi.StorageApi {\n    return this.getAgent('Storage');\n  }\n\n  targetAgent(): ProtocolProxyApi.TargetApi {\n    return this.getAgent('Target');\n  }\n\n  tracingAgent(): ProtocolProxyApi.TracingApi {\n    return this.getAgent('Tracing');\n  }\n\n  webAudioAgent(): ProtocolProxyApi.WebAudioApi {\n    return this.getAgent('WebAudio');\n  }\n\n  webAuthnAgent(): ProtocolProxyApi.WebAuthnApi {\n    return this.getAgent('WebAuthn');\n  }\n\n  // Dispatcher registration and de-registration, keep alphabetically sorted.\n\n  /**\n   * Make sure that `Domain` is only ever instantiated with one protocol domain\n   * name, because if `Domain` allows multiple domains, the type is unsound.\n   */\n  private registerDispatcher<Domain extends ProtocolDomainName>(\n      domain: Domain, dispatcher: ProtocolProxyApi.ProtocolDispatchers[Domain]): void {\n    const manager = this.#dispatchers.get(domain);\n    if (!manager) {\n      return;\n    }\n    manager.addDomainDispatcher(dispatcher);\n  }\n\n  /**\n   * Make sure that `Domain` is only ever instantiated with one protocol domain\n   * name, because if `Domain` allows multiple domains, the type is unsound.\n   */\n  private unregisterDispatcher<Domain extends ProtocolDomainName>(\n      domain: Domain, dispatcher: ProtocolProxyApi.ProtocolDispatchers[Domain]): void {\n    const manager = this.#dispatchers.get(domain);\n    if (!manager) {\n      return;\n    }\n    manager.removeDomainDispatcher(dispatcher);\n  }\n\n  registerAccessibilityDispatcher(dispatcher: ProtocolProxyApi.AccessibilityDispatcher): void {\n    this.registerDispatcher('Accessibility', dispatcher);\n  }\n\n  registerAnimationDispatcher(dispatcher: ProtocolProxyApi.AnimationDispatcher): void {\n    this.registerDispatcher('Animation', dispatcher);\n  }\n\n  registerAuditsDispatcher(dispatcher: ProtocolProxyApi.AuditsDispatcher): void {\n    this.registerDispatcher('Audits', dispatcher);\n  }\n\n  registerCSSDispatcher(dispatcher: ProtocolProxyApi.CSSDispatcher): void {\n    this.registerDispatcher('CSS', dispatcher);\n  }\n\n  registerDatabaseDispatcher(dispatcher: ProtocolProxyApi.DatabaseDispatcher): void {\n    this.registerDispatcher('Database', dispatcher);\n  }\n\n  registerBackgroundServiceDispatcher(dispatcher: ProtocolProxyApi.BackgroundServiceDispatcher): void {\n    this.registerDispatcher('BackgroundService', dispatcher);\n  }\n\n  registerDebuggerDispatcher(dispatcher: ProtocolProxyApi.DebuggerDispatcher): void {\n    this.registerDispatcher('Debugger', dispatcher);\n  }\n\n  unregisterDebuggerDispatcher(dispatcher: ProtocolProxyApi.DebuggerDispatcher): void {\n    this.unregisterDispatcher('Debugger', dispatcher);\n  }\n\n  registerDOMDispatcher(dispatcher: ProtocolProxyApi.DOMDispatcher): void {\n    this.registerDispatcher('DOM', dispatcher);\n  }\n\n  registerDOMStorageDispatcher(dispatcher: ProtocolProxyApi.DOMStorageDispatcher): void {\n    this.registerDispatcher('DOMStorage', dispatcher);\n  }\n\n  registerFetchDispatcher(dispatcher: ProtocolProxyApi.FetchDispatcher): void {\n    this.registerDispatcher('Fetch', dispatcher);\n  }\n\n  registerHeapProfilerDispatcher(dispatcher: ProtocolProxyApi.HeapProfilerDispatcher): void {\n    this.registerDispatcher('HeapProfiler', dispatcher);\n  }\n\n  registerInspectorDispatcher(dispatcher: ProtocolProxyApi.InspectorDispatcher): void {\n    this.registerDispatcher('Inspector', dispatcher);\n  }\n\n  registerLayerTreeDispatcher(dispatcher: ProtocolProxyApi.LayerTreeDispatcher): void {\n    this.registerDispatcher('LayerTree', dispatcher);\n  }\n\n  registerLogDispatcher(dispatcher: ProtocolProxyApi.LogDispatcher): void {\n    this.registerDispatcher('Log', dispatcher);\n  }\n\n  registerMediaDispatcher(dispatcher: ProtocolProxyApi.MediaDispatcher): void {\n    this.registerDispatcher('Media', dispatcher);\n  }\n\n  registerNetworkDispatcher(dispatcher: ProtocolProxyApi.NetworkDispatcher): void {\n    this.registerDispatcher('Network', dispatcher);\n  }\n\n  registerOverlayDispatcher(dispatcher: ProtocolProxyApi.OverlayDispatcher): void {\n    this.registerDispatcher('Overlay', dispatcher);\n  }\n\n  registerPageDispatcher(dispatcher: ProtocolProxyApi.PageDispatcher): void {\n    this.registerDispatcher('Page', dispatcher);\n  }\n\n  registerProfilerDispatcher(dispatcher: ProtocolProxyApi.ProfilerDispatcher): void {\n    this.registerDispatcher('Profiler', dispatcher);\n  }\n\n  registerRuntimeDispatcher(dispatcher: ProtocolProxyApi.RuntimeDispatcher): void {\n    this.registerDispatcher('Runtime', dispatcher);\n  }\n\n  registerSecurityDispatcher(dispatcher: ProtocolProxyApi.SecurityDispatcher): void {\n    this.registerDispatcher('Security', dispatcher);\n  }\n\n  registerServiceWorkerDispatcher(dispatcher: ProtocolProxyApi.ServiceWorkerDispatcher): void {\n    this.registerDispatcher('ServiceWorker', dispatcher);\n  }\n\n  registerStorageDispatcher(dispatcher: ProtocolProxyApi.StorageDispatcher): void {\n    this.registerDispatcher('Storage', dispatcher);\n  }\n\n  registerTargetDispatcher(dispatcher: ProtocolProxyApi.TargetDispatcher): void {\n    this.registerDispatcher('Target', dispatcher);\n  }\n\n  registerTracingDispatcher(dispatcher: ProtocolProxyApi.TracingDispatcher): void {\n    this.registerDispatcher('Tracing', dispatcher);\n  }\n\n  registerWebAudioDispatcher(dispatcher: ProtocolProxyApi.WebAudioDispatcher): void {\n    this.registerDispatcher('WebAudio', dispatcher);\n  }\n\n  getNeedsNodeJSPatching(): boolean {\n    return this.needsNodeJSPatching;\n  }\n}\n\n/**\n * This is a class that serves as the prototype for a domains #agents (every target\n * has it's own set of #agents). The InspectorBackend keeps an instance of this class\n * per domain, and each TargetBase creates its #agents (via Object.create) and installs\n * this instance as prototype.\n *\n * The reasons this is done is so that on the prototypes we can install the implementations\n * of the invoke_enable, etc. methods that the front-end uses.\n */\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _AgentPrototype {\n  replyArgs: {\n    [x: string]: string[],\n  };\n  readonly domain: string;\n  target!: TargetBase;\n  constructor(domain: string) {\n    this.replyArgs = {};\n    this.domain = domain;\n  }\n\n  registerCommand(methodName: UnqualifiedName, parameters: CommandParameter[], replyArgs: string[]): void {\n    const domainAndMethod = qualifyName(this.domain, methodName);\n\n    function sendMessagePromise(this: _AgentPrototype, ...args: unknown[]): Promise<unknown> {\n      return _AgentPrototype.prototype.sendMessageToBackendPromise.call(this, domainAndMethod, parameters, args);\n    }\n\n    // @ts-ignore Method code generation\n    this[methodName] = sendMessagePromise;\n\n    function invoke(\n        this: _AgentPrototype, request: Object|undefined = {}): Promise<Protocol.ProtocolResponseWithError> {\n      return this.invoke(domainAndMethod, request);\n    }\n\n    // @ts-ignore Method code generation\n    this['invoke_' + methodName] = invoke;\n\n    this.replyArgs[domainAndMethod] = replyArgs;\n  }\n\n  private prepareParameters(\n      method: string, parameters: CommandParameter[], args: unknown[], errorCallback: (arg0: string) => void): Object\n      |null {\n    const params: {[x: string]: unknown} = {};\n    let hasParams = false;\n\n    for (const param of parameters) {\n      const paramName = param.name;\n      const typeName = param.type;\n      const optionalFlag = param.optional;\n\n      if (!args.length && !optionalFlag) {\n        errorCallback(\n            `Protocol Error: Invalid number of arguments for method '${method}' call. ` +\n            `It must have the following arguments ${JSON.stringify(parameters)}'.`);\n        return null;\n      }\n\n      const value = args.shift();\n      if (optionalFlag && typeof value === 'undefined') {\n        continue;\n      }\n\n      if (typeof value !== typeName) {\n        errorCallback(\n            `Protocol Error: Invalid type of argument '${paramName}' for method '${method}' call. ` +\n            `It must be '${typeName}' but it is '${typeof value}'.`);\n        return null;\n      }\n\n      params[paramName] = value;\n      hasParams = true;\n    }\n\n    if (args.length) {\n      errorCallback(`Protocol Error: Extra ${args.length} arguments in a call to method '${method}'.`);\n      return null;\n    }\n\n    return hasParams ? params : null;\n  }\n\n  private sendMessageToBackendPromise(method: QualifiedName, parameters: CommandParameter[], args: unknown[]):\n      Promise<unknown> {\n    let errorMessage;\n    function onError(message: string): void {\n      console.error(message);\n      errorMessage = message;\n    }\n    const params = this.prepareParameters(method, parameters, args, onError);\n    if (errorMessage) {\n      return Promise.resolve(null);\n    }\n\n    return new Promise(resolve => {\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const callback: Callback = (error: MessageError|null, result: any|null): void => {\n        if (error) {\n          if (!test.suppressRequestErrors && error.code !== DevToolsStubErrorCode && error.code !== GenericError &&\n              error.code !== ConnectionClosedErrorCode) {\n            console.error('Request ' + method + ' failed. ' + JSON.stringify(error));\n          }\n\n          resolve(null);\n          return;\n        }\n\n        const args = this.replyArgs[method];\n        resolve(result && args.length ? result[args[0]] : undefined);\n      };\n\n      const router = this.target.router();\n      if (!router) {\n        SessionRouter.dispatchConnectionError(callback, method);\n      } else {\n        router.sendMessage(this.target.sessionId, this.domain, method, params, callback);\n      }\n    });\n  }\n\n  private invoke(method: QualifiedName, request: Object|null): Promise<Protocol.ProtocolResponseWithError> {\n    return new Promise(fulfill => {\n      const callback: Callback = (error: MessageError|undefined|null, result: Object|null): void => {\n        if (error && !test.suppressRequestErrors && error.code !== DevToolsStubErrorCode &&\n            error.code !== GenericError && error.code !== ConnectionClosedErrorCode) {\n          console.error('Request ' + method + ' failed. ' + JSON.stringify(error));\n        }\n\n        const errorMessage = error?.message;\n        fulfill({...result, getError: (): string | undefined => errorMessage});\n      };\n\n      const router = this.target.router();\n      if (!router) {\n        SessionRouter.dispatchConnectionError(callback, method);\n      } else {\n        router.sendMessage(this.target.sessionId, this.domain, method, request, callback);\n      }\n    });\n  }\n}\n\n/**\n * A `DispatcherManager` has a collection of #dispatchers that implement one of the\n * `ProtocolProxyApi.{Foo}Dispatcher` interfaces. Each target uses one of these per\n * domain to manage the registered #dispatchers. The class knows the parameter names\n * of the events via `#eventArgs`, which is a map managed by the inspector back-end\n * so that there is only one map per domain that is shared among all DispatcherManagers.\n */\nclass DispatcherManager<Domain extends ProtocolDomainName> {\n  #eventArgs: ReadonlyEventParameterNames;\n  #dispatchers: ProtocolProxyApi.ProtocolDispatchers[Domain][] = [];\n\n  constructor(eventArgs: ReadonlyEventParameterNames) {\n    this.#eventArgs = eventArgs;\n  }\n\n  addDomainDispatcher(dispatcher: ProtocolProxyApi.ProtocolDispatchers[Domain]): void {\n    this.#dispatchers.push(dispatcher);\n  }\n\n  removeDomainDispatcher(dispatcher: ProtocolProxyApi.ProtocolDispatchers[Domain]): void {\n    const index = this.#dispatchers.indexOf(dispatcher);\n    if (index === -1) {\n      return;\n    }\n    this.#dispatchers.splice(index, 1);\n  }\n\n  dispatch(event: UnqualifiedName, messageObject: EventMessage): void {\n    if (!this.#dispatchers.length) {\n      return;\n    }\n\n    if (!this.#eventArgs.has(messageObject.method)) {\n      InspectorBackend.reportProtocolWarning(\n          `Protocol Warning: Attempted to dispatch an unspecified event '${messageObject.method}'`, messageObject);\n      return;\n    }\n\n    const messageParams = {...messageObject.params};\n    for (let index = 0; index < this.#dispatchers.length; ++index) {\n      const dispatcher = this.#dispatchers[index];\n\n      if (event in dispatcher) {\n        const f = dispatcher[event as string as keyof ProtocolProxyApi.ProtocolDispatchers[Domain]];\n        // @ts-ignore Can't type check the dispatch.\n        f.call(dispatcher, messageParams);\n      }\n    }\n  }\n}\n\nexport const inspectorBackend = new InspectorBackend();\n"],
  "mappings": "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",
  "names": []
}
