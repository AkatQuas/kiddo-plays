{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/Cookie.ts"],
  "sourcesContent": ["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Platform from '../platform/platform.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nconst OPAQUE_PARITION_KEY = '<opaque>';\n\nexport class Cookie {\n  readonly #nameInternal: string;\n  readonly #valueInternal: string;\n  readonly #typeInternal: Type|null|undefined;\n  #attributes: {\n    [x: string]: string|number|boolean|undefined,\n  };\n  #sizeInternal: number;\n  #priorityInternal: Protocol.Network.CookiePriority;\n  #cookieLine: string|null;\n  constructor(name: string, value: string, type?: Type|null, priority?: Protocol.Network.CookiePriority) {\n    this.#nameInternal = name;\n    this.#valueInternal = value;\n    this.#typeInternal = type;\n    this.#attributes = {};\n    this.#sizeInternal = 0;\n    this.#priorityInternal = (priority || 'Medium' as Protocol.Network.CookiePriority);\n    this.#cookieLine = null;\n  }\n\n  static fromProtocolCookie(protocolCookie: Protocol.Network.Cookie): Cookie {\n    const cookie = new Cookie(protocolCookie.name, protocolCookie.value, null, protocolCookie.priority);\n    cookie.addAttribute('domain', protocolCookie['domain']);\n    cookie.addAttribute('path', protocolCookie['path']);\n    if (protocolCookie['expires']) {\n      cookie.addAttribute('expires', protocolCookie['expires'] * 1000);\n    }\n    if (protocolCookie['httpOnly']) {\n      cookie.addAttribute('httpOnly');\n    }\n    if (protocolCookie['secure']) {\n      cookie.addAttribute('secure');\n    }\n    if (protocolCookie['sameSite']) {\n      cookie.addAttribute('sameSite', protocolCookie['sameSite']);\n    }\n    if (protocolCookie.sameParty) {\n      cookie.addAttribute('sameParty');\n    }\n    if ('sourcePort' in protocolCookie) {\n      cookie.addAttribute('sourcePort', protocolCookie.sourcePort);\n    }\n    if ('sourceScheme' in protocolCookie) {\n      cookie.addAttribute('sourceScheme', protocolCookie.sourceScheme);\n    }\n    if ('partitionKey' in protocolCookie) {\n      cookie.addAttribute('partitionKey', protocolCookie.partitionKey);\n    }\n    if ('partitionKeyOpaque' in protocolCookie) {\n      cookie.addAttribute('partitionKey', OPAQUE_PARITION_KEY);\n    }\n    cookie.setSize(protocolCookie['size']);\n    return cookie;\n  }\n\n  key(): string {\n    return (this.domain() || '-') + ' ' + this.name() + ' ' + (this.path() || '-');\n  }\n\n  name(): string {\n    return this.#nameInternal;\n  }\n\n  value(): string {\n    return this.#valueInternal;\n  }\n\n  type(): Type|null|undefined {\n    return this.#typeInternal;\n  }\n\n  httpOnly(): boolean {\n    return 'httponly' in this.#attributes;\n  }\n\n  secure(): boolean {\n    return 'secure' in this.#attributes;\n  }\n\n  sameSite(): Protocol.Network.CookieSameSite {\n    // TODO(allada) This should not rely on #attributes and instead store them individually.\n    // when #attributes get added via addAttribute() they are lowercased, hence the lowercasing of samesite here\n    return this.#attributes['samesite'] as Protocol.Network.CookieSameSite;\n  }\n\n  sameParty(): boolean {\n    return 'sameparty' in this.#attributes;\n  }\n\n  partitionKey(): string {\n    return this.#attributes['partitionkey'] as string;\n  }\n\n  partitionKeyOpaque(): boolean {\n    return (this.#attributes['partitionkey'] === OPAQUE_PARITION_KEY);\n  }\n\n  priority(): Protocol.Network.CookiePriority {\n    return this.#priorityInternal;\n  }\n\n  session(): boolean {\n    // RFC 2965 suggests using Discard attribute to mark session cookies, but this does not seem to be widely used.\n    // Check for absence of explicitly max-age or expiry date instead.\n    return !('expires' in this.#attributes || 'max-age' in this.#attributes);\n  }\n\n  path(): string {\n    return this.#attributes['path'] as string;\n  }\n\n  domain(): string {\n    return this.#attributes['domain'] as string;\n  }\n\n  expires(): number {\n    return this.#attributes['expires'] as number;\n  }\n\n  maxAge(): number {\n    return this.#attributes['max-age'] as number;\n  }\n\n  sourcePort(): number {\n    return this.#attributes['sourceport'] as number;\n  }\n\n  sourceScheme(): Protocol.Network.CookieSourceScheme {\n    return this.#attributes['sourcescheme'] as Protocol.Network.CookieSourceScheme;\n  }\n\n  size(): number {\n    return this.#sizeInternal;\n  }\n\n  /**\n   * @deprecated\n   */\n  url(): Platform.DevToolsPath.UrlString|null {\n    if (!this.domain() || !this.path()) {\n      return null;\n    }\n    let port = '';\n    const sourcePort = this.sourcePort();\n    // Do not include standard ports to ensure the back-end will change standard ports according to the scheme.\n    if (sourcePort && sourcePort !== 80 && sourcePort !== 443) {\n      port = `:${this.sourcePort()}`;\n    }\n    // We must not consider the this.sourceScheme() here, otherwise it will be impossible to set a cookie without\n    // the Secure attribute from a secure origin.\n    return (this.secure() ? 'https://' : 'http://') + this.domain() + port + this.path() as\n        Platform.DevToolsPath.UrlString;\n  }\n\n  setSize(size: number): void {\n    this.#sizeInternal = size;\n  }\n\n  expiresDate(requestDate: Date): Date|null {\n    // RFC 6265 indicates that the max-age attribute takes precedence over the expires attribute\n    if (this.maxAge()) {\n      return new Date(requestDate.getTime() + 1000 * this.maxAge());\n    }\n\n    if (this.expires()) {\n      return new Date(this.expires());\n    }\n\n    return null;\n  }\n\n  addAttribute(key: string, value?: string|number|boolean): void {\n    const normalizedKey = key.toLowerCase();\n    switch (normalizedKey) {\n      case 'priority':\n        this.#priorityInternal = (value as Protocol.Network.CookiePriority);\n        break;\n      default:\n        this.#attributes[normalizedKey] = value;\n    }\n  }\n\n  setCookieLine(cookieLine: string): void {\n    this.#cookieLine = cookieLine;\n  }\n\n  getCookieLine(): string|null {\n    return this.#cookieLine;\n  }\n\n  matchesSecurityOrigin(securityOrigin: string): boolean {\n    const hostname = new URL(securityOrigin).hostname;\n    return Cookie.isDomainMatch(this.domain(), hostname);\n  }\n\n  static isDomainMatch(domain: string, hostname: string): boolean {\n    // This implementation mirrors\n    // https://source.chromium.org/search?q=net::cookie_util::IsDomainMatch()\n    //\n    // Can domain match in two ways; as a domain cookie (where the cookie\n    // domain begins with \".\") or as a host cookie (where it doesn't).\n\n    // Some consumers of the CookieMonster expect to set cookies on\n    // URLs like http://.strange.url.  To retrieve cookies in this instance,\n    // we allow matching as a host cookie even when the domain_ starts with\n    // a period.\n    if (hostname === domain) {\n      return true;\n    }\n\n    // Domain cookie must have an initial \".\".  To match, it must be\n    // equal to url's host with initial period removed, or a suffix of\n    // it.\n\n    // Arguably this should only apply to \"http\" or \"https\" cookies, but\n    // extension cookie tests currently use the funtionality, and if we\n    // ever decide to implement that it should be done by preventing\n    // such cookies from being set.\n    if (!domain || domain[0] !== '.') {\n      return false;\n    }\n\n    // The host with a \".\" prefixed.\n    if (domain.substr(1) === hostname) {\n      return true;\n    }\n\n    // A pure suffix of the host (ok since we know the domain already\n    // starts with a \".\")\n    return hostname.length > domain.length && hostname.endsWith(domain);\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Type {\n  Request = 0,\n  Response = 1,\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Attributes {\n  Name = 'name',\n  Value = 'value',\n  Size = 'size',\n  Domain = 'domain',\n  Path = 'path',\n  Expires = 'expires',\n  HttpOnly = 'httpOnly',\n  Secure = 'secure',\n  SameSite = 'sameSite',\n  SameParty = 'sameParty',\n  SourceScheme = 'sourceScheme',\n  SourcePort = 'sourcePort',\n  Priority = 'priority',\n  PartitionKey = 'partitionKey',\n}\n"],
  "mappings": "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",
  "names": []
}
