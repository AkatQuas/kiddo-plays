{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/SourceMapManager.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as i18n from '../i18n/i18n.js';\nimport * as Platform from '../platform/platform.js';\n\nimport type {FrameAssociated} from './FrameAssociated.js';\nimport type {Target} from './Target.js';\nimport {Type} from './Target.js';\nimport {Events as TargetManagerEvents, TargetManager} from './TargetManager.js';\nimport type {SourceMap} from './SourceMap.js';\nimport {TextSourceMap} from './SourceMap.js';\n\nconst UIStrings = {\n  /**\n  *@description Error message when failing to load a source map text\n  *@example {An error occurred} PH1\n  */\n  devtoolsFailedToLoadSourcemapS: 'DevTools failed to load source map: {PH1}',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/SourceMapManager.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class SourceMapManager<T extends FrameAssociated> extends Common.ObjectWrapper.ObjectWrapper<EventTypes<T>> {\n  readonly #target: Target;\n  #isEnabled: boolean;\n  readonly #relativeSourceURL: Map<T, Platform.DevToolsPath.UrlString>;\n  readonly #relativeSourceMapURL: Map<T, Platform.DevToolsPath.UrlString>;\n  #resolvedSourceMapId: Map<T, string>;\n  readonly #sourceMapById: Map<string, SourceMap>;\n  #sourceMapIdToLoadingClients: Platform.MapUtilities.Multimap<string, T>;\n  #sourceMapIdToClients: Platform.MapUtilities.Multimap<string, T>;\n\n  constructor(target: Target) {\n    super();\n\n    this.#target = target;\n    this.#isEnabled = true;\n\n    this.#relativeSourceURL = new Map();\n    this.#relativeSourceMapURL = new Map();\n    this.#resolvedSourceMapId = new Map();\n\n    this.#sourceMapById = new Map();\n    this.#sourceMapIdToLoadingClients = new Platform.MapUtilities.Multimap();\n    this.#sourceMapIdToClients = new Platform.MapUtilities.Multimap();\n\n    TargetManager.instance().addEventListener(TargetManagerEvents.InspectedURLChanged, this.inspectedURLChanged, this);\n  }\n\n  setEnabled(isEnabled: boolean): void {\n    if (isEnabled === this.#isEnabled) {\n      return;\n    }\n    this.#isEnabled = isEnabled;\n    // We need this copy, because `this.#resolvedSourceMapId` is getting modified\n    // in the loop body and trying to iterate over it at the same time leads to\n    // an infinite loop.\n    const clients = [...this.#resolvedSourceMapId.keys()];\n    for (const client of clients) {\n      const relativeSourceURL = this.#relativeSourceURL.get(client);\n      const relativeSourceMapURL = this.#relativeSourceMapURL.get(client);\n      this.detachSourceMap(client);\n      this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);\n    }\n  }\n\n  private getBaseUrl(): Platform.DevToolsPath.UrlString {\n    let target: Target|null = this.#target;\n    while (target && target.type() !== Type.Frame) {\n      target = target.parentTarget();\n    }\n    return target?.inspectedURL() ?? Platform.DevToolsPath.EmptyUrlString;\n  }\n\n  private inspectedURLChanged(event: Common.EventTarget.EventTargetEvent<Target>): void {\n    if (event.data !== this.#target) {\n      return;\n    }\n\n    // We need this copy, because `this.#resolvedSourceMapId` is getting modified\n    // in the loop body and trying to iterate over it at the same time leads to\n    // an infinite loop.\n    const prevSourceMapIds = new Map(this.#resolvedSourceMapId);\n    for (const [client, prevSourceMapId] of prevSourceMapIds) {\n      const relativeSourceURL = this.#relativeSourceURL.get(client);\n      const relativeSourceMapURL = this.#relativeSourceMapURL.get(client);\n      if (relativeSourceURL === undefined || relativeSourceMapURL === undefined) {\n        continue;\n      }\n      const resolvedUrls = this.resolveRelativeURLs(relativeSourceURL, relativeSourceMapURL);\n      if (resolvedUrls !== null && prevSourceMapId !== resolvedUrls.sourceMapId) {\n        this.detachSourceMap(client);\n        this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);\n      }\n    }\n  }\n\n  sourceMapForClient(client: T): SourceMap|null {\n    const sourceMapId = this.#resolvedSourceMapId.get(client);\n    if (!sourceMapId) {\n      return null;\n    }\n    return this.#sourceMapById.get(sourceMapId) || null;\n  }\n\n  // This method actively awaits the source map, if still loading.\n  sourceMapForClientPromise(client: T): Promise<SourceMap|null> {\n    const sourceMapId = this.#resolvedSourceMapId.get(client);\n    if (!sourceMapId) {\n      // The source map has detached or none exists for this client.\n      return Promise.resolve(null);\n    }\n\n    const sourceMap = this.sourceMapForClient(client);\n    if (sourceMap) {\n      return Promise.resolve(sourceMap);\n    }\n\n    if (!this.#sourceMapIdToLoadingClients.has(sourceMapId)) {\n      // The source map failed to attach.\n      return Promise.resolve(null);\n    }\n\n    return new Promise(resolve => {\n      const sourceMapAddedDescriptor = this.addEventListener(Events.SourceMapAttached, event => {\n        if (event.data.client !== client) {\n          return;\n        }\n        this.removeEventListener(Events.SourceMapAttached, sourceMapAddedDescriptor.listener);\n        this.removeEventListener(Events.SourceMapFailedToAttach, sourceMapFailedDescriptor.listener);\n        resolve(event.data.sourceMap);\n      });\n      const sourceMapFailedDescriptor = this.addEventListener(Events.SourceMapFailedToAttach, event => {\n        if (event.data.client !== client) {\n          return;\n        }\n        this.removeEventListener(Events.SourceMapAttached, sourceMapAddedDescriptor.listener);\n        this.removeEventListener(Events.SourceMapFailedToAttach, sourceMapFailedDescriptor.listener);\n        resolve(null);\n      });\n    });\n  }\n\n  clientsForSourceMap(sourceMap: SourceMap): T[] {\n    const sourceMapId = this.getSourceMapId(sourceMap.compiledURL(), sourceMap.url());\n    if (this.#sourceMapIdToClients.has(sourceMapId)) {\n      return [...this.#sourceMapIdToClients.get(sourceMapId)];\n    }\n    return [...this.#sourceMapIdToLoadingClients.get(sourceMapId)];\n  }\n\n  private getSourceMapId(sourceURL: Platform.DevToolsPath.UrlString, sourceMapURL: Platform.DevToolsPath.UrlString):\n      string {\n    return `${sourceURL}:${sourceMapURL}`;\n  }\n\n  private resolveRelativeURLs(\n      sourceURL: Platform.DevToolsPath.UrlString, sourceMapURL: Platform.DevToolsPath.UrlString): {\n    sourceURL: Platform.DevToolsPath.UrlString,\n    sourceMapURL: Platform.DevToolsPath.UrlString,\n    sourceMapId: string,\n  }|null {\n    // |#sourceURL| can be a random string, but is generally an absolute path.\n    // Complete it to inspected page url for relative links.\n    const resolvedSourceURL = Common.ParsedURL.ParsedURL.completeURL(this.getBaseUrl(), sourceURL);\n    if (!resolvedSourceURL) {\n      return null;\n    }\n    const resolvedSourceMapURL = Common.ParsedURL.ParsedURL.completeURL(resolvedSourceURL, sourceMapURL);\n    if (!resolvedSourceMapURL) {\n      return null;\n    }\n    return {\n      sourceURL: resolvedSourceURL,\n      sourceMapURL: resolvedSourceMapURL,\n      sourceMapId: this.getSourceMapId(resolvedSourceURL, resolvedSourceMapURL),\n    };\n  }\n\n  attachSourceMap(\n      client: T, relativeSourceURL: Platform.DevToolsPath.UrlString|undefined,\n      relativeSourceMapURL: Platform.DevToolsPath.UrlString|undefined): void {\n    // TODO(chromium:1011811): Strengthen the type to obsolte the undefined check once core/sdk/ is fully typescriptified.\n    if (relativeSourceURL === undefined || !relativeSourceMapURL) {\n      return;\n    }\n    console.assert(!this.#resolvedSourceMapId.has(client), 'SourceMap is already attached to client');\n    const resolvedURLs = this.resolveRelativeURLs(relativeSourceURL, relativeSourceMapURL);\n    if (!resolvedURLs) {\n      return;\n    }\n    this.#relativeSourceURL.set(client, relativeSourceURL);\n    this.#relativeSourceMapURL.set(client, relativeSourceMapURL);\n\n    const {sourceURL, sourceMapURL, sourceMapId} = resolvedURLs;\n    this.#resolvedSourceMapId.set(client, sourceMapId);\n\n    if (!this.#isEnabled) {\n      return;\n    }\n\n    this.dispatchEventToListeners(Events.SourceMapWillAttach, {client});\n\n    if (this.#sourceMapById.has(sourceMapId)) {\n      attach.call(this, sourceMapId, client);\n      return;\n    }\n    if (!this.#sourceMapIdToLoadingClients.has(sourceMapId)) {\n      void TextSourceMap.load(sourceMapURL, sourceURL, client.createPageResourceLoadInitiator())\n          .catch(error => {\n            Common.Console.Console.instance().warn(\n                i18nString(UIStrings.devtoolsFailedToLoadSourcemapS, {PH1: error.message}));\n            return null;\n          })\n          .then(onSourceMap.bind(this, sourceMapId));\n    }\n    this.#sourceMapIdToLoadingClients.set(sourceMapId, client);\n\n    function onSourceMap(this: SourceMapManager<T>, sourceMapId: string, sourceMap: SourceMap|null): void {\n      this.sourceMapLoadedForTest();\n      const clients = this.#sourceMapIdToLoadingClients.get(sourceMapId);\n      this.#sourceMapIdToLoadingClients.deleteAll(sourceMapId);\n      if (!clients.size) {\n        return;\n      }\n      if (!sourceMap) {\n        for (const client of clients) {\n          this.dispatchEventToListeners(Events.SourceMapFailedToAttach, {client});\n        }\n        return;\n      }\n      this.#sourceMapById.set(sourceMapId, sourceMap);\n      for (const client of clients) {\n        attach.call(this, sourceMapId, client);\n      }\n    }\n\n    function attach(this: SourceMapManager<T>, sourceMapId: string, client: T): void {\n      this.#sourceMapIdToClients.set(sourceMapId, client);\n      const sourceMap = this.#sourceMapById.get(sourceMapId) as SourceMap;\n      this.dispatchEventToListeners(Events.SourceMapAttached, {client, sourceMap});\n    }\n  }\n\n  detachSourceMap(client: T): void {\n    const sourceMapId = this.#resolvedSourceMapId.get(client);\n    this.#relativeSourceURL.delete(client);\n    this.#relativeSourceMapURL.delete(client);\n    this.#resolvedSourceMapId.delete(client);\n\n    if (!sourceMapId) {\n      return;\n    }\n    if (!this.#sourceMapIdToClients.hasValue(sourceMapId, client)) {\n      if (this.#sourceMapIdToLoadingClients.delete(sourceMapId, client)) {\n        this.dispatchEventToListeners(Events.SourceMapFailedToAttach, {client});\n      }\n      return;\n    }\n    this.#sourceMapIdToClients.delete(sourceMapId, client);\n    const sourceMap = this.#sourceMapById.get(sourceMapId);\n    if (!sourceMap) {\n      return;\n    }\n    if (!this.#sourceMapIdToClients.has(sourceMapId)) {\n      this.#sourceMapById.delete(sourceMapId);\n    }\n    this.dispatchEventToListeners(Events.SourceMapDetached, {client, sourceMap});\n  }\n\n  private sourceMapLoadedForTest(): void {\n  }\n\n  dispose(): void {\n    TargetManager.instance().removeEventListener(\n        TargetManagerEvents.InspectedURLChanged, this.inspectedURLChanged, this);\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  SourceMapWillAttach = 'SourceMapWillAttach',\n  SourceMapFailedToAttach = 'SourceMapFailedToAttach',\n  SourceMapAttached = 'SourceMapAttached',\n  SourceMapDetached = 'SourceMapDetached',\n}\n\nexport type EventTypes<T extends FrameAssociated> = {\n  [Events.SourceMapWillAttach]: {client: T},\n  [Events.SourceMapFailedToAttach]: {client: T},\n  [Events.SourceMapAttached]: {client: T, sourceMap: SourceMap},\n  [Events.SourceMapDetached]: {client: T, sourceMap: SourceMap},\n};\n"],
  "mappings": "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",
  "names": []
}
