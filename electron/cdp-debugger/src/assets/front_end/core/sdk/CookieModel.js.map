{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/CookieModel.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Common from '../common/common.js';\nimport * as Root from '../root/root.js';\n\nimport type {Attributes} from './Cookie.js';\nimport {Cookie} from './Cookie.js';\nimport type {Resource} from './Resource.js';\nimport {ResourceTreeModel} from './ResourceTreeModel.js';\nimport type {Target} from './Target.js';\nimport {Capability} from './Target.js';\nimport {SDKModel} from './SDKModel.js';\n\nexport class CookieModel extends SDKModel<void> {\n  readonly #blockedCookies: Map<string, Cookie>;\n  readonly #cookieToBlockedReasons: Map<Cookie, BlockedReason[]>;\n  constructor(target: Target) {\n    super(target);\n\n    this.#blockedCookies = new Map();\n    this.#cookieToBlockedReasons = new Map();\n  }\n\n  addBlockedCookie(cookie: Cookie, blockedReasons: BlockedReason[]|null): void {\n    const key = cookie.key();\n    const previousCookie = this.#blockedCookies.get(key);\n    this.#blockedCookies.set(key, cookie);\n    if (blockedReasons) {\n      this.#cookieToBlockedReasons.set(cookie, blockedReasons);\n    } else {\n      this.#cookieToBlockedReasons.delete(cookie);\n    }\n    if (previousCookie) {\n      this.#cookieToBlockedReasons.delete(previousCookie);\n    }\n  }\n\n  getCookieToBlockedReasonsMap(): ReadonlyMap<Cookie, BlockedReason[]> {\n    return this.#cookieToBlockedReasons;\n  }\n\n  async getCookies(urls: string[]): Promise<Cookie[]> {\n    const response = await this.target().networkAgent().invoke_getCookies({urls});\n    if (response.getError()) {\n      return [];\n    }\n    const normalCookies = response.cookies.map(Cookie.fromProtocolCookie);\n    return normalCookies.concat(Array.from(this.#blockedCookies.values()));\n  }\n\n  async deleteCookie(cookie: Cookie): Promise<void> {\n    await this.deleteCookies([cookie]);\n  }\n\n  async clear(domain?: string, securityOrigin?: string): Promise<void> {\n    const cookies = await this.getCookiesForDomain(domain || null);\n    if (securityOrigin) {\n      const cookiesToDelete = cookies.filter(cookie => {\n        return cookie.matchesSecurityOrigin(securityOrigin);\n      });\n      await this.deleteCookies(cookiesToDelete);\n    } else {\n      await this.deleteCookies(cookies);\n    }\n  }\n\n  async saveCookie(cookie: Cookie): Promise<boolean> {\n    let domain = cookie.domain();\n    if (!domain.startsWith('.')) {\n      domain = '';\n    }\n    let expires: number|undefined = undefined;\n    if (cookie.expires()) {\n      expires = Math.floor(Date.parse(`${cookie.expires()}`) / 1000);\n    }\n    const enabled = Root.Runtime.experiments.isEnabled('experimentalCookieFeatures');\n    const preserveUnset = (scheme: Protocol.Network.CookieSourceScheme): Protocol.Network.CookieSourceScheme.Unset|\n                          undefined => scheme === Protocol.Network.CookieSourceScheme.Unset ? scheme : undefined;\n    const protocolCookie = {\n      name: cookie.name(),\n      value: cookie.value(),\n      url: cookie.url() || undefined,\n      domain,\n      path: cookie.path(),\n      secure: cookie.secure(),\n      httpOnly: cookie.httpOnly(),\n      sameSite: cookie.sameSite(),\n      expires,\n      priority: cookie.priority(),\n      sameParty: cookie.sameParty(),\n      partitionKey: cookie.partitionKey(),\n      sourceScheme: enabled ? cookie.sourceScheme() : preserveUnset(cookie.sourceScheme()),\n      sourcePort: enabled ? cookie.sourcePort() : undefined,\n    };\n    const response = await this.target().networkAgent().invoke_setCookie(protocolCookie);\n    const error = response.getError();\n    if (error || !response.success) {\n      return false;\n    }\n    return response.success;\n  }\n\n  /**\n   * Returns cookies needed by current page's frames whose security origins are |domain|.\n   */\n  getCookiesForDomain(domain: string|null): Promise<Cookie[]> {\n    const resourceURLs = [];\n    function populateResourceURLs(resource: Resource): boolean {\n      const documentURL = Common.ParsedURL.ParsedURL.fromString(resource.documentURL);\n      if (documentURL && (!domain || documentURL.securityOrigin() === domain)) {\n        resourceURLs.push(resource.url);\n      }\n      return false;\n    }\n    const resourceTreeModel = this.target().model(ResourceTreeModel);\n    if (resourceTreeModel) {\n      // In case the current frame was unreachable, add it's cookies\n      // because they might help to debug why the frame was unreachable.\n      if (resourceTreeModel.mainFrame && resourceTreeModel.mainFrame.unreachableUrl()) {\n        resourceURLs.push(resourceTreeModel.mainFrame.unreachableUrl());\n      }\n\n      resourceTreeModel.forAllResources(populateResourceURLs);\n    }\n    return this.getCookies(resourceURLs);\n  }\n\n  async deleteCookies(cookies: Cookie[]): Promise<void> {\n    const networkAgent = this.target().networkAgent();\n    this.#blockedCookies.clear();\n    this.#cookieToBlockedReasons.clear();\n    await Promise.all(cookies.map(\n        cookie => networkAgent.invoke_deleteCookies(\n            {name: cookie.name(), url: undefined, domain: cookie.domain(), path: cookie.path()})));\n  }\n}\n\nSDKModel.register(CookieModel, {capabilities: Capability.Network, autostart: false});\nexport interface BlockedReason {\n  uiString: string;\n  attribute: Attributes|null;\n}\n"],
  "mappings": "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",
  "names": []
}
