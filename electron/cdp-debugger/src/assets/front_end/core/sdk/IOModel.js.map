{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/IOModel.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\n\nimport {RemoteObject} from './RemoteObject.js';\nimport type {Target} from './Target.js';\nimport {Capability} from './Target.js';\nimport {SDKModel} from './SDKModel.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport class IOModel extends SDKModel<void> {\n  constructor(target: Target) {\n    super(target);\n  }\n\n  async read(handle: Protocol.IO.StreamHandle, size?: number, offset?: number): Promise<string|ArrayBuffer|null> {\n    const result = await this.target().ioAgent().invoke_read({handle, offset, size});\n    if (result.getError()) {\n      throw new Error(result.getError());\n    }\n    if (result.eof) {\n      return null;\n    }\n    if (result.base64Encoded) {\n      return Common.Base64.decode(result.data);\n    }\n    return result.data;\n  }\n\n  async close(handle: Protocol.IO.StreamHandle): Promise<void> {\n    const result = await this.target().ioAgent().invoke_close({handle});\n    if (result.getError()) {\n      console.error('Could not close stream.');\n    }\n  }\n\n  async resolveBlob(objectOrObjectId: Protocol.Runtime.RemoteObjectId|RemoteObject): Promise<string> {\n    const objectId = objectOrObjectId instanceof RemoteObject ? objectOrObjectId.objectId : objectOrObjectId;\n    if (!objectId) {\n      throw new Error('Remote object has undefined objectId');\n    }\n    const result = await this.target().ioAgent().invoke_resolveBlob({objectId});\n    if (result.getError()) {\n      throw new Error(result.getError());\n    }\n    return `blob:${result.uuid}`;\n  }\n\n  async readToString(handle: Protocol.IO.StreamHandle): Promise<string> {\n    const strings: string[] = [];\n    const decoder = new TextDecoder();\n    for (;;) {\n      const data = await this.read(handle, 1024 * 1024);\n      if (data === null) {\n        strings.push(decoder.decode());\n        break;\n      }\n      if (data instanceof ArrayBuffer) {\n        strings.push(decoder.decode(data, {stream: true}));\n      } else {\n        strings.push(data);\n      }\n    }\n    return strings.join('');\n  }\n}\n\nSDKModel.register(IOModel, {capabilities: Capability.IO, autostart: true});\n"],
  "mappings": "AAIA;AAEA;AAEA;AACA;AAGO,6BAAsB,SAAe;AAAA,EAC1C,YAAY,QAAgB;AAC1B,UAAM;AAAA;AAAA,QAGF,KAAK,QAAkC,MAAe,QAAmD;AAC7G,UAAM,SAAS,MAAM,KAAK,SAAS,UAAU,YAAY,EAAC,QAAQ,QAAQ;AAC1E,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI,MAAM,OAAO;AAAA;AAEzB,QAAI,OAAO,KAAK;AACd,aAAO;AAAA;AAET,QAAI,OAAO,eAAe;AACxB,aAAO,OAAO,OAAO,OAAO,OAAO;AAAA;AAErC,WAAO,OAAO;AAAA;AAAA,QAGV,MAAM,QAAiD;AAC3D,UAAM,SAAS,MAAM,KAAK,SAAS,UAAU,aAAa,EAAC;AAC3D,QAAI,OAAO,YAAY;AACrB,cAAQ,MAAM;AAAA;AAAA;AAAA,QAIZ,YAAY,kBAAiF;AACjG,UAAM,WAAW,4BAA4B,eAAe,iBAAiB,WAAW;AACxF,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,MAAM;AAAA;AAElB,UAAM,SAAS,MAAM,KAAK,SAAS,UAAU,mBAAmB,EAAC;AACjE,QAAI,OAAO,YAAY;AACrB,YAAM,IAAI,MAAM,OAAO;AAAA;AAEzB,WAAO,QAAQ,OAAO;AAAA;AAAA,QAGlB,aAAa,QAAmD;AACpE,UAAM,UAAoB;AAC1B,UAAM,UAAU,IAAI;AACpB,eAAS;AACP,YAAM,OAAO,MAAM,KAAK,KAAK,QAAQ,OAAO;AAC5C,UAAI,SAAS,MAAM;AACjB,gBAAQ,KAAK,QAAQ;AACrB;AAAA;AAEF,UAAI,gBAAgB,aAAa;AAC/B,gBAAQ,KAAK,QAAQ,OAAO,MAAM,EAAC,QAAQ;AAAA,aACtC;AACL,gBAAQ,KAAK;AAAA;AAAA;AAGjB,WAAO,QAAQ,KAAK;AAAA;AAAA;AAIxB,SAAS,SAAS,SAAS,EAAC,cAAc,WAAW,IAAI,WAAW;",
  "names": []
}
