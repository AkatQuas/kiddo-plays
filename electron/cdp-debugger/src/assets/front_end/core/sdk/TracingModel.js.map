{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/TracingModel.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\n\nimport type {EventPayload} from './TracingManager.js';\n\ntype IgnoreListArgs = {\n  [key: string]: string|number|ObjectSnapshot,\n};\n\nexport class TracingModel {\n  #backingStorageInternal: BackingStorage;\n  #firstWritePending: boolean;\n  readonly #processById: Map<string|number, Process>;\n  readonly #processByName: Map<string, Process>;\n  #minimumRecordTimeInternal: number;\n  #maximumRecordTimeInternal: number;\n  readonly #devToolsMetadataEventsInternal: Event[];\n  #asyncEvents: AsyncEvent[];\n  readonly #openAsyncEvents: Map<string, AsyncEvent>;\n  readonly #openNestableAsyncEvents: Map<string, AsyncEvent[]>;\n  readonly #profileGroups: Map<string, ProfileEventsGroup>;\n  readonly #parsedCategories: Map<string, Set<string>>;\n  readonly #mainFrameNavStartTimes: Map<string, Event>;\n\n  constructor(backingStorage: BackingStorage) {\n    this.#backingStorageInternal = backingStorage;\n    // Avoid extra reset of the storage as it's expensive.\n    this.#firstWritePending = true;\n    this.#processById = new Map();\n    this.#processByName = new Map();\n    this.#minimumRecordTimeInternal = Number(Infinity);\n    this.#maximumRecordTimeInternal = Number(-Infinity);\n    this.#devToolsMetadataEventsInternal = [];\n    this.#asyncEvents = [];\n    this.#openAsyncEvents = new Map();\n    this.#openNestableAsyncEvents = new Map();\n    this.#profileGroups = new Map();\n    this.#parsedCategories = new Map();\n    this.#mainFrameNavStartTimes = new Map();\n  }\n\n  static isNestableAsyncPhase(phase: string): boolean {\n    return phase === 'b' || phase === 'e' || phase === 'n';\n  }\n\n  static isAsyncBeginPhase(phase: string): boolean {\n    return phase === 'S' || phase === 'b';\n  }\n\n  static isAsyncPhase(phase: string): boolean {\n    return TracingModel.isNestableAsyncPhase(phase) || phase === 'S' || phase === 'T' || phase === 'F' || phase === 'p';\n  }\n\n  static isFlowPhase(phase: string): boolean {\n    return phase === 's' || phase === 't' || phase === 'f';\n  }\n\n  static isCompletePhase(phase: string): boolean {\n    return phase === 'X';\n  }\n\n  static isTopLevelEvent(event: Event): boolean {\n    return event.hasCategory(DevToolsTimelineEventCategory) && event.name === 'RunTask' ||\n        event.hasCategory(LegacyTopLevelEventCategory) ||\n        event.hasCategory(DevToolsMetadataEventCategory) &&\n        event.name === 'Program';  // Older timelines may have this instead of toplevel.\n  }\n\n  static extractId(payload: EventPayload): string|undefined {\n    const scope = payload.scope || '';\n    if (typeof payload.id2 === 'undefined') {\n      return scope && payload.id ? `${scope}@${payload.id}` : payload.id;\n    }\n    const id2 = payload.id2;\n    if (typeof id2 === 'object' && ('global' in id2) !== ('local' in id2)) {\n      return typeof id2['global'] !== 'undefined' ? `:${scope}:${id2['global']}` :\n                                                    `:${scope}:${payload.pid}:${id2['local']}`;\n    }\n    console.error(\n        `Unexpected id2 field at ${payload.ts / 1000}, one and only one of 'local' and 'global' should be present.`);\n    return undefined;\n  }\n\n  static browserMainThread(tracingModel: TracingModel): Thread|null {\n    const processes = tracingModel.sortedProcesses();\n    // Avoid warning for an empty #model.\n    if (!processes.length) {\n      return null;\n    }\n    const browserMainThreadName = 'CrBrowserMain';\n    const browserProcesses = [];\n    const browserMainThreads = [];\n    for (const process of processes) {\n      if (process.name().toLowerCase().endsWith('browser')) {\n        browserProcesses.push(process);\n      }\n      browserMainThreads.push(...process.sortedThreads().filter(t => t.name() === browserMainThreadName));\n    }\n    if (browserMainThreads.length === 1) {\n      return browserMainThreads[0];\n    }\n    if (browserProcesses.length === 1) {\n      return browserProcesses[0].threadByName(browserMainThreadName);\n    }\n    const tracingStartedInBrowser =\n        tracingModel.devToolsMetadataEvents().filter(e => e.name === 'TracingStartedInBrowser');\n    if (tracingStartedInBrowser.length === 1) {\n      return tracingStartedInBrowser[0].thread;\n    }\n    Common.Console.Console.instance().error(\n        'Failed to find browser main thread in trace, some timeline features may be unavailable');\n    return null;\n  }\n\n  devToolsMetadataEvents(): Event[] {\n    return this.#devToolsMetadataEventsInternal;\n  }\n\n  addEvents(events: EventPayload[]): void {\n    for (let i = 0; i < events.length; ++i) {\n      this.addEvent(events[i]);\n    }\n  }\n\n  tracingComplete(): void {\n    this.processPendingAsyncEvents();\n    this.#backingStorageInternal.appendString(this.#firstWritePending ? '[]' : ']');\n    this.#backingStorageInternal.finishWriting();\n    this.#firstWritePending = false;\n    for (const process of this.#processById.values()) {\n      for (const thread of process.threads.values()) {\n        thread.tracingComplete();\n      }\n    }\n  }\n\n  dispose(): void {\n    if (!this.#firstWritePending) {\n      this.#backingStorageInternal.reset();\n    }\n  }\n\n  adjustTime(offset: number): void {\n    this.#minimumRecordTimeInternal += offset;\n    this.#maximumRecordTimeInternal += offset;\n    for (const process of this.#processById.values()) {\n      for (const thread of process.threads.values()) {\n        for (const event of thread.events()) {\n          event.startTime += offset;\n          if (typeof event.endTime === 'number') {\n            event.endTime += offset;\n          }\n        }\n        for (const event of thread.asyncEvents()) {\n          event.startTime += offset;\n          if (typeof event.endTime === 'number') {\n            event.endTime += offset;\n          }\n        }\n      }\n    }\n  }\n\n  private addEvent(payload: EventPayload): void {\n    let process = this.#processById.get(payload.pid);\n    if (!process) {\n      process = new Process(this, payload.pid);\n      this.#processById.set(payload.pid, process);\n    }\n\n    const phase = Phase;\n    const eventsDelimiter = ',\\n';\n    this.#backingStorageInternal.appendString(this.#firstWritePending ? '[' : eventsDelimiter);\n    this.#firstWritePending = false;\n    const stringPayload = JSON.stringify(payload);\n    const isAccessible = payload.ph === phase.SnapshotObject;\n    let backingStorage: (() => Promise<string|null>)|null = null;\n    const keepStringsLessThan = 10000;\n    if (isAccessible && stringPayload.length > keepStringsLessThan) {\n      backingStorage = this.#backingStorageInternal.appendAccessibleString(stringPayload);\n    } else {\n      this.#backingStorageInternal.appendString(stringPayload);\n    }\n\n    const timestamp = payload.ts / 1000;\n    // We do allow records for unrelated threads to arrive out-of-order,\n    // so there's a chance we're getting records from the past.\n    if (timestamp && timestamp < this.#minimumRecordTimeInternal &&\n        (payload.ph === phase.Begin || payload.ph === phase.Complete || payload.ph === phase.Instant) &&\n        // UMA related events are ignored when calculating the minimumRecordTime because they might\n        // be related to previous navigations that happened before the current trace started and\n        // will currently not be displayed anyways.\n        // See crbug.com/1201198\n        (!payload.name.endsWith('::UMA'))) {\n      this.#minimumRecordTimeInternal = timestamp;\n    }\n\n    if (payload.name === 'TracingStartedInBrowser') {\n      // If we received a timestamp for tracing start, use that for minimumRecordTime.\n      this.#minimumRecordTimeInternal = timestamp;\n    }\n\n    // Track only main thread navigation start items. This is done by tracking\n    // isOutermostMainFrame, and whether documentLoaderURL is set.\n    if (payload.name === 'navigationStart') {\n      const data = (payload.args.data as {\n        isLoadingMainFrame: boolean,\n        documentLoaderURL: string,\n        navigationId: string,\n        isOutermostMainFrame?: boolean,\n      } | null);\n      if (data) {\n        const {isLoadingMainFrame, documentLoaderURL, navigationId, isOutermostMainFrame} = data;\n        if ((isOutermostMainFrame ?? isLoadingMainFrame) && documentLoaderURL !== '') {\n          const thread = process.threadById(payload.tid);\n          const navStartEvent = Event.fromPayload(payload, thread);\n          this.#mainFrameNavStartTimes.set(navigationId, navStartEvent);\n        }\n      }\n    }\n\n    const endTimeStamp = (payload.ts + (payload.dur || 0)) / 1000;\n    this.#maximumRecordTimeInternal = Math.max(this.#maximumRecordTimeInternal, endTimeStamp);\n    const event = process.addEvent(payload);\n    if (!event) {\n      return;\n    }\n    if (payload.ph === phase.Sample) {\n      this.addSampleEvent(event);\n      return;\n    }\n    // Build async event when we've got events from all threads & processes, so we can sort them and process in the\n    // chronological order. However, also add individual async events to the thread flow (above), so we can easily\n    // display them on the same chart as other events, should we choose so.\n    if (TracingModel.isAsyncPhase(payload.ph)) {\n      this.#asyncEvents.push((event as AsyncEvent));\n    }\n    event.setBackingStorage(backingStorage);\n    if (event.hasCategory(DevToolsMetadataEventCategory)) {\n      this.#devToolsMetadataEventsInternal.push(event);\n    }\n\n    if (payload.ph !== phase.Metadata) {\n      return;\n    }\n\n    switch (payload.name) {\n      case MetadataEvent.ProcessSortIndex: {\n        process.setSortIndex(payload.args['sort_index']);\n        break;\n      }\n      case MetadataEvent.ProcessName: {\n        const processName = payload.args['name'];\n        process.setName(processName);\n        this.#processByName.set(processName, process);\n        break;\n      }\n      case MetadataEvent.ThreadSortIndex: {\n        process.threadById(payload.tid).setSortIndex(payload.args['sort_index']);\n        break;\n      }\n      case MetadataEvent.ThreadName: {\n        process.threadById(payload.tid).setName(payload.args['name']);\n        break;\n      }\n    }\n  }\n\n  private addSampleEvent(event: Event): void {\n    const id = `${event.thread.process().id()}:${event.id}`;\n    const group = this.#profileGroups.get(id);\n    if (group) {\n      group.addChild(event);\n    } else {\n      this.#profileGroups.set(id, new ProfileEventsGroup(event));\n    }\n  }\n\n  profileGroup(event: Event): ProfileEventsGroup|null {\n    return this.#profileGroups.get(`${event.thread.process().id()}:${event.id}`) || null;\n  }\n\n  minimumRecordTime(): number {\n    return this.#minimumRecordTimeInternal;\n  }\n\n  maximumRecordTime(): number {\n    return this.#maximumRecordTimeInternal;\n  }\n\n  navStartTimes(): Map<string, Event> {\n    return this.#mainFrameNavStartTimes;\n  }\n\n  sortedProcesses(): Process[] {\n    return NamedObject.sort([...this.#processById.values()]);\n  }\n\n  getProcessByName(name: string): Process|null {\n    return this.#processByName.get(name) ?? null;\n  }\n\n  getProcessById(pid: number): Process|null {\n    return this.#processById.get(pid) || null;\n  }\n\n  getThreadByName(processName: string, threadName: string): Thread|null {\n    const process = this.getProcessByName(processName);\n    return process && process.threadByName(threadName);\n  }\n\n  private processPendingAsyncEvents(): void {\n    this.#asyncEvents.sort(Event.compareStartTime);\n    for (let i = 0; i < this.#asyncEvents.length; ++i) {\n      const event = this.#asyncEvents[i];\n      if (TracingModel.isNestableAsyncPhase(event.phase)) {\n        this.addNestableAsyncEvent(event);\n      } else {\n        this.addAsyncEvent(event);\n      }\n    }\n    this.#asyncEvents = [];\n    this.closeOpenAsyncEvents();\n  }\n\n  private closeOpenAsyncEvents(): void {\n    for (const event of this.#openAsyncEvents.values()) {\n      event.setEndTime(this.#maximumRecordTimeInternal);\n      // FIXME: remove this once we figure a better way to convert async console\n      // events to sync [waterfall] timeline records.\n      event.steps[0].setEndTime(this.#maximumRecordTimeInternal);\n    }\n    this.#openAsyncEvents.clear();\n\n    for (const eventStack of this.#openNestableAsyncEvents.values()) {\n      while (eventStack.length) {\n        const event = eventStack.pop();\n        if (!event) {\n          continue;\n        }\n        event.setEndTime(this.#maximumRecordTimeInternal);\n      }\n    }\n    this.#openNestableAsyncEvents.clear();\n  }\n\n  private addNestableAsyncEvent(event: Event): void {\n    const phase = Phase;\n    const key = event.categoriesString + '.' + event.id;\n    let openEventsStack = this.#openNestableAsyncEvents.get(key);\n\n    switch (event.phase) {\n      case phase.NestableAsyncBegin: {\n        if (!openEventsStack) {\n          openEventsStack = [];\n          this.#openNestableAsyncEvents.set(key, openEventsStack);\n        }\n        const asyncEvent = new AsyncEvent(event);\n        openEventsStack.push(asyncEvent);\n        event.thread.addAsyncEvent(asyncEvent);\n        break;\n      }\n\n      case phase.NestableAsyncInstant: {\n        if (openEventsStack && openEventsStack.length) {\n          const event = openEventsStack[openEventsStack.length - 1];\n          if (event) {\n            event.addStep(event);\n          }\n        }\n        break;\n      }\n\n      case phase.NestableAsyncEnd: {\n        if (!openEventsStack || !openEventsStack.length) {\n          break;\n        }\n        const top = openEventsStack.pop();\n        if (!top) {\n          break;\n        }\n        if (top.name !== event.name) {\n          console.error(\n              `Begin/end event mismatch for nestable async event, ${top.name} vs. ${event.name}, key: ${key}`);\n          break;\n        }\n        top.addStep(event);\n      }\n    }\n  }\n\n  private addAsyncEvent(event: Event): void {\n    const phase = Phase;\n    const key = event.categoriesString + '.' + event.name + '.' + event.id;\n    let asyncEvent = this.#openAsyncEvents.get(key);\n\n    if (event.phase === phase.AsyncBegin) {\n      if (asyncEvent) {\n        console.error(`Event ${event.name} has already been started`);\n        return;\n      }\n      asyncEvent = new AsyncEvent(event);\n      this.#openAsyncEvents.set(key, asyncEvent);\n      event.thread.addAsyncEvent(asyncEvent);\n      return;\n    }\n    if (!asyncEvent) {\n      // Quietly ignore stray async events, we're probably too late for the start.\n      return;\n    }\n    if (event.phase === phase.AsyncEnd) {\n      asyncEvent.addStep(event);\n      this.#openAsyncEvents.delete(key);\n      return;\n    }\n    if (event.phase === phase.AsyncStepInto || event.phase === phase.AsyncStepPast) {\n      const lastStep = asyncEvent.steps[asyncEvent.steps.length - 1];\n      if (lastStep && lastStep.phase !== phase.AsyncBegin && lastStep.phase !== event.phase) {\n        console.assert(\n            false,\n            'Async event step phase mismatch: ' + lastStep.phase + ' at ' + lastStep.startTime + ' vs. ' + event.phase +\n                ' at ' + event.startTime);\n        return;\n      }\n      asyncEvent.addStep(event);\n      return;\n    }\n    console.assert(false, 'Invalid async event phase');\n  }\n\n  backingStorage(): BackingStorage {\n    return this.#backingStorageInternal;\n  }\n\n  parsedCategoriesForString(str: string): Set<string> {\n    let parsedCategories = this.#parsedCategories.get(str);\n    if (!parsedCategories) {\n      parsedCategories = new Set(str ? str.split(',') : []);\n      this.#parsedCategories.set(str, parsedCategories);\n    }\n    return parsedCategories;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Phase {\n  Begin = 'B',\n  End = 'E',\n  Complete = 'X',\n  Instant = 'I',\n  AsyncBegin = 'S',\n  AsyncStepInto = 'T',\n  AsyncStepPast = 'p',\n  AsyncEnd = 'F',\n  NestableAsyncBegin = 'b',\n  NestableAsyncEnd = 'e',\n  NestableAsyncInstant = 'n',\n  FlowBegin = 's',\n  FlowStep = 't',\n  FlowEnd = 'f',\n  Metadata = 'M',\n  Counter = 'C',\n  Sample = 'P',\n  CreateObject = 'N',\n  SnapshotObject = 'O',\n  DeleteObject = 'D',\n}\n\nexport const MetadataEvent = {\n  ProcessSortIndex: 'process_sort_index',\n  ProcessName: 'process_name',\n  ThreadSortIndex: 'thread_sort_index',\n  ThreadName: 'thread_name',\n};\n\n// TODO(alph): LegacyTopLevelEventCategory is not recorded since M74 and used for loading\n// legacy profiles. Drop at some point.\nexport const LegacyTopLevelEventCategory = 'toplevel';\n\nexport const DevToolsMetadataEventCategory = 'disabled-by-default-devtools.timeline';\nexport const DevToolsTimelineEventCategory = 'disabled-by-default-devtools.timeline';\n\nexport abstract class BackingStorage {\n  appendString(_string: string): void {\n  }\n\n  abstract appendAccessibleString(string: string): () => Promise<string|null>;\n\n  finishWriting(): void {\n  }\n\n  reset(): void {\n  }\n}\n\nexport class Event {\n  categoriesString: string;\n  readonly #parsedCategories: Set<string>;\n  name: string;\n  phase: Phase;\n  startTime: number;\n  thread: Thread;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: any;\n  id!: string|null;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  bind_id!: string|null;\n  ordinal: number;\n  selfTime: number;\n  endTime?: number;\n  duration?: number;\n\n  constructor(categories: string|undefined, name: string, phase: Phase, startTime: number, thread: Thread) {\n    this.categoriesString = categories || '';\n    this.#parsedCategories = thread.getModel().parsedCategoriesForString(this.categoriesString);\n    this.name = name;\n    this.phase = phase;\n    this.startTime = startTime;\n    this.thread = thread;\n    this.args = {};\n    this.ordinal = 0;\n\n    this.selfTime = 0;\n  }\n\n  static fromPayload(payload: EventPayload, thread: Thread): Event {\n    const event = new Event(payload.cat, payload.name, (payload.ph as Phase), payload.ts / 1000, thread);\n    if (payload.args) {\n      event.addArgs(payload.args);\n    }\n    if (typeof payload.dur === 'number') {\n      event.setEndTime((payload.ts + payload.dur) / 1000);\n    }\n    const id = TracingModel.extractId(payload);\n    if (typeof id !== 'undefined') {\n      event.id = id;\n    }\n    if (payload.bind_id) {\n      event.bind_id = payload.bind_id;\n    }\n\n    return event;\n  }\n\n  static compareStartTime(a: Event|null, b: Event|null): number {\n    if (!a || !b) {\n      return 0;\n    }\n\n    return a.startTime - b.startTime;\n  }\n\n  static orderedCompareStartTime(a: Event, b: Event): number {\n    // Array.mergeOrdered coalesces objects if comparator returns 0.\n    // To change this behavior this comparator return -1 in the case events\n    // startTime's are equal, so both events got placed into the result array.\n    return a.startTime - b.startTime || a.ordinal - b.ordinal || -1;\n  }\n\n  hasCategory(categoryName: string): boolean {\n    return this.#parsedCategories.has(categoryName);\n  }\n\n  setEndTime(endTime: number): void {\n    if (endTime < this.startTime) {\n      console.assert(false, 'Event out of order: ' + this.name);\n      return;\n    }\n    this.endTime = endTime;\n    this.duration = endTime - this.startTime;\n  }\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  addArgs(args: any): void {\n    // Shallow copy args to avoid modifying original #payload which may be saved to file.\n    for (const name in args) {\n      if (name in this.args) {\n        console.error('Same argument name (' + name + ') is used for begin and end phases of ' + this.name);\n      }\n\n      (this.args as IgnoreListArgs)[name] = (args as IgnoreListArgs)[name];\n    }\n  }\n\n  complete(endEvent: Event): void {\n    if (endEvent.args) {\n      this.addArgs(endEvent.args);\n    } else {\n      console.error('Missing mandatory event argument \\'args\\' at ' + endEvent.startTime);\n    }\n    this.setEndTime(endEvent.startTime);\n  }\n\n  setBackingStorage(_backingStorage: (() => Promise<string|null>)|null): void {\n  }\n}\n\n// eslint-disable-next-line rulesdir/enforce_custom_event_names, rulesdir/static_custom_event_names\nexport class ObjectSnapshot extends Event {\n  #backingStorage: (() => Promise<string|null>)|null;\n  #objectPromiseInternal: Promise<ObjectSnapshot|null>|null;\n\n  constructor(category: string|undefined, name: string, startTime: number, thread: Thread) {\n    super(category, name, Phase.SnapshotObject, startTime, thread);\n    this.#backingStorage = null;\n    this.#objectPromiseInternal = null;\n  }\n\n  static fromPayload(payload: EventPayload, thread: Thread): ObjectSnapshot {\n    const snapshot = new ObjectSnapshot(payload.cat, payload.name, payload.ts / 1000, thread);\n    const id = TracingModel.extractId(payload);\n    if (typeof id !== 'undefined') {\n      snapshot.id = id;\n    }\n    if (!payload.args || !payload.args['snapshot']) {\n      console.error('Missing mandatory \\'snapshot\\' argument at ' + payload.ts / 1000);\n      return snapshot;\n    }\n    if (payload.args) {\n      snapshot.addArgs(payload.args);\n    }\n    return snapshot;\n  }\n\n  requestObject(callback: (arg0: ObjectSnapshot|null) => void): void {\n    const snapshot = this.args['snapshot'];\n    if (snapshot) {\n      callback((snapshot as ObjectSnapshot));\n      return;\n    }\n    const storage = this.#backingStorage;\n    if (storage) {\n      storage().then(onRead, callback.bind(null, null));\n    }\n\n    function onRead(result: string|null): void {\n      if (!result) {\n        callback(null);\n        return;\n      }\n      try {\n        const payload = JSON.parse(result);\n        callback(payload['args']['snapshot']);\n      } catch (e) {\n        Common.Console.Console.instance().error('Malformed event data in backing storage');\n        callback(null);\n      }\n    }\n  }\n\n  objectPromise(): Promise<ObjectSnapshot|null> {\n    if (!this.#objectPromiseInternal) {\n      this.#objectPromiseInternal = new Promise(this.requestObject.bind(this));\n    }\n    return this.#objectPromiseInternal;\n  }\n\n  setBackingStorage(backingStorage: (() => Promise<string|null>)|null): void {\n    if (!backingStorage) {\n      return;\n    }\n    this.#backingStorage = backingStorage;\n    this.args = {};\n  }\n}\n\n// eslint-disable-next-line rulesdir/enforce_custom_event_names, rulesdir/static_custom_event_names\nexport class AsyncEvent extends Event {\n  steps: Event[];\n  causedFrame: boolean;\n\n  constructor(startEvent: Event) {\n    super(startEvent.categoriesString, startEvent.name, startEvent.phase, startEvent.startTime, startEvent.thread);\n    this.addArgs(startEvent.args);\n    this.steps = [startEvent];\n    this.causedFrame = false;\n  }\n\n  addStep(event: Event): void {\n    this.steps.push(event);\n    if (event.phase === Phase.AsyncEnd || event.phase === Phase.NestableAsyncEnd) {\n      this.setEndTime(event.startTime);\n      // FIXME: ideally, we shouldn't do this, but this makes the logic of converting\n      // async console events to sync ones much simpler.\n      this.steps[0].setEndTime(event.startTime);\n    }\n  }\n}\n\nclass ProfileEventsGroup {\n  children: Event[];\n  constructor(event: Event) {\n    this.children = [event];\n  }\n\n  addChild(event: Event): void {\n    this.children.push(event);\n  }\n}\n\nclass NamedObject {\n  model: TracingModel;\n  readonly idInternal: number;\n  #nameInternal: string;\n  #sortIndex: number;\n  constructor(model: TracingModel, id: number) {\n    this.model = model;\n    this.idInternal = id;\n    this.#nameInternal = '';\n    this.#sortIndex = 0;\n  }\n\n  static sort<Item extends NamedObject>(array: Item[]): Item[] {\n    return array.sort((a, b) => {\n      return a.#sortIndex !== b.#sortIndex ? a.#sortIndex - b.#sortIndex : a.name().localeCompare(b.name());\n    });\n  }\n\n  setName(name: string): void {\n    this.#nameInternal = name;\n  }\n\n  name(): string {\n    return this.#nameInternal;\n  }\n\n  id(): number {\n    return this.idInternal;\n  }\n\n  setSortIndex(sortIndex: number): void {\n    this.#sortIndex = sortIndex;\n  }\n\n  getModel(): TracingModel {\n    return this.model;\n  }\n}\n\nexport class Process extends NamedObject {\n  readonly threads: Map<number, Thread>;\n  readonly #threadByNameInternal: Map<string, Thread|null>;\n  constructor(model: TracingModel, id: number) {\n    super(model, id);\n    this.threads = new Map();\n    this.#threadByNameInternal = new Map();\n  }\n\n  threadById(id: number): Thread {\n    let thread = this.threads.get(id);\n    if (!thread) {\n      thread = new Thread(this, id);\n      this.threads.set(id, thread);\n    }\n    return thread;\n  }\n\n  threadByName(name: string): Thread|null {\n    return this.#threadByNameInternal.get(name) || null;\n  }\n\n  setThreadByName(name: string, thread: Thread): void {\n    this.#threadByNameInternal.set(name, thread);\n  }\n\n  addEvent(payload: EventPayload): Event|null {\n    return this.threadById(payload.tid).addEvent(payload);\n  }\n\n  sortedThreads(): Thread[] {\n    return NamedObject.sort([...this.threads.values()]);\n  }\n}\n\nexport class Thread extends NamedObject {\n  readonly #processInternal: Process;\n  #eventsInternal: Event[];\n  readonly #asyncEventsInternal: AsyncEvent[];\n  #lastTopLevelEvent: Event|null;\n  constructor(process: Process, id: number) {\n    super(process.getModel(), id);\n    this.#processInternal = process;\n\n    this.#eventsInternal = [];\n    this.#asyncEventsInternal = [];\n    this.#lastTopLevelEvent = null;\n  }\n\n  tracingComplete(): void {\n    this.#asyncEventsInternal.sort(Event.compareStartTime);\n    this.#eventsInternal.sort(Event.compareStartTime);\n    const phases = Phase;\n    const stack: Event[] = [];\n    const toDelete = new Set<number>();\n    for (let i = 0; i < this.#eventsInternal.length; ++i) {\n      const e = this.#eventsInternal[i];\n      e.ordinal = i;\n      switch (e.phase) {\n        case phases.End: {\n          toDelete.add(i);  // Mark for removal.\n          // Quietly ignore unbalanced close events, they're legit (we could have missed start one).\n          if (!stack.length) {\n            continue;\n          }\n          const top = stack.pop();\n          if (!top) {\n            continue;\n          }\n          if (top.name !== e.name || top.categoriesString !== e.categoriesString) {\n            console.error(\n                'B/E events mismatch at ' + top.startTime + ' (' + top.name + ') vs. ' + e.startTime + ' (' + e.name +\n                ')');\n          } else {\n            top.complete(e);\n          }\n          break;\n        }\n        case phases.Begin: {\n          stack.push(e);\n          break;\n        }\n      }\n    }\n\n    // Handle Begin events with no matching End.\n    // This commonly happens due to a bug in the trace machinery. See crbug.com/982252\n    while (stack.length) {\n      const event = stack.pop();\n      if (event) {\n        // Masquerade the event as Instant, so it's rendered to the user.\n        // The ideal fix is resolving crbug.com/1021571, but handling that without a perfetto migration appears prohibitive\n        event.phase = phases.Instant;\n      }\n    }\n    this.#eventsInternal = this.#eventsInternal.filter((_, idx) => !toDelete.has(idx));\n  }\n\n  addEvent(payload: EventPayload): Event|null {\n    const event = payload.ph === Phase.SnapshotObject ? ObjectSnapshot.fromPayload(payload, this) :\n                                                        Event.fromPayload(payload, this);\n    if (TracingModel.isTopLevelEvent(event)) {\n      // Discard nested \"top-level\" events.\n      const lastTopLevelEvent = this.#lastTopLevelEvent;\n      if (lastTopLevelEvent && (lastTopLevelEvent.endTime || 0) > event.startTime) {\n        return null;\n      }\n      this.#lastTopLevelEvent = event;\n    }\n    this.#eventsInternal.push(event);\n    return event;\n  }\n\n  addAsyncEvent(asyncEvent: AsyncEvent): void {\n    this.#asyncEventsInternal.push(asyncEvent);\n  }\n\n  setName(name: string): void {\n    super.setName(name);\n    this.#processInternal.setThreadByName(name, this);\n  }\n\n  process(): Process {\n    return this.#processInternal;\n  }\n\n  events(): Event[] {\n    return this.#eventsInternal;\n  }\n\n  asyncEvents(): AsyncEvent[] {\n    return this.#asyncEventsInternal;\n  }\n\n  removeEventsByName(name: string): Event[] {\n    const extracted: Event[] = [];\n    this.#eventsInternal = this.#eventsInternal.filter(e => {\n      if (!e) {\n        return false;\n      }\n\n      if (e.name !== name) {\n        return true;\n      }\n\n      extracted.push(e);\n      return false;\n    });\n\n    return extracted;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
