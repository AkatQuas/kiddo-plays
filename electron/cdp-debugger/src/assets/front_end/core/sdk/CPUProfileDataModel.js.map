{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/CPUProfileDataModel.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as i18n from '../i18n/i18n.js';\nimport * as Platform from '../platform/platform.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {ProfileNode, ProfileTreeModel} from './ProfileTreeModel.js';\nimport type {Target} from './Target.js';\n\nconst UIStrings = {\n  /**\n   * @description Text in CPUProfile Data Model. The phrase is a warning shown to users when\n   * DevTools has received incomplete data and tries to interpolate the missing data manually.\n   * The placeholder is always a number, and references the number of data points that DevTools\n   * is trying to fix up.\n   * A sample is a single point of recorded data at a specific point in time. If many such samples\n   * are collected over a period of time, its called a \"profile\". In this context, \"CPU profile\"\n   * means collected data about the behavior of the CPU.\n   * \"Parser\" in this context is the piece of DevTools, that interprets the collected samples.\n   * @example {2} PH1\n   */\n  devtoolsCpuProfileParserIsFixing: '`DevTools`: `CPU` profile parser is fixing {PH1} missing samples.',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/CPUProfileDataModel.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class CPUProfileNode extends ProfileNode {\n  id: number;\n  self: number;\n  positionTicks: Protocol.Profiler.PositionTickInfo[]|undefined;\n  deoptReason: string|null;\n\n  constructor(node: Protocol.Profiler.ProfileNode, sampleTime: number) {\n    const callFrame = node.callFrame || ({\n                        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n                        // @ts-expect-error\n                        functionName: node['functionName'],\n                        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n                        // @ts-expect-error\n                        scriptId: node['scriptId'],\n                        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n                        // @ts-expect-error\n                        url: node['url'],\n                        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n                        // @ts-expect-error\n                        lineNumber: node['lineNumber'] - 1,\n                        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n                        // @ts-expect-error\n                        columnNumber: node['columnNumber'] - 1,\n                      } as Protocol.Runtime.CallFrame);\n    super(callFrame);\n    this.id = node.id;\n    this.self = (node.hitCount || 0) * sampleTime;\n    this.positionTicks = node.positionTicks;\n    // Compatibility: legacy backends could provide \"no reason\" for optimized functions.\n    this.deoptReason = node.deoptReason && node.deoptReason !== 'no reason' ? node.deoptReason : null;\n  }\n}\n\nexport class CPUProfileDataModel extends ProfileTreeModel {\n  profileStartTime: number;\n  profileEndTime: number;\n  timestamps: number[];\n  samples: number[]|undefined;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  lines: any;\n  totalHitCount: number;\n  profileHead: CPUProfileNode;\n  #idToNode!: Map<number, CPUProfileNode>;\n  gcNode!: CPUProfileNode;\n  programNode?: ProfileNode;\n  idleNode?: ProfileNode;\n  #stackStartTimes?: Float64Array;\n  #stackChildrenDuration?: Float64Array;\n  constructor(profile: Protocol.Profiler.Profile, target: Target|null) {\n    super(target);\n    // @ts-ignore Legacy types\n    const isLegacyFormat = Boolean(profile['head']);\n    if (isLegacyFormat) {\n      // Legacy format contains raw timestamps and start/stop times are in seconds.\n      this.profileStartTime = profile.startTime * 1000;\n      this.profileEndTime = profile.endTime * 1000;\n      // @ts-ignore Legacy types\n      this.timestamps = profile.timestamps;\n      this.compatibilityConversionHeadToNodes(profile);\n    } else {\n      // Current format encodes timestamps as deltas. Start/stop times are in microseconds.\n      this.profileStartTime = profile.startTime / 1000;\n      this.profileEndTime = profile.endTime / 1000;\n      this.timestamps = this.convertTimeDeltas(profile);\n    }\n    this.samples = profile.samples;\n    // @ts-ignore Legacy types\n    this.lines = profile.lines;\n    this.totalHitCount = 0;\n    this.profileHead = this.translateProfileTree(profile.nodes);\n    this.initialize(this.profileHead);\n    this.extractMetaNodes();\n    if (this.samples) {\n      this.buildIdToNodeMap();\n      this.sortSamples();\n      this.normalizeTimestamps();\n      this.fixMissingSamples();\n    }\n  }\n\n  private compatibilityConversionHeadToNodes(profile: Protocol.Profiler.Profile): void {\n    // @ts-ignore Legacy types\n    if (!profile.head || profile.nodes) {\n      return;\n    }\n    const nodes: Protocol.Profiler.ProfileNode[] = [];\n    // @ts-ignore Legacy types\n    convertNodesTree(profile.head);\n    profile.nodes = nodes;\n    // @ts-ignore Legacy types\n    delete profile.head;\n    function convertNodesTree(node: Protocol.Profiler.ProfileNode): number {\n      nodes.push(node);\n      // @ts-ignore Legacy types\n      node.children = (node.children as Protocol.Profiler.ProfileNode[]).map(convertNodesTree);\n      return node.id;\n    }\n  }\n\n  private convertTimeDeltas(profile: Protocol.Profiler.Profile): number[] {\n    if (!profile.timeDeltas) {\n      return [];\n    }\n    let lastTimeUsec = profile.startTime;\n    const timestamps = new Array(profile.timeDeltas.length);\n    for (let i = 0; i < profile.timeDeltas.length; ++i) {\n      lastTimeUsec += profile.timeDeltas[i];\n      timestamps[i] = lastTimeUsec;\n    }\n    return timestamps;\n  }\n\n  private translateProfileTree(nodes: Protocol.Profiler.ProfileNode[]): CPUProfileNode {\n    function isNativeNode(node: Protocol.Profiler.ProfileNode): boolean {\n      if (node.callFrame) {\n        return Boolean(node.callFrame.url) && node.callFrame.url.startsWith('native ');\n      }\n      // @ts-ignore Legacy types\n      return Boolean(node['url']) && node['url'].startsWith('native ');\n    }\n\n    function buildChildrenFromParents(nodes: Protocol.Profiler.ProfileNode[]): void {\n      if (nodes[0].children) {\n        return;\n      }\n      nodes[0].children = [];\n      for (let i = 1; i < nodes.length; ++i) {\n        const node = nodes[i];\n        // @ts-ignore Legacy types\n        const parentNode = nodeByIdMap.get(node.parent);\n        // @ts-ignore Legacy types\n        if (parentNode.children) {\n          // @ts-ignore Legacy types\n          parentNode.children.push(node.id);\n        } else {\n          // @ts-ignore Legacy types\n          parentNode.children = [node.id];\n        }\n      }\n    }\n\n    function buildHitCountFromSamples(nodes: Protocol.Profiler.ProfileNode[], samples: number[]|undefined): void {\n      if (typeof (nodes[0].hitCount) === 'number') {\n        return;\n      }\n      if (!samples) {\n        throw new Error('Error: Neither hitCount nor samples are present in profile.');\n      }\n      for (let i = 0; i < nodes.length; ++i) {\n        nodes[i].hitCount = 0;\n      }\n      for (let i = 0; i < samples.length; ++i) {\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n        // @ts-expect-error\n        ++((nodeByIdMap.get(samples[i]) as Protocol.Profiler.ProfileNode).hitCount);\n      }\n    }\n\n    const nodeByIdMap = new Map<number, Protocol.Profiler.ProfileNode>();\n    for (let i = 0; i < nodes.length; ++i) {\n      const node = nodes[i];\n      nodeByIdMap.set(node.id, node);\n    }\n\n    buildHitCountFromSamples(nodes, this.samples);\n    buildChildrenFromParents(nodes);\n    this.totalHitCount = nodes.reduce((acc, node) => acc + (node.hitCount || 0), 0);\n    const sampleTime = (this.profileEndTime - this.profileStartTime) / this.totalHitCount;\n    const keepNatives =\n        Boolean(Common.Settings.Settings.instance().moduleSetting('showNativeFunctionsInJSProfile').get());\n    const root = nodes[0];\n    const idMap = new Map<number, number>([[root.id, root.id]]);\n    const resultRoot = new CPUProfileNode(root, sampleTime);\n    if (!root.children) {\n      throw new Error('Missing children for root');\n    }\n    const parentNodeStack = root.children.map(() => resultRoot);\n    const sourceNodeStack = root.children.map(id => nodeByIdMap.get(id));\n    while (sourceNodeStack.length) {\n      let parentNode = parentNodeStack.pop();\n      const sourceNode = sourceNodeStack.pop();\n      if (!sourceNode || !parentNode) {\n        continue;\n      }\n      if (!sourceNode.children) {\n        sourceNode.children = [];\n      }\n      const targetNode = new CPUProfileNode(sourceNode, sampleTime);\n      if (keepNatives || !isNativeNode(sourceNode)) {\n        parentNode.children.push(targetNode);\n        parentNode = targetNode;\n      } else {\n        parentNode.self += targetNode.self;\n      }\n      idMap.set(sourceNode.id, parentNode.id);\n      parentNodeStack.push.apply(parentNodeStack, sourceNode.children.map(() => parentNode as CPUProfileNode));\n      sourceNodeStack.push.apply(sourceNodeStack, sourceNode.children.map(id => nodeByIdMap.get(id)));\n    }\n    if (this.samples) {\n      this.samples = this.samples.map(id => idMap.get(id) as number);\n    }\n    return resultRoot;\n  }\n\n  private sortSamples(): void {\n    const timestamps = this.timestamps;\n    if (!timestamps) {\n      return;\n    }\n    const samples = this.samples;\n    if (!samples) {\n      return;\n    }\n    const indices = timestamps.map((x, index) => index);\n    indices.sort((a, b) => timestamps[a] - timestamps[b]);\n    for (let i = 0; i < timestamps.length; ++i) {\n      let index: number = indices[i];\n      if (index === i) {\n        continue;\n      }\n      // Move items in a cycle.\n      const savedTimestamp = timestamps[i];\n      const savedSample = samples[i];\n      let currentIndex: number = i;\n      while (index !== i) {\n        samples[currentIndex] = samples[index];\n        timestamps[currentIndex] = timestamps[index];\n        currentIndex = index;\n        index = indices[index];\n        indices[currentIndex] = currentIndex;\n      }\n      samples[currentIndex] = savedSample;\n      timestamps[currentIndex] = savedTimestamp;\n    }\n  }\n\n  private normalizeTimestamps(): void {\n    if (!this.samples) {\n      return;\n    }\n    let timestamps: number[] = this.timestamps;\n    if (!timestamps) {\n      // Support loading old CPU profiles that are missing timestamps.\n      // Derive timestamps from profile start and stop times.\n      const profileStartTime = this.profileStartTime;\n      const interval = (this.profileEndTime - profileStartTime) / this.samples.length;\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      timestamps = (new Float64Array(this.samples.length + 1) as any);\n      for (let i = 0; i < timestamps.length; ++i) {\n        timestamps[i] = profileStartTime + i * interval;\n      }\n      this.timestamps = timestamps;\n      return;\n    }\n\n    // Convert samples from usec to msec\n    for (let i = 0; i < timestamps.length; ++i) {\n      timestamps[i] /= 1000;\n    }\n    if (this.samples.length === timestamps.length) {\n      // Support for a legacy format where were no timeDeltas.\n      // Add an extra timestamp used to calculate the last sample duration.\n      const averageSample = ((timestamps[timestamps.length - 1] || 0) - timestamps[0]) / (timestamps.length - 1);\n      this.timestamps.push((timestamps[timestamps.length - 1] || 0) + averageSample);\n    }\n    this.profileStartTime = timestamps[0];\n    this.profileEndTime = (timestamps[timestamps.length - 1] as number);\n  }\n\n  private buildIdToNodeMap(): void {\n    this.#idToNode = new Map();\n    const idToNode = this.#idToNode;\n    const stack = [this.profileHead];\n    while (stack.length) {\n      const node = (stack.pop() as CPUProfileNode);\n      idToNode.set(node.id, node);\n      // @ts-ignore Legacy types\n      stack.push.apply(stack, node.children);\n    }\n  }\n\n  private extractMetaNodes(): void {\n    const topLevelNodes = this.profileHead.children;\n    for (let i = 0; i < topLevelNodes.length && !(this.gcNode && this.programNode && this.idleNode); i++) {\n      const node = topLevelNodes[i];\n      if (node.functionName === '(garbage collector)') {\n        this.gcNode = (node as CPUProfileNode);\n      } else if (node.functionName === '(program)') {\n        this.programNode = node;\n      } else if (node.functionName === '(idle)') {\n        this.idleNode = node;\n      }\n    }\n  }\n\n  private fixMissingSamples(): void {\n    // Sometimes sampler is not able to parse the JS stack and returns\n    // a (program) sample instead. The issue leads to call frames belong\n    // to the same function invocation being split apart.\n    // Here's a workaround for that. When there's a single (program) sample\n    // between two call stacks sharing the same bottom node, it is replaced\n    // with the preceeding sample.\n    const samples = this.samples;\n    if (!samples) {\n      return;\n    }\n    const samplesCount = samples.length;\n    if (!this.programNode || samplesCount < 3) {\n      return;\n    }\n    const idToNode = this.#idToNode;\n    const programNodeId = this.programNode.id;\n    const gcNodeId = this.gcNode ? this.gcNode.id : -1;\n    const idleNodeId = this.idleNode ? this.idleNode.id : -1;\n    let prevNodeId: number = samples[0];\n    let nodeId: number = samples[1];\n    let count = 0;\n    for (let sampleIndex = 1; sampleIndex < samplesCount - 1; sampleIndex++) {\n      const nextNodeId = samples[sampleIndex + 1];\n      if (nodeId === programNodeId && !isSystemNode(prevNodeId) && !isSystemNode(nextNodeId) &&\n          bottomNode((idToNode.get(prevNodeId) as ProfileNode)) ===\n              bottomNode((idToNode.get(nextNodeId) as ProfileNode))) {\n        ++count;\n        samples[sampleIndex] = prevNodeId;\n      }\n      prevNodeId = nodeId;\n      nodeId = nextNodeId;\n    }\n    if (count) {\n      Common.Console.Console.instance().warn(i18nString(UIStrings.devtoolsCpuProfileParserIsFixing, {PH1: count}));\n    }\n    function bottomNode(node: ProfileNode): ProfileNode {\n      while (node.parent && node.parent.parent) {\n        node = node.parent;\n      }\n      return node;\n    }\n    function isSystemNode(nodeId: number): boolean {\n      return nodeId === programNodeId || nodeId === gcNodeId || nodeId === idleNodeId;\n    }\n  }\n\n  forEachFrame(\n      openFrameCallback: (arg0: number, arg1: CPUProfileNode, arg2: number) => void,\n      closeFrameCallback: (arg0: number, arg1: CPUProfileNode, arg2: number, arg3: number, arg4: number) => void,\n      startTime?: number, stopTime?: number): void {\n    if (!this.profileHead || !this.samples) {\n      return;\n    }\n\n    startTime = startTime || 0;\n    stopTime = stopTime || Infinity;\n    const samples = this.samples;\n    const timestamps = this.timestamps;\n    const idToNode = this.#idToNode;\n    const gcNode = this.gcNode;\n    const samplesCount = samples.length;\n    const startIndex =\n        Platform.ArrayUtilities.lowerBound(timestamps, startTime, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n    let stackTop = 0;\n    const stackNodes = [];\n    let prevId: number = this.profileHead.id;\n    let sampleTime;\n    let gcParentNode: CPUProfileNode|null = null;\n\n    // Extra slots for gc being put on top,\n    // and one at the bottom to allow safe stackTop-1 access.\n    const stackDepth = this.maxDepth + 3;\n    if (!this.#stackStartTimes) {\n      this.#stackStartTimes = new Float64Array(stackDepth);\n    }\n    const stackStartTimes = this.#stackStartTimes;\n    if (!this.#stackChildrenDuration) {\n      this.#stackChildrenDuration = new Float64Array(stackDepth);\n    }\n    const stackChildrenDuration = this.#stackChildrenDuration;\n\n    let node;\n    let sampleIndex;\n    for (sampleIndex = startIndex; sampleIndex < samplesCount; sampleIndex++) {\n      sampleTime = timestamps[sampleIndex];\n      if (sampleTime >= stopTime) {\n        break;\n      }\n      const id = samples[sampleIndex];\n      if (id === prevId) {\n        continue;\n      }\n      node = idToNode.get(id);\n      let prevNode: CPUProfileNode = (idToNode.get(prevId) as CPUProfileNode);\n\n      if (node === gcNode) {\n        // GC samples have no stack, so we just put GC node on top of the last recorded sample.\n        gcParentNode = prevNode;\n        openFrameCallback(gcParentNode.depth + 1, gcNode, sampleTime);\n        stackStartTimes[++stackTop] = sampleTime;\n        stackChildrenDuration[stackTop] = 0;\n        prevId = id;\n        continue;\n      }\n      if (prevNode === gcNode && gcParentNode) {\n        // end of GC frame\n        const start = stackStartTimes[stackTop];\n        const duration = sampleTime - start;\n        stackChildrenDuration[stackTop - 1] += duration;\n        closeFrameCallback(gcParentNode.depth + 1, gcNode, start, duration, duration - stackChildrenDuration[stackTop]);\n        --stackTop;\n        prevNode = gcParentNode;\n        prevId = prevNode.id;\n        gcParentNode = null;\n      }\n\n      while (node && node.depth > prevNode.depth) {\n        stackNodes.push(node);\n        node = node.parent;\n      }\n\n      // Go down to the LCA and close current intervals.\n      while (prevNode !== node) {\n        const start = stackStartTimes[stackTop];\n        const duration = sampleTime - start;\n        stackChildrenDuration[stackTop - 1] += duration;\n        closeFrameCallback(\n            prevNode.depth, (prevNode as CPUProfileNode), start, duration, duration - stackChildrenDuration[stackTop]);\n        --stackTop;\n        if (node && node.depth === prevNode.depth) {\n          stackNodes.push(node);\n          node = node.parent;\n        }\n        prevNode = (prevNode.parent as CPUProfileNode);\n      }\n\n      // Go up the nodes stack and open new intervals.\n      while (stackNodes.length) {\n        const currentNode = (stackNodes.pop() as CPUProfileNode);\n        node = currentNode;\n        openFrameCallback(currentNode.depth, currentNode, sampleTime);\n        stackStartTimes[++stackTop] = sampleTime;\n        stackChildrenDuration[stackTop] = 0;\n      }\n\n      prevId = id;\n    }\n\n    sampleTime = timestamps[sampleIndex] || this.profileEndTime;\n    if (gcParentNode && idToNode.get(prevId) === gcNode) {\n      const start = stackStartTimes[stackTop];\n      const duration = sampleTime - start;\n      stackChildrenDuration[stackTop - 1] += duration;\n      closeFrameCallback(\n          gcParentNode.depth + 1, (node as CPUProfileNode), start, duration,\n          duration - stackChildrenDuration[stackTop]);\n      --stackTop;\n      prevId = gcParentNode.id;\n    }\n    for (let node = idToNode.get(prevId); node && node.parent; node = (node.parent as CPUProfileNode)) {\n      const start = stackStartTimes[stackTop];\n      const duration = sampleTime - start;\n      stackChildrenDuration[stackTop - 1] += duration;\n      closeFrameCallback(\n          node.depth, (node as CPUProfileNode), start, duration, duration - stackChildrenDuration[stackTop]);\n      --stackTop;\n    }\n  }\n\n  nodeByIndex(index: number): CPUProfileNode|null {\n    return this.samples && this.#idToNode.get(this.samples[index]) || null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
