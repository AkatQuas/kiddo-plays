{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/ServiceWorkerCacheModel.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as i18n from '../i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type {NameValue} from './NetworkRequest.js';\nimport type {Target} from './Target.js';\nimport {Capability} from './Target.js';\nimport {SDKModel} from './SDKModel.js';\nimport {Events as SecurityOriginManagerEvents, SecurityOriginManager} from './SecurityOriginManager.js';\n\nconst UIStrings = {\n  /**\n  *@description Text in Service Worker Cache Model\n  *@example {https://cache} PH1\n  *@example {error message} PH2\n  */\n  serviceworkercacheagentError: '`ServiceWorkerCacheAgent` error deleting cache entry {PH1} in cache: {PH2}',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/sdk/ServiceWorkerCacheModel.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class ServiceWorkerCacheModel extends SDKModel<EventTypes> implements ProtocolProxyApi.StorageDispatcher {\n  readonly cacheAgent: ProtocolProxyApi.CacheStorageApi;\n  readonly #storageAgent: ProtocolProxyApi.StorageApi;\n  readonly #securityOriginManager: SecurityOriginManager;\n\n  readonly #cachesInternal = new Map<string, Cache>();\n  readonly #originsUpdated = new Set<string>();\n  readonly #throttler = new Common.Throttler.Throttler(2000);\n  #enabled = false;\n\n  // Used by tests to remove the Throttler timeout.\n  #scheduleAsSoonAsPossible = false;\n\n  /**\n   * Invariant: This #model can only be constructed on a ServiceWorker target.\n   */\n  constructor(target: Target) {\n    super(target);\n    target.registerStorageDispatcher(this);\n\n    this.cacheAgent = target.cacheStorageAgent();\n    this.#storageAgent = target.storageAgent();\n    this.#securityOriginManager = (target.model(SecurityOriginManager) as SecurityOriginManager);\n  }\n\n  enable(): void {\n    if (this.#enabled) {\n      return;\n    }\n\n    this.#securityOriginManager.addEventListener(\n        SecurityOriginManagerEvents.SecurityOriginAdded, this.securityOriginAdded, this);\n    this.#securityOriginManager.addEventListener(\n        SecurityOriginManagerEvents.SecurityOriginRemoved, this.securityOriginRemoved, this);\n\n    for (const securityOrigin of this.#securityOriginManager.securityOrigins()) {\n      this.addOrigin(securityOrigin);\n    }\n    this.#enabled = true;\n  }\n\n  clearForOrigin(origin: string): void {\n    this.removeOrigin(origin);\n    this.addOrigin(origin);\n  }\n\n  refreshCacheNames(): void {\n    for (const cache of this.#cachesInternal.values()) {\n      this.cacheRemoved(cache);\n    }\n    this.#cachesInternal.clear();\n    const securityOrigins = this.#securityOriginManager.securityOrigins();\n    for (const securityOrigin of securityOrigins) {\n      void this.loadCacheNames(securityOrigin);\n    }\n  }\n\n  async deleteCache(cache: Cache): Promise<void> {\n    const response = await this.cacheAgent.invoke_deleteCache({cacheId: cache.cacheId});\n    if (response.getError()) {\n      console.error(`ServiceWorkerCacheAgent error deleting cache ${cache.toString()}: ${response.getError()}`);\n      return;\n    }\n    this.#cachesInternal.delete(cache.cacheId);\n    this.cacheRemoved(cache);\n  }\n\n  async deleteCacheEntry(cache: Cache, request: string): Promise<void> {\n    const response = await this.cacheAgent.invoke_deleteEntry({cacheId: cache.cacheId, request});\n    if (response.getError()) {\n      Common.Console.Console.instance().error(i18nString(\n          UIStrings.serviceworkercacheagentError, {PH1: cache.toString(), PH2: String(response.getError())}));\n      return;\n    }\n  }\n\n  loadCacheData(\n      cache: Cache, skipCount: number, pageSize: number, pathFilter: string,\n      callback: (arg0: Array<Protocol.CacheStorage.DataEntry>, arg1: number) => void): void {\n    void this.requestEntries(cache, skipCount, pageSize, pathFilter, callback);\n  }\n\n  loadAllCacheData(\n      cache: Cache, pathFilter: string,\n      callback: (arg0: Array<Protocol.CacheStorage.DataEntry>, arg1: number) => void): void {\n    void this.requestAllEntries(cache, pathFilter, callback);\n  }\n\n  caches(): Cache[] {\n    const caches = new Array();\n    for (const cache of this.#cachesInternal.values()) {\n      caches.push(cache);\n    }\n    return caches;\n  }\n\n  dispose(): void {\n    for (const cache of this.#cachesInternal.values()) {\n      this.cacheRemoved(cache);\n    }\n    this.#cachesInternal.clear();\n    if (this.#enabled) {\n      this.#securityOriginManager.removeEventListener(\n          SecurityOriginManagerEvents.SecurityOriginAdded, this.securityOriginAdded, this);\n      this.#securityOriginManager.removeEventListener(\n          SecurityOriginManagerEvents.SecurityOriginRemoved, this.securityOriginRemoved, this);\n    }\n  }\n\n  private addOrigin(securityOrigin: string): void {\n    void this.loadCacheNames(securityOrigin);\n    if (this.isValidSecurityOrigin(securityOrigin)) {\n      void this.#storageAgent.invoke_trackCacheStorageForOrigin({origin: securityOrigin});\n    }\n  }\n\n  private removeOrigin(securityOrigin: string): void {\n    for (const [opaqueId, cache] of this.#cachesInternal.entries()) {\n      if (cache.securityOrigin === securityOrigin) {\n        this.#cachesInternal.delete((opaqueId as string));\n        this.cacheRemoved((cache as Cache));\n      }\n    }\n    if (this.isValidSecurityOrigin(securityOrigin)) {\n      void this.#storageAgent.invoke_untrackCacheStorageForOrigin({origin: securityOrigin});\n    }\n  }\n\n  private isValidSecurityOrigin(securityOrigin: string): boolean {\n    const parsedURL = Common.ParsedURL.ParsedURL.fromString(securityOrigin);\n    return parsedURL !== null && parsedURL.scheme.startsWith('http');\n  }\n\n  private async loadCacheNames(securityOrigin: string): Promise<void> {\n    const response = await this.cacheAgent.invoke_requestCacheNames({securityOrigin: securityOrigin});\n    if (response.getError()) {\n      return;\n    }\n    this.updateCacheNames(securityOrigin, response.caches);\n  }\n\n  private updateCacheNames(securityOrigin: string, cachesJson: Protocol.CacheStorage.Cache[]): void {\n    function deleteAndSaveOldCaches(this: ServiceWorkerCacheModel, cache: Cache): void {\n      if (cache.securityOrigin === securityOrigin && !updatingCachesIds.has(cache.cacheId)) {\n        oldCaches.set(cache.cacheId, cache);\n        this.#cachesInternal.delete(cache.cacheId);\n      }\n    }\n\n    const updatingCachesIds = new Set<string>();\n    const newCaches = new Map<string, Cache>();\n    const oldCaches = new Map<string, Cache>();\n\n    for (const cacheJson of cachesJson) {\n      const cache = new Cache(this, cacheJson.securityOrigin, cacheJson.cacheName, cacheJson.cacheId);\n      updatingCachesIds.add(cache.cacheId);\n      if (this.#cachesInternal.has(cache.cacheId)) {\n        continue;\n      }\n      newCaches.set(cache.cacheId, cache);\n      this.#cachesInternal.set(cache.cacheId, cache);\n    }\n    this.#cachesInternal.forEach(deleteAndSaveOldCaches, this);\n    newCaches.forEach(this.cacheAdded, this);\n    oldCaches.forEach(this.cacheRemoved, this);\n  }\n\n  private securityOriginAdded(event: Common.EventTarget.EventTargetEvent<string>): void {\n    this.addOrigin(event.data);\n  }\n\n  private securityOriginRemoved(event: Common.EventTarget.EventTargetEvent<string>): void {\n    this.removeOrigin(event.data);\n  }\n\n  private cacheAdded(cache: Cache): void {\n    this.dispatchEventToListeners(Events.CacheAdded, {model: this, cache: cache});\n  }\n\n  private cacheRemoved(cache: Cache): void {\n    this.dispatchEventToListeners(Events.CacheRemoved, {model: this, cache: cache});\n  }\n\n  private async requestEntries(\n      cache: Cache, skipCount: number, pageSize: number, pathFilter: string,\n      callback: (arg0: Array<Protocol.CacheStorage.DataEntry>, arg1: number) => void): Promise<void> {\n    const response =\n        await this.cacheAgent.invoke_requestEntries({cacheId: cache.cacheId, skipCount, pageSize, pathFilter});\n    if (response.getError()) {\n      console.error('ServiceWorkerCacheAgent error while requesting entries: ', response.getError());\n      return;\n    }\n    callback(response.cacheDataEntries, response.returnCount);\n  }\n\n  private async requestAllEntries(\n      cache: Cache, pathFilter: string,\n      callback: (arg0: Array<Protocol.CacheStorage.DataEntry>, arg1: number) => void): Promise<void> {\n    const response = await this.cacheAgent.invoke_requestEntries({cacheId: cache.cacheId, pathFilter});\n    if (response.getError()) {\n      console.error('ServiceWorkerCacheAgent error while requesting entries: ', response.getError());\n      return;\n    }\n    callback(response.cacheDataEntries, response.returnCount);\n  }\n\n  cacheStorageListUpdated({origin}: Protocol.Storage.CacheStorageListUpdatedEvent): void {\n    this.#originsUpdated.add(origin);\n\n    void this.#throttler.schedule(() => {\n      const promises = Array.from(this.#originsUpdated, origin => this.loadCacheNames(origin));\n      this.#originsUpdated.clear();\n      return Promise.all(promises);\n    }, this.#scheduleAsSoonAsPossible);\n  }\n\n  cacheStorageContentUpdated({origin, cacheName}: Protocol.Storage.CacheStorageContentUpdatedEvent): void {\n    this.dispatchEventToListeners(Events.CacheStorageContentUpdated, {origin, cacheName});\n  }\n\n  indexedDBListUpdated(_event: Protocol.Storage.IndexedDBListUpdatedEvent): void {\n  }\n\n  indexedDBContentUpdated(_event: Protocol.Storage.IndexedDBContentUpdatedEvent): void {\n  }\n\n  interestGroupAccessed(_event: Protocol.Storage.InterestGroupAccessedEvent): void {\n  }\n\n  setThrottlerSchedulesAsSoonAsPossibleForTest(): void {\n    this.#scheduleAsSoonAsPossible = true;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  CacheAdded = 'CacheAdded',\n  CacheRemoved = 'CacheRemoved',\n  CacheStorageContentUpdated = 'CacheStorageContentUpdated',\n}\n\nexport interface CacheEvent {\n  model: ServiceWorkerCacheModel;\n  cache: Cache;\n}\n\nexport interface CacheStorageContentUpdatedEvent {\n  origin: string;\n  cacheName: string;\n}\n\nexport type EventTypes = {\n  [Events.CacheAdded]: CacheEvent,\n  [Events.CacheRemoved]: CacheEvent,\n  [Events.CacheStorageContentUpdated]: CacheStorageContentUpdatedEvent,\n};\n\nexport class Cache {\n  readonly #model: ServiceWorkerCacheModel;\n  securityOrigin: string;\n  cacheName: string;\n  cacheId: Protocol.CacheStorage.CacheId;\n\n  constructor(\n      model: ServiceWorkerCacheModel, securityOrigin: string, cacheName: string,\n      cacheId: Protocol.CacheStorage.CacheId) {\n    this.#model = model;\n    this.securityOrigin = securityOrigin;\n    this.cacheName = cacheName;\n    this.cacheId = cacheId;\n  }\n\n  equals(cache: Cache): boolean {\n    return this.cacheId === cache.cacheId;\n  }\n\n  toString(): string {\n    return this.securityOrigin + this.cacheName;\n  }\n\n  async requestCachedResponse(url: Platform.DevToolsPath.UrlString, requestHeaders: NameValue[]):\n      Promise<Protocol.CacheStorage.CachedResponse|null> {\n    const response = await this.#model.cacheAgent.invoke_requestCachedResponse(\n        {cacheId: this.cacheId, requestURL: url, requestHeaders});\n    if (response.getError()) {\n      return null;\n    }\n    return response.response;\n  }\n}\n\nSDKModel.register(ServiceWorkerCacheModel, {capabilities: Capability.Storage, autostart: false});\n"],
  "mappings": "AAIA;AACA;AAOA;AACA;AACA;AAEA,MAAM,YAAY;AAAA,EAMhB,8BAA8B;AAAA;AAEhC,MAAM,OAAO,KAAK,KAAK,kBAAkB,uCAAuC;AAChF,MAAM,aAAa,KAAK,KAAK,mBAAmB,KAAK,QAAW;AAEzD,6CAAsC,SAAmE;AAAA,EACrG;AAAA;AAAA;AAAA,oBAIkB,oBAAI;AAAA,oBACJ,oBAAI;AAAA,eACT,IAAI,OAAO,UAAU,UAAU;AAAA,aAC1C;AAAA,8BAGiB;AAAA,EAK5B,YAAY,QAAgB;AAC1B,UAAM;AACN,WAAO,0BAA0B;AAEjC,SAAK,aAAa,OAAO;AACzB,yBAAqB,OAAO;AAC5B,kCAA+B,OAAO,MAAM;AAAA;AAAA,EAG9C,SAAe;AACb,QAAI,eAAe;AACjB;AAAA;AAGF,gCAA4B,iBACxB,4BAA4B,qBAAqB,KAAK,qBAAqB;AAC/E,gCAA4B,iBACxB,4BAA4B,uBAAuB,KAAK,uBAAuB;AAEnF,eAAW,kBAAkB,4BAA4B,mBAAmB;AAC1E,WAAK,UAAU;AAAA;AAEjB,oBAAgB;AAAA;AAAA,EAGlB,eAAe,QAAsB;AACnC,SAAK,aAAa;AAClB,SAAK,UAAU;AAAA;AAAA,EAGjB,oBAA0B;AACxB,eAAW,SAAS,qBAAqB,UAAU;AACjD,WAAK,aAAa;AAAA;AAEpB,yBAAqB;AACrB,UAAM,kBAAkB,4BAA4B;AACpD,eAAW,kBAAkB,iBAAiB;AAC5C,WAAK,KAAK,eAAe;AAAA;AAAA;AAAA,QAIvB,YAAY,OAA6B;AAC7C,UAAM,WAAW,MAAM,KAAK,WAAW,mBAAmB,EAAC,SAAS,MAAM;AAC1E,QAAI,SAAS,YAAY;AACvB,cAAQ,MAAM,gDAAgD,MAAM,eAAe,SAAS;AAC5F;AAAA;AAEF,yBAAqB,OAAO,MAAM;AAClC,SAAK,aAAa;AAAA;AAAA,QAGd,iBAAiB,OAAc,SAAgC;AACnE,UAAM,WAAW,MAAM,KAAK,WAAW,mBAAmB,EAAC,SAAS,MAAM,SAAS;AACnF,QAAI,SAAS,YAAY;AACvB,aAAO,QAAQ,QAAQ,WAAW,MAAM,WACpC,UAAU,8BAA8B,EAAC,KAAK,MAAM,YAAY,KAAK,OAAO,SAAS;AACzF;AAAA;AAAA;AAAA,EAIJ,cACI,OAAc,WAAmB,UAAkB,YACnD,UAAsF;AACxF,SAAK,KAAK,eAAe,OAAO,WAAW,UAAU,YAAY;AAAA;AAAA,EAGnE,iBACI,OAAc,YACd,UAAsF;AACxF,SAAK,KAAK,kBAAkB,OAAO,YAAY;AAAA;AAAA,EAGjD,SAAkB;AAChB,UAAM,SAAS,IAAI;AACnB,eAAW,SAAS,qBAAqB,UAAU;AACjD,aAAO,KAAK;AAAA;AAEd,WAAO;AAAA;AAAA,EAGT,UAAgB;AACd,eAAW,SAAS,qBAAqB,UAAU;AACjD,WAAK,aAAa;AAAA;AAEpB,yBAAqB;AACrB,QAAI,eAAe;AACjB,kCAA4B,oBACxB,4BAA4B,qBAAqB,KAAK,qBAAqB;AAC/E,kCAA4B,oBACxB,4BAA4B,uBAAuB,KAAK,uBAAuB;AAAA;AAAA;AAAA,EAI/E,UAAU,gBAA8B;AAC9C,SAAK,KAAK,eAAe;AACzB,QAAI,KAAK,sBAAsB,iBAAiB;AAC9C,WAAK,mBAAmB,kCAAkC,EAAC,QAAQ;AAAA;AAAA;AAAA,EAI/D,aAAa,gBAA8B;AACjD,eAAW,CAAC,UAAU,UAAU,qBAAqB,WAAW;AAC9D,UAAI,MAAM,mBAAmB,gBAAgB;AAC3C,6BAAqB,OAAQ;AAC7B,aAAK,aAAc;AAAA;AAAA;AAGvB,QAAI,KAAK,sBAAsB,iBAAiB;AAC9C,WAAK,mBAAmB,oCAAoC,EAAC,QAAQ;AAAA;AAAA;AAAA,EAIjE,sBAAsB,gBAAiC;AAC7D,UAAM,YAAY,OAAO,UAAU,UAAU,WAAW;AACxD,WAAO,cAAc,QAAQ,UAAU,OAAO,WAAW;AAAA;AAAA,QAG7C,eAAe,gBAAuC;AAClE,UAAM,WAAW,MAAM,KAAK,WAAW,yBAAyB,EAAC;AACjE,QAAI,SAAS,YAAY;AACvB;AAAA;AAEF,SAAK,iBAAiB,gBAAgB,SAAS;AAAA;AAAA,EAGzC,iBAAiB,gBAAwB,YAAiD;AAChG,oCAA+D,OAAoB;AACjF,UAAI,MAAM,mBAAmB,kBAAkB,CAAC,kBAAkB,IAAI,MAAM,UAAU;AACpF,kBAAU,IAAI,MAAM,SAAS;AAC7B,6BAAqB,OAAO,MAAM;AAAA;AAAA;AAItC,UAAM,oBAAoB,oBAAI;AAC9B,UAAM,YAAY,oBAAI;AACtB,UAAM,YAAY,oBAAI;AAEtB,eAAW,aAAa,YAAY;AAClC,YAAM,QAAQ,IAAI,MAAM,MAAM,UAAU,gBAAgB,UAAU,WAAW,UAAU;AACvF,wBAAkB,IAAI,MAAM;AAC5B,UAAI,qBAAqB,IAAI,MAAM,UAAU;AAC3C;AAAA;AAEF,gBAAU,IAAI,MAAM,SAAS;AAC7B,2BAAqB,IAAI,MAAM,SAAS;AAAA;AAE1C,yBAAqB,QAAQ,wBAAwB;AACrD,cAAU,QAAQ,KAAK,YAAY;AACnC,cAAU,QAAQ,KAAK,cAAc;AAAA;AAAA,EAG/B,oBAAoB,OAA0D;AACpF,SAAK,UAAU,MAAM;AAAA;AAAA,EAGf,sBAAsB,OAA0D;AACtF,SAAK,aAAa,MAAM;AAAA;AAAA,EAGlB,WAAW,OAAoB;AACrC,SAAK,yBAAyB,OAAO,YAAY,EAAC,OAAO,MAAM;AAAA;AAAA,EAGzD,aAAa,OAAoB;AACvC,SAAK,yBAAyB,OAAO,cAAc,EAAC,OAAO,MAAM;AAAA;AAAA,QAGrD,eACV,OAAc,WAAmB,UAAkB,YACnD,UAA+F;AACjG,UAAM,WACF,MAAM,KAAK,WAAW,sBAAsB,EAAC,SAAS,MAAM,SAAS,WAAW,UAAU;AAC9F,QAAI,SAAS,YAAY;AACvB,cAAQ,MAAM,4DAA4D,SAAS;AACnF;AAAA;AAEF,aAAS,SAAS,kBAAkB,SAAS;AAAA;AAAA,QAGjC,kBACV,OAAc,YACd,UAA+F;AACjG,UAAM,WAAW,MAAM,KAAK,WAAW,sBAAsB,EAAC,SAAS,MAAM,SAAS;AACtF,QAAI,SAAS,YAAY;AACvB,cAAQ,MAAM,4DAA4D,SAAS;AACnF;AAAA;AAEF,aAAS,SAAS,kBAAkB,SAAS;AAAA;AAAA,EAG/C,wBAAwB,EAAC,UAA8D;AACrF,yBAAqB,IAAI;AAEzB,SAAK,gBAAgB,SAAS,MAAM;AAClC,YAAM,WAAW,MAAM,KAAK,sBAAsB,aAAU,KAAK,eAAe;AAChF,2BAAqB;AACrB,aAAO,QAAQ,IAAI;AAAA,OAClB;AAAA;AAAA,EAGL,2BAA2B,EAAC,QAAQ,aAAoE;AACtG,SAAK,yBAAyB,OAAO,4BAA4B,EAAC,QAAQ;AAAA;AAAA,EAG5E,qBAAqB,QAA0D;AAAA;AAAA,EAG/E,wBAAwB,QAA6D;AAAA;AAAA,EAGrF,sBAAsB,QAA2D;AAAA;AAAA,EAGjF,+CAAqD;AACnD,qCAAiC;AAAA;AAAA;AAM9B,WAAK,SAAL,kBAAK,YAAL;AACL,0BAAa;AACb,4BAAe;AACf,0CAA6B;AAHnB;AAAA;AAsBL,mBAAY;AAAA;AAAA,EAEjB;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACI,OAAgC,gBAAwB,WACxD,SAAwC;AAC1C,kBAAc;AACd,SAAK,iBAAiB;AACtB,SAAK,YAAY;AACjB,SAAK,UAAU;AAAA;AAAA,EAGjB,OAAO,OAAuB;AAC5B,WAAO,KAAK,YAAY,MAAM;AAAA;AAAA,EAGhC,WAAmB;AACjB,WAAO,KAAK,iBAAiB,KAAK;AAAA;AAAA,QAG9B,sBAAsB,KAAsC,gBACX;AACrD,UAAM,WAAW,MAAM,YAAY,WAAW,6BAC1C,EAAC,SAAS,KAAK,SAAS,YAAY,KAAK;AAC7C,QAAI,SAAS,YAAY;AACvB,aAAO;AAAA;AAET,WAAO,SAAS;AAAA;AAAA;AAIpB,SAAS,SAAS,yBAAyB,EAAC,cAAc,WAAW,SAAS,WAAW;",
  "names": []
}
