{
  "version": 3,
  "sources": ["../../../../../../front_end/core/host/ResourceLoader.ts"],
  "sourcesContent": ["// Copyright (c) 2015 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport * as Common from '../common/common.js';\nimport * as i18n from '../i18n/i18n.js';\n\nimport {InspectorFrontendHostInstance} from './InspectorFrontendHost.js';\nimport type {LoadNetworkResourceResult} from './InspectorFrontendHostAPI.js';\n\nconst UIStrings = {\n  /**\n  *@description Name of an error category used in error messages\n  */\n  systemError: 'System error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  connectionError: 'Connection error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  certificateError: 'Certificate error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  httpError: 'HTTP error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  cacheError: 'Cache error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  signedExchangeError: 'Signed Exchange error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  ftpError: 'FTP error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  certificateManagerError: 'Certificate manager error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  dnsResolverError: 'DNS resolver error',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  unknownError: 'Unknown error',\n  /**\n  *@description Phrase used in error messages that carry a network error name\n  *@example {404} PH1\n  *@example {net::ERR_INSUFFICIENT_RESOURCES} PH2\n  */\n  httpErrorStatusCodeSS: 'HTTP error: status code {PH1}, {PH2}',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  invalidUrl: 'Invalid URL',\n  /**\n  *@description Name of an error category used in error messages\n  */\n  decodingDataUrlFailed: 'Decoding Data URL failed',\n};\nconst str_ = i18n.i18n.registerUIStrings('core/host/ResourceLoader.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport const ResourceLoader = {};\n\nlet _lastStreamId = 0;\n\nconst _boundStreams: {\n  [x: number]: Common.StringOutputStream.OutputStream,\n} = {};\n\nconst _bindOutputStream = function(stream: Common.StringOutputStream.OutputStream): number {\n  _boundStreams[++_lastStreamId] = stream;\n  return _lastStreamId;\n};\n\nconst _discardOutputStream = function(id: number): void {\n  void _boundStreams[id].close();\n  delete _boundStreams[id];\n};\n\nexport const streamWrite = function(id: number, chunk: string): void {\n  void _boundStreams[id].write(chunk);\n};\nexport interface LoadErrorDescription {\n  statusCode: number;\n  netError?: number;\n  netErrorName?: string;\n  urlValid?: boolean;\n  message?: string;\n}\n\nexport let load = function(\n    url: string, headers: {\n      [x: string]: string,\n    }|null,\n    callback: (\n        arg0: boolean, arg1: {\n          [x: string]: string,\n        },\n        arg2: string, arg3: LoadErrorDescription) => void): void {\n  const stream = new Common.StringOutputStream.StringOutputStream();\n  loadAsStream(url, headers, stream, mycallback);\n\n  function mycallback(\n      success: boolean, headers: {\n        [x: string]: string,\n      },\n      errorDescription: LoadErrorDescription): void {\n    callback(success, headers, stream.data(), errorDescription);\n  }\n};\n\nexport function setLoadForTest(\n    newLoad: (\n        arg0: string, arg1: {\n          [x: string]: string,\n        }|null,\n        arg2: (\n            arg0: boolean, arg1: {\n              [x: string]: string,\n            },\n            arg2: string, arg3: LoadErrorDescription) => void) => void): void {\n  load = newLoad;\n}\n\nfunction getNetErrorCategory(netError: number): string {\n  if (netError > -100) {\n    return i18nString(UIStrings.systemError);\n  }\n  if (netError > -200) {\n    return i18nString(UIStrings.connectionError);\n  }\n  if (netError > -300) {\n    return i18nString(UIStrings.certificateError);\n  }\n  if (netError > -400) {\n    return i18nString(UIStrings.httpError);\n  }\n  if (netError > -500) {\n    return i18nString(UIStrings.cacheError);\n  }\n  if (netError > -600) {\n    return i18nString(UIStrings.signedExchangeError);\n  }\n  if (netError > -700) {\n    return i18nString(UIStrings.ftpError);\n  }\n  if (netError > -800) {\n    return i18nString(UIStrings.certificateManagerError);\n  }\n  if (netError > -900) {\n    return i18nString(UIStrings.dnsResolverError);\n  }\n  return i18nString(UIStrings.unknownError);\n}\n\nfunction isHTTPError(netError: number): boolean {\n  return netError <= -300 && netError > -400;\n}\n\nexport function netErrorToMessage(\n    netError: number|undefined, httpStatusCode: number|undefined, netErrorName: string|undefined): string|null {\n  if (netError === undefined || netErrorName === undefined) {\n    return null;\n  }\n  if (netError !== 0) {\n    if (isHTTPError(netError)) {\n      return i18nString(UIStrings.httpErrorStatusCodeSS, {PH1: String(httpStatusCode), PH2: netErrorName});\n    }\n    const errorCategory = getNetErrorCategory(netError);\n    // We don't localize here, as `errorCategory` is already localized,\n    // and `netErrorName` is an error code like 'net::ERR_CERT_AUTHORITY_INVALID'.\n    return `${errorCategory}: ${netErrorName}`;\n  }\n  return null;\n}\n\nfunction createErrorMessageFromResponse(response: LoadNetworkResourceResult): {\n  success: boolean,\n  description: LoadErrorDescription,\n} {\n  const {statusCode, netError, netErrorName, urlValid, messageOverride} = response;\n  let message = '';\n  const success = statusCode >= 200 && statusCode < 300;\n  if (typeof messageOverride === 'string') {\n    message = messageOverride;\n  } else if (!success) {\n    if (typeof netError === 'undefined') {\n      if (urlValid === false) {\n        message = i18nString(UIStrings.invalidUrl);\n      } else {\n        message = i18nString(UIStrings.unknownError);\n      }\n    } else {\n      const maybeMessage = netErrorToMessage(netError, statusCode, netErrorName);\n      if (maybeMessage) {\n        message = maybeMessage;\n      }\n    }\n  }\n  console.assert(success === (message.length === 0));\n  return {success, description: {statusCode, netError, netErrorName, urlValid, message}};\n}\n\nconst loadXHR = (url: string): Promise<string> => {\n  return new Promise((successCallback, failureCallback) => {\n    function onReadyStateChanged(): void {\n      if (xhr.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (xhr.status !== 200) {\n        xhr.onreadystatechange = null;\n        failureCallback(new Error(String(xhr.status)));\n        return;\n      }\n      xhr.onreadystatechange = null;\n      successCallback(xhr.responseText);\n    }\n\n    const xhr = new XMLHttpRequest();\n    xhr.withCredentials = false;\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = onReadyStateChanged;\n    xhr.send(null);\n  });\n};\n\nexport const loadAsStream = function(\n    url: string, headers: {\n      [x: string]: string,\n    }|null,\n    stream: Common.StringOutputStream.OutputStream,\n    callback?:\n        ((arg0: boolean, arg1: {\n           [x: string]: string,\n         },\n          arg2: LoadErrorDescription) => void)): void {\n  const streamId = _bindOutputStream(stream);\n  const parsedURL = new Common.ParsedURL.ParsedURL(url);\n  if (parsedURL.isDataURL()) {\n    loadXHR(url).then(dataURLDecodeSuccessful).catch(dataURLDecodeFailed);\n    return;\n  }\n\n  const rawHeaders = [];\n  if (headers) {\n    for (const key in headers) {\n      rawHeaders.push(key + ': ' + headers[key]);\n    }\n  }\n  InspectorFrontendHostInstance.loadNetworkResource(url, rawHeaders.join('\\r\\n'), streamId, finishedCallback);\n\n  function finishedCallback(response: LoadNetworkResourceResult): void {\n    if (callback) {\n      const {success, description} = createErrorMessageFromResponse(response);\n      callback(success, response.headers || {}, description);\n    }\n    _discardOutputStream(streamId);\n  }\n\n  function dataURLDecodeSuccessful(text: string): void {\n    streamWrite(streamId, text);\n    finishedCallback(({statusCode: 200} as LoadNetworkResourceResult));\n  }\n\n  function dataURLDecodeFailed(_xhrStatus: Error): void {\n    const messageOverride: string = i18nString(UIStrings.decodingDataUrlFailed);\n    finishedCallback(({statusCode: 404, messageOverride} as LoadNetworkResourceResult));\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
