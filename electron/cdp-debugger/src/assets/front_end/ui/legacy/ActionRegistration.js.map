{
  "version": 3,
  "sources": ["../../../../../../front_end/ui/legacy/ActionRegistration.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\n\nimport {Context} from './Context.js';\n\nexport interface ActionDelegate {\n  handleAction(_context: Context, _actionId: string): boolean;\n}\n\nexport class Action extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  private enabledInternal = true;\n  private toggledInternal = false;\n  private actionRegistration: ActionRegistration;\n  constructor(actionRegistration: ActionRegistration) {\n    super();\n    this.actionRegistration = actionRegistration;\n  }\n\n  id(): string {\n    return this.actionRegistration.actionId;\n  }\n\n  async execute(): Promise<boolean> {\n    if (!this.actionRegistration.loadActionDelegate) {\n      return false;\n    }\n    const delegate = await this.actionRegistration.loadActionDelegate();\n    const actionId = this.id();\n    return delegate.handleAction(Context.instance(), actionId);\n  }\n\n  icon(): string|undefined {\n    return this.actionRegistration.iconClass;\n  }\n\n  toggledIcon(): string|undefined {\n    return this.actionRegistration.toggledIconClass;\n  }\n\n  toggleWithRedColor(): boolean {\n    return Boolean(this.actionRegistration.toggleWithRedColor);\n  }\n\n  setEnabled(enabled: boolean): void {\n    if (this.enabledInternal === enabled) {\n      return;\n    }\n\n    this.enabledInternal = enabled;\n    this.dispatchEventToListeners(Events.Enabled, enabled);\n  }\n\n  enabled(): boolean {\n    return this.enabledInternal;\n  }\n\n  category(): string {\n    return this.actionRegistration.category;\n  }\n\n  tags(): string|void {\n    if (this.actionRegistration.tags) {\n      // Get localized keys and separate by null character to prevent fuzzy matching from matching across them.\n      return this.actionRegistration.tags.map(tag => tag()).join('\\0');\n    }\n  }\n\n  toggleable(): boolean {\n    return Boolean(this.actionRegistration.toggleable);\n  }\n\n  title(): string {\n    let title = this.actionRegistration.title ? this.actionRegistration.title() : '';\n    const options = this.actionRegistration.options;\n    if (options) {\n      // Actions with an 'options' property don't have a title field. Instead, the displayed\n      // title is taken from the 'title' property of the option that is not active. Only one of the\n      // two options can be active at a given moment and the 'toggled' property of the action along\n      // with the 'value' of the options are used to determine which one it is.\n\n      for (const pair of options) {\n        if (pair.value !== this.toggledInternal) {\n          title = pair.title();\n        }\n      }\n    }\n    return title;\n  }\n\n  toggled(): boolean {\n    return this.toggledInternal;\n  }\n\n  setToggled(toggled: boolean): void {\n    console.assert(this.toggleable(), 'Shouldn\\'t be toggling an untoggleable action', this.id());\n    if (this.toggledInternal === toggled) {\n      return;\n    }\n\n    this.toggledInternal = toggled;\n    this.dispatchEventToListeners(Events.Toggled, toggled);\n  }\n\n  options(): undefined|Array<ExtensionOption> {\n    return this.actionRegistration.options;\n  }\n\n  contextTypes(): undefined|Array<Function> {\n    if (this.actionRegistration.contextTypes) {\n      return this.actionRegistration.contextTypes();\n    }\n    return undefined;\n  }\n\n  canInstantiate(): boolean {\n    return Boolean(this.actionRegistration.loadActionDelegate);\n  }\n\n  bindings(): Array<Binding>|undefined {\n    return this.actionRegistration.bindings;\n  }\n\n  experiment(): string|undefined {\n    return this.actionRegistration.experiment;\n  }\n\n  condition(): string|undefined {\n    return this.actionRegistration.condition;\n  }\n\n  order(): number|undefined {\n    return this.actionRegistration.order;\n  }\n}\n\nconst registeredActionExtensions: Array<Action> = [];\n\nconst actionIdSet = new Set<string>();\n\nexport function registerActionExtension(registration: ActionRegistration): void {\n  const actionId = registration.actionId;\n  if (actionIdSet.has(actionId)) {\n    throw new Error(`Duplicate Action id '${actionId}': ${new Error().stack}`);\n  }\n  actionIdSet.add(actionId);\n  registeredActionExtensions.push(new Action(registration));\n}\n\nexport function getRegisteredActionExtensions(): Array<Action> {\n  return registeredActionExtensions\n      .filter(\n          action => Root.Runtime.Runtime.isDescriptorEnabled(\n              {experiment: action.experiment(), condition: action.condition()}))\n      .sort((firstAction, secondAction) => {\n        const order1 = firstAction.order() || 0;\n        const order2 = secondAction.order() || 0;\n        return order1 - order2;\n      });\n}\n\nexport function maybeRemoveActionExtension(actionId: string): boolean {\n  const actionIndex = registeredActionExtensions.findIndex(action => action.id() === actionId);\n  if (actionIndex < 0 || !actionIdSet.delete(actionId)) {\n    return false;\n  }\n  registeredActionExtensions.splice(actionIndex, 1);\n  return true;\n}\n\nexport const enum Platforms {\n  All = 'All platforms',\n  Mac = 'mac',\n  WindowsLinux = 'windows,linux',\n  Android = 'Android',\n  Windows = 'windows',\n}\n\nexport const enum Events {\n  Enabled = 'Enabled',\n  Toggled = 'Toggled',\n}\n\nexport type EventTypes = {\n  [Events.Enabled]: boolean,\n  [Events.Toggled]: boolean,\n};\n\n// TODO(crbug.com/1181019)\nexport const ActionCategory = {\n  ELEMENTS: 'Elements',\n  SCREENSHOT: 'Screenshot',\n  NETWORK: 'Network',\n  MEMORY: 'Memory',\n  JAVASCRIPT_PROFILER: 'JavaScript Profiler',\n  CONSOLE: 'Console',\n  PERFORMANCE: 'Performance',\n  MOBILE: 'Mobile',\n  SENSORS: 'Sensors',\n  HELP: 'Help',\n  INPUTS: 'Inputs',\n  LAYERS: 'Layers',\n  NAVIGATION: 'Navigation',\n  DRAWER: 'Drawer',\n  GLOBAL: 'Global',\n  RESOURCES: 'Resources',\n  BACKGROUND_SERVICES: 'Background Services',\n  SETTINGS: 'Settings',\n  DEBUGGER: 'Debugger',\n  SOURCES: 'Sources',\n  RENDERING: 'Rendering',\n};\n\ntype ActionCategory = typeof ActionCategory[keyof typeof ActionCategory];\n\nexport const enum IconClass {\n  LARGEICON_NODE_SEARCH = 'largeicon-node-search',\n  LARGEICON_START_RECORDING = 'largeicon-start-recording',\n  LARGEICON_STOP_RECORDING = 'largeicon-stop-recording',\n  LARGEICON_REFRESH = 'largeicon-refresh',\n  LARGEICON_CLEAR = 'largeicon-clear',\n  LARGEICON_VISIBILITY = 'largeicon-visibility',\n  LARGEICON_PHONE = 'largeicon-phone',\n  LARGEICON_PLAY = 'largeicon-play',\n  LARGEICON_DOWNLOAD = 'largeicon-download',\n  LARGEICON_PAUSE = 'largeicon-pause',\n  LARGEICON_RESUME = 'largeicon-resume',\n  LARGEICON_TRASH_BIN = 'largeicon-trash-bin',\n  LARGEICON_SETTINGS_GEAR = 'largeicon-settings-gear',\n  LARGEICON_STEP_OVER = 'largeicon-step-over',\n  LARGE_ICON_STEP_INTO = 'largeicon-step-into',\n  LARGE_ICON_STEP = 'largeicon-step',\n  LARGE_ICON_STEP_OUT = 'largeicon-step-out',\n  LARGE_ICON_DEACTIVATE_BREAKPOINTS = 'largeicon-deactivate-breakpoints',\n  LARGE_ICON_ADD = 'largeicon-add',\n}\n\nexport const enum KeybindSet {\n  DEVTOOLS_DEFAULT = 'devToolsDefault',\n  VS_CODE = 'vsCode',\n}\n\nexport interface ExtensionOption {\n  value: boolean;\n  title: () => Platform.UIString.LocalizedString;\n  text?: string;\n}\n\nexport interface Binding {\n  platform?: Platforms;\n  shortcut: string;\n  keybindSets?: Array<KeybindSet>;\n}\n\n/**\n * The representation of an action extension to be registered.\n */\nexport interface ActionRegistration {\n  /**\n   * The unique id of an Action extension.\n   */\n  actionId: string;\n  /**\n   * The category with which the action is displayed in the UI.\n   */\n  category: ActionCategory;\n  /**\n   * The title with which the action is displayed in the UI.\n   */\n  title?: () => Platform.UIString.LocalizedString;\n  /**\n   * The type of the icon used to trigger the action.\n   */\n  iconClass?: IconClass;\n  /**\n   * Whether the style of the icon toggles on interaction.\n   */\n  toggledIconClass?: IconClass;\n  /**\n   * Whether the class 'toolbar-toggle-with-red-color' is toggled on the icon on interaction.\n   */\n  toggleWithRedColor?: boolean;\n  /**\n   * Words used to find an action in the Command Menu.\n   */\n  tags?: Array<() => Platform.UIString.LocalizedString>;\n  /**\n   * Whether the action is toggleable.\n   */\n  toggleable?: boolean;\n  /**\n   * Loads the class that handles the action when it is triggered. The common pattern for implementing\n   * this function relies on having the module that contains the action\u2019s handler lazily loaded. For example:\n   * ```js\n   *  let loadedElementsModule;\n   *\n   *  async function loadElementsModule() {\n   *\n   *    if (!loadedElementsModule) {\n   *      loadedElementsModule = await import('./elements.js');\n   *    }\n   *    return loadedElementsModule;\n   *  }\n   *  UI.ActionRegistration.registerActionExtension({\n   *   <...>\n   *    async loadActionDelegate() {\n   *      const Elements = await loadElementsModule();\n   *      return Elements.ElementsPanel.ElementsActionDelegate.instance();\n   *    },\n   *   <...>\n   *  });\n   * ```\n   */\n  loadActionDelegate?: () => Promise<ActionDelegate>;\n  /**\n   * Returns the classes that represent the 'context flavors' under which the action is available for triggering.\n   * The context of the application is described in 'flavors' that are usually views added and removed to the context\n   * as the user interacts with the application (e.g when the user moves across views). (See UI.Context)\n   * When the action is supposed to be available globally, that is, it does not depend on the application to have\n   * a specific context, the value of this property should be undefined.\n   *\n   * Because the method is synchronous, context types should be already loaded when the method is invoked.\n   * In the case that an action has context types it depends on, and they haven't been loaded yet, the function should\n   * return an empty array. Once the context types have been loaded, the function should return an array with all types\n   * that it depends on.\n   *\n   * The common pattern for implementing this function is relying on having the module with the corresponding context\n   * types loaded and stored when the related 'view' extension is loaded asynchronously. As an example:\n   *\n   * ```js\n   * let loadedElementsModule;\n   *\n   * async function loadElementsModule() {\n   *\n   *   if (!loadedElementsModule) {\n   *     loadedElementsModule = await import('./elements.js');\n   *   }\n   *   return loadedElementsModule;\n   * }\n   * function maybeRetrieveContextTypes(getClassCallBack: (elementsModule: typeof Elements) => unknown[]): unknown[] {\n   *\n   *   if (loadedElementsModule === undefined) {\n   *     return [];\n   *   }\n   *   return getClassCallBack(loadedElementsModule);\n   * }\n   * UI.ActionRegistration.registerActionExtension({\n   *\n   *   contextTypes() {\n   *     return maybeRetrieveContextTypes(Elements => [Elements.ElementsPanel.ElementsPanel]);\n   *   }\n   *   <...>\n   * });\n   * ```\n   */\n  contextTypes?: () => Array<Function>;\n  /**\n   * The descriptions for each of the two states in which a toggleable action can be.\n   */\n  options?: Array<ExtensionOption>;\n  /**\n   * The description of the variables (e.g. platform, keys and keybind sets) under which a keyboard shortcut triggers the action.\n   * If a keybind must be available on all platforms, its 'platform' property must be undefined. The same applies to keybind sets\n   * and the keybindSet property.\n   *\n   * Keybinds also depend on the context types of their corresponding action, and so they will only be available when such context types\n   * are flavors of the current appliaction context.\n   */\n  bindings?: Array<Binding>;\n  /**\n   * The name of the experiment an action is associated with. Enabling and disabling the declared\n   * experiment will enable and disable the action respectively.\n   */\n  experiment?: Root.Runtime.ExperimentName;\n  /**\n   * A condition represented as a string the action's availability depends on. Conditions come\n   * from the queryParamsObject defined in Runtime and just as the experiment field, they determine the availability\n   * of the setting. A condition can be negated by prepending a \u2018!\u2019 to the value of the condition\n   * property and in that case the behaviour of the action's availability will be inverted.\n   */\n  condition?: Root.Runtime.ConditionName;\n  /**\n   * Used to sort actions when all registered actions are queried.\n   */\n  order?: number;\n}\n"],
  "mappings": "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",
  "names": []
}
