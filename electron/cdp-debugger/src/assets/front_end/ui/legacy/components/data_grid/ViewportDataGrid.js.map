{
  "version": 3,
  "sources": ["../../../../../../../../front_end/ui/legacy/components/data_grid/ViewportDataGrid.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as UI from '../../legacy.js';\n\nimport type {DataGridData, Parameters} from './DataGrid.js';\nimport {DataGridImpl, DataGridNode} from './DataGrid.js';\n\nconst UIStrings = {\n  /**\n  *@description accessible name for expandible nodes in datagrids\n  */\n  collapsed: 'collapsed',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/data_grid/ViewportDataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class ViewportDataGrid<T> extends Common.ObjectWrapper.eventMixin<EventTypes, typeof DataGridImpl>(\n    DataGridImpl)<ViewportDataGridNode<T>> {\n  private readonly onScrollBound: (event: Event|null) => void;\n  private visibleNodes: ViewportDataGridNode<T>[];\n  stickToBottom: boolean;\n  private updateIsFromUser: boolean;\n  private lastScrollTop: number;\n  private firstVisibleIsStriped: boolean;\n  private isStriped: boolean;\n  private updateAnimationFrameId?: number;\n\n  constructor(dataGridParameters: Parameters) {\n    super(dataGridParameters);\n\n    this.onScrollBound = this.onScroll.bind(this);\n    this.scrollContainer.addEventListener('scroll', this.onScrollBound, true);\n\n    this.visibleNodes = [];\n    this.inline = false;\n\n    this.stickToBottom = false;\n    this.updateIsFromUser = false;\n    this.lastScrollTop = 0;\n    this.firstVisibleIsStriped = false;\n    this.isStriped = false;\n\n    this.setRootNode(new ViewportDataGridNode());\n  }\n\n  setStriped(striped: boolean): void {\n    this.isStriped = striped;\n    let startsWithOdd = true;\n    if (this.visibleNodes.length) {\n      const allChildren = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n      startsWithOdd = Boolean(allChildren.indexOf(this.visibleNodes[0]));\n    }\n    this.updateStripesClass(startsWithOdd);\n  }\n\n  private updateStripesClass(startsWithOdd: boolean): void {\n    this.element.classList.toggle('striped-data-grid', !startsWithOdd && this.isStriped);\n    this.element.classList.toggle('striped-data-grid-starts-with-odd', startsWithOdd && this.isStriped);\n  }\n\n  setScrollContainer(scrollContainer: HTMLElement): void {\n    this.scrollContainer.removeEventListener('scroll', this.onScrollBound, true);\n    this.scrollContainerInternal = scrollContainer;\n    this.scrollContainer.addEventListener('scroll', this.onScrollBound, true);\n  }\n\n  onResize(): void {\n    if (this.stickToBottom) {\n      this.scrollContainer.scrollTop = this.scrollContainer.scrollHeight - this.scrollContainer.clientHeight;\n    }\n    this.scheduleUpdate();\n    super.onResize();\n  }\n\n  setStickToBottom(stick: boolean): void {\n    this.stickToBottom = stick;\n  }\n\n  private onScroll(_event: Event|null): void {\n    this.stickToBottom = UI.UIUtils.isScrolledToBottom(this.scrollContainer);\n    if (this.lastScrollTop !== this.scrollContainer.scrollTop) {\n      this.scheduleUpdate(true);\n    }\n  }\n\n  scheduleUpdateStructure(): void {\n    this.scheduleUpdate();\n  }\n\n  scheduleUpdate(isFromUser?: boolean): void {\n    if (this.stickToBottom && isFromUser) {\n      this.stickToBottom = UI.UIUtils.isScrolledToBottom(this.scrollContainer);\n    }\n    this.updateIsFromUser = this.updateIsFromUser || Boolean(isFromUser);\n    if (this.updateAnimationFrameId) {\n      return;\n    }\n    this.updateAnimationFrameId = this.element.window().requestAnimationFrame(this.update.bind(this));\n  }\n\n  // TODO(allada) This should be fixed to never be needed. It is needed right now for network because removing\n  // elements happens followed by a scheduleRefresh() which causes white space to be visible, but the waterfall\n  // updates instantly.\n  updateInstantly(): void {\n    this.update();\n  }\n\n  renderInline(): void {\n    this.inline = true;\n    super.renderInline();\n    this.update();\n  }\n\n  private calculateVisibleNodes(clientHeight: number, scrollTop: number): {\n    topPadding: number,\n    bottomPadding: number,\n    contentHeight: number,\n    visibleNodes: Array<ViewportDataGridNode<T>>,\n    offset: number,\n  } {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    if (this.inline) {\n      return {topPadding: 0, bottomPadding: 0, contentHeight: 0, visibleNodes: nodes, offset: 0};\n    }\n\n    const size = nodes.length;\n    let i = 0;\n    let y = 0;\n\n    for (; i < size && y + nodes[i].nodeSelfHeight() < scrollTop; ++i) {\n      y += nodes[i].nodeSelfHeight();\n    }\n    const start = i;\n    const topPadding = y;\n\n    for (; i < size && y < scrollTop + clientHeight; ++i) {\n      y += nodes[i].nodeSelfHeight();\n    }\n    const end = i;\n\n    let bottomPadding = 0;\n    for (; i < size; ++i) {\n      bottomPadding += nodes[i].nodeSelfHeight();\n    }\n\n    return {\n      topPadding: topPadding,\n      bottomPadding: bottomPadding,\n      contentHeight: y - topPadding,\n      visibleNodes: nodes.slice(start, end),\n      offset: start,\n    };\n  }\n\n  private contentHeight(): number {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    let result = 0;\n    for (let i = 0, size = nodes.length; i < size; ++i) {\n      result += nodes[i].nodeSelfHeight();\n    }\n    return result;\n  }\n\n  private update(): void {\n    if (this.updateAnimationFrameId) {\n      this.element.window().cancelAnimationFrame(this.updateAnimationFrameId);\n      delete this.updateAnimationFrameId;\n    }\n\n    const clientHeight = this.scrollContainer.clientHeight - this.headerHeightInScroller();\n    let scrollTop: number = this.scrollContainer.scrollTop;\n    const currentScrollTop = scrollTop;\n    const maxScrollTop = Math.max(0, this.contentHeight() - clientHeight);\n    if (!this.updateIsFromUser && this.stickToBottom) {\n      scrollTop = maxScrollTop;\n    }\n    this.updateIsFromUser = false;\n    scrollTop = Math.min(maxScrollTop, scrollTop);\n\n    const viewportState = this.calculateVisibleNodes(clientHeight, scrollTop);\n    const visibleNodes = viewportState.visibleNodes;\n    const visibleNodesSet = new Set<ViewportDataGridNode<T>>(visibleNodes);\n\n    for (let i = 0; i < this.visibleNodes.length; ++i) {\n      const oldNode = this.visibleNodes[i];\n      if (!visibleNodesSet.has(oldNode) && oldNode.attached()) {\n        const element = oldNode.existingElement();\n        if (element) {\n          element.remove();\n        }\n      }\n    }\n\n    let previousElement = this.topFillerRowElement();\n    const tBody = this.dataTableBody;\n    let offset = viewportState.offset;\n\n    if (visibleNodes.length) {\n      const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n      const index = nodes.indexOf(visibleNodes[0]);\n      this.updateStripesClass(Boolean(index % 2));\n      if (this.stickToBottom && index !== -1 && Boolean(index % 2) !== this.firstVisibleIsStriped) {\n        offset += 1;\n      }\n    }\n\n    this.firstVisibleIsStriped = Boolean(offset % 2);\n\n    for (let i = 0; i < visibleNodes.length; ++i) {\n      const node = visibleNodes[i];\n      const element = (node.element() as HTMLElement);\n      node.setStriped((offset + i) % 2 === 0);\n      if (element !== previousElement.nextSibling) {\n        tBody.insertBefore(element, previousElement.nextSibling);\n      }\n      node.revealed = true;\n      previousElement = element;\n    }\n\n    this.setVerticalPadding(viewportState.topPadding, viewportState.bottomPadding);\n    this.lastScrollTop = scrollTop;\n    if (scrollTop !== currentScrollTop) {\n      this.scrollContainer.scrollTop = scrollTop;\n    }\n    const contentFits =\n        viewportState.contentHeight <= clientHeight && viewportState.topPadding + viewportState.bottomPadding === 0;\n    if (contentFits !== this.element.classList.contains('data-grid-fits-viewport')) {\n      this.element.classList.toggle('data-grid-fits-viewport', contentFits);\n      this.updateWidths();\n    }\n    this.visibleNodes = visibleNodes;\n    this.dispatchEventToListeners(Events.ViewportCalculated);\n  }\n\n  revealViewportNode(node: ViewportDataGridNode<T>): void {\n    const nodes = (this.rootNode() as ViewportDataGridNode<T>).flatChildren();\n    const index = nodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    let fromY = 0;\n    for (let i = 0; i < index; ++i) {\n      fromY += nodes[i].nodeSelfHeight();\n    }\n    const toY = fromY + node.nodeSelfHeight();\n    let scrollTop: number = this.scrollContainer.scrollTop;\n    const visibleHeight = this.scrollContainer.offsetHeight - this.headerHeightInScroller();\n    if (scrollTop > fromY) {\n      scrollTop = fromY;\n      this.stickToBottom = false;\n    } else if (scrollTop + visibleHeight < toY) {\n      scrollTop = toY - visibleHeight;\n    }\n    this.scrollContainer.scrollTop = scrollTop;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  ViewportCalculated = 'ViewportCalculated',\n}\n\nexport type EventTypes = {\n  [Events.ViewportCalculated]: void,\n};\n\nexport class ViewportDataGridNode<T> extends DataGridNode<ViewportDataGridNode<T>> {\n  private stale: boolean;\n  private flatNodes: ViewportDataGridNode<T>[]|null;\n  private isStripedInternal: boolean;\n\n  constructor(data?: DataGridData|null, hasChildren?: boolean) {\n    super(data, hasChildren);\n    this.stale = false;\n    this.flatNodes = null;\n    this.isStripedInternal = false;\n  }\n\n  element(): Element {\n    const existingElement = this.existingElement();\n    const element = existingElement || this.createElement();\n    if (!existingElement || this.stale) {\n      this.createCells(element);\n      this.stale = false;\n    }\n    return element;\n  }\n\n  setStriped(isStriped: boolean): void {\n    this.isStripedInternal = isStriped;\n    this.element().classList.toggle('odd', isStriped);\n  }\n\n  isStriped(): boolean {\n    return this.isStripedInternal;\n  }\n\n  clearFlatNodes(): void {\n    this.flatNodes = null;\n    const parent = (this.parent as ViewportDataGridNode<T>);\n    if (parent) {\n      parent.clearFlatNodes();\n    }\n  }\n\n  flatChildren(): ViewportDataGridNode<T>[] {\n    if (this.flatNodes) {\n      return this.flatNodes;\n    }\n    const flatNodes: ViewportDataGridNode<T>[] = [];\n    const children = ([this.children] as ViewportDataGridNode<T>[][]);\n    const counters: number[] = [0];\n    let depth = 0;\n    while (depth >= 0) {\n      if (children[depth].length <= counters[depth]) {\n        depth--;\n        continue;\n      }\n      const node = children[depth][counters[depth]++];\n      flatNodes.push(node);\n      if (node.expanded && node.children.length) {\n        depth++;\n        children[depth] = (node.children as ViewportDataGridNode<T>[]);\n        counters[depth] = 0;\n      }\n    }\n\n    this.flatNodes = flatNodes;\n    return flatNodes;\n  }\n\n  insertChild(child: DataGridNode<ViewportDataGridNode<T>>, index: number): void {\n    this.clearFlatNodes();\n    if (child.parent === this) {\n      const currentIndex = this.children.indexOf(child);\n      if (currentIndex < 0) {\n        console.assert(false, 'Inconsistent DataGrid state');\n      }\n      if (currentIndex === index) {\n        return;\n      }\n      if (currentIndex < index) {\n        --index;\n      }\n    }\n    child.remove();\n    child.parent = this;\n    child.dataGrid = this.dataGrid;\n    if (!this.children.length) {\n      this.setHasChildren(true);\n    }\n    this.children.splice(index, 0, child);\n    child.recalculateSiblings(index);\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  removeChild(child: DataGridNode<ViewportDataGridNode<T>>): void {\n    this.clearFlatNodes();\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(child, false);\n    }\n    if (child.previousSibling) {\n      child.previousSibling.nextSibling = child.nextSibling;\n    }\n    if (child.nextSibling) {\n      child.nextSibling.previousSibling = child.previousSibling;\n    }\n    if (child.parent !== this) {\n      throw 'removeChild: Node is not a child of this node.';\n    }\n\n    Platform.ArrayUtilities.removeElement(this.children, child, true);\n    (child as ViewportDataGridNode<T>).unlink();\n\n    if (!this.children.length) {\n      this.setHasChildren(false);\n    }\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  removeChildren(): void {\n    this.clearFlatNodes();\n    if (this.dataGrid) {\n      this.dataGrid.updateSelectionBeforeRemoval(this, true);\n    }\n    for (let i = 0; i < this.children.length; ++i) {\n      (this.children[i] as ViewportDataGridNode<T>).unlink();\n    }\n    this.children = ([] as ViewportDataGridNode<T>[]);\n\n    if (this.expanded && this.dataGrid) {\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n    }\n  }\n\n  private unlink(): void {\n    const existingElement = this.existingElement();\n    if (this.attached() && existingElement) {\n      existingElement.remove();\n    }\n    this.resetNode();\n  }\n\n  collapse(): void {\n    if (!this.expanded) {\n      return;\n    }\n    this.clearFlatNodes();\n    this.expandedInternal = false;\n    const existingElement = this.existingElement();\n    if (existingElement) {\n      existingElement.classList.remove('expanded');\n    }\n    if (this.selected) {\n      (this.dataGrid as ViewportDataGrid<T>).updateGridAccessibleName(i18nString(UIStrings.collapsed));\n    }\n    (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n  }\n\n  expand(): void {\n    if (this.expanded) {\n      return;\n    }\n    (this.dataGrid as ViewportDataGrid<T>).stickToBottom = false;\n    this.clearFlatNodes();\n    super.expand();\n    (this.dataGrid as ViewportDataGrid<T>).scheduleUpdateStructure();\n  }\n\n  attached(): boolean {\n    const existingElement = this.existingElement();\n    return Boolean(this.dataGrid && existingElement && existingElement.parentElement);\n  }\n\n  refresh(): void {\n    if (this.attached()) {\n      this.stale = true;\n      (this.dataGrid as ViewportDataGrid<T>).scheduleUpdate();\n    } else {\n      this.resetElement();\n    }\n  }\n\n  reveal(): void {\n    (this.dataGrid as ViewportDataGrid<T>).revealViewportNode(this);\n  }\n\n  recalculateSiblings(index: number): void {\n    this.clearFlatNodes();\n    super.recalculateSiblings(index);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
