{
  "version": 3,
  "sources": ["../../../../../../../../front_end/ui/legacy/components/perf_ui/PieChart.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as ComponentHelpers from '../../../components/helpers/helpers.js';\nimport * as LitHtml from '../../../lit-html/lit-html.js';\nimport pieChartStyles from './pieChart.css.js';\n\nconst {render, html, svg} = LitHtml;\n\nimport * as i18n from '../../../../core/i18n/i18n.js';\nconst UIStrings = {\n  /**\n  *@description Text for sum\n  */\n  total: 'Total',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/PieChart.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface Slice {\n  value: number;\n  color: string;\n  title: string;\n}\n\nexport interface PieChartData {\n  chartName: string;\n  size: number;\n  formatter: (value: number) => string;\n  showLegend: boolean;\n  total: number;\n  slices: Slice[];\n}\n// If the slices are not available when constructing the pie chart, set .data\n// immediately, with total=0 and slices=[], so that the chart is rendered with\n// the correct initial size. This avoids a layout shift when the slices are\n// later populated.\nexport class PieChart extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-perf-piechart`;\n  private readonly shadow = this.attachShadow({mode: 'open'});\n  private chartName = '';\n  private size = 0;\n  private formatter = (val: number): string => String(val);\n  private showLegend = false;\n  private total = 0;\n  private slices: readonly Slice[] = [];\n\n  private totalSelected = true;\n  private sliceSelected = -1;\n\n  private readonly innerR = 0.618;\n  private lastAngle = -Math.PI / 2;\n\n  connectedCallback(): void {\n    this.shadow.adoptedStyleSheets = [pieChartStyles];\n  }\n\n  set data(data: PieChartData) {\n    this.chartName = data.chartName;\n    this.size = data.size;\n    this.formatter = data.formatter;\n    this.showLegend = data.showLegend;\n    this.total = data.total;\n    this.slices = data.slices;\n\n    this.render();\n  }\n\n  private render(): void {\n    this.lastAngle = -Math.PI / 2;\n    // clang-format off\n    const output = html`\n      <div class=\"root\" role=\"group\" @keydown=${this.onKeyDown} aria-label=${this.chartName}>\n        <div class=\"chart-root\" style=\"width: ${this.size}px; height: ${this.size}px;\">\n          ${svg`\n          <svg>\n          <g transform=\"scale(${this.size / 2}) translate(1, 1) scale(0.99, 0.99)\">\n            <circle r=\"1\" stroke=\"hsl(0, 0%, 80%)\" fill=\"transparent\" stroke-width=${1 / this.size}></circle>\n            <circle r=${this.innerR} stroke=\"hsl(0, 0%, 80%)\" fill=\"transparent\" stroke-width=${1 / this.size}></circle>\n            ${this.slices.map((slice, index) => {\n              const selected = this.sliceSelected === index;\n              const tabIndex = selected && !this.showLegend ? '0' : '-1';\n              return svg`<path class=\"slice ${selected ? 'selected' : ''}\"\n                  @click=${this.onSliceClicked(index)} tabIndex=${tabIndex}\n                  fill=${slice.color} d=${this.getPathStringForSlice(slice)}\n                  aria-label=${slice.title} id=${selected ? 'selectedSlice' : ''}></path>`;\n            })}\n            <!-- This is so that the selected slice is re-drawn on top, to avoid re-ordering slices\n            just to render them properly. -->\n            <use href=\"#selectedSlice\" />\n            </g>\n          </svg>\n          `}\n          <div class=\"pie-chart-foreground\">\n            <div class=\"pie-chart-total ${this.totalSelected ? 'selected' : ''}\" @click=${this.selectTotal}\n                tabIndex=${this.totalSelected && !this.showLegend ? '1' : '-1'}>\n              ${this.total ? this.formatter(this.total) : ''}\n            </div>\n          </div>\n        </div>\n        ${this.showLegend ? html`\n        <div class=\"pie-chart-legend\">\n          ${this.slices.map((slice, index): LitHtml.TemplateResult => {\n            const selected = this.sliceSelected === index;\n            return html`\n              <div class=\"pie-chart-legend-row ${selected ? 'selected' : ''}\"\n                  @click=${this.onSliceClicked(index)} tabIndex=${selected ? '0' : '-1'}>\n                <div class=\"pie-chart-size\">${this.formatter(slice.value)}</div>\n                <div class=\"pie-chart-swatch\" style=\"background-color: ${slice.color};\"></div>\n                <div class=\"pie-chart-name\">${slice.title}</div>\n              </div>`;\n          })}\n          <div class=\"pie-chart-legend-row ${this.totalSelected ? 'selected' : ''}\"\n              @click=${this.selectTotal} tabIndex=${this.totalSelected ? '0' : '-1'}>\n            <div class=\"pie-chart-size\">${this.formatter(this.total)}</div>\n            <div class=\"pie-chart-swatch pie-chart-empty-swatch\"></div>\n            <div class=\"pie-chart-name\">${i18nString(UIStrings.total)}</div>\n          </div>\n        </div>\n        ` : ''}\n    `;\n    // clang-format on\n    render(output, this.shadow, {host: this});\n  }\n\n  private onSliceClicked(index: number): () => void {\n    return (): void => {\n      this.selectSlice(index);\n    };\n  }\n\n  private selectSlice(index: number): void {\n    this.totalSelected = false;\n    this.sliceSelected = index;\n    this.render();\n  }\n\n  private selectTotal(): void {\n    this.totalSelected = true;\n    this.sliceSelected = -1;\n    this.render();\n  }\n\n  private selectAndFocusTotal(): void {\n    this.selectTotal();\n    // In order for the :focus-visible styles to work, we need to focus the\n    // newly selected item. This is so that the outline is only shown for focus\n    // caused by keyboard events and not all focus e.g. showing a focus ring\n    // when we click on something is not necessary. The same goes for focusing\n    // slices below.\n    const totalLegendRow = this.shadow.querySelector<HTMLDivElement>('.pie-chart-legend > :last-child');\n    if (!totalLegendRow) {\n      return;\n    }\n    totalLegendRow.focus();\n  }\n\n  private selectAndFocusSlice(index: number): void {\n    this.selectSlice(index);\n    const sliceLegendRow = this.shadow.querySelector<HTMLDivElement>(`.pie-chart-legend > :nth-child(${index + 1})`);\n    if (!sliceLegendRow) {\n      return;\n    }\n    sliceLegendRow.focus();\n  }\n\n  private focusNextElement(): void {\n    if (this.totalSelected) {\n      this.selectAndFocusSlice(0);\n    } else if (this.sliceSelected === this.slices.length - 1) {\n      this.selectAndFocusTotal();\n    } else {\n      this.selectAndFocusSlice(this.sliceSelected + 1);\n    }\n  }\n\n  private focusPreviousElement(): void {\n    if (this.totalSelected) {\n      this.selectAndFocusSlice(this.slices.length - 1);\n    } else if (this.sliceSelected === 0) {\n      this.selectAndFocusTotal();\n    } else {\n      this.selectAndFocusSlice(this.sliceSelected - 1);\n    }\n  }\n\n  private onKeyDown(event: KeyboardEvent): void {\n    let handled = false;\n    if (event.key === 'ArrowDown') {\n      this.focusNextElement();\n      handled = true;\n    } else if (event.key === 'ArrowUp') {\n      this.focusPreviousElement();\n      handled = true;\n    }\n\n    if (handled) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n    }\n  }\n\n  private getPathStringForSlice(slice: Slice): string|undefined {\n    const value = slice.value;\n    let sliceAngle = value / this.total * 2 * Math.PI;\n    if (!isFinite(sliceAngle)) {\n      return;\n    }\n    sliceAngle = Math.min(sliceAngle, 2 * Math.PI * 0.9999);\n    const x1 = Math.cos(this.lastAngle);\n    const y1 = Math.sin(this.lastAngle);\n    this.lastAngle += sliceAngle;\n    const x2 = Math.cos(this.lastAngle);\n    const y2 = Math.sin(this.lastAngle);\n    const r2 = this.innerR;\n    const x3 = x2 * r2;\n    const y3 = y2 * r2;\n    const x4 = x1 * r2;\n    const y4 = y1 * r2;\n    const largeArc = sliceAngle > Math.PI ? 1 : 0;\n\n    const pathString =\n        `M${x1},${y1} A1,1,0,${largeArc},1,${x2},${y2} L${x3},${y3} A${r2},${r2},0,${largeArc},0,${x4},${y4} Z`;\n    return pathString;\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-perf-piechart', PieChart);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface HTMLElementTagNameMap {\n    'devtools-perf-piechart': PieChart;\n  }\n}\n"],
  "mappings": "AAIA;AACA;AACA;AAEA,MAAM,EAAC,QAAQ,MAAM,QAAO;AAE5B;AACA,MAAM,YAAY;AAAA,EAIhB,OAAO;AAAA;AAET,MAAM,OAAO,KAAK,KAAK,kBAAkB,4CAA4C;AACrF,MAAM,aAAa,KAAK,KAAK,mBAAmB,KAAK,QAAW;AAoBzD,8BAAuB,YAAY;AAAA,SACxB,aAAa,QAAQ;AAAA,EACpB,SAAS,KAAK,aAAa,EAAC,MAAM;AAAA,EAC3C,YAAY;AAAA,EACZ,OAAO;AAAA,EACP,YAAY,CAAC,QAAwB,OAAO;AAAA,EAC5C,aAAa;AAAA,EACb,QAAQ;AAAA,EACR,SAA2B;AAAA,EAE3B,gBAAgB;AAAA,EAChB,gBAAgB;AAAA,EAEP,SAAS;AAAA,EAClB,YAAY,CAAC,KAAK,KAAK;AAAA,EAE/B,oBAA0B;AACxB,SAAK,OAAO,qBAAqB,CAAC;AAAA;AAAA,MAGhC,KAAK,MAAoB;AAC3B,SAAK,YAAY,KAAK;AACtB,SAAK,OAAO,KAAK;AACjB,SAAK,YAAY,KAAK;AACtB,SAAK,aAAa,KAAK;AACvB,SAAK,QAAQ,KAAK;AAClB,SAAK,SAAS,KAAK;AAEnB,SAAK;AAAA;AAAA,EAGC,SAAe;AACrB,SAAK,YAAY,CAAC,KAAK,KAAK;AAE5B,UAAM,SAAS;AAAA,gDAC6B,KAAK,wBAAwB,KAAK;AAAA,gDAClC,KAAK,mBAAmB,KAAK;AAAA,YACjE;AAAA;AAAA,gCAEoB,KAAK,OAAO;AAAA,qFACyC,IAAI,KAAK;AAAA,wBACtE,KAAK,mEAAmE,IAAI,KAAK;AAAA,cAC3F,KAAK,OAAO,IAAI,CAAC,OAAO,UAAU;AAClC,YAAM,WAAW,KAAK,kBAAkB;AACxC,YAAM,WAAW,YAAY,CAAC,KAAK,aAAa,MAAM;AACtD,aAAO,yBAAyB,WAAW,aAAa;AAAA,2BAC3C,KAAK,eAAe,mBAAmB;AAAA,yBACzC,MAAM,WAAW,KAAK,sBAAsB;AAAA,+BACtC,MAAM,YAAY,WAAW,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0CASpC,KAAK,gBAAgB,aAAa,cAAc,KAAK;AAAA,2BACpE,KAAK,iBAAiB,CAAC,KAAK,aAAa,MAAM;AAAA,gBAC1D,KAAK,QAAQ,KAAK,UAAU,KAAK,SAAS;AAAA;AAAA;AAAA;AAAA,UAIhD,KAAK,aAAa;AAAA;AAAA,YAEhB,KAAK,OAAO,IAAI,CAAC,OAAO,UAAkC;AAC1D,YAAM,WAAW,KAAK,kBAAkB;AACxC,aAAO;AAAA,iDAC8B,WAAW,aAAa;AAAA,2BAC9C,KAAK,eAAe,mBAAmB,WAAW,MAAM;AAAA,8CACrC,KAAK,UAAU,MAAM;AAAA,yEACM,MAAM;AAAA,8CACjC,MAAM;AAAA;AAAA;AAAA,6CAGP,KAAK,gBAAgB,aAAa;AAAA,uBACxD,KAAK,wBAAwB,KAAK,gBAAgB,MAAM;AAAA,0CACrC,KAAK,UAAU,KAAK;AAAA;AAAA,0CAEpB,WAAW,UAAU;AAAA;AAAA;AAAA,YAGnD;AAAA;AAGR,WAAO,QAAQ,KAAK,QAAQ,EAAC,MAAM;AAAA;AAAA,EAG7B,eAAe,OAA2B;AAChD,WAAO,MAAY;AACjB,WAAK,YAAY;AAAA;AAAA;AAAA,EAIb,YAAY,OAAqB;AACvC,SAAK,gBAAgB;AACrB,SAAK,gBAAgB;AACrB,SAAK;AAAA;AAAA,EAGC,cAAoB;AAC1B,SAAK,gBAAgB;AACrB,SAAK,gBAAgB;AACrB,SAAK;AAAA;AAAA,EAGC,sBAA4B;AAClC,SAAK;AAML,UAAM,iBAAiB,KAAK,OAAO,cAA8B;AACjE,QAAI,CAAC,gBAAgB;AACnB;AAAA;AAEF,mBAAe;AAAA;AAAA,EAGT,oBAAoB,OAAqB;AAC/C,SAAK,YAAY;AACjB,UAAM,iBAAiB,KAAK,OAAO,cAA8B,kCAAkC,QAAQ;AAC3G,QAAI,CAAC,gBAAgB;AACnB;AAAA;AAEF,mBAAe;AAAA;AAAA,EAGT,mBAAyB;AAC/B,QAAI,KAAK,eAAe;AACtB,WAAK,oBAAoB;AAAA,eAChB,KAAK,kBAAkB,KAAK,OAAO,SAAS,GAAG;AACxD,WAAK;AAAA,WACA;AACL,WAAK,oBAAoB,KAAK,gBAAgB;AAAA;AAAA;AAAA,EAI1C,uBAA6B;AACnC,QAAI,KAAK,eAAe;AACtB,WAAK,oBAAoB,KAAK,OAAO,SAAS;AAAA,eACrC,KAAK,kBAAkB,GAAG;AACnC,WAAK;AAAA,WACA;AACL,WAAK,oBAAoB,KAAK,gBAAgB;AAAA;AAAA;AAAA,EAI1C,UAAU,OAA4B;AAC5C,QAAI,UAAU;AACd,QAAI,MAAM,QAAQ,aAAa;AAC7B,WAAK;AACL,gBAAU;AAAA,eACD,MAAM,QAAQ,WAAW;AAClC,WAAK;AACL,gBAAU;AAAA;AAGZ,QAAI,SAAS;AACX,YAAM;AACN,YAAM;AAAA;AAAA;AAAA,EAIF,sBAAsB,OAAgC;AAC5D,UAAM,QAAQ,MAAM;AACpB,QAAI,aAAa,QAAQ,KAAK,QAAQ,IAAI,KAAK;AAC/C,QAAI,CAAC,SAAS,aAAa;AACzB;AAAA;AAEF,iBAAa,KAAK,IAAI,YAAY,IAAI,KAAK,KAAK;AAChD,UAAM,KAAK,KAAK,IAAI,KAAK;AACzB,UAAM,KAAK,KAAK,IAAI,KAAK;AACzB,SAAK,aAAa;AAClB,UAAM,KAAK,KAAK,IAAI,KAAK;AACzB,UAAM,KAAK,KAAK,IAAI,KAAK;AACzB,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAChB,UAAM,KAAK,KAAK;AAChB,UAAM,WAAW,aAAa,KAAK,KAAK,IAAI;AAE5C,UAAM,aACF,IAAI,MAAM,aAAa,cAAc,MAAM,OAAO,MAAM,OAAO,MAAM,QAAQ,cAAc,MAAM;AACrG,WAAO;AAAA;AAAA;AAIX,iBAAiB,eAAe,gBAAgB,0BAA0B;",
  "names": []
}
