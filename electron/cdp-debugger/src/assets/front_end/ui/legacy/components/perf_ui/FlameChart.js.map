{
  "version": 3,
  "sources": ["../../../../../../../../front_end/ui/legacy/components/perf_ui/FlameChart.ts"],
  "sourcesContent": ["/**\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as Host from '../../../../core/host/host.js';\nimport * as i18n from '../../../../core/i18n/i18n.js';\nimport * as Platform from '../../../../core/platform/platform.js';\nimport * as Root from '../../../../core/root/root.js';\nimport type * as SDK from '../../../../core/sdk/sdk.js';\nimport type * as TimelineModel from '../../../../models/timeline_model/timeline_model.js';\nimport * as UI from '../../legacy.js';\nimport * as ThemeSupport from '../../theme_support/theme_support.js';\n\nimport type {ChartViewportDelegate} from './ChartViewport.js';\nimport {ChartViewport} from './ChartViewport.js';\nimport type {Calculator} from './TimelineGrid.js';\nimport {TimelineGrid} from './TimelineGrid.js';\nimport flameChartStyles from './flameChart.css.legacy.js';\n\nconst UIStrings = {\n  /**\n  *@description Aria accessible name in Flame Chart of the Performance panel\n  */\n  flameChart: 'Flame Chart',\n  /**\n  *@description Text for the screen reader to announce a hovered group\n  *@example {Network} PH1\n  */\n  sHovered: '{PH1} hovered',\n  /**\n  *@description Text for screen reader to announce a selected group.\n  *@example {Network} PH1\n  */\n  sSelected: '{PH1} selected',\n  /**\n  *@description Text for screen reader to announce an expanded group\n  *@example {Network} PH1\n  */\n  sExpanded: '{PH1} expanded',\n  /**\n  *@description Text for screen reader to announce a collapsed group\n  *@example {Network} PH1\n  */\n  sCollapsed: '{PH1} collapsed',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/legacy/components/perf_ui/FlameChart.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class FlameChartDelegate {\n  windowChanged(_startTime: number, _endTime: number, _animate: boolean): void {\n  }\n  updateRangeSelection(_startTime: number, _endTime: number): void {\n  }\n  updateSelectedGroup(_flameChart: FlameChart, _group: Group|null): void {\n  }\n}\n\ninterface GroupExpansionState {\n  [key: string]: boolean;\n}\n\nexport class FlameChart extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(UI.Widget.VBox)\n    implements Calculator, ChartViewportDelegate {\n  private readonly groupExpansionSetting?: Common.Settings.Setting<GroupExpansionState>;\n  private groupExpansionState: GroupExpansionState;\n  private readonly flameChartDelegate: FlameChartDelegate;\n  private useWebGL: boolean;\n  private chartViewport: ChartViewport;\n  private dataProvider: FlameChartDataProvider;\n  private candyStripeCanvas: HTMLCanvasElement;\n  private viewportElement: HTMLElement;\n  private canvasGL!: HTMLCanvasElement;\n  private canvas: HTMLCanvasElement;\n  private entryInfo: HTMLElement;\n  private readonly markerHighlighElement: HTMLElement;\n  private readonly highlightElement: HTMLElement;\n  private readonly selectedElement: HTMLElement;\n  private rulerEnabled: boolean;\n  private readonly rangeSelectionStart: number;\n  private readonly rangeSelectionEnd: number;\n  private barHeight: number;\n  private textBaseline: number;\n  private textPadding: number;\n  private readonly markerRadius: number;\n  private readonly headerLeftPadding: number;\n  private arrowSide: number;\n  private readonly expansionArrowIndent: number;\n  private readonly headerLabelXPadding: number;\n  private readonly headerLabelYPadding: number;\n  private highlightedMarkerIndex: number;\n  private highlightedEntryIndex: number;\n  private selectedEntryIndex: number;\n  private rawTimelineDataLength: number;\n  private textWidth: Map<string, Map<string, number>>;\n  private readonly markerPositions: Map<number, {\n    x: number,\n    width: number,\n  }>;\n  private lastMouseOffsetX: number;\n  private selectedGroup: number;\n  private keyboardFocusedGroup: number;\n  private offsetWidth!: number;\n  private offsetHeight!: number;\n  private dragStartX!: number;\n  private dragStartY!: number;\n  private lastMouseOffsetY!: number;\n  private minimumBoundaryInternal!: number;\n  private maxDragOffset!: number;\n  private shaderProgram?: WebGLProgram|null;\n  private vertexBuffer?: WebGLBuffer|null;\n  private colorBuffer?: WebGLBuffer|null;\n  private uScalingFactor?: WebGLUniformLocation|null;\n  private uShiftVector?: WebGLUniformLocation|null;\n  private aVertexPosition?: number;\n  private aVertexColor?: number;\n  private vertexCount?: number;\n  private prevTimelineData?: TimelineData;\n  private timelineLevels?: number[][]|null;\n  private visibleLevelOffsets?: Uint32Array|null;\n  private visibleLevels?: Uint16Array|null;\n  private groupOffsets?: Uint32Array|null;\n  private rawTimelineData?: TimelineData|null;\n  private forceDecorationCache?: Int8Array|null;\n  private entryColorsCache?: string[]|null;\n  private visibleLevelHeights?: Uint32Array;\n  private totalTime?: number;\n\n  constructor(\n      dataProvider: FlameChartDataProvider, flameChartDelegate: FlameChartDelegate,\n      groupExpansionSetting?: Common.Settings.Setting<GroupExpansionState>) {\n    super(true);\n    this.registerRequiredCSS(flameChartStyles);\n    this.contentElement.classList.add('flame-chart-main-pane');\n    this.groupExpansionSetting = groupExpansionSetting;\n    this.groupExpansionState = groupExpansionSetting && groupExpansionSetting.get() || {};\n    this.flameChartDelegate = flameChartDelegate;\n\n    this.useWebGL = Root.Runtime.experiments.isEnabled('timelineWebGL');\n    this.chartViewport = new ChartViewport(this);\n    this.chartViewport.show(this.contentElement);\n\n    this.dataProvider = dataProvider;\n    this.candyStripeCanvas = document.createElement('canvas');\n    this.createCandyStripePattern();\n\n    this.viewportElement = this.chartViewport.viewportElement;\n    if (this.useWebGL) {\n      this.canvasGL = (this.viewportElement.createChild('canvas', 'fill') as HTMLCanvasElement);\n      this.initWebGL();\n    }\n    this.canvas = (this.viewportElement.createChild('canvas', 'fill') as HTMLCanvasElement);\n\n    this.canvas.tabIndex = 0;\n    UI.ARIAUtils.setAccessibleName(this.canvas, i18nString(UIStrings.flameChart));\n    UI.ARIAUtils.markAsTree(this.canvas);\n    this.setDefaultFocusedElement(this.canvas);\n    this.canvas.classList.add('flame-chart-canvas');\n    this.canvas.addEventListener('mousemove', this.onMouseMove.bind(this), false);\n    this.canvas.addEventListener('mouseout', this.onMouseOut.bind(this), false);\n    this.canvas.addEventListener('click', this.onClick.bind(this), false);\n    this.canvas.addEventListener('keydown', this.onKeyDown.bind(this), false);\n\n    this.entryInfo = this.viewportElement.createChild('div', 'flame-chart-entry-info');\n    this.markerHighlighElement = this.viewportElement.createChild('div', 'flame-chart-marker-highlight-element');\n    this.highlightElement = this.viewportElement.createChild('div', 'flame-chart-highlight-element');\n    this.selectedElement = this.viewportElement.createChild('div', 'flame-chart-selected-element');\n    this.canvas.addEventListener('focus', () => {\n      this.dispatchEventToListeners(Events.CanvasFocused);\n    }, false);\n\n    UI.UIUtils.installDragHandle(\n        this.viewportElement, this.startDragging.bind(this), this.dragging.bind(this), this.endDragging.bind(this),\n        null);\n\n    this.rulerEnabled = true;\n    this.rangeSelectionStart = 0;\n    this.rangeSelectionEnd = 0;\n    this.barHeight = 17;\n    this.textBaseline = 5;\n    this.textPadding = 5;\n    this.markerRadius = 6;\n    this.chartViewport.setWindowTimes(\n        dataProvider.minimumBoundary(), dataProvider.minimumBoundary() + dataProvider.totalTime());\n\n    this.headerLeftPadding = 6;\n    this.arrowSide = 8;\n    this.expansionArrowIndent = this.headerLeftPadding + this.arrowSide / 2;\n    this.headerLabelXPadding = 3;\n    this.headerLabelYPadding = 2;\n\n    this.highlightedMarkerIndex = -1;\n    this.highlightedEntryIndex = -1;\n    this.selectedEntryIndex = -1;\n    this.rawTimelineDataLength = 0;\n    this.textWidth = new Map();\n    this.markerPositions = new Map();\n\n    this.lastMouseOffsetX = 0;\n    this.selectedGroup = -1;\n\n    // Keyboard focused group is used to navigate groups irrespective of whether they are selectable or not\n    this.keyboardFocusedGroup = -1;\n\n    ThemeSupport.ThemeSupport.instance().addEventListener(ThemeSupport.ThemeChangeEvent.eventName, () => {\n      this.scheduleUpdate();\n    });\n  }\n\n  willHide(): void {\n    this.hideHighlight();\n  }\n\n  setBarHeight(value: number): void {\n    this.barHeight = value;\n  }\n\n  setTextBaseline(value: number): void {\n    this.textBaseline = value;\n  }\n\n  setTextPadding(value: number): void {\n    this.textPadding = value;\n  }\n\n  enableRuler(enable: boolean): void {\n    this.rulerEnabled = enable;\n  }\n\n  alwaysShowVerticalScroll(): void {\n    this.chartViewport.alwaysShowVerticalScroll();\n  }\n\n  disableRangeSelection(): void {\n    this.chartViewport.disableRangeSelection();\n  }\n\n  highlightEntry(entryIndex: number): void {\n    if (this.highlightedEntryIndex === entryIndex) {\n      return;\n    }\n    if (!this.dataProvider.entryColor(entryIndex)) {\n      return;\n    }\n    this.highlightedEntryIndex = entryIndex;\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.dispatchEventToListeners(Events.EntryHighlighted, entryIndex);\n  }\n\n  hideHighlight(): void {\n    this.entryInfo.removeChildren();\n    this.highlightedEntryIndex = -1;\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.dispatchEventToListeners(Events.EntryHighlighted, -1);\n  }\n\n  private createCandyStripePattern(): void {\n    // Set the candy stripe pattern to 17px so it repeats well.\n    const size = 17;\n    this.candyStripeCanvas.width = size;\n    this.candyStripeCanvas.height = size;\n\n    const ctx = this.candyStripeCanvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n\n    // Rotate the stripe by 45deg to the right.\n    ctx.translate(size * 0.5, size * 0.5);\n    ctx.rotate(Math.PI * 0.25);\n    ctx.translate(-size * 0.5, -size * 0.5);\n\n    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';\n    for (let x = -size; x < size * 2; x += 3) {\n      ctx.fillRect(x, -size, 1, size * 3);\n    }\n  }\n\n  private resetCanvas(): void {\n    const ratio = window.devicePixelRatio;\n    const width = Math.round(this.offsetWidth * ratio);\n    const height = Math.round(this.offsetHeight * ratio);\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.canvas.style.width = `${width / ratio}px`;\n    this.canvas.style.height = `${height / ratio}px`;\n    if (this.useWebGL) {\n      this.canvasGL.width = width;\n      this.canvasGL.height = height;\n      this.canvasGL.style.width = `${width / ratio}px`;\n      this.canvasGL.style.height = `${height / ratio}px`;\n    }\n  }\n\n  windowChanged(startTime: number, endTime: number, animate: boolean): void {\n    this.flameChartDelegate.windowChanged(startTime, endTime, animate);\n  }\n\n  updateRangeSelection(startTime: number, endTime: number): void {\n    this.flameChartDelegate.updateRangeSelection(startTime, endTime);\n  }\n\n  setSize(width: number, height: number): void {\n    this.offsetWidth = width;\n    this.offsetHeight = height;\n  }\n\n  private startDragging(event: MouseEvent): boolean {\n    this.hideHighlight();\n    this.maxDragOffset = 0;\n    this.dragStartX = event.pageX;\n    this.dragStartY = event.pageY;\n    return true;\n  }\n\n  private dragging(event: MouseEvent): void {\n    const dx = event.pageX - this.dragStartX;\n    const dy = event.pageY - this.dragStartY;\n    this.maxDragOffset = Math.max(this.maxDragOffset, Math.sqrt(dx * dx + dy * dy));\n  }\n\n  private endDragging(_event: MouseEvent): void {\n    this.updateHighlight();\n  }\n\n  private timelineData(): TimelineData|null {\n    if (!this.dataProvider) {\n      return null;\n    }\n    const timelineData = this.dataProvider.timelineData();\n    if (timelineData !== this.rawTimelineData ||\n        (timelineData && timelineData.entryStartTimes.length !== this.rawTimelineDataLength)) {\n      this.processTimelineData(timelineData);\n    }\n    return this.rawTimelineData || null;\n  }\n\n  private revealEntry(entryIndex: number): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const timeLeft = this.chartViewport.windowLeftTime();\n    const timeRight = this.chartViewport.windowRightTime();\n    const entryStartTime = timelineData.entryStartTimes[entryIndex];\n    const entryTotalTime = timelineData.entryTotalTimes[entryIndex];\n    const entryEndTime = entryStartTime + entryTotalTime;\n    let minEntryTimeWindow = Math.min(entryTotalTime, timeRight - timeLeft);\n\n    const level = timelineData.entryLevels[entryIndex];\n    this.chartViewport.setScrollOffset(this.levelToOffset(level), this.levelHeight(level));\n\n    const minVisibleWidthPx = 30;\n    const futurePixelToTime = (timeRight - timeLeft) / this.offsetWidth;\n    minEntryTimeWindow = Math.max(minEntryTimeWindow, futurePixelToTime * minVisibleWidthPx);\n    if (timeLeft > entryEndTime) {\n      const delta = timeLeft - entryEndTime + minEntryTimeWindow;\n      this.windowChanged(timeLeft - delta, timeRight - delta, /* animate */ true);\n    } else if (timeRight < entryStartTime) {\n      const delta = entryStartTime - timeRight + minEntryTimeWindow;\n      this.windowChanged(timeLeft + delta, timeRight + delta, /* animate */ true);\n    }\n  }\n\n  setWindowTimes(startTime: number, endTime: number, animate?: boolean): void {\n    this.chartViewport.setWindowTimes(startTime, endTime, animate);\n    this.updateHighlight();\n  }\n\n  private onMouseMove(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    this.lastMouseOffsetX = mouseEvent.offsetX;\n    this.lastMouseOffsetY = mouseEvent.offsetY;\n    if (!this.enabled()) {\n      return;\n    }\n    if (this.chartViewport.isDragging()) {\n      return;\n    }\n    if (this.coordinatesToGroupIndex(mouseEvent.offsetX, mouseEvent.offsetY, true /* headerOnly */) >= 0) {\n      this.hideHighlight();\n      this.viewportElement.style.cursor = 'pointer';\n      return;\n    }\n    this.updateHighlight();\n  }\n\n  private updateHighlight(): void {\n    const entryIndex = this.coordinatesToEntryIndex(this.lastMouseOffsetX, this.lastMouseOffsetY);\n    if (entryIndex === -1) {\n      this.hideHighlight();\n      const group = this.coordinatesToGroupIndex(this.lastMouseOffsetX, this.lastMouseOffsetY, false /* headerOnly */);\n      if (group >= 0 && this.rawTimelineData && this.rawTimelineData.groups &&\n          this.rawTimelineData.groups[group].selectable) {\n        this.viewportElement.style.cursor = 'pointer';\n      } else {\n        this.viewportElement.style.cursor = 'default';\n      }\n      return;\n    }\n    if (this.chartViewport.isDragging()) {\n      return;\n    }\n    this.updatePopover(entryIndex);\n    this.viewportElement.style.cursor = this.dataProvider.canJumpToEntry(entryIndex) ? 'pointer' : 'default';\n    this.highlightEntry(entryIndex);\n  }\n\n  private onMouseOut(): void {\n    this.lastMouseOffsetX = -1;\n    this.lastMouseOffsetY = -1;\n    this.hideHighlight();\n  }\n\n  private updatePopover(entryIndex: number): void {\n    if (entryIndex === this.highlightedEntryIndex) {\n      this.updatePopoverOffset();\n      return;\n    }\n    this.entryInfo.removeChildren();\n    const popoverElement = this.dataProvider.prepareHighlightedEntryInfo(entryIndex);\n    if (popoverElement) {\n      this.entryInfo.appendChild(popoverElement);\n      this.updatePopoverOffset();\n    }\n  }\n\n  private updatePopoverOffset(): void {\n    const mouseX = this.lastMouseOffsetX;\n    const mouseY = this.lastMouseOffsetY;\n    const parentWidth = this.entryInfo.parentElement ? this.entryInfo.parentElement.clientWidth : 0;\n    const parentHeight = this.entryInfo.parentElement ? this.entryInfo.parentElement.clientHeight : 0;\n    const infoWidth = this.entryInfo.clientWidth;\n    const infoHeight = this.entryInfo.clientHeight;\n    const /** @const */ offsetX = 10;\n    const /** @const */ offsetY = 6;\n    let x;\n    let y;\n    for (let quadrant = 0; quadrant < 4; ++quadrant) {\n      const dx = quadrant & 2 ? -offsetX - infoWidth : offsetX;\n      const dy = quadrant & 1 ? -offsetY - infoHeight : offsetY;\n      x = Platform.NumberUtilities.clamp(mouseX + dx, 0, parentWidth - infoWidth);\n      y = Platform.NumberUtilities.clamp(mouseY + dy, 0, parentHeight - infoHeight);\n      if (x >= mouseX || mouseX >= x + infoWidth || y >= mouseY || mouseY >= y + infoHeight) {\n        break;\n      }\n    }\n    this.entryInfo.style.left = x + 'px';\n    this.entryInfo.style.top = y + 'px';\n  }\n\n  private onClick(event: Event): void {\n    const mouseEvent = (event as MouseEvent);\n    this.focus();\n    // onClick comes after dragStart and dragEnd events.\n    // So if there was drag (mouse move) in the middle of that events\n    // we skip the click. Otherwise we jump to the sources.\n    const clickThreshold = 5;\n    if (this.maxDragOffset > clickThreshold) {\n      return;\n    }\n\n    this.selectGroup(this.coordinatesToGroupIndex(mouseEvent.offsetX, mouseEvent.offsetY, false /* headerOnly */));\n    this.toggleGroupExpand(this.coordinatesToGroupIndex(mouseEvent.offsetX, mouseEvent.offsetY, true /* headerOnly */));\n    const timelineData = this.timelineData();\n    if (mouseEvent.shiftKey && this.highlightedEntryIndex !== -1 && timelineData) {\n      const start = timelineData.entryStartTimes[this.highlightedEntryIndex];\n      const end = start + timelineData.entryTotalTimes[this.highlightedEntryIndex];\n      this.chartViewport.setRangeSelection(start, end);\n    } else {\n      this.chartViewport.onClick(mouseEvent);\n      this.dispatchEventToListeners(Events.EntryInvoked, this.highlightedEntryIndex);\n    }\n  }\n\n  private selectGroup(groupIndex: number): void {\n    if (groupIndex < 0 || this.selectedGroup === groupIndex) {\n      return;\n    }\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    if (!groups) {\n      return;\n    }\n\n    this.keyboardFocusedGroup = groupIndex;\n    this.scrollGroupIntoView(groupIndex);\n    const groupName = groups[groupIndex].name;\n    if (!groups[groupIndex].selectable) {\n      this.deselectAllGroups();\n      UI.ARIAUtils.alert(i18nString(UIStrings.sHovered, {PH1: groupName}));\n    } else {\n      this.selectedGroup = groupIndex;\n      this.flameChartDelegate.updateSelectedGroup(this, groups[groupIndex]);\n      this.resetCanvas();\n      this.draw();\n      UI.ARIAUtils.alert(i18nString(UIStrings.sSelected, {PH1: groupName}));\n    }\n  }\n\n  private deselectAllGroups(): void {\n    this.selectedGroup = -1;\n    this.flameChartDelegate.updateSelectedGroup(this, null);\n    this.resetCanvas();\n    this.draw();\n  }\n\n  private deselectAllEntries(): void {\n    this.selectedEntryIndex = -1;\n    this.resetCanvas();\n    this.draw();\n  }\n\n  private isGroupFocused(index: number): boolean {\n    return index === this.selectedGroup || index === this.keyboardFocusedGroup;\n  }\n\n  private scrollGroupIntoView(index: number): void {\n    if (index < 0) {\n      return;\n    }\n\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    const groupOffsets = this.groupOffsets;\n    if (!groupOffsets || !groups) {\n      return;\n    }\n    const groupTop = groupOffsets[index];\n\n    let nextOffset = groupOffsets[index + 1];\n    if (index === groups.length - 1) {\n      nextOffset += groups[index].style.padding;\n    }\n\n    // For the top group, scroll all the way to the top of the chart\n    // to accommodate the bar with time markers\n    const scrollTop = index === 0 ? 0 : groupTop;\n\n    const scrollHeight = Math.min(nextOffset - scrollTop, this.chartViewport.chartHeight());\n    this.chartViewport.setScrollOffset(scrollTop, scrollHeight);\n  }\n\n  private toggleGroupExpand(groupIndex: number): void {\n    if (groupIndex < 0 || !this.isGroupCollapsible(groupIndex)) {\n      return;\n    }\n\n    if (!this.rawTimelineData || !this.rawTimelineData.groups) {\n      return;\n    }\n\n    this.expandGroup(groupIndex, !this.rawTimelineData.groups[groupIndex].expanded /* setExpanded */);\n  }\n\n  private expandGroup(\n      groupIndex: number, setExpanded: boolean|undefined = true, propagatedExpand: boolean|undefined = false): void {\n    if (groupIndex < 0 || !this.isGroupCollapsible(groupIndex)) {\n      return;\n    }\n\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups;\n    if (!groups) {\n      return;\n    }\n\n    const group = groups[groupIndex];\n    group.expanded = setExpanded;\n\n    this.groupExpansionState[group.name] = group.expanded;\n    if (this.groupExpansionSetting) {\n      this.groupExpansionSetting.set(this.groupExpansionState);\n    }\n    this.updateLevelPositions();\n\n    this.updateHighlight();\n    if (!group.expanded) {\n      const timelineData = this.timelineData();\n      if (timelineData) {\n        const level = timelineData.entryLevels[this.selectedEntryIndex];\n        if (this.selectedEntryIndex >= 0 && level >= group.startLevel &&\n            (groupIndex >= groups.length - 1 || groups[groupIndex + 1].startLevel > level)) {\n          this.selectedEntryIndex = -1;\n        }\n      }\n    }\n\n    this.updateHeight();\n    this.resetCanvas();\n    this.draw();\n\n    this.scrollGroupIntoView(groupIndex);\n    // We only want to read expanded/collapsed state on user inputted expand/collapse\n    if (!propagatedExpand) {\n      const groupName = groups[groupIndex].name;\n      const content = group.expanded ? i18nString(UIStrings.sExpanded, {PH1: groupName}) :\n                                       i18nString(UIStrings.sCollapsed, {PH1: groupName});\n      UI.ARIAUtils.alert(content);\n    }\n  }\n\n  private onKeyDown(e: KeyboardEvent): void {\n    if (!UI.KeyboardShortcut.KeyboardShortcut.hasNoModifiers(e) || !this.timelineData()) {\n      return;\n    }\n\n    const eventHandled = this.handleSelectionNavigation(e);\n\n    // Handle keyboard navigation in groups\n    if (!eventHandled && this.rawTimelineData && this.rawTimelineData.groups) {\n      this.handleKeyboardGroupNavigation(e);\n    }\n  }\n\n  bindCanvasEvent(eventName: string, onEvent: (arg0: Event) => void): void {\n    this.canvas.addEventListener(eventName, onEvent);\n  }\n\n  private handleKeyboardGroupNavigation(event: Event): void {\n    const keyboardEvent = (event as KeyboardEvent);\n    let handled = false;\n    let entrySelected = false;\n\n    if (keyboardEvent.code === 'ArrowUp') {\n      handled = this.selectPreviousGroup();\n    } else if (keyboardEvent.code === 'ArrowDown') {\n      handled = this.selectNextGroup();\n    } else if (keyboardEvent.code === 'ArrowLeft') {\n      if (this.keyboardFocusedGroup >= 0) {\n        this.expandGroup(this.keyboardFocusedGroup, false /* setExpanded */);\n        handled = true;\n      }\n    } else if (keyboardEvent.code === 'ArrowRight') {\n      if (this.keyboardFocusedGroup >= 0) {\n        this.expandGroup(this.keyboardFocusedGroup, true /* setExpanded */);\n        this.selectFirstChild();\n        handled = true;\n      }\n    } else if (keyboardEvent.key === 'Enter') {\n      entrySelected = this.selectFirstEntryInCurrentGroup();\n      handled = entrySelected;\n    }\n\n    if (handled && !entrySelected) {\n      this.deselectAllEntries();\n    }\n\n    if (handled) {\n      keyboardEvent.consume(true);\n    }\n  }\n\n  private selectFirstEntryInCurrentGroup(): boolean {\n    if (!this.rawTimelineData) {\n      return false;\n    }\n\n    const allGroups = this.rawTimelineData.groups;\n\n    if (this.keyboardFocusedGroup < 0 || !allGroups) {\n      return false;\n    }\n\n    const group = allGroups[this.keyboardFocusedGroup];\n    const startLevelInGroup = group.startLevel;\n\n    // Return if no levels in this group\n    if (startLevelInGroup < 0) {\n      return false;\n    }\n\n    // Make sure this is the innermost nested group with this startLevel\n    // This is because a parent group also contains levels of all its child groups\n    // So check if the next group has the same level, if it does, user should\n    // go to that child group to select this entry\n    if (this.keyboardFocusedGroup < allGroups.length - 1 &&\n        allGroups[this.keyboardFocusedGroup + 1].startLevel === startLevelInGroup) {\n      return false;\n    }\n\n    if (!this.timelineLevels) {\n      return false;\n    }\n\n    // Get first (default) entry in startLevel of selected group\n    const firstEntryIndex = this.timelineLevels[startLevelInGroup][0];\n\n    this.expandGroup(this.keyboardFocusedGroup, true /* setExpanded */);\n    this.setSelectedEntry(firstEntryIndex);\n    return true;\n  }\n\n  private selectPreviousGroup(): boolean {\n    if (this.keyboardFocusedGroup <= 0) {\n      return false;\n    }\n\n    const groupIndexToSelect = this.getGroupIndexToSelect(-1 /* offset */);\n    this.selectGroup(groupIndexToSelect);\n    return true;\n  }\n\n  private selectNextGroup(): boolean {\n    if (!this.rawTimelineData || !this.rawTimelineData.groups) {\n      return false;\n    }\n\n    if (this.keyboardFocusedGroup >= this.rawTimelineData.groups.length - 1) {\n      return false;\n    }\n\n    const groupIndexToSelect = this.getGroupIndexToSelect(1 /* offset */);\n    this.selectGroup(groupIndexToSelect);\n    return true;\n  }\n\n  private getGroupIndexToSelect(offset: number): number {\n    if (!this.rawTimelineData || !this.rawTimelineData.groups) {\n      throw new Error('No raw timeline data');\n    }\n    const allGroups = this.rawTimelineData.groups;\n    let groupIndexToSelect = this.keyboardFocusedGroup;\n    let groupName, groupWithSubNestingLevel;\n\n    do {\n      groupIndexToSelect += offset;\n      groupName = this.rawTimelineData.groups[groupIndexToSelect].name;\n      groupWithSubNestingLevel = this.keyboardFocusedGroup !== -1 &&\n          allGroups[groupIndexToSelect].style.nestingLevel > allGroups[this.keyboardFocusedGroup].style.nestingLevel;\n    } while (groupIndexToSelect > 0 && groupIndexToSelect < allGroups.length - 1 &&\n             (!groupName || groupWithSubNestingLevel));\n\n    return groupIndexToSelect;\n  }\n\n  private selectFirstChild(): void {\n    if (!this.rawTimelineData || !this.rawTimelineData.groups) {\n      return;\n    }\n\n    const allGroups = this.rawTimelineData.groups;\n    if (this.keyboardFocusedGroup < 0 || this.keyboardFocusedGroup >= allGroups.length - 1) {\n      return;\n    }\n\n    const groupIndexToSelect = this.keyboardFocusedGroup + 1;\n    if (allGroups[groupIndexToSelect].style.nestingLevel > allGroups[this.keyboardFocusedGroup].style.nestingLevel) {\n      this.selectGroup(groupIndexToSelect);\n    }\n  }\n\n  private handleSelectionNavigation(event: KeyboardEvent): boolean {\n    if (this.selectedEntryIndex === -1) {\n      return false;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return false;\n    }\n\n    function timeComparator(time: number, entryIndex: number): number {\n      if (!timelineData) {\n        throw new Error('No timeline data');\n      }\n      return time - timelineData.entryStartTimes[entryIndex];\n    }\n\n    function entriesIntersect(entry1: number, entry2: number): boolean {\n      if (!timelineData) {\n        throw new Error('No timeline data');\n      }\n\n      const start1 = timelineData.entryStartTimes[entry1];\n      const start2 = timelineData.entryStartTimes[entry2];\n      const end1 = start1 + timelineData.entryTotalTimes[entry1];\n      const end2 = start2 + timelineData.entryTotalTimes[entry2];\n      return start1 < end2 && start2 < end1;\n    }\n\n    const keyboardEvent = (event as KeyboardEvent);\n    const keys = UI.KeyboardShortcut.Keys;\n    if (keyboardEvent.keyCode === keys.Left.code || keyboardEvent.keyCode === keys.Right.code) {\n      const level = timelineData.entryLevels[this.selectedEntryIndex];\n      const levelIndexes = this.timelineLevels ? this.timelineLevels[level] : [];\n      let indexOnLevel = Platform.ArrayUtilities.lowerBound(levelIndexes, this.selectedEntryIndex, (a, b) => a - b);\n      indexOnLevel += keyboardEvent.keyCode === keys.Left.code ? -1 : 1;\n      event.consume(true);\n      if (indexOnLevel >= 0 && indexOnLevel < levelIndexes.length) {\n        this.dispatchEventToListeners(Events.EntrySelected, levelIndexes[indexOnLevel]);\n      }\n      return true;\n    }\n\n    if (keyboardEvent.keyCode === keys.Up.code || keyboardEvent.keyCode === keys.Down.code) {\n      let level = timelineData.entryLevels[this.selectedEntryIndex];\n      level += keyboardEvent.keyCode === keys.Up.code ? -1 : 1;\n      if (level < 0 || (this.timelineLevels && level >= this.timelineLevels.length)) {\n        this.deselectAllEntries();\n        keyboardEvent.consume(true);\n        return true;\n      }\n      const entryTime = timelineData.entryStartTimes[this.selectedEntryIndex] +\n          timelineData.entryTotalTimes[this.selectedEntryIndex] / 2;\n      const levelIndexes = this.timelineLevels ? this.timelineLevels[level] : [];\n      let indexOnLevel = Platform.ArrayUtilities.upperBound(levelIndexes, entryTime, timeComparator) - 1;\n      if (!entriesIntersect(this.selectedEntryIndex, levelIndexes[indexOnLevel])) {\n        ++indexOnLevel;\n        if (indexOnLevel >= levelIndexes.length ||\n            !entriesIntersect(this.selectedEntryIndex, levelIndexes[indexOnLevel])) {\n          if (keyboardEvent.code === 'ArrowDown') {\n            return false;\n          }\n\n          // Stay in the current group and give focus to the parent group instead of entries\n          this.deselectAllEntries();\n          keyboardEvent.consume(true);\n          return true;\n        }\n      }\n      keyboardEvent.consume(true);\n      this.dispatchEventToListeners(Events.EntrySelected, levelIndexes[indexOnLevel]);\n      return true;\n    }\n    if (event.key === 'Enter') {\n      event.consume(true);\n      this.dispatchEventToListeners(Events.EntryInvoked, this.selectedEntryIndex);\n      return true;\n    }\n    return false;\n  }\n\n  private coordinatesToEntryIndex(x: number, y: number): number {\n    if (x < 0 || y < 0) {\n      return -1;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return -1;\n    }\n    y += this.chartViewport.scrollOffset();\n    if (!this.visibleLevelOffsets) {\n      throw new Error('No visible level offsets');\n    }\n    const cursorLevel =\n        Platform.ArrayUtilities.upperBound(this.visibleLevelOffsets, y, Platform.ArrayUtilities.DEFAULT_COMPARATOR) - 1;\n    if (cursorLevel < 0 || (this.visibleLevels && !this.visibleLevels[cursorLevel])) {\n      return -1;\n    }\n    const offsetFromLevel = y - this.visibleLevelOffsets[cursorLevel];\n    if (offsetFromLevel > this.levelHeight(cursorLevel)) {\n      return -1;\n    }\n\n    // Check markers first.\n    for (const [index, pos] of this.markerPositions) {\n      if (timelineData.entryLevels[index] !== cursorLevel) {\n        continue;\n      }\n      if (pos.x <= x && x < pos.x + pos.width) {\n        return index as number;\n      }\n    }\n\n    // Check regular entries.\n    const entryStartTimes = timelineData.entryStartTimes;\n    const entriesOnLevel: number[] = this.timelineLevels ? this.timelineLevels[cursorLevel] : [];\n    if (!entriesOnLevel || !entriesOnLevel.length) {\n      return -1;\n    }\n\n    const cursorTime = this.chartViewport.pixelToTime(x);\n    const indexOnLevel = Math.max(\n        Platform.ArrayUtilities.upperBound(\n            entriesOnLevel, cursorTime, (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n            1,\n        0);\n\n    function checkEntryHit(this: FlameChart, entryIndex: number|undefined): boolean {\n      if (entryIndex === undefined) {\n        return false;\n      }\n\n      if (!timelineData) {\n        return false;\n      }\n\n      const startTime = entryStartTimes[entryIndex];\n      const duration = timelineData.entryTotalTimes[entryIndex];\n      const startX = this.chartViewport.timeToPosition(startTime);\n      const endX = this.chartViewport.timeToPosition(startTime + duration);\n      const barThresholdPx = 3;\n      return startX - barThresholdPx < x && x < endX + barThresholdPx;\n    }\n\n    let entryIndex: number = entriesOnLevel[indexOnLevel];\n    if (checkEntryHit.call(this, entryIndex)) {\n      return entryIndex;\n    }\n    entryIndex = entriesOnLevel[indexOnLevel + 1];\n    if (checkEntryHit.call(this, entryIndex)) {\n      return entryIndex;\n    }\n    return -1;\n  }\n\n  private coordinatesToGroupIndex(x: number, y: number, headerOnly: boolean): number {\n    if (!this.rawTimelineData || !this.rawTimelineData.groups || !this.groupOffsets) {\n      return -1;\n    }\n\n    if (x < 0 || y < 0) {\n      return -1;\n    }\n    y += this.chartViewport.scrollOffset();\n    const groups = this.rawTimelineData.groups || [];\n    const group =\n        Platform.ArrayUtilities.upperBound(this.groupOffsets, y, Platform.ArrayUtilities.DEFAULT_COMPARATOR) - 1;\n    if (group < 0 || group >= groups.length) {\n      return -1;\n    }\n    const height = headerOnly ? groups[group].style.height : this.groupOffsets[group + 1] - this.groupOffsets[group];\n    if (y - this.groupOffsets[group] >= height) {\n      return -1;\n    }\n    if (!headerOnly) {\n      return group;\n    }\n\n    const context = (this.canvas.getContext('2d') as CanvasRenderingContext2D);\n    context.save();\n    context.font = groups[group].style.font;\n    const right = this.headerLeftPadding + this.labelWidthForGroup(context, groups[group]);\n    context.restore();\n    if (x > right) {\n      return -1;\n    }\n\n    return group;\n  }\n\n  private markerIndexAtPosition(x: number): number {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return -1;\n    }\n\n    const markers = timelineData.markers;\n    if (!markers) {\n      return -1;\n    }\n    const /** @const */ accurracyOffsetPx = 4;\n    const time = this.chartViewport.pixelToTime(x);\n    const leftTime = this.chartViewport.pixelToTime(x - accurracyOffsetPx);\n    const rightTime = this.chartViewport.pixelToTime(x + accurracyOffsetPx);\n    const left = this.markerIndexBeforeTime(leftTime);\n    let markerIndex = -1;\n    let distance: number = Infinity;\n    for (let i = left; i < markers.length && markers[i].startTime() < rightTime; i++) {\n      const nextDistance = Math.abs(markers[i].startTime() - time);\n      if (nextDistance < distance) {\n        markerIndex = i;\n        distance = nextDistance;\n      }\n    }\n    return markerIndex;\n  }\n\n  private markerIndexBeforeTime(time: number): number {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      throw new Error('No timeline data');\n    }\n\n    const markers = timelineData.markers;\n    if (!markers) {\n      throw new Error('No timeline markers');\n    }\n\n    return Platform.ArrayUtilities.lowerBound(\n        timelineData.markers, time, (markerTimestamp, marker) => markerTimestamp - marker.startTime());\n  }\n\n  private draw(): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n\n    const visibleLevelOffsets = this.visibleLevelOffsets ? this.visibleLevelOffsets : new Uint32Array();\n\n    const width = this.offsetWidth;\n    const height = this.offsetHeight;\n    const context = (this.canvas.getContext('2d') as CanvasRenderingContext2D);\n    context.save();\n    const ratio = window.devicePixelRatio;\n    const top = this.chartViewport.scrollOffset();\n    context.scale(ratio, ratio);\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n    context.fillRect(0, 0, width, height);\n    context.translate(0, -top);\n    const defaultFont = '11px ' + Host.Platform.fontFamily();\n    context.font = defaultFont;\n\n    const candyStripePattern = context.createPattern(this.candyStripeCanvas, 'repeat');\n\n    const entryTotalTimes = timelineData.entryTotalTimes;\n    const entryStartTimes = timelineData.entryStartTimes;\n    const entryLevels = timelineData.entryLevels;\n    const timeToPixel = this.chartViewport.timeToPixel();\n\n    const titleIndices = [];\n    const markerIndices = [];\n    const textPadding = this.textPadding;\n    const minTextWidth = 2 * textPadding + UI.UIUtils.measureTextWidth(context, '\u2026');\n    const minTextWidthDuration = this.chartViewport.pixelToTimeOffset(minTextWidth);\n    const minVisibleBarLevel = Math.max(\n        Platform.ArrayUtilities.upperBound(visibleLevelOffsets, top, Platform.ArrayUtilities.DEFAULT_COMPARATOR) - 1,\n        0);\n    this.markerPositions.clear();\n\n    let mainThreadTopLevel = -1;\n\n    // Find the main thread so that we can mark tasks longer than 50ms.\n    if ('groups' in timelineData && Array.isArray(timelineData.groups)) {\n      const mainThread = timelineData.groups.find(group => {\n        if (!group.track) {\n          return false;\n        }\n\n        return group.track.name === 'CrRendererMain';\n      });\n\n      if (mainThread) {\n        mainThreadTopLevel = mainThread.startLevel;\n      }\n    }\n\n    const colorBuckets = new Map<string, {\n      indexes: number[],\n    }>();\n    for (let level = minVisibleBarLevel; level < this.dataProvider.maxStackDepth(); ++level) {\n      if (this.levelToOffset(level) > top + height) {\n        break;\n      }\n      if (!this.visibleLevels || !this.visibleLevels[level]) {\n        continue;\n      }\n      if (!this.timelineLevels) {\n        continue;\n      }\n\n      // Entries are ordered by start time within a level, so find the last visible entry.\n      const levelIndexes = this.timelineLevels[level];\n      const rightIndexOnLevel = Platform.ArrayUtilities.lowerBound(\n                                    levelIndexes, this.chartViewport.windowRightTime(),\n                                    (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n          1;\n      let lastDrawOffset = Infinity;\n      for (let entryIndexOnLevel = rightIndexOnLevel; entryIndexOnLevel >= 0; --entryIndexOnLevel) {\n        const entryIndex = levelIndexes[entryIndexOnLevel];\n        const duration = entryTotalTimes[entryIndex];\n        if (isNaN(duration)) {\n          markerIndices.push(entryIndex);\n          continue;\n        }\n        if (duration >= minTextWidthDuration || (this.forceDecorationCache && this.forceDecorationCache[entryIndex])) {\n          titleIndices.push(entryIndex);\n        }\n\n        const entryStartTime = entryStartTimes[entryIndex];\n        const entryOffsetRight = entryStartTime + duration;\n        if (entryOffsetRight <= this.chartViewport.windowLeftTime()) {\n          break;\n        }\n        if (this.useWebGL) {\n          continue;\n        }\n\n        const barX = this.timeToPositionClipped(entryStartTime);\n        // Check if the entry entirely fits into an already drawn pixel, we can just skip drawing it.\n        if (barX >= lastDrawOffset) {\n          continue;\n        }\n        lastDrawOffset = barX;\n\n        if (this.entryColorsCache) {\n          const color = this.entryColorsCache[entryIndex];\n          let bucket = colorBuckets.get(color);\n          if (!bucket) {\n            bucket = {indexes: []};\n            colorBuckets.set(color, bucket);\n          }\n          bucket.indexes.push(entryIndex);\n        }\n      }\n    }\n\n    if (this.useWebGL) {\n      this.drawGL();\n    } else {\n      context.save();\n      this.forEachGroupInViewport((offset, index, group, isFirst, groupHeight) => {\n        if (this.isGroupFocused(index)) {\n          context.fillStyle =\n              ThemeSupport.ThemeSupport.instance().getComputedValue('--selected-group-background', this.contentElement);\n          context.fillRect(0, offset, width, groupHeight - group.style.padding);\n        }\n      });\n      context.restore();\n\n      for (const [color, {indexes}] of colorBuckets) {\n        context.beginPath();\n        for (let i = 0; i < indexes.length; ++i) {\n          const entryIndex = indexes[i];\n          const duration = entryTotalTimes[entryIndex];\n          if (isNaN(duration)) {\n            continue;\n          }\n          const entryStartTime = entryStartTimes[entryIndex];\n          const barX = this.timeToPositionClipped(entryStartTime);\n          const barLevel = entryLevels[entryIndex];\n          const barHeight = this.levelHeight(barLevel);\n          const barY = this.levelToOffset(barLevel);\n          const barRight = this.timeToPositionClipped(entryStartTime + duration);\n          const barWidth = Math.max(barRight - barX, 1);\n          context.rect(barX, barY, barWidth - 0.4, barHeight - 1);\n        }\n        context.fillStyle = color;\n        context.fill();\n\n        // Draw long task regions.\n        context.beginPath();\n        for (let i = 0; i < indexes.length; ++i) {\n          const entryIndex = indexes[i];\n          const duration = entryTotalTimes[entryIndex];\n          const showLongDurations = entryLevels[entryIndex] === mainThreadTopLevel;\n\n          if (!showLongDurations) {\n            continue;\n          }\n\n          if (isNaN(duration) || duration < 50) {\n            continue;\n          }\n\n          const entryStartTime = entryStartTimes[entryIndex];\n          const barX = this.timeToPositionClipped(entryStartTime + 50);\n          const barLevel = entryLevels[entryIndex];\n          const barHeight = this.levelHeight(barLevel);\n          const barY = this.levelToOffset(barLevel);\n          const barRight = this.timeToPositionClipped(entryStartTime + duration);\n          const barWidth = Math.max(barRight - barX, 1);\n          context.rect(barX, barY, barWidth - 0.4, barHeight - 1);\n        }\n\n        if (candyStripePattern) {\n          context.fillStyle = candyStripePattern;\n          context.fill();\n        }\n      }\n    }\n\n    context.textBaseline = 'alphabetic';\n    context.beginPath();\n    let lastMarkerLevel = -1;\n    let lastMarkerX: number = -Infinity;\n    // Markers are sorted top to bottom, right to left.\n    for (let m = markerIndices.length - 1; m >= 0; --m) {\n      const entryIndex = markerIndices[m];\n      const title = this.dataProvider.entryTitle(entryIndex);\n      if (!title) {\n        continue;\n      }\n      const entryStartTime = entryStartTimes[entryIndex];\n      const level = entryLevels[entryIndex];\n      if (lastMarkerLevel !== level) {\n        lastMarkerX = -Infinity;\n      }\n      const x = Math.max(this.chartViewport.timeToPosition(entryStartTime), lastMarkerX);\n      const y = this.levelToOffset(level);\n      const h = this.levelHeight(level);\n      const padding = 4;\n      const width = Math.ceil(UI.UIUtils.measureTextWidth(context, title)) + 2 * padding;\n      lastMarkerX = x + width + 1;\n      lastMarkerLevel = level;\n      this.markerPositions.set(entryIndex, {x, width});\n      context.fillStyle = this.dataProvider.entryColor(entryIndex);\n      context.fillRect(x, y, width, h - 1);\n      context.fillStyle = 'white';\n      context.fillText(title, x + padding, y + h - this.textBaseline);\n    }\n    context.strokeStyle = 'rgba(0, 0, 0, 0.2)';\n    context.stroke();\n\n    for (let i = 0; i < titleIndices.length; ++i) {\n      const entryIndex = titleIndices[i];\n      const entryStartTime = entryStartTimes[entryIndex];\n      const barX = this.timeToPositionClipped(entryStartTime);\n      const barRight = Math.min(this.timeToPositionClipped(entryStartTime + entryTotalTimes[entryIndex]), width) + 1;\n      const barWidth = barRight - barX;\n      const barLevel = entryLevels[entryIndex];\n      const barY = this.levelToOffset(barLevel);\n      let text = this.dataProvider.entryTitle(entryIndex);\n      if (text && text.length) {\n        context.font = this.dataProvider.entryFont(entryIndex) || defaultFont;\n        text = UI.UIUtils.trimTextMiddle(context, text, barWidth - 2 * textPadding);\n      }\n      const unclippedBarX = this.chartViewport.timeToPosition(entryStartTime);\n      const barHeight = this.levelHeight(barLevel);\n      if (this.dataProvider.decorateEntry(\n              entryIndex, context, text, barX, barY, barWidth, barHeight, unclippedBarX, timeToPixel)) {\n        continue;\n      }\n      if (!text || !text.length) {\n        continue;\n      }\n      context.fillStyle = this.dataProvider.textColor(entryIndex);\n      context.fillText(text, barX + textPadding, barY + barHeight - this.textBaseline);\n    }\n\n    context.restore();\n\n    this.drawGroupHeaders(width, height);\n    this.drawFlowEvents(context, width, height);\n    this.drawMarkers();\n    const dividersData = TimelineGrid.calculateGridOffsets(this);\n    const navStartTimes = Array.from(this.dataProvider.navStartTimes().values());\n\n    let navStartTimeIndex = 0;\n    const drawAdjustedTime = (time: number): string => {\n      if (navStartTimes.length === 0) {\n        return this.formatValue(time, dividersData.precision);\n      }\n\n      // Track when the time crosses the boundary to the next nav start record,\n      // and when it does, move the nav start array index accordingly.\n      const hasNextNavStartTime = navStartTimes.length > navStartTimeIndex + 1;\n      if (hasNextNavStartTime && time > navStartTimes[navStartTimeIndex + 1].startTime) {\n        navStartTimeIndex++;\n      }\n\n      // Adjust the time by the nearest nav start marker's value.\n      const nearestMarker = navStartTimes[navStartTimeIndex];\n      if (nearestMarker) {\n        time -= nearestMarker.startTime - this.zeroTime();\n      }\n\n      return this.formatValue(time, dividersData.precision);\n    };\n\n    TimelineGrid.drawCanvasGrid(context, dividersData);\n    if (this.rulerEnabled) {\n      TimelineGrid.drawCanvasHeaders(context, dividersData, drawAdjustedTime, 3, HeaderHeight);\n    }\n\n    this.updateElementPosition(this.highlightElement, this.highlightedEntryIndex);\n    this.updateElementPosition(this.selectedElement, this.selectedEntryIndex);\n    this.updateMarkerHighlight();\n  }\n\n  private initWebGL(): void {\n    const gl = (this.canvasGL.getContext('webgl') as WebGLRenderingContext | null);\n    if (!gl) {\n      console.error('Failed to obtain WebGL context.');\n      this.useWebGL = false;  // Fallback to use canvas.\n      return;\n    }\n\n    const vertexShaderSource = `\n  attribute vec2 aVertexPosition;\n  attribute float aVertexColor;\n\n  uniform vec2 uScalingFactor;\n  uniform vec2 uShiftVector;\n\n  varying mediump vec2 vPalettePosition;\n\n  void main() {\n  vec2 shiftedPosition = aVertexPosition - uShiftVector;\n  gl_Position = vec4(shiftedPosition * uScalingFactor + vec2(-1.0, 1.0), 0.0, 1.0);\n  vPalettePosition = vec2(aVertexColor, 0.5);\n  }`;\n\n    const fragmentShaderSource = `\n  varying mediump vec2 vPalettePosition;\n  uniform sampler2D uSampler;\n\n  void main() {\n  gl_FragColor = texture2D(uSampler, vPalettePosition);\n  }`;\n\n    function loadShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader|null {\n      const shader = gl.createShader(type);\n      if (!shader) {\n        return null;\n      }\n\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        return shader;\n      }\n      console.error('Shader compile error: ' + gl.getShaderInfoLog(shader));\n      gl.deleteShader(shader);\n      return null;\n    }\n\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    const shaderProgram = gl.createProgram();\n    if (!shaderProgram || !vertexShader || !fragmentShader) {\n      return;\n    }\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n      this.shaderProgram = shaderProgram;\n      gl.useProgram(shaderProgram);\n    } else {\n      this.shaderProgram = null;\n      throw new Error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\n    }\n\n    this.vertexBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n\n    this.uScalingFactor = gl.getUniformLocation(shaderProgram, 'uScalingFactor');\n    this.uShiftVector = gl.getUniformLocation(shaderProgram, 'uShiftVector');\n    const uSampler = gl.getUniformLocation(shaderProgram, 'uSampler');\n    gl.uniform1i(uSampler, 0);\n    this.aVertexPosition = gl.getAttribLocation(this.shaderProgram, 'aVertexPosition');\n    this.aVertexColor = gl.getAttribLocation(this.shaderProgram, 'aVertexColor');\n    gl.enableVertexAttribArray(this.aVertexPosition);\n    gl.enableVertexAttribArray(this.aVertexColor);\n  }\n\n  private setupGLGeometry(): void {\n    const gl = (this.canvasGL.getContext('webgl') as WebGLRenderingContext | null);\n    if (!gl) {\n      return;\n    }\n\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n\n    const entryTotalTimes = timelineData.entryTotalTimes;\n    const entryStartTimes = timelineData.entryStartTimes;\n    const entryLevels = timelineData.entryLevels;\n\n    const verticesPerBar = 6;\n    const vertexArray = new Float32Array(entryTotalTimes.length * verticesPerBar * 2);\n    let colorArray = new Uint8Array(entryTotalTimes.length * verticesPerBar);\n    let vertex = 0;\n    const parsedColorCache = new Map<string, number>();\n    const colors: number[] = [];\n\n    const visibleLevels = this.visibleLevels || [];\n    const rawTimelineData = this.rawTimelineData || {groups: []};\n\n    const collapsedOverviewLevels = new Array(visibleLevels.length);\n    const groups = rawTimelineData.groups || [];\n    this.forEachGroup((offset, index, group) => {\n      if (group.style.useFirstLineForOverview || !this.isGroupCollapsible(index) || group.expanded) {\n        return;\n      }\n      let nextGroup = index + 1;\n      while (nextGroup < groups.length && groups[nextGroup].style.nestingLevel > group.style.nestingLevel) {\n        ++nextGroup;\n      }\n      const endLevel = nextGroup < groups.length ? groups[nextGroup].startLevel : this.dataProvider.maxStackDepth();\n      for (let i = group.startLevel; i < endLevel; ++i) {\n        collapsedOverviewLevels[i] = offset;\n      }\n    });\n\n    for (let i = 0; i < entryTotalTimes.length; ++i) {\n      const level = entryLevels[i];\n      const collapsedGroupOffset = collapsedOverviewLevels[level];\n      if (!visibleLevels[level] && !collapsedGroupOffset) {\n        continue;\n      }\n      if (!this.entryColorsCache) {\n        continue;\n      }\n\n      const color = this.entryColorsCache[i];\n      if (!color) {\n        continue;\n      }\n      let colorIndex = parsedColorCache.get(color);\n      if (colorIndex === undefined) {\n        const parsedColor = Common.Color.Color.parse(color);\n        if (parsedColor) {\n          const rgba = parsedColor.canonicalRGBA();\n          rgba[3] = Math.round(rgba[3] * 255);\n          colorIndex = colors.length / 4;\n          colors.push(...rgba);\n          if (colorIndex === 256) {\n            colorArray = new Uint8Array(colorArray);\n          }\n        }\n\n        if (colorIndex) {\n          parsedColorCache.set(color, colorIndex);\n        }\n      }\n      for (let j = 0; j < verticesPerBar; ++j) {\n        if (colorIndex) {\n          colorArray[vertex + j] = colorIndex;\n        }\n      }\n\n      const vpos = vertex * 2;\n      const x0 = entryStartTimes[i] - this.minimumBoundaryInternal;\n      const x1 = x0 + entryTotalTimes[i];\n      const y0 = collapsedGroupOffset || this.levelToOffset(level);\n      const y1 = y0 + this.levelHeight(level) - 1;\n      vertexArray[vpos + 0] = x0;\n      vertexArray[vpos + 1] = y0;\n      vertexArray[vpos + 2] = x1;\n      vertexArray[vpos + 3] = y0;\n      vertexArray[vpos + 4] = x0;\n      vertexArray[vpos + 5] = y1;\n      vertexArray[vpos + 6] = x0;\n      vertexArray[vpos + 7] = y1;\n      vertexArray[vpos + 8] = x1;\n      vertexArray[vpos + 9] = y0;\n      vertexArray[vpos + 10] = x1;\n      vertexArray[vpos + 11] = y1;\n\n      vertex += verticesPerBar;\n    }\n    this.vertexCount = vertex;\n\n    const paletteTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, paletteTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.activeTexture(gl.TEXTURE0);\n\n    const numColors = colors.length / 4;\n    const useShortForColors = numColors >= 256;\n    const width = !useShortForColors ? 256 : Math.min(1 << 16, gl.getParameter(gl.MAX_TEXTURE_SIZE));\n    console.assert(numColors <= width, 'Too many colors');\n    const height = 1;\n    const colorIndexType = useShortForColors ? gl.UNSIGNED_SHORT : gl.UNSIGNED_BYTE;\n    if (useShortForColors) {\n      const factor = (1 << 16) / width;\n      for (let i = 0; i < vertex; ++i) {\n        colorArray[i] *= factor;\n      }\n    }\n\n    const pixels = new Uint8Array(width * 4);\n    pixels.set(colors);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n    if (this.vertexBuffer && this.aVertexPosition) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);\n      gl.vertexAttribPointer(this.aVertexPosition, /* vertexComponents */ 2, gl.FLOAT, false, 0, 0);\n    }\n\n    if (this.colorBuffer && this.aVertexColor) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n      gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.STATIC_DRAW);\n      gl.vertexAttribPointer(this.aVertexColor, /* colorComponents */ 1, colorIndexType, true, 0, 0);\n    }\n  }\n\n  private drawGL(): void {\n    const gl = (this.canvasGL.getContext('webgl') as WebGLRenderingContext | null);\n    if (!gl) {\n      return;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n\n    if (!this.prevTimelineData || timelineData.entryTotalTimes !== this.prevTimelineData.entryTotalTimes) {\n      this.prevTimelineData = timelineData;\n      this.setupGLGeometry();\n    }\n\n    gl.viewport(0, 0, this.canvasGL.width, this.canvasGL.height);\n\n    if (!this.vertexCount) {\n      return;\n    }\n\n    const viewportScale = [2.0 / this.boundarySpan(), -2.0 * window.devicePixelRatio / this.canvasGL.height];\n    const viewportShift = [this.minimumBoundary() - this.zeroTime(), this.chartViewport.scrollOffset()];\n    if (this.uScalingFactor) {\n      gl.uniform2fv(this.uScalingFactor, viewportScale);\n    }\n\n    if (this.uShiftVector) {\n      gl.uniform2fv(this.uShiftVector, viewportShift);\n    }\n\n    gl.drawArrays(gl.TRIANGLES, 0, this.vertexCount);\n  }\n\n  private drawGroupHeaders(width: number, height: number): void {\n    const context = (this.canvas.getContext('2d') as CanvasRenderingContext2D);\n    const top = this.chartViewport.scrollOffset();\n    const ratio = window.devicePixelRatio;\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups || [];\n    if (!groups.length) {\n      return;\n    }\n\n    const groupOffsets = this.groupOffsets;\n    if (groupOffsets === null || groupOffsets === undefined) {\n      return;\n    }\n    const lastGroupOffset = groupOffsets[groupOffsets.length - 1];\n\n    context.save();\n    context.scale(ratio, ratio);\n    context.translate(0, -top);\n    const defaultFont = '11px ' + Host.Platform.fontFamily();\n    context.font = defaultFont;\n\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background');\n    this.forEachGroupInViewport((offset, index, group) => {\n      const paddingHeight = group.style.padding;\n      if (paddingHeight < 5) {\n        return;\n      }\n      context.fillRect(0, offset - paddingHeight + 2, width, paddingHeight - 4);\n    });\n    if (groups.length && lastGroupOffset < top + height) {\n      context.fillRect(0, lastGroupOffset + 2, width, top + height - lastGroupOffset);\n    }\n\n    context.strokeStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background-elevation-1');\n    context.beginPath();\n    this.forEachGroupInViewport((offset, index, group, isFirst) => {\n      if (isFirst || group.style.padding < 4) {\n        return;\n      }\n      hLine(offset - 2.5);\n    });\n    hLine(lastGroupOffset + 1.5);\n    context.stroke();\n\n    this.forEachGroupInViewport((offset, index, group) => {\n      if (group.style.useFirstLineForOverview) {\n        return;\n      }\n      if (!this.isGroupCollapsible(index) || group.expanded) {\n        if (!group.style.shareHeaderLine && this.isGroupFocused(index)) {\n          context.fillStyle = group.style.backgroundColor;\n          context.fillRect(0, offset, width, group.style.height);\n        }\n        return;\n      }\n      if (this.useWebGL) {\n        return;\n      }\n      let nextGroup = index + 1;\n      while (nextGroup < groups.length && groups[nextGroup].style.nestingLevel > group.style.nestingLevel) {\n        nextGroup++;\n      }\n      const endLevel = nextGroup < groups.length ? groups[nextGroup].startLevel : this.dataProvider.maxStackDepth();\n      this.drawCollapsedOverviewForGroup(group, offset, endLevel);\n    });\n\n    context.save();\n    this.forEachGroupInViewport((offset, index, group) => {\n      context.font = group.style.font;\n      if (this.isGroupCollapsible(index) && !group.expanded || group.style.shareHeaderLine) {\n        const width = this.labelWidthForGroup(context, group) + 2;\n        if (this.isGroupFocused(index)) {\n          context.fillStyle =\n              ThemeSupport.ThemeSupport.instance().getComputedValue('--selected-group-background', this.contentElement);\n        } else {\n          const parsedColor = Common.Color.Color.parse(group.style.backgroundColor);\n          if (parsedColor) {\n            context.fillStyle = (parsedColor.setAlpha(0.8).asString(null) as string);\n          }\n        }\n\n        context.fillRect(\n            this.headerLeftPadding - this.headerLabelXPadding, offset + this.headerLabelYPadding, width,\n            group.style.height - 2 * this.headerLabelYPadding);\n      }\n      context.fillStyle = group.style.color;\n      context.fillText(\n          group.name, Math.floor(this.expansionArrowIndent * (group.style.nestingLevel + 1) + this.arrowSide),\n          offset + group.style.height - this.textBaseline);\n    });\n    context.restore();\n\n    context.fillStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-secondary');\n    context.beginPath();\n    this.forEachGroupInViewport((offset, index, group) => {\n      if (this.isGroupCollapsible(index)) {\n        drawExpansionArrow.call(\n            this, this.expansionArrowIndent * (group.style.nestingLevel + 1),\n            offset + group.style.height - this.textBaseline - this.arrowSide / 2, Boolean(group.expanded));\n      }\n    });\n    context.fill();\n\n    context.strokeStyle = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-details-hairline-light');\n    context.beginPath();\n    context.stroke();\n\n    this.forEachGroupInViewport((offset, index, group, isFirst, groupHeight) => {\n      if (this.isGroupFocused(index)) {\n        const lineWidth = 2;\n        const bracketLength = 10;\n        context.fillStyle =\n            ThemeSupport.ThemeSupport.instance().getComputedValue('--selected-group-border', this.contentElement);\n        context.fillRect(0, offset - lineWidth, lineWidth, groupHeight - group.style.padding + 2 * lineWidth);\n        context.fillRect(0, offset - lineWidth, bracketLength, lineWidth);\n        context.fillRect(0, offset + groupHeight - group.style.padding, bracketLength, lineWidth);\n      }\n    });\n\n    context.restore();\n\n    function hLine(y: number): void {\n      context.moveTo(0, y);\n      context.lineTo(width, y);\n    }\n\n    function drawExpansionArrow(this: FlameChart, x: number, y: number, expanded: boolean): void {\n      const arrowHeight = this.arrowSide * Math.sqrt(3) / 2;\n      const arrowCenterOffset = Math.round(arrowHeight / 2);\n      context.save();\n      context.translate(x, y);\n      context.rotate(expanded ? Math.PI / 2 : 0);\n      context.moveTo(-arrowCenterOffset, -this.arrowSide / 2);\n      context.lineTo(-arrowCenterOffset, this.arrowSide / 2);\n      context.lineTo(arrowHeight - arrowCenterOffset, 0);\n      context.restore();\n    }\n  }\n\n  private forEachGroup(callback: (arg0: number, arg1: number, arg2: Group, arg3: boolean, arg4: number) => void): void {\n    if (!this.rawTimelineData) {\n      return;\n    }\n    const groups = this.rawTimelineData.groups || [];\n    if (!groups.length) {\n      return;\n    }\n    const groupOffsets = this.groupOffsets;\n    if (!groupOffsets) {\n      return;\n    }\n\n    const groupStack: {\n      nestingLevel: number,\n      visible: boolean,\n    }[] = [{nestingLevel: -1, visible: true}];\n    for (let i = 0; i < groups.length; ++i) {\n      const groupTop = groupOffsets[i];\n      const group = groups[i];\n      let firstGroup = true;\n      let last: {\n        nestingLevel: number,\n        visible: boolean,\n      } = groupStack[groupStack.length - 1];\n      while (last && last.nestingLevel >= group.style.nestingLevel) {\n        groupStack.pop();\n        firstGroup = false;\n        last = groupStack[groupStack.length - 1];\n      }\n      last = groupStack[groupStack.length - 1];\n      const parentGroupVisible = last ? last.visible : false;\n      const thisGroupVisible = parentGroupVisible && (!this.isGroupCollapsible(i) || group.expanded);\n      groupStack.push({nestingLevel: group.style.nestingLevel, visible: Boolean(thisGroupVisible)});\n      const nextOffset = i === groups.length - 1 ? groupOffsets[i + 1] + group.style.padding : groupOffsets[i + 1];\n      if (!parentGroupVisible) {\n        continue;\n      }\n      callback(groupTop, i, group, firstGroup, nextOffset - groupTop);\n    }\n  }\n\n  private forEachGroupInViewport(\n      callback: (arg0: number, arg1: number, arg2: Group, arg3: boolean, arg4: number) => void): void {\n    const top = this.chartViewport.scrollOffset();\n    this.forEachGroup((groupTop, index, group, firstGroup, height) => {\n      if (groupTop - group.style.padding > top + this.offsetHeight) {\n        return;\n      }\n      if (groupTop + height < top) {\n        return;\n      }\n      callback(groupTop, index, group, firstGroup, height);\n    });\n  }\n\n  private labelWidthForGroup(context: CanvasRenderingContext2D, group: Group): number {\n    return UI.UIUtils.measureTextWidth(context, group.name) +\n        this.expansionArrowIndent * (group.style.nestingLevel + 1) + 2 * this.headerLabelXPadding;\n  }\n\n  private drawCollapsedOverviewForGroup(group: Group, y: number, endLevel: number): void {\n    const range = new Common.SegmentedRange.SegmentedRange<string>(mergeCallback);\n    const timeWindowLeft = this.chartViewport.windowLeftTime();\n    const timeWindowRight = this.chartViewport.windowRightTime();\n    const context = (this.canvas.getContext('2d') as CanvasRenderingContext2D);\n    const barHeight = group.style.height;\n    if (!this.rawTimelineData) {\n      return;\n    }\n    const entryStartTimes = this.rawTimelineData.entryStartTimes;\n    const entryTotalTimes = this.rawTimelineData.entryTotalTimes;\n    const timeToPixel = this.chartViewport.timeToPixel();\n\n    for (let level = group.startLevel; level < endLevel; ++level) {\n      const levelIndexes: number[] = this.timelineLevels ? this.timelineLevels[level] : [];\n      const rightIndexOnLevel =\n          Platform.ArrayUtilities.lowerBound(\n              levelIndexes, timeWindowRight, (time, entryIndex) => time - entryStartTimes[entryIndex]) -\n          1;\n      let lastDrawOffset: number = Infinity;\n\n      for (let entryIndexOnLevel = rightIndexOnLevel; entryIndexOnLevel >= 0; --entryIndexOnLevel) {\n        const entryIndex = levelIndexes[entryIndexOnLevel];\n        const entryStartTime = entryStartTimes[entryIndex];\n        const barX = this.timeToPositionClipped(entryStartTime);\n        const entryEndTime = entryStartTime + entryTotalTimes[entryIndex];\n        if (isNaN(entryEndTime) || barX >= lastDrawOffset) {\n          continue;\n        }\n        if (entryEndTime <= timeWindowLeft) {\n          break;\n        }\n        lastDrawOffset = barX;\n        const color = this.entryColorsCache ? this.entryColorsCache[entryIndex] : '';\n        const endBarX = this.timeToPositionClipped(entryEndTime);\n        if (group.style.useDecoratorsForOverview && this.dataProvider.forceDecoration(entryIndex)) {\n          const unclippedBarX = this.chartViewport.timeToPosition(entryStartTime);\n          const barWidth = endBarX - barX;\n          context.beginPath();\n          context.fillStyle = color;\n          context.fillRect(barX, y, barWidth, barHeight - 1);\n          this.dataProvider.decorateEntry(\n              entryIndex, context, '', barX, y, barWidth, barHeight, unclippedBarX, timeToPixel);\n          continue;\n        }\n        range.append(new Common.SegmentedRange.Segment(barX, endBarX, color));\n      }\n    }\n\n    const segments = range.segments().slice().sort((a, b) => a.data.localeCompare(b.data));\n    let lastColor;\n    context.beginPath();\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i];\n      if (lastColor !== segments[i].data) {\n        context.fill();\n        context.beginPath();\n        lastColor = segments[i].data;\n        context.fillStyle = lastColor;\n      }\n      context.rect(segment.begin, y, segment.end - segment.begin, barHeight);\n    }\n    context.fill();\n\n    function mergeCallback<T>(a: Common.SegmentedRange.Segment<T>, b: Common.SegmentedRange.Segment<T>):\n        Common.SegmentedRange.Segment<T>|null {\n      return a.data === b.data && a.end + 0.4 > b.end ? a : null;\n    }\n  }\n\n  private drawFlowEvents(context: CanvasRenderingContext2D, _width: number, _height: number): void {\n    context.save();\n    const ratio = window.devicePixelRatio;\n    const top = this.chartViewport.scrollOffset();\n    const arrowWidth = 6;\n    context.scale(ratio, ratio);\n    context.translate(0, -top);\n\n    context.fillStyle = '#7f5050';\n    context.strokeStyle = '#7f5050';\n    const td = this.timelineData();\n    if (!td) {\n      return;\n    }\n\n    const endIndex = Platform.ArrayUtilities.lowerBound(\n        td.flowStartTimes, this.chartViewport.windowRightTime(), Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n\n    context.lineWidth = 0.5;\n    for (let i = 0; i < endIndex; ++i) {\n      if (!td.flowEndTimes[i] || td.flowEndTimes[i] < this.chartViewport.windowLeftTime()) {\n        continue;\n      }\n      const startX = this.chartViewport.timeToPosition(td.flowStartTimes[i]);\n      const endX = this.chartViewport.timeToPosition(td.flowEndTimes[i]);\n      const startLevel = td.flowStartLevels[i];\n      const endLevel = td.flowEndLevels[i];\n      const startY = this.levelToOffset(startLevel) + this.levelHeight(startLevel) / 2;\n      const endY = this.levelToOffset(endLevel) + this.levelHeight(endLevel) / 2;\n\n      const segment = Math.min((endX - startX) / 4, 40);\n      const distanceTime = td.flowEndTimes[i] - td.flowStartTimes[i];\n      const distanceY = (endY - startY) / 10;\n      const spread = 30;\n      const lineY = distanceTime < 1 ? startY : spread + Math.max(0, startY + distanceY * (i % spread));\n\n      const p = [];\n      p.push({x: startX, y: startY});\n      p.push({x: startX + arrowWidth, y: startY});\n      p.push({x: startX + segment + 2 * arrowWidth, y: startY});\n      p.push({x: startX + segment, y: lineY});\n      p.push({x: startX + segment * 2, y: lineY});\n      p.push({x: endX - segment * 2, y: lineY});\n      p.push({x: endX - segment, y: lineY});\n      p.push({x: endX - segment - 2 * arrowWidth, y: endY});\n      p.push({x: endX - arrowWidth, y: endY});\n\n      context.beginPath();\n      context.moveTo(p[0].x, p[0].y);\n      context.lineTo(p[1].x, p[1].y);\n      context.bezierCurveTo(p[2].x, p[2].y, p[3].x, p[3].y, p[4].x, p[4].y);\n      context.lineTo(p[5].x, p[5].y);\n      context.bezierCurveTo(p[6].x, p[6].y, p[7].x, p[7].y, p[8].x, p[8].y);\n      context.stroke();\n\n      context.beginPath();\n      context.arc(startX, startY, 2, -Math.PI / 2, Math.PI / 2, false);\n      context.fill();\n\n      context.beginPath();\n      context.moveTo(endX, endY);\n      context.lineTo(endX - arrowWidth, endY - 3);\n      context.lineTo(endX - arrowWidth, endY + 3);\n      context.fill();\n    }\n    context.restore();\n  }\n\n  private drawMarkers(): void {\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const markers = timelineData.markers;\n    const left = this.markerIndexBeforeTime(this.minimumBoundary());\n    const rightBoundary = this.maximumBoundary();\n    const timeToPixel = this.chartViewport.timeToPixel();\n\n    const context = (this.canvas.getContext('2d') as CanvasRenderingContext2D);\n    context.save();\n    const ratio = window.devicePixelRatio;\n    context.scale(ratio, ratio);\n    context.translate(0, 3);\n    const height = HeaderHeight - 1;\n    for (let i = left; i < markers.length; i++) {\n      const timestamp = markers[i].startTime();\n      if (timestamp > rightBoundary) {\n        break;\n      }\n      markers[i].draw(context, this.chartViewport.timeToPosition(timestamp), height, timeToPixel);\n    }\n    context.restore();\n  }\n\n  private updateMarkerHighlight(): void {\n    const element = this.markerHighlighElement;\n    if (element.parentElement) {\n      element.remove();\n    }\n    const markerIndex = this.highlightedMarkerIndex;\n    if (markerIndex === -1) {\n      return;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n    const marker = timelineData.markers[markerIndex];\n    const barX = this.timeToPositionClipped(marker.startTime());\n    UI.Tooltip.Tooltip.install(element, marker.title() || '');\n    const style = element.style;\n    style.left = barX + 'px';\n    style.backgroundColor = marker.color();\n    this.viewportElement.appendChild(element);\n  }\n\n  private processTimelineData(timelineData: TimelineData|null): void {\n    if (!timelineData) {\n      this.timelineLevels = null;\n      this.visibleLevelOffsets = null;\n      this.visibleLevels = null;\n      this.groupOffsets = null;\n      this.rawTimelineData = null;\n      this.forceDecorationCache = null;\n      this.entryColorsCache = null;\n      this.rawTimelineDataLength = 0;\n      this.selectedGroup = -1;\n      this.keyboardFocusedGroup = -1;\n      this.flameChartDelegate.updateSelectedGroup(this, null);\n      return;\n    }\n\n    this.rawTimelineData = timelineData;\n    this.rawTimelineDataLength = timelineData.entryStartTimes.length;\n    this.forceDecorationCache = new Int8Array(this.rawTimelineDataLength);\n    this.entryColorsCache = new Array(this.rawTimelineDataLength);\n    for (let i = 0; i < this.rawTimelineDataLength; ++i) {\n      this.forceDecorationCache[i] = this.dataProvider.forceDecoration(i) ? 1 : 0;\n      this.entryColorsCache[i] = this.dataProvider.entryColor(i);\n    }\n\n    const entryCounters = new Uint32Array(this.dataProvider.maxStackDepth() + 1);\n    for (let i = 0; i < timelineData.entryLevels.length; ++i) {\n      ++entryCounters[timelineData.entryLevels[i]];\n    }\n    const levelIndexes = new Array(entryCounters.length);\n    for (let i = 0; i < levelIndexes.length; ++i) {\n      levelIndexes[i] = new Uint32Array(entryCounters[i]);\n      entryCounters[i] = 0;\n    }\n\n    for (let i = 0; i < timelineData.entryLevels.length; ++i) {\n      const level = timelineData.entryLevels[i];\n      levelIndexes[level][entryCounters[level]++] = i;\n    }\n    this.timelineLevels = levelIndexes;\n    const groups = this.rawTimelineData.groups || [];\n    for (let i = 0; i < groups.length; ++i) {\n      const expanded = this.groupExpansionState[groups[i].name];\n      if (expanded !== undefined) {\n        groups[i].expanded = expanded;\n      }\n    }\n    this.updateLevelPositions();\n    this.updateHeight();\n\n    this.selectedGroup = timelineData.selectedGroup ? groups.indexOf(timelineData.selectedGroup) : -1;\n    this.keyboardFocusedGroup = this.selectedGroup;\n    this.flameChartDelegate.updateSelectedGroup(this, timelineData.selectedGroup);\n  }\n\n  private updateLevelPositions(): void {\n    const levelCount = this.dataProvider.maxStackDepth();\n    const groups = this.rawTimelineData ? (this.rawTimelineData.groups || []) : [];\n    this.visibleLevelOffsets = new Uint32Array(levelCount + 1);\n    this.visibleLevelHeights = new Uint32Array(levelCount);\n    this.visibleLevels = new Uint16Array(levelCount);\n    this.groupOffsets = new Uint32Array(groups.length + 1);\n\n    let groupIndex = -1;\n    let currentOffset = this.rulerEnabled ? HeaderHeight + 2 : 2;\n    let visible = true;\n    const groupStack: {\n      nestingLevel: number,\n      visible: boolean,\n    }[] = [{nestingLevel: -1, visible: true}];\n    const lastGroupLevel =\n        Math.max(levelCount, groups.length ? (groups[groups.length - 1] as Group).startLevel + 1 : 0);\n    let level;\n    for (level = 0; level < lastGroupLevel; ++level) {\n      let parentGroupIsVisible = true;\n      let style;\n      while (groupIndex < groups.length - 1 && level === groups[groupIndex + 1].startLevel) {\n        ++groupIndex;\n        style = groups[groupIndex].style;\n        let nextLevel = true;\n        let last: {\n          nestingLevel: number,\n          visible: boolean,\n        } = groupStack[groupStack.length - 1];\n        while (last && last.nestingLevel >= style.nestingLevel) {\n          groupStack.pop();\n          nextLevel = false;\n          last = groupStack[groupStack.length - 1];\n        }\n        const thisGroupIsVisible =\n            groupIndex >= 0 && this.isGroupCollapsible(groupIndex) ? groups[groupIndex].expanded : true;\n\n        last = groupStack[groupStack.length - 1];\n        parentGroupIsVisible = last ? last.visible : false;\n        visible = Boolean(thisGroupIsVisible) && parentGroupIsVisible;\n        groupStack.push({nestingLevel: style.nestingLevel, visible: visible});\n        if (parentGroupIsVisible) {\n          currentOffset += nextLevel ? 0 : style.padding;\n        }\n        this.groupOffsets[groupIndex] = currentOffset;\n        if (parentGroupIsVisible && !style.shareHeaderLine) {\n          currentOffset += style.height;\n        }\n      }\n      if (level >= levelCount) {\n        continue;\n      }\n      const isFirstOnLevel = groupIndex >= 0 && level === groups[groupIndex].startLevel;\n      const thisLevelIsVisible =\n          parentGroupIsVisible && (visible || isFirstOnLevel && groups[groupIndex].style.useFirstLineForOverview);\n      let height;\n      if (groupIndex >= 0) {\n        const group = groups[groupIndex];\n        const styleB = group.style;\n        height = isFirstOnLevel && !styleB.shareHeaderLine || (styleB.collapsible && !group.expanded) ?\n            styleB.height :\n            (styleB.itemsHeight || this.barHeight);\n      } else {\n        height = this.barHeight;\n      }\n      this.visibleLevels[level] = thisLevelIsVisible ? 1 : 0;\n      this.visibleLevelOffsets[level] = currentOffset;\n      this.visibleLevelHeights[level] = height;\n      if (thisLevelIsVisible || (parentGroupIsVisible && style && style.shareHeaderLine && isFirstOnLevel)) {\n        currentOffset += this.visibleLevelHeights[level];\n      }\n    }\n    if (groupIndex >= 0) {\n      this.groupOffsets[groupIndex + 1] = currentOffset;\n    }\n    this.visibleLevelOffsets[level] = currentOffset;\n    if (this.useWebGL) {\n      this.setupGLGeometry();\n    }\n  }\n\n  private isGroupCollapsible(index: number): boolean|undefined {\n    if (!this.rawTimelineData) {\n      return;\n    }\n\n    const groups = this.rawTimelineData.groups || [];\n    const style = groups[index].style;\n    if (!style.shareHeaderLine || !style.collapsible) {\n      return Boolean(style.collapsible);\n    }\n    const isLastGroup = index + 1 >= groups.length;\n    if (!isLastGroup && groups[index + 1].style.nestingLevel > style.nestingLevel) {\n      return true;\n    }\n    const nextGroupLevel = isLastGroup ? this.dataProvider.maxStackDepth() : groups[index + 1].startLevel;\n    if (nextGroupLevel !== groups[index].startLevel + 1) {\n      return true;\n    }\n    // For groups that only have one line and share header line, pretend these are not collapsible\n    // unless the itemsHeight does not match the headerHeight\n    return style.height !== style.itemsHeight;\n  }\n\n  setSelectedEntry(entryIndex: number): void {\n    if (this.selectedEntryIndex === entryIndex) {\n      return;\n    }\n    if (entryIndex !== -1) {\n      this.chartViewport.hideRangeSelection();\n    }\n    this.selectedEntryIndex = entryIndex;\n    this.revealEntry(entryIndex);\n    this.updateElementPosition(this.selectedElement, this.selectedEntryIndex);\n  }\n\n  private updateElementPosition(element: Element, entryIndex: number): void {\n    const elementMinWidthPx = 2;\n    element.classList.add('hidden');\n    if (entryIndex === -1) {\n      return;\n    }\n    const timelineData = this.timelineData();\n    if (!timelineData) {\n      return;\n    }\n\n    const startTime = timelineData.entryStartTimes[entryIndex];\n    const duration = timelineData.entryTotalTimes[entryIndex];\n    let barX = 0;\n    let barWidth = 0;\n    let visible = true;\n    if (Number.isNaN(duration)) {\n      const position = this.markerPositions.get(entryIndex);\n      if (position) {\n        barX = position.x;\n        barWidth = position.width;\n      } else {\n        visible = false;\n      }\n    } else {\n      barX = this.chartViewport.timeToPosition(startTime);\n      barWidth = duration * this.chartViewport.timeToPixel();\n    }\n    if (barX + barWidth <= 0 || barX >= this.offsetWidth) {\n      return;\n    }\n    const barCenter = barX + barWidth / 2;\n    barWidth = Math.max(barWidth, elementMinWidthPx);\n    barX = barCenter - barWidth / 2;\n    const entryLevel = timelineData.entryLevels[entryIndex];\n    const barY = this.levelToOffset(entryLevel) - this.chartViewport.scrollOffset();\n    const barHeight = this.levelHeight(entryLevel);\n    const style = (element as HTMLElement).style;\n    style.left = barX + 'px';\n    style.top = barY + 'px';\n    style.width = barWidth + 'px';\n    style.height = barHeight - 1 + 'px';\n    element.classList.toggle('hidden', !visible);\n    this.viewportElement.appendChild(element);\n  }\n\n  private timeToPositionClipped(time: number): number {\n    return Platform.NumberUtilities.clamp(this.chartViewport.timeToPosition(time), 0, this.offsetWidth);\n  }\n\n  private levelToOffset(level: number): number {\n    if (!this.visibleLevelOffsets) {\n      throw new Error('No visible level offsets');\n    }\n    return this.visibleLevelOffsets[level];\n  }\n\n  private levelHeight(level: number): number {\n    if (!this.visibleLevelHeights) {\n      throw new Error('No visible level heights');\n    }\n    return this.visibleLevelHeights[level];\n  }\n\n  private updateBoundaries(): void {\n    this.totalTime = this.dataProvider.totalTime();\n    this.minimumBoundaryInternal = this.dataProvider.minimumBoundary();\n    this.chartViewport.setBoundaries(this.minimumBoundaryInternal, this.totalTime);\n  }\n\n  private updateHeight(): void {\n    const height = this.levelToOffset(this.dataProvider.maxStackDepth()) + 2;\n    this.chartViewport.setContentHeight(height);\n  }\n\n  onResize(): void {\n    this.scheduleUpdate();\n  }\n\n  update(): void {\n    if (!this.timelineData()) {\n      return;\n    }\n    this.resetCanvas();\n    this.updateHeight();\n    this.updateBoundaries();\n    this.draw();\n    if (!this.chartViewport.isDragging()) {\n      this.updateHighlight();\n    }\n  }\n\n  reset(): void {\n    this.chartViewport.reset();\n    this.rawTimelineData = null;\n    this.rawTimelineDataLength = 0;\n    this.highlightedMarkerIndex = -1;\n    this.highlightedEntryIndex = -1;\n    this.selectedEntryIndex = -1;\n    this.textWidth = new Map();\n    this.chartViewport.scheduleUpdate();\n  }\n\n  scheduleUpdate(): void {\n    this.chartViewport.scheduleUpdate();\n  }\n\n  private enabled(): boolean {\n    return this.rawTimelineDataLength !== 0;\n  }\n\n  computePosition(time: number): number {\n    return this.chartViewport.timeToPosition(time);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return this.dataProvider.formatValue(value - this.zeroTime(), precision);\n  }\n\n  maximumBoundary(): number {\n    return this.chartViewport.windowRightTime();\n  }\n\n  minimumBoundary(): number {\n    return this.chartViewport.windowLeftTime();\n  }\n\n  zeroTime(): number {\n    return this.dataProvider.minimumBoundary();\n  }\n\n  boundarySpan(): number {\n    return this.maximumBoundary() - this.minimumBoundary();\n  }\n}\n\nexport const HeaderHeight = 15;\nexport const MinimalTimeWindowMs = 0.5;\n\nexport class TimelineData {\n  entryLevels: number[]|Uint16Array;\n  entryTotalTimes: number[]|Float32Array;\n  entryStartTimes: number[]|Float64Array;\n  groups: Group[];\n  markers: FlameChartMarker[];\n  flowStartTimes: number[];\n  flowStartLevels: number[];\n  flowEndTimes: number[];\n  flowEndLevels: number[];\n  selectedGroup: Group|null;\n  constructor(\n      entryLevels: number[]|Uint16Array, entryTotalTimes: number[]|Float32Array, entryStartTimes: number[]|Float64Array,\n      groups: Group[]|null) {\n    this.entryLevels = entryLevels;\n    this.entryTotalTimes = entryTotalTimes;\n    this.entryStartTimes = entryStartTimes;\n    this.groups = groups || [];\n    this.markers = [];\n    this.flowStartTimes = [];\n    this.flowStartLevels = [];\n    this.flowEndTimes = [];\n    this.flowEndLevels = [];\n    this.selectedGroup = null;\n  }\n}\n\nexport interface FlameChartDataProvider {\n  minimumBoundary(): number;\n\n  totalTime(): number;\n\n  formatValue(value: number, precision?: number): string;\n\n  maxStackDepth(): number;\n\n  timelineData(): TimelineData|null;\n\n  prepareHighlightedEntryInfo(entryIndex: number): Element|null;\n\n  canJumpToEntry(entryIndex: number): boolean;\n\n  entryTitle(entryIndex: number): string|null;\n\n  entryFont(entryIndex: number): string|null;\n\n  entryColor(entryIndex: number): string;\n\n  decorateEntry(\n      entryIndex: number, context: CanvasRenderingContext2D, text: string|null, barX: number, barY: number,\n      barWidth: number, barHeight: number, unclippedBarX: number, timeToPixelRatio: number): boolean;\n\n  forceDecoration(entryIndex: number): boolean;\n\n  textColor(entryIndex: number): string;\n\n  navStartTimes(): Map<string, SDK.TracingModel.Event>;\n}\n\nexport interface FlameChartMarker {\n  startTime(): number;\n  color(): string;\n  title(): string|null;\n  draw(context: CanvasRenderingContext2D, x: number, height: number, pixelsPerMillisecond: number): void;\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  CanvasFocused = 'CanvasFocused',\n  EntryInvoked = 'EntryInvoked',\n  EntrySelected = 'EntrySelected',\n  EntryHighlighted = 'EntryHighlighted',\n}\n\nexport type EventTypes = {\n  [Events.CanvasFocused]: number|void,\n  [Events.EntryInvoked]: number,\n  [Events.EntrySelected]: number,\n  [Events.EntryHighlighted]: number,\n};\n\nexport interface Group {\n  name: Common.UIString.LocalizedString;\n  startLevel: number;\n  expanded?: boolean;\n  selectable?: boolean;\n  style: {\n    height: number,\n    padding: number,\n    collapsible: boolean,\n    font: string,\n    color: string,\n    backgroundColor: string,\n    nestingLevel: number,\n    itemsHeight?: number,\n    shareHeaderLine?: boolean,\n    useFirstLineForOverview?: boolean,\n    useDecoratorsForOverview?: boolean,\n  };\n  track?: TimelineModel.TimelineModel.Track|null;\n}\nexport interface GroupStyle {\n  height: number;\n  padding: number;\n  collapsible: boolean;\n  font: string;\n  color: string;\n  backgroundColor: string;\n  nestingLevel: number;\n  itemsHeight?: number;\n  shareHeaderLine?: boolean;\n  useFirstLineForOverview?: boolean;\n  useDecoratorsForOverview?: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
