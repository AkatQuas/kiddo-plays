{
  "version": 3,
  "sources": ["../../../../../../../../front_end/ui/legacy/components/inline_editor/CSSShadowModel.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../../core/common/common.js';\nimport * as TextUtils from '../../../../models/text_utils/text_utils.js';\n\nexport class CSSShadowModel {\n  private readonly isBoxShadowInternal: boolean;\n  private insetInternal: boolean;\n  private offsetXInternal: CSSLength;\n  private offsetYInternal: CSSLength;\n  private blurRadiusInternal: CSSLength;\n  private spreadRadiusInternal: CSSLength;\n  private colorInternal: Common.Color.Color;\n  private format: Part[];\n  private important: boolean;\n\n  constructor(isBoxShadow: boolean) {\n    this.isBoxShadowInternal = isBoxShadow;\n    this.insetInternal = false;\n    this.offsetXInternal = CSSLength.zero();\n    this.offsetYInternal = CSSLength.zero();\n    this.blurRadiusInternal = CSSLength.zero();\n    this.spreadRadiusInternal = CSSLength.zero();\n    this.colorInternal = (Common.Color.Color.parse('black') as Common.Color.Color);\n    this.format = [Part.OffsetX, Part.OffsetY];\n    this.important = false;\n  }\n\n  static parseTextShadow(text: string): CSSShadowModel[] {\n    return CSSShadowModel.parseShadow(text, false);\n  }\n\n  static parseBoxShadow(text: string): CSSShadowModel[] {\n    return CSSShadowModel.parseShadow(text, true);\n  }\n\n  private static parseShadow(text: string, isBoxShadow: boolean): CSSShadowModel[] {\n    const shadowTexts = [];\n    // Split by commas that aren't inside of color values to get the individual shadow values.\n    const splits = TextUtils.TextUtils.Utils.splitStringByRegexes(text, [Common.Color.Regex, /,/g]);\n    let currentIndex = 0;\n    for (let i = 0; i < splits.length; i++) {\n      if (splits[i].regexIndex === 1) {\n        const comma = splits[i];\n        shadowTexts.push(text.substring(currentIndex, comma.position));\n        currentIndex = comma.position + 1;\n      }\n    }\n    shadowTexts.push(text.substring(currentIndex, text.length));\n\n    const shadows = [];\n    for (let i = 0; i < shadowTexts.length; i++) {\n      const shadow = new CSSShadowModel(isBoxShadow);\n      shadow.format = [];\n      let nextPartAllowed = true;\n      const regexes = [/!important/gi, /inset/gi, Common.Color.Regex, CSSLength.Regex];\n      const results = TextUtils.TextUtils.Utils.splitStringByRegexes(shadowTexts[i], regexes);\n      for (let j = 0; j < results.length; j++) {\n        const result = results[j];\n        if (result.regexIndex === -1) {\n          // Don't allow anything other than inset, color, length values, and whitespace.\n          if (/\\S/.test(result.value)) {\n            return [];\n          }\n          // All parts must be separated by whitespace.\n          nextPartAllowed = true;\n        } else {\n          if (!nextPartAllowed) {\n            return [];\n          }\n          nextPartAllowed = false;\n          if (result.regexIndex === 0) {\n            shadow.important = true;\n            shadow.format.push(Part.Important);\n          } else if (result.regexIndex === 1) {\n            shadow.insetInternal = true;\n            shadow.format.push(Part.Inset);\n          } else if (result.regexIndex === 2) {\n            const color = Common.Color.Color.parse(result.value);\n            if (!color) {\n              return [];\n            }\n            shadow.colorInternal = color;\n            shadow.format.push(Part.Color);\n          } else if (result.regexIndex === 3) {\n            const length = CSSLength.parse(result.value);\n            if (!length) {\n              return [];\n            }\n            const previousPart = shadow.format.length > 0 ? shadow.format[shadow.format.length - 1] : '';\n            if (previousPart === Part.OffsetX) {\n              shadow.offsetYInternal = length;\n              shadow.format.push(Part.OffsetY);\n            } else if (previousPart === Part.OffsetY) {\n              shadow.blurRadiusInternal = length;\n              shadow.format.push(Part.BlurRadius);\n            } else if (previousPart === Part.BlurRadius) {\n              shadow.spreadRadiusInternal = length;\n              shadow.format.push(Part.SpreadRadius);\n            } else {\n              shadow.offsetXInternal = length;\n              shadow.format.push(Part.OffsetX);\n            }\n          }\n        }\n      }\n      if (invalidCount(shadow, Part.OffsetX, 1, 1) || invalidCount(shadow, Part.OffsetY, 1, 1) ||\n          invalidCount(shadow, Part.Color, 0, 1) || invalidCount(shadow, Part.BlurRadius, 0, 1) ||\n          invalidCount(shadow, Part.Inset, 0, isBoxShadow ? 1 : 0) ||\n          invalidCount(shadow, Part.SpreadRadius, 0, isBoxShadow ? 1 : 0) ||\n          invalidCount(shadow, Part.Important, 0, 1)) {\n        return [];\n      }\n      shadows.push(shadow);\n    }\n    return shadows;\n\n    function invalidCount(shadow: CSSShadowModel, part: string, min: number, max: number): boolean {\n      let count = 0;\n      for (let i = 0; i < shadow.format.length; i++) {\n        if (shadow.format[i] === part) {\n          count++;\n        }\n      }\n      return count < min || count > max;\n    }\n  }\n\n  setInset(inset: boolean): void {\n    this.insetInternal = inset;\n    if (this.format.indexOf(Part.Inset) === -1) {\n      this.format.unshift(Part.Inset);\n    }\n  }\n\n  setOffsetX(offsetX: CSSLength): void {\n    this.offsetXInternal = offsetX;\n  }\n\n  setOffsetY(offsetY: CSSLength): void {\n    this.offsetYInternal = offsetY;\n  }\n\n  setBlurRadius(blurRadius: CSSLength): void {\n    this.blurRadiusInternal = blurRadius;\n    if (this.format.indexOf(Part.BlurRadius) === -1) {\n      const yIndex = this.format.indexOf(Part.OffsetY);\n      this.format.splice(yIndex + 1, 0, Part.BlurRadius);\n    }\n  }\n\n  setSpreadRadius(spreadRadius: CSSLength): void {\n    this.spreadRadiusInternal = spreadRadius;\n    if (this.format.indexOf(Part.SpreadRadius) === -1) {\n      this.setBlurRadius(this.blurRadiusInternal);\n      const blurIndex = this.format.indexOf(Part.BlurRadius);\n      this.format.splice(blurIndex + 1, 0, Part.SpreadRadius);\n    }\n  }\n\n  setColor(color: Common.Color.Color): void {\n    this.colorInternal = color;\n    if (this.format.indexOf(Part.Color) === -1) {\n      this.format.push(Part.Color);\n    }\n  }\n\n  isBoxShadow(): boolean {\n    return this.isBoxShadowInternal;\n  }\n\n  inset(): boolean {\n    return this.insetInternal;\n  }\n\n  offsetX(): CSSLength {\n    return this.offsetXInternal;\n  }\n\n  offsetY(): CSSLength {\n    return this.offsetYInternal;\n  }\n\n  blurRadius(): CSSLength {\n    return this.blurRadiusInternal;\n  }\n\n  spreadRadius(): CSSLength {\n    return this.spreadRadiusInternal;\n  }\n\n  color(): Common.Color.Color {\n    return this.colorInternal;\n  }\n\n  asCSSText(): string {\n    const parts = [];\n    for (let i = 0; i < this.format.length; i++) {\n      const part = this.format[i];\n      if (part === Part.Inset && this.insetInternal) {\n        parts.push('inset');\n      } else if (part === Part.OffsetX) {\n        parts.push(this.offsetXInternal.asCSSText());\n      } else if (part === Part.OffsetY) {\n        parts.push(this.offsetYInternal.asCSSText());\n      } else if (part === Part.BlurRadius) {\n        parts.push(this.blurRadiusInternal.asCSSText());\n      } else if (part === Part.SpreadRadius) {\n        parts.push(this.spreadRadiusInternal.asCSSText());\n      } else if (part === Part.Color) {\n        parts.push(this.colorInternal.asString(this.colorInternal.format()));\n      } else if (part === Part.Important && this.important) {\n        parts.push('!important');\n      }\n    }\n    return parts.join(' ');\n  }\n}\n\nconst enum Part {\n  Inset = 'I',\n  OffsetX = 'X',\n  OffsetY = 'Y',\n  BlurRadius = 'B',\n  SpreadRadius = 'S',\n  Color = 'C',\n  Important = 'M',\n}\n\nexport class CSSLength {\n  amount: number;\n  unit: string;\n  constructor(amount: number, unit: string) {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  static parse(text: string): CSSLength|null {\n    const lengthRegex = new RegExp('^(?:' + CSSLength.Regex.source + ')$', 'i');\n    const match = text.match(lengthRegex);\n    if (!match) {\n      return null;\n    }\n    if (match.length > 2 && match[2]) {\n      return new CSSLength(parseFloat(match[1]), match[2]);\n    }\n    return CSSLength.zero();\n  }\n\n  static zero(): CSSLength {\n    return new CSSLength(0, '');\n  }\n\n  asCSSText(): string {\n    return this.amount + this.unit;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static Regex = (function(): RegExp {\n    const number = '([+-]?(?:[0-9]*[.])?[0-9]+(?:[eE][+-]?[0-9]+)?)';\n    const unit = '(ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmax|vmin|vw)';\n    const zero = '[+-]?(?:0*[.])?0+(?:[eE][+-]?[0-9]+)?';\n    return new RegExp(number + unit + '|' + zero, 'gi');\n  })();\n}\n"],
  "mappings": "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",
  "names": []
}
