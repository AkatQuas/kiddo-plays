{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/data_grid/DataGridController.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport type * as TextUtils from '../../../models/text_utils/text_utils.js';\nimport type {SortState, Column, Row} from './DataGridUtils.js';\nimport {SortDirection, getRowEntryForColumnId, getStringifiedCellValues} from './DataGridUtils.js';\nimport type {DataGridData, DataGridContextMenusConfiguration} from './DataGrid.js';\nimport type {ContextMenuColumnSortClickEvent, ColumnHeaderClickEvent} from './DataGridEvents.js';\nimport {DataGrid} from './DataGrid.js';\nimport dataGridControllerStyles from './dataGridController.css.js';\n\nexport interface DataGridControllerData {\n  columns: Column[];\n  rows: Row[];\n  filters?: readonly TextUtils.TextUtils.ParsedFilter[];\n  /**\n   * Sets an initial sort state for the data grid. Is only used if the component\n   * hasn't rendered yet. If you pass this in on subsequent renders, it is\n   * ignored.\n   */\n  initialSort?: SortState;\n  contextMenus?: DataGridContextMenusConfiguration;\n  label?: string;\n}\n\nexport class DataGridController extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-data-grid-controller`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  #hasRenderedAtLeastOnce = false;\n  #columns: readonly Column[] = [];\n  #rows: Row[] = [];\n  #contextMenus?: DataGridContextMenusConfiguration = undefined;\n  #label?: string = undefined;\n\n  /**\n   * Because the controller will sort data in place (e.g. mutate it) when we get\n   * new data in we store the original data separately. This is so we don't\n   * mutate the data we're given, but a copy of the data. If our `get data` is\n   * called, we'll return the original, not the sorted data.\n   */\n  #originalColumns: readonly Column[] = [];\n  #originalRows: Row[] = [];\n\n  #sortState: Readonly<SortState>|null = null;\n  #filters: readonly TextUtils.TextUtils.ParsedFilter[] = [];\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [dataGridControllerStyles];\n  }\n\n  get data(): DataGridControllerData {\n    return {\n      columns: this.#originalColumns as Column[],\n      rows: this.#originalRows as Row[],\n      filters: this.#filters,\n      contextMenus: this.#contextMenus,\n      label: this.#label,\n    };\n  }\n\n  set data(data: DataGridControllerData) {\n    this.#originalColumns = data.columns;\n    this.#originalRows = data.rows;\n    this.#contextMenus = data.contextMenus;\n    this.#filters = data.filters || [];\n    this.#contextMenus = data.contextMenus;\n    this.#label = data.label;\n\n    this.#columns = [...this.#originalColumns];\n    this.#rows = this.#cloneAndFilterRows(data.rows, this.#filters);\n\n    if (!this.#hasRenderedAtLeastOnce && data.initialSort) {\n      this.#sortState = data.initialSort;\n    }\n\n    if (this.#sortState) {\n      this.#sortRows(this.#sortState);\n    }\n\n    this.#render();\n  }\n\n  #testRowWithFilter(row: Row, filter: TextUtils.TextUtils.ParsedFilter): boolean {\n    let rowMatchesFilter = false;\n\n    const {key, text, negative, regex} = filter;\n\n    let dataToTest;\n    if (key) {\n      dataToTest = getStringifiedCellValues([getRowEntryForColumnId(row, key)]);\n    } else {\n      dataToTest = getStringifiedCellValues(row.cells);\n    }\n\n    if (regex) {\n      rowMatchesFilter = regex.test(dataToTest);\n    } else if (text) {\n      rowMatchesFilter = dataToTest.includes(text.toLowerCase());\n    }\n\n    // If `negative` is set to `true`, that means we have to flip the final\n    // result, because the filter is matching anything that doesn't match. e.g.\n    // {text: 'foo', negative: false} matches rows that contain the text `foo`\n    // but {text: 'foo', negative: true} matches rows that do NOT contain the\n    // text `foo` so if a filter is marked as negative, we first match against\n    // that filter, and then we flip it here.\n    return negative ? !rowMatchesFilter : rowMatchesFilter;\n  }\n\n  #cloneAndFilterRows(rows: Row[], filters: readonly TextUtils.TextUtils.ParsedFilter[]): Row[] {\n    if (filters.length === 0) {\n      return [...rows];\n    }\n\n    return rows.map(row => {\n      // We assume that the row should be visible by default.\n      let rowShouldBeVisible = true;\n      for (const filter of filters) {\n        const rowMatchesFilter = this.#testRowWithFilter(row, filter);\n        // If there are multiple filters, if any return false we hide the row.\n        // So if we get a false from testRowWithFilter, we can break early and return false.\n        if (!rowMatchesFilter) {\n          rowShouldBeVisible = false;\n          break;\n        }\n      }\n      return {\n        ...row,\n        hidden: !rowShouldBeVisible,\n      };\n    });\n  }\n\n  #sortRows(state: SortState): void {\n    const {columnId, direction} = state;\n\n    this.#rows.sort((row1, row2) => {\n      const cell1 = getRowEntryForColumnId(row1, columnId);\n      const cell2 = getRowEntryForColumnId(row2, columnId);\n\n      const value1 = typeof cell1.value === 'number' ? cell1.value : String(cell1.value).toUpperCase();\n      const value2 = typeof cell2.value === 'number' ? cell2.value : String(cell2.value).toUpperCase();\n      if (value1 < value2) {\n        return direction === SortDirection.ASC ? -1 : 1;\n      }\n      if (value1 > value2) {\n        return direction === SortDirection.ASC ? 1 : -1;\n      }\n      return 0;\n    });\n    this.#render();\n  }\n\n  #onColumnHeaderClick(event: ColumnHeaderClickEvent): void {\n    const {column} = event.data;\n    if (column.sortable) {\n      this.#applySortOnColumn(column);\n    }\n  }\n\n  #applySortOnColumn(column: Column): void {\n    if (this.#sortState && this.#sortState.columnId === column.id) {\n      const {columnId, direction} = this.#sortState;\n\n      /* When users sort, we go No Sort => ASC => DESC => No sort\n       * So if the current direction is DESC, we clear the state.\n       */\n      if (direction === SortDirection.DESC) {\n        this.#sortState = null;\n      } else {\n        /* The state is ASC, so toggle to DESC */\n        this.#sortState = {\n          columnId,\n          direction: SortDirection.DESC,\n        };\n      }\n    } else {\n      /* The column wasn't previously sorted, so we sort it in ASC order. */\n      this.#sortState = {\n        columnId: column.id,\n        direction: SortDirection.ASC,\n      };\n    }\n\n    if (this.#sortState) {\n      this.#sortRows(this.#sortState);\n    } else {\n      // No sortstate = render the original rows.\n      this.#rows = this.#cloneAndFilterRows(this.#originalRows, this.#filters);\n      this.#render();\n    }\n  }\n\n  #onContextMenuColumnSortClick(event: ContextMenuColumnSortClickEvent): void {\n    this.#applySortOnColumn(event.data.column);\n  }\n\n  #onContextMenuHeaderResetClick(): void {\n    this.#sortState = null;\n    this.#rows = [...this.#originalRows];\n    this.#render();\n  }\n\n  #render(): void {\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    LitHtml.render(LitHtml.html`\n      <${DataGrid.litTagName} .data=${{\n          columns: this.#columns,\n          rows: this.#rows,\n          activeSort: this.#sortState,\n          contextMenus: this.#contextMenus,\n          label: this.#label,\n        } as DataGridData}\n        @columnheaderclick=${this.#onColumnHeaderClick}\n        @contextmenucolumnsortclick=${this.#onContextMenuColumnSortClick}\n        @contextmenuheaderresetclick=${this.#onContextMenuHeaderResetClick}\n     ></${DataGrid.litTagName}>\n    `, this.#shadow, {\n      host: this,\n    });\n    // clang-format on\n    this.#hasRenderedAtLeastOnce = true;\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-data-grid-controller', DataGridController);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid-controller': DataGridController;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
