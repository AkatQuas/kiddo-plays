{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/data_grid/DataGridUtils.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as LitHtml from '../../../ui/lit-html/lit-html.js';\nimport * as DataGridRenderers from './DataGridRenderers.js';\nimport * as IconButton from '../../../ui/components/icon_button/icon_button.js';\n\nexport interface CSSStylesObject {\n  readonly [name: string]: string;\n}\n\n/**\n  * A column is an object with the following properties:\n  *\n  * - `id`: a unique ID for that column.\n  * - `title`: the user visible title.\n  * - `visible`: if the column is visible when rendered\n  * - `hideable`: if the user is able to show/hide the column via the context menu.\n  * - `widthWeighting`: a number that denotes the width of the column. This is a proportion\n  *   of the total weighting of all columns (for details see below).\n  * - `sortable`: an optional property to denote if the  column is sortable.\n  *   Note, if you're rendering a data-grid yourself you likely  shouldn't set\n  *   this. It's set by the `data-grid-controller`, which is the component you\n  *   want if your table needs to be sortable.\n  * - `styles`: an optional property of key-value sets of CSS properties and values.\n*/\nexport interface Column {\n  id: string;\n  title: string;\n  titleElement?: LitHtml.TemplateResult;\n  sortable?: boolean;\n  widthWeighting: number;\n  hideable: boolean;\n  visible: boolean;\n  styles?: CSSStylesObject;\n}\n\nexport type CellValue = string|number|boolean|IconButton.Icon.Icon|null;\n\n/**\n * A cell contains a `columnId`, which is the ID of the column the cell\n * reprsents, and the `value`, which is a string value for that cell.\n *\n * Note that currently cells cannot render complex data (e.g. nested HTML) but\n * in future we may extend the DataGrid to support this.\n */\nexport interface Cell {\n  columnId: string;\n  value: CellValue;\n  title?: string;\n  renderer?: (value: CellValue) => LitHtml.TemplateResult | typeof LitHtml.nothing;\n}\n\nexport function getStringifiedCellValues(cells: Cell[]): string {\n  return JSON\n      .stringify(cells.map(cell => {\n        if (cell.value instanceof IconButton.Icon.Icon) {\n          return null;\n        }\n        return cell.value;\n      }))\n      .toLowerCase();\n}\n\nexport type Row = {\n  cells: Cell[],\n  hidden?: boolean,\n  styles?: CSSStylesObject,\n};\n\nexport const enum SortDirection {\n  ASC = 'ASC',\n  DESC = 'DESC',\n}\n\nexport interface SortState {\n  columnId: string;\n  direction: SortDirection;\n}\n\nexport type CellPosition = readonly [columnIndex: number, rowIndex: number];\n\nexport function getRowEntryForColumnId(row: Row, id: string): Cell {\n  const rowEntry = row.cells.find(r => r.columnId === id);\n  if (rowEntry === undefined) {\n    throw new Error(`Found a row that was missing an entry for column ${id}.`);\n  }\n\n  return rowEntry;\n}\n\nexport function renderCellValue(cell: Cell): LitHtml.LitTemplate {\n  if (cell.renderer) {\n    return cell.renderer(cell.value);\n  }\n\n  return DataGridRenderers.primitiveRenderer(cell.value);\n}\n\n/**\n * When the user passes in columns we want to know how wide each one should be.\n * We don't work in exact percentages, or pixel values, because it's then\n * unclear what to do in the event that one column is hidden. How do we\n * distribute up the extra space?\n *\n * Instead, each column has a weighting, which is its width proportionate to the\n * total weighting of all columns. For example:\n *\n * -> two columns both with widthWeighting: 1, will be 50% each, because the\n * total weight = 2, and each column is 1\n *\n * -> if you have two columns, the first width a weight of 2, and the second\n * with a weight of 1, the first will take up 66% and the other 33%.\n *\n * This way, when you are calculating the %, it's easy to do because if a\n * particular column becomes hidden, you ignore it / give it a weighting of 0,\n * and the space is evenly distributed amongst the remaining visible columns.\n *\n * @param allColumns\n * @param columnId\n */\nexport function calculateColumnWidthPercentageFromWeighting(allColumns: readonly Column[], columnId: string): number {\n  const totalWeights =\n      allColumns.filter(c => c.visible).reduce((sumOfWeights, col) => sumOfWeights + col.widthWeighting, 0);\n  const matchingColumn = allColumns.find(c => c.id === columnId);\n  if (!matchingColumn) {\n    throw new Error(`Could not find column with ID ${columnId}`);\n  }\n  if (matchingColumn.widthWeighting < 1) {\n    throw new Error(`Error with column ${columnId}: width weightings must be >= 1.`);\n  }\n  if (!matchingColumn.visible) {\n    return 0;\n  }\n\n  return Math.round((matchingColumn.widthWeighting / totalWeights) * 100);\n}\n\nexport interface HandleArrowKeyOptions {\n  key: Platform.KeyboardUtilities.ArrowKey;\n  currentFocusedCell: readonly[number, number];\n  columns: readonly Column[];\n  rows: readonly Row[];\n}\n\nexport function handleArrowKeyNavigation(options: HandleArrowKeyOptions): CellPosition {\n  const {key, currentFocusedCell, columns, rows} = options;\n  const [selectedColIndex, selectedRowIndex] = currentFocusedCell;\n\n  switch (key) {\n    case Platform.KeyboardUtilities.ArrowKey.LEFT: {\n      const firstVisibleColumnIndex = columns.findIndex(c => c.visible);\n      if (selectedColIndex === firstVisibleColumnIndex) {\n        // User is as far left as they can go, so don't move them.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      // Set the next index to first be the column we are already on, and then\n      // iterate back through all columns to our left, breaking the loop if we\n      // find one that's not hidden. If we don't find one, we'll stay where we\n      // are.\n      let nextColIndex = selectedColIndex;\n      for (let i = nextColIndex - 1; i >= 0; i--) {\n        const col = columns[i];\n        if (col.visible) {\n          nextColIndex = i;\n          break;\n        }\n      }\n\n      return [nextColIndex, selectedRowIndex];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.RIGHT: {\n      // Set the next index to first be the column we are already on, and then\n      // iterate through all columns to our right, breaking the loop if we\n      // find one that's not hidden. If we don't find one, we'll stay where we\n      // are.\n      let nextColIndex = selectedColIndex;\n      for (let i = nextColIndex + 1; i < columns.length; i++) {\n        const col = columns[i];\n        if (col.visible) {\n          nextColIndex = i;\n          break;\n        }\n      }\n\n      return [nextColIndex, selectedRowIndex];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.UP: {\n      const columnsSortable = columns.some(col => col.sortable === true);\n      const minRowIndex = columnsSortable ? 0 : 1;\n      if (selectedRowIndex === minRowIndex) {\n        // If any columns are sortable the user can navigate into the column\n        // header row, else they cannot. So if they are on the highest row they\n        // can be, just return the current cell as they cannot move up.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      let rowIndexToMoveTo = selectedRowIndex;\n\n      for (let i = selectedRowIndex - 1; i >= minRowIndex; i--) {\n        // This means we got past all the body rows and therefore the user needs\n        // to go into the column row.\n        if (i === 0) {\n          rowIndexToMoveTo = 0;\n          break;\n        }\n        const matchingRow = rows[i - 1];\n        if (!matchingRow.hidden) {\n          rowIndexToMoveTo = i;\n          break;\n        }\n      }\n\n      return [selectedColIndex, rowIndexToMoveTo];\n    }\n\n    case Platform.KeyboardUtilities.ArrowKey.DOWN: {\n      if (selectedRowIndex === 0) {\n        // The user is on the column header. So find the first visible body row and take them there!\n        const firstVisibleBodyRowIndex = rows.findIndex(row => !row.hidden);\n        if (firstVisibleBodyRowIndex > -1) {\n          return [selectedColIndex, firstVisibleBodyRowIndex + 1];\n        }\n        // If we didn't find a single visible row, leave the user where they are.\n        return [selectedColIndex, selectedRowIndex];\n      }\n\n      let rowIndexToMoveTo = selectedRowIndex;\n      // Work down from our starting position to find the next visible row to move to.\n      for (let i = rowIndexToMoveTo + 1; i < rows.length + 1; i++) {\n        const matchingRow = rows[i - 1];\n        if (!matchingRow.hidden) {\n          rowIndexToMoveTo = i;\n          break;\n        }\n      }\n\n      return [selectedColIndex, rowIndexToMoveTo];\n    }\n\n    default:\n      return Platform.assertNever(key, `Unknown arrow key: ${key}`);\n  }\n}\n\nexport const calculateFirstFocusableCell =\n    (options: {columns: readonly Column[], rows: readonly Row[]}): [colIndex: number, rowIndex: number] => {\n      const {columns, rows} = options;\n      const someColumnsSortable = columns.some(col => col.sortable === true);\n      const focusableRowIndex = someColumnsSortable ? 0 : rows.findIndex(row => !row.hidden) + 1;\n      const focusableColIndex = columns.findIndex(col => col.visible);\n\n      return [focusableColIndex, focusableRowIndex];\n    };\n\nexport const getCellTitleFromCellContent = (text: string): string =>\n    text.length < 25 ? text : text.substr(0, 20) + '\\u2026';\n"],
  "mappings": "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",
  "names": []
}
