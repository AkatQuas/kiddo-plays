{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/data_grid/DataGrid.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Host from '../../../core/host/host.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as UI from '../../legacy/legacy.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport dataGridStyles from './dataGrid.css.js';\nimport {BodyCellFocusedEvent, ColumnHeaderClickEvent, ContextMenuHeaderResetClickEvent} from './DataGridEvents.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nimport {addColumnVisibilityCheckboxes, addSortableColumnItems} from './DataGridContextMenuUtils.js';\nimport type {CellPosition, Column, Row, SortState} from './DataGridUtils.js';\nimport {\n  calculateColumnWidthPercentageFromWeighting,\n  calculateFirstFocusableCell,\n  getCellTitleFromCellContent,\n  getRowEntryForColumnId,\n  handleArrowKeyNavigation,\n  renderCellValue,\n  SortDirection,\n} from './DataGridUtils.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nconst UIStrings = {\n  /**\n  *@description A context menu item in the Data Grid of a data grid\n  */\n  sortBy: 'Sort By',\n  /**\n  *@description A context menu item in data grids to reset the columns to their default weight\n  */\n  resetColumns: 'Reset Columns',\n  /**\n  *@description A context menu item in data grids to list header options.\n  */\n  headerOptions: 'Header Options',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/data_grid/DataGrid.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport interface DataGridContextMenusConfiguration {\n  headerRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[]) => void;\n  bodyRow?: (menu: UI.ContextMenu.ContextMenu, columns: readonly Column[], row: Readonly<Row>) => void;\n}\n\nexport interface DataGridData {\n  columns: Column[];\n  rows: Row[];\n  activeSort: SortState|null;\n  contextMenus?: DataGridContextMenusConfiguration;\n  label?: string;\n}\n\nconst enum UserScrollState {\n  NOT_SCROLLED = 'NOT_SCROLLED',\n  MANUAL_SCROLL_NOT_BOTTOM = 'MANUAL_SCROLL_NOT_BOTTOM',\n  SCROLLED_TO_BOTTOM = 'SCROLLED_TO_BOTTOM',\n}\n\nconst KEYS_TREATED_AS_CLICKS = new Set([' ', 'Enter']);\n\nconst ROW_HEIGHT_PIXELS = 18;\nconst PADDING_ROWS_COUNT = 10;\n\nexport class DataGrid extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-data-grid`;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #columns: readonly Column[] = [];\n  #rows: readonly Row[] = [];\n  #sortState: Readonly<SortState>|null = null;\n  #isRendering = false;\n  #userScrollState: UserScrollState = UserScrollState.NOT_SCROLLED;\n  #contextMenus?: DataGridContextMenusConfiguration = undefined;\n  #label?: string = undefined;\n  #currentResize: {\n    rightCellCol: HTMLTableColElement,\n    leftCellCol: HTMLTableColElement,\n    leftCellColInitialPercentageWidth: number,\n    rightCellColInitialPercentageWidth: number,\n    initialLeftCellWidth: number,\n    initialRightCellWidth: number,\n    initialMouseX: number,\n    documentForCursorChange: Document,\n    cursorToRestore: string,\n  }|null = null;\n  // Because we only render a subset of rows, we need a way to look up the\n  // actual row index from the original dataset. We could use this.rows[index]\n  // but that's O(n) and will slow as the dataset grows. A weakmap makes the\n  // lookup constant.\n  readonly #rowIndexMap = new WeakMap<Row, number>();\n  readonly #resizeObserver = new ResizeObserver(() => {\n    void this.#alignScrollHandlers();\n  });\n\n  // Thie have to be bound as they are put onto the global document, not onto\n  // this element, so LitHtml does not bind them for us.\n  #boundOnResizePointerMove = this.#onResizePointerMove.bind(this);\n\n  /**\n   * Following guidance from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html, we\n   * allow a single cell inside the table to be focusable, such that when a user\n   * tabs in they select that cell. IMPORTANT: if the data-grid has sortable\n   * columns, the user has to be able to navigate to the headers to toggle the\n   * sort. [0,0] is considered the first cell INCLUDING the column header\n   * Therefore if a user is on the first header cell, the position is considered [0, 0],\n   * and if a user is on the first body cell, the position is considered [0, 1].\n   *\n   * We set the selectable cell to the first tbody value by default, but then on the\n   * first render if any of the columns are sortable we'll set the active cell\n   * to [0, 0].\n   */\n  #cellToFocusIfUserTabsIn: CellPosition = [0, 1];\n  #cellUserHasFocused: CellPosition|null = null;\n\n  #hasRenderedAtLeastOnce = false;\n  #userHasFocusInDataGrid = false;\n  #scheduleRender = false;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [dataGridStyles];\n    ComponentHelpers.SetCSSProperty.set(this, '--table-row-height', `${ROW_HEIGHT_PIXELS}px`);\n  }\n\n  get data(): DataGridData {\n    return {\n      columns: this.#columns as Column[],\n      rows: this.#rows as Row[],\n      activeSort: this.#sortState,\n      contextMenus: this.#contextMenus,\n      label: this.#label,\n    };\n  }\n\n  set data(data: DataGridData) {\n    this.#columns = data.columns;\n    this.#rows = data.rows;\n    this.#rows.forEach((row, index) => {\n      this.#rowIndexMap.set(row, index);\n    });\n    this.#sortState = data.activeSort;\n    this.#contextMenus = data.contextMenus;\n    this.#label = data.label;\n\n    /**\n     * On first render, now we have data, we can figure out which cell is the\n     * focusable cell for the table.\n     *\n     * If any columns are sortable, we pick [0, 0], which is the first cell of\n     * the columns row. However, if any columns are hidden, we adjust\n     * accordingly. e.g., if the first column is hidden, we'll set the starting\n     * index as [1, 0].\n     *\n     * If the columns aren't sortable, we pick the first visible body row as the\n     * index.\n     *\n     * We only do this on the first render; otherwise if we re-render and the\n     * user has focused a cell, this logic will reset it.\n     */\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#cellToFocusIfUserTabsIn = calculateFirstFocusableCell({columns: this.#columns, rows: this.#rows});\n    }\n\n    if (this.#hasRenderedAtLeastOnce && this.#userHasCellFocused()) {\n      const [selectedColIndex, selectedRowIndex] = this.#tabbableCell();\n      const columnOutOfBounds = selectedColIndex > this.#columns.length;\n      const rowOutOfBounds = selectedRowIndex > this.#rows.length;\n\n      /** If the row or column was removed, so the user is out of bounds, we\n       * move them to the last focusable cell, which should be close to where\n       * they were. */\n      if (columnOutOfBounds || rowOutOfBounds) {\n        this.#cellUserHasFocused = [\n          columnOutOfBounds ? this.#columns.length : selectedColIndex,\n          rowOutOfBounds ? this.#rows.length : selectedRowIndex,\n        ];\n      }\n    }\n\n    void this.#render();\n  }\n\n  #shouldAutoScrollToBottom(): boolean {\n    /**\n     * If the user's last scroll took them to the bottom, then we assume they\n     * want to automatically scroll.\n     */\n    if (this.#userScrollState === UserScrollState.SCROLLED_TO_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * If the user does not have focus in the data grid (e.g. they haven't\n     * selected a cell), we automatically scroll, as long as the user hasn't\n     * manually scrolled the data-grid to somewhere that isn't the bottom.\n     */\n    if (!this.#userHasFocusInDataGrid && this.#userScrollState !== UserScrollState.MANUAL_SCROLL_NOT_BOTTOM) {\n      return true;\n    }\n\n    /**\n     * Else, the user has focused a cell, or their last scroll action took them\n     * not to the bottom, so we assume that they don't want to be auto-scrolled.\n     */\n    return false;\n  }\n\n  #scrollToBottomIfRequired(): void {\n    if (this.#hasRenderedAtLeastOnce === false || !this.#shouldAutoScrollToBottom()) {\n      return;\n    }\n\n    void coordinator.read(() => {\n      const wrapper = this.#shadow.querySelector('.wrapping-container');\n      if (!wrapper) {\n        return;\n      }\n      const scrollHeight = wrapper.scrollHeight;\n      void coordinator.scroll(() => {\n        wrapper.scrollTo(0, scrollHeight);\n      });\n    });\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#resizeObserver.observe(this.#shadow.host);\n    }\n  }\n\n  #userHasCellFocused(): boolean {\n    return this.#cellUserHasFocused !== null;\n  }\n\n  #getTableElementForCellUserHasFocused(): HTMLTableCellElement|null {\n    if (!this.#cellUserHasFocused) {\n      return null;\n    }\n    const [columnIndex, rowIndex] = this.#cellUserHasFocused;\n    const cell = this.#shadow.querySelector<HTMLTableCellElement>(\n        `[data-row-index=\"${rowIndex}\"][data-col-index=\"${columnIndex}\"]`);\n    return cell;\n  }\n\n  async #focusTableCellInDOM(cell: HTMLTableCellElement): Promise<void> {\n    await coordinator.write(() => {\n      cell.focus();\n    });\n  }\n\n  #focusCellIfRequired([newColumnIndex, newRowIndex]: CellPosition): void {\n    this.#userHasFocusInDataGrid = true;\n\n    if (this.#cellUserHasFocused && this.#cellUserHasFocused[0] === newColumnIndex &&\n        this.#cellUserHasFocused[1] === newRowIndex) {\n      // The cell is already active and focused so we don't need to do anything.\n      return;\n    }\n\n    this.#cellUserHasFocused = [newColumnIndex, newRowIndex];\n    void this.#render();\n    const tableCell = this.#getTableElementForCellUserHasFocused();\n    if (!tableCell) {\n      // Return in case the cell is out of bounds and we do nothing\n      return;\n    }\n    /* The cell may already be focused if the user clicked into it, but we also\n     * add arrow key support, so in the case where we're programatically moving the\n     * focus, ensure we actually focus the cell.\n     */\n    void this.#focusTableCellInDOM(tableCell);\n  }\n\n  #onTableKeyDown(event: KeyboardEvent): void {\n    const key = event.key;\n\n    if (!this.#cellUserHasFocused) {\n      return;\n    }\n\n    if (KEYS_TREATED_AS_CLICKS.has(key)) {\n      const [focusedColumnIndex, focusedRowIndex] = this.#cellUserHasFocused;\n      const activeColumn = this.#columns[focusedColumnIndex];\n      if (focusedRowIndex === 0 && activeColumn && activeColumn.sortable) {\n        this.#onColumnHeaderClick(activeColumn, focusedColumnIndex);\n      }\n    }\n\n    if (!Platform.KeyboardUtilities.keyIsArrowKey(key)) {\n      return;\n    }\n\n    const nextFocusedCell = handleArrowKeyNavigation({\n      key: key,\n      currentFocusedCell: this.#cellUserHasFocused,\n      columns: this.#columns,\n      rows: this.#rows,\n    });\n    event.preventDefault();\n    this.#focusCellIfRequired(nextFocusedCell);\n  }\n\n  #onColumnHeaderClick(col: Column, index: number): void {\n    this.dispatchEvent(new ColumnHeaderClickEvent(col, index));\n  }\n\n  /**\n   * Applies the aria-sort label to a column's th.\n   * Guidance on values of attribute taken from\n   * https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html.\n   */\n  #ariaSortForHeader(col: Column): string|undefined {\n    if (col.sortable && (!this.#sortState || this.#sortState.columnId !== col.id)) {\n      // Column is sortable but is not currently sorted\n      return 'none';\n    }\n\n    if (this.#sortState && this.#sortState.columnId === col.id) {\n      return this.#sortState.direction === SortDirection.ASC ? 'ascending' : 'descending';\n    }\n\n    // Column is not sortable, so don't apply any label\n    return undefined;\n  }\n\n  #renderEmptyFillerRow(numberOfVisibleRows: number): LitHtml.TemplateResult {\n    const emptyCells = this.#columns.map((col, colIndex) => {\n      if (!col.visible) {\n        return LitHtml.nothing;\n      }\n      const emptyCellClasses = LitHtml.Directives.classMap({\n        firstVisibleColumn: colIndex === 0,\n      });\n      return LitHtml.html`<td aria-hidden=\"true\" class=${emptyCellClasses} data-filler-row-column-index=${\n          colIndex}></td>`;\n    });\n    const emptyRowClasses = LitHtml.Directives.classMap({\n      'filler-row': true,\n      'padding-row': true,\n      'empty-table': numberOfVisibleRows === 0,\n    });\n    return LitHtml.html`<tr aria-hidden=\"true\" class=${emptyRowClasses}>${emptyCells}</tr>`;\n  }\n\n  #cleanUpAfterResizeColumnComplete(): void {\n    if (!this.#currentResize) {\n      return;\n    }\n    this.#currentResize.documentForCursorChange.body.style.cursor = this.#currentResize.cursorToRestore;\n    this.#currentResize = null;\n    // Realign the scroll handlers now the table columns have been resized.\n    void this.#alignScrollHandlers();\n  }\n\n  #onResizePointerDown(event: PointerEvent): void {\n    if (event.buttons !== 1 || (Host.Platform.isMac() && event.ctrlKey)) {\n      // Ensure we only react to a left click drag mouse down event.\n      // On Mac we ignore Ctrl-click which can be used to bring up context menus, etc.\n      return;\n    }\n    event.preventDefault();\n    const resizerElement = event.target as HTMLElement;\n    if (!resizerElement) {\n      return;\n    }\n    const leftColumnIndex = resizerElement.dataset.columnIndex;\n    if (!leftColumnIndex) {\n      return;\n    }\n    const leftColumnIndexAsNumber = globalThis.parseInt(leftColumnIndex, 10);\n    /* To find the cell to the right we can't just go +1 as it might be hidden,\n     * so find the next index that is visible.\n     */\n    const rightColumnIndexAsNumber = this.#columns.findIndex((column, index) => {\n      return index > leftColumnIndexAsNumber && column.visible === true;\n    });\n\n    const leftCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCell = this.#shadow.querySelector(`td[data-filler-row-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCell || !rightCell) {\n      return;\n    }\n    // We query for the <col> elements as they are the elements that we put the actual width on.\n    const leftCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${leftColumnIndexAsNumber}\"]`);\n    const rightCellCol =\n        this.#shadow.querySelector<HTMLTableColElement>(`col[data-col-column-index=\"${rightColumnIndexAsNumber}\"]`);\n    if (!leftCellCol || !rightCellCol) {\n      return;\n    }\n\n    const targetDocumentForCursorChange = (event.target as Node).ownerDocument;\n    if (!targetDocumentForCursorChange) {\n      return;\n    }\n    // We now store values that we'll make use of in the mousemouse event to calculate how much to resize the table by.\n    this.#currentResize = {\n      leftCellCol,\n      rightCellCol,\n      leftCellColInitialPercentageWidth: globalThis.parseInt(leftCellCol.style.width, 10),\n      rightCellColInitialPercentageWidth: globalThis.parseInt(rightCellCol.style.width, 10),\n      initialLeftCellWidth: leftCell.clientWidth,\n      initialRightCellWidth: rightCell.clientWidth,\n      initialMouseX: event.x,\n      documentForCursorChange: targetDocumentForCursorChange,\n      cursorToRestore: resizerElement.style.cursor,\n    };\n\n    targetDocumentForCursorChange.body.style.cursor = 'col-resize';\n    resizerElement.setPointerCapture(event.pointerId);\n    resizerElement.addEventListener('pointermove', this.#boundOnResizePointerMove);\n  }\n\n  #onResizePointerMove(event: PointerEvent): void {\n    event.preventDefault();\n    if (!this.#currentResize) {\n      return;\n    }\n\n    const MIN_CELL_WIDTH_PERCENTAGE = 10;\n    const MAX_CELL_WIDTH_PERCENTAGE = (this.#currentResize.leftCellColInitialPercentageWidth +\n                                       this.#currentResize.rightCellColInitialPercentageWidth) -\n        MIN_CELL_WIDTH_PERCENTAGE;\n    const deltaOfMouseMove = event.x - this.#currentResize.initialMouseX;\n    const absoluteDelta = Math.abs(deltaOfMouseMove);\n    const percentageDelta =\n        (absoluteDelta / (this.#currentResize.initialLeftCellWidth + this.#currentResize.initialRightCellWidth)) * 100;\n\n    let newLeftColumnPercentage;\n    let newRightColumnPercentage;\n    if (deltaOfMouseMove > 0) {\n      /**\n       * A positive delta means the user moved their mouse to the right, so we\n       * want to make the right column smaller, and the left column larger.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    } else if (deltaOfMouseMove < 0) {\n      /**\n       * Negative delta means the user moved their mouse to the left, which\n       * means we want to make the right column larger, and the left column\n       * smaller.\n       */\n      newLeftColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.leftCellColInitialPercentageWidth - percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n      newRightColumnPercentage = Platform.NumberUtilities.clamp(\n          this.#currentResize.rightCellColInitialPercentageWidth + percentageDelta, MIN_CELL_WIDTH_PERCENTAGE,\n          MAX_CELL_WIDTH_PERCENTAGE);\n    }\n\n    if (!newLeftColumnPercentage || !newRightColumnPercentage) {\n      // The delta was 0, so nothing to do.\n      return;\n    }\n\n    // We limit the values to two decimal places to not work with huge decimals.\n    // It also prevents stuttering if the user barely moves the mouse, as the\n    // browser won't try to move the column by 0.0000001% or similar.\n    this.#currentResize.leftCellCol.style.width = newLeftColumnPercentage.toFixed(2) + '%';\n    this.#currentResize.rightCellCol.style.width = newRightColumnPercentage.toFixed(2) + '%';\n  }\n\n  #onResizePointerUp(event: PointerEvent): void {\n    event.preventDefault();\n    const resizer = event.target as HTMLElement;\n    if (!resizer) {\n      return;\n    }\n    resizer.releasePointerCapture(event.pointerId);\n    resizer.removeEventListener('pointermove', this.#boundOnResizePointerMove);\n    this.#cleanUpAfterResizeColumnComplete();\n  }\n\n  #renderResizeForCell(column: Column, position: CellPosition): LitHtml.LitTemplate {\n    /**\n     * A resizer for a column is placed at the far right of the _previous column\n     * cell_. So when we get called with [1, 0] that means this dragger is\n     * resizing column 1, but the dragger itself is located within column 0. We\n     * need the column to the left because when you resize a column you're not\n     * only resizing it but also the column to its left.\n     */\n    const [columnIndex] = position;\n    const lastVisibleColumnIndex = this.#getIndexOfLastVisibleColumn();\n    // If we are in the very last column, there is no column to the right to resize, so don't render a resizer.\n    if (columnIndex === lastVisibleColumnIndex || !column.visible) {\n      return LitHtml.nothing;\n    }\n\n    return LitHtml.html`<span class=\"cell-resize-handle\"\n     @pointerdown=${this.#onResizePointerDown}\n     @pointerup=${this.#onResizePointerUp}\n     data-column-index=${columnIndex}\n    ></span>`;\n  }\n\n  #getIndexOfLastVisibleColumn(): number {\n    let index = this.#columns.length - 1;\n    for (; index > -1; index--) {\n      const col = this.#columns[index];\n      if (col.visible) {\n        break;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * This function is called when the user right clicks on the header row of the\n   * data grid.\n   */\n  #onHeaderContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    addColumnVisibilityCheckboxes(this, menu);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.#contextMenus && this.#contextMenus.headerRow) {\n      // Let the user append things to the menu\n      this.#contextMenus.headerRow(menu, this.#columns);\n    }\n    void menu.show();\n  }\n\n  #onBodyRowContextMenu(event: MouseEvent): void {\n    if (event.button !== 2) {\n      // 2 = secondary button = right click. We only show context menus if the\n      // user has right clicked.\n      return;\n    }\n    /**\n     * We now make sure that the event came from an HTML element with a\n     * data-row-index attribute, else we bail.\n     */\n    if (!event.target || !(event.target instanceof HTMLElement)) {\n      return;\n    }\n    const rowIndexAttribute = event.target.dataset.rowIndex;\n    if (!rowIndexAttribute) {\n      return;\n    }\n\n    const rowIndex = parseInt(rowIndexAttribute, 10);\n    // rowIndex - 1 here because in the UI the 0th row is the column headers.\n    const rowThatWasClicked = this.#rows[rowIndex - 1];\n\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    const sortMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.sortBy));\n    addSortableColumnItems(this, sortMenu);\n\n    const headerOptionsMenu = menu.defaultSection().appendSubMenuItem(i18nString(UIStrings.headerOptions));\n    addColumnVisibilityCheckboxes(this, headerOptionsMenu);\n    headerOptionsMenu.defaultSection().appendItem(i18nString(UIStrings.resetColumns), () => {\n      this.dispatchEvent(new ContextMenuHeaderResetClickEvent());\n    });\n\n    if (this.#contextMenus && this.#contextMenus.bodyRow) {\n      this.#contextMenus.bodyRow(menu, this.#columns, rowThatWasClicked);\n    }\n    void menu.show();\n  }\n\n  #onScroll(event: Event): void {\n    const wrapper = event.target as HTMLElement;\n    if (!wrapper) {\n      return;\n    }\n\n    // Need to Math.round because on high res screens we can end up with decimal\n    // point numbers for scroll positions.\n    const userIsAtBottom = Math.round(wrapper.scrollTop + wrapper.clientHeight) === Math.round(wrapper.scrollHeight);\n    this.#userScrollState =\n        userIsAtBottom ? UserScrollState.SCROLLED_TO_BOTTOM : UserScrollState.MANUAL_SCROLL_NOT_BOTTOM;\n\n    void this.#render();\n  }\n\n  #alignScrollHandlers(): Promise<void> {\n    return coordinator.read(() => {\n      const columnHeaders = this.#shadow.querySelectorAll<HTMLElement>('th:not(.hidden)');\n      const handlers = this.#shadow.querySelectorAll<HTMLElement>('.cell-resize-handle');\n      const table = this.#shadow.querySelector<HTMLTableElement>('table');\n      if (!table) {\n        return;\n      }\n\n      columnHeaders.forEach(async (header, index) => {\n        const columnWidth = header.clientWidth;\n        const columnLeftOffset = header.offsetLeft;\n        if (handlers[index]) {\n          const handlerWidth = handlers[index].clientWidth;\n          void coordinator.write(() => {\n            /**\n             * Render the resizer at the far right of the column; we subtract\n             * its width so it sits on the inner edge of the column.\n             */\n            handlers[index].style.left = `${columnLeftOffset + columnWidth - handlerWidth}px`;\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Calculates the index of the first row we want to render, and the last row we want to render.\n   * Pads in each direction by PADDING_ROWS_COUNT so we render some rows that are off scren.\n   */\n  #calculateTopAndBottomRowIndexes(): Promise<{topVisibleRow: number, bottomVisibleRow: number}> {\n    return coordinator.read(() => {\n      const wrapper = this.#shadow.querySelector('.wrapping-container');\n\n      // On first render we don't have a wrapper, so we can't get at its\n      // scroll/height values. So we default to the inner height of the window as\n      // the limit for rendering. This means we may over-render by a few rows, but\n      // better that than either render everything, or rendering too few rows.\n      let scrollTop = 0;\n      let clientHeight = window.innerHeight;\n      if (wrapper) {\n        scrollTop = wrapper.scrollTop;\n        clientHeight = wrapper.clientHeight;\n      }\n      const padding = ROW_HEIGHT_PIXELS * PADDING_ROWS_COUNT;\n      let topVisibleRow = Math.floor((scrollTop - padding) / ROW_HEIGHT_PIXELS);\n      let bottomVisibleRow = Math.ceil((scrollTop + clientHeight + padding) / ROW_HEIGHT_PIXELS);\n\n      topVisibleRow = Math.max(0, topVisibleRow);\n      bottomVisibleRow = Math.min(this.#rows.filter(r => !r.hidden).length, bottomVisibleRow);\n\n      return {\n        topVisibleRow,\n        bottomVisibleRow,\n      };\n    });\n  }\n\n  #onFocusOut(): void {\n    /**\n     * When any element in the data-grid loses focus, we set this to false. If\n     * the user then focuses another cell, that code will set the focus to true.\n     * We need to know if the user is focused because if they are and they've\n     * scrolled their focused cell out of rendering view and back in, we want to\n     * refocus it. But if they aren't focused and that happens, we don't, else\n     * we can steal focus away from the user if they are typing into an input\n     * box to filter the data-grid, for example.\n     */\n    this.#userHasFocusInDataGrid = false;\n  }\n\n  #tabbableCell(): CellPosition {\n    /**\n     * If the user has selected a cell, this is the cell that should be\n     * \"tabbable\" if the user tabs out and into the data-grid. If the user\n     * hasn't selected a cell, we fallback to the default cell that we set as\n     * tabbable when we render.\n     */\n    return this.#cellUserHasFocused || this.#cellToFocusIfUserTabsIn;\n  }\n\n  /**\n   * Renders the data-grid table. Note that we do not render all rows; the\n   * performance cost are too high once you have a large enough table. Instead\n   * we calculate the size of the container we are rendering into, and then\n   * render only the rows required to fill that table (plus a bit extra for\n   * padding).\n   */\n  async #render(): Promise<void> {\n    if (this.#isRendering) {\n      // If we receive a request to render during a previous render call, we block\n      // the newly requested render (since we could receive a lot of them in quick\n      // succession), but we do ensure that at the end of the current render we\n      // go again with the latest data.\n      this.#scheduleRender = true;\n      return;\n    }\n    this.#isRendering = true;\n\n    const {topVisibleRow, bottomVisibleRow} = await this.#calculateTopAndBottomRowIndexes();\n    const nonHiddenRows = this.#rows.filter(row => !row.hidden);\n    const renderableRows = nonHiddenRows.filter((_, idx) => idx >= topVisibleRow && idx <= bottomVisibleRow);\n    const indexOfFirstVisibleColumn = this.#columns.findIndex(col => col.visible);\n    const anyColumnsSortable = this.#columns.some(col => col.sortable === true);\n\n    await coordinator.write(() => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(LitHtml.html`\n      ${this.#columns.map((col, columnIndex) => {\n        /**\n        * We render the resizers outside of the table. One is rendered for each\n        * column, and they are positioned absolutely at the right position. They\n        * have 100% height so they sit over the entire table and can be grabbed\n        * by the user.\n        */\n        return this.#renderResizeForCell(col, [columnIndex, 0]);\n      })}\n      <div class=\"wrapping-container\" @scroll=${this.#onScroll} @focusout=${this.#onFocusOut}>\n        <table\n          aria-label=${LitHtml.Directives.ifDefined(this.#label)}\n          aria-rowcount=${this.#rows.length}\n          aria-colcount=${this.#columns.length}\n          @keydown=${this.#onTableKeyDown}\n        >\n          <colgroup>\n            ${this.#columns.map((col, colIndex) => {\n              const width = calculateColumnWidthPercentageFromWeighting(this.#columns, col.id);\n              const style = `width: ${width}%`;\n              if (!col.visible) {\n                return LitHtml.nothing;\n              }\n              return LitHtml.html`<col style=${style} data-col-column-index=${colIndex}>`;\n            })}\n          </colgroup>\n          <thead>\n            <tr @contextmenu=${this.#onHeaderContextMenu}>\n              ${this.#columns.map((col, columnIndex) => {\n                const thClasses = LitHtml.Directives.classMap({\n                  hidden: !col.visible,\n                  firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                });\n                const tabbableCell = this.#tabbableCell();\n                const cellIsFocusableCell = anyColumnsSortable && columnIndex === tabbableCell[0] && tabbableCell[1] === 0;\n\n                return LitHtml.html`<th class=${thClasses}\n                  style=${LitHtml.Directives.ifDefined(col.styles ? LitHtml.Directives.styleMap(col.styles) : undefined)}\n                  data-grid-header-cell=${col.id}\n                  @focus=${(): void => {\n                    this.#focusCellIfRequired([columnIndex, 0]);\n                  }}\n                  @click=${(): void => {\n                    /**\n                     * We use click here rather than focus because if you've\n                     * clicked on the header to sort, you've also focused it. If\n                     * you then click it again to change the sorting, this\n                     * doesn't emit a focus event as the cell is already\n                     * focused.\n                     */\n                    this.#onColumnHeaderClick(col, columnIndex);\n                  }}\n                  title=${col.title}\n                  aria-sort=${LitHtml.Directives.ifDefined(this.#ariaSortForHeader(col))}\n                  aria-colindex=${columnIndex + 1}\n                  data-row-index='0'\n                  data-col-index=${columnIndex}\n                  tabindex=${LitHtml.Directives.ifDefined(anyColumnsSortable ? (cellIsFocusableCell ? '0' : '-1') : undefined)}\n                >${col.titleElement || col.title}</th>`;\n              })}\n            </tr>\n          </thead>\n          <tbody>\n            <tr class=\"filler-row-top padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${topVisibleRow * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n            ${LitHtml.Directives.repeat(renderableRows, row => this.#rowIndexMap.get(row), (row): LitHtml.TemplateResult => {\n              const rowIndex = this.#rowIndexMap.get(row);\n              if (rowIndex === undefined) {\n                throw new Error('Trying to render a row that has no index in the rowIndexMap');\n              }\n              const tabbableCell = this.#tabbableCell();\n              // Remember that row 0 is considered the header row, so the first tbody row is row 1.\n              const tableRowIndex = rowIndex + 1;\n\n              // Check for cellUserHasFocused instead of tabbableCell so that we\n              // don't highlight the active cell before they've even clicked it.\n              const rowIsSelected = this.#cellUserHasFocused ? tableRowIndex === this.#cellUserHasFocused[1] : false;\n\n              const rowClasses = LitHtml.Directives.classMap({\n                selected: rowIsSelected,\n                hidden: row.hidden === true,\n              });\n              return LitHtml.html`\n                <tr\n                  aria-rowindex=${rowIndex + 1}\n                  class=${rowClasses}\n                  style=${LitHtml.Directives.ifDefined(row.styles ? LitHtml.Directives.styleMap(row.styles) : undefined)}\n                  @contextmenu=${this.#onBodyRowContextMenu}\n                >${this.#columns.map((col, columnIndex) => {\n                  const cell = getRowEntryForColumnId(row, col.id);\n                  const cellClasses = LitHtml.Directives.classMap({\n                    hidden: !col.visible,\n                    firstVisibleColumn: columnIndex === indexOfFirstVisibleColumn,\n                  });\n                  const cellIsFocusableCell = columnIndex === tabbableCell[0] && tableRowIndex === tabbableCell[1];\n                  const cellOutput = col.visible ? renderCellValue(cell) : null;\n                  return LitHtml.html`<td\n                    class=${cellClasses}\n                    style=${LitHtml.Directives.ifDefined(col.styles ? LitHtml.Directives.styleMap(col.styles) : undefined)}\n                    tabindex=${cellIsFocusableCell ? '0' : '-1'}\n                    aria-colindex=${columnIndex + 1}\n                    title=${cell.title || getCellTitleFromCellContent(String(cell.value))}\n                    data-row-index=${tableRowIndex}\n                    data-col-index=${columnIndex}\n                    data-grid-value-cell-for-column=${col.id}\n                    @focus=${(): void => {\n                      this.#focusCellIfRequired([columnIndex, tableRowIndex]);\n                      this.dispatchEvent(new BodyCellFocusedEvent(cell, row));\n                    }}\n                  >${cellOutput}</td>`;\n                })}\n              `;\n            })}\n            ${this.#renderEmptyFillerRow(renderableRows.length)}\n            <tr class=\"filler-row-bottom padding-row\" style=${LitHtml.Directives.styleMap({\n              height: `${Math.max(0, nonHiddenRows.length - bottomVisibleRow) * ROW_HEIGHT_PIXELS}px`,\n            })} aria-hidden=\"true\"></tr>\n          </tbody>\n        </table>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n\n    // This ensures if the user has a cell focused, but then scrolls so that\n    // the focused cell is now not rendered, that when it then gets scrolled\n    // back in, that it becomes rendered.\n    // However, if the cell is a column header, we don't do this, as that\n    // can never be not-rendered.\n    const tabbableCell = this.#tabbableCell();\n    const currentlyFocusedRowIndex = tabbableCell[1];\n    const tabbableCellElement = this.#getTableElementForCellUserHasFocused();\n    if (this.#userHasFocusInDataGrid && currentlyFocusedRowIndex > 0 && tabbableCellElement) {\n      void this.#focusTableCellInDOM(tabbableCellElement);\n    }\n    this.#scrollToBottomIfRequired();\n    this.#engageResizeObserver();\n    if (this.#hasRenderedAtLeastOnce) {\n      // We may have had a cell's width change on a re-render, or it may have\n      // been hidden entirely, so we need to ensure that the resize handlers are\n      // re-positioned correctly if so.\n\n      // We don't have to do this on first render as it will fire when the resize observer is engaged.\n      void this.#alignScrollHandlers();\n    }\n\n    this.#isRendering = false;\n    this.#hasRenderedAtLeastOnce = true;\n\n    // If we've received more data mid-render we will do one extra render at\n    // the end with the most recent data.\n    if (this.#scheduleRender) {\n      this.#scheduleRender = false;\n      void this.#render();\n    }\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-data-grid', DataGrid);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-data-grid': DataGrid;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
