{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/render_coordinator/RenderCoordinator.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Components don't orchestrate their DOM updates in a wider context\n * (i.e. the host frame's document), which leads to interleaved reading\n * and writing of layout-centric values, e.g. clientHeight, scrollTop etc.\n *\n * This helper to ensure that we do reads, writes, and scrolls at the\n * correct point in the frame lifecycle. It groups reads to the start of a\n * frame, where we can assume layout-centric values are available on the\n * basis of the last completed frame, and then it runs all writes\n * afterwards. In the event that a read / write / scroll callback contains\n * calls for more read / write / scroll calls, such calls will be scheduled\n * for the next available frame.\n */\n\ninterface CoordinatorCallback {\n  (): unknown;\n}\n\ninterface CoordinatorFrame {\n  readers: CoordinatorCallback[];\n  writers: CoordinatorCallback[];\n}\n\ninterface CoordinatorLogEntry {\n  time: number;\n  value: string;\n}\n\nconst enum ACTION {\n  READ = 'read',\n  WRITE = 'write',\n}\n\nexport class RenderCoordinatorQueueEmptyEvent extends Event {\n  static readonly eventName = 'renderqueueempty';\n  constructor() {\n    super(RenderCoordinatorQueueEmptyEvent.eventName);\n  }\n}\n\nexport class RenderCoordinatorNewFrameEvent extends Event {\n  static readonly eventName = 'newframe';\n  constructor() {\n    super(RenderCoordinatorNewFrameEvent.eventName);\n  }\n}\n\ntype RenderCoordinatorResolverCallback = (value: unknown) => void;\ntype RenderCoordinatorRejectorCallback = (error: Error) => void;\n\nlet renderCoordinatorInstance: RenderCoordinator;\n\nconst UNNAMED_READ = 'Unnamed read';\nconst UNNAMED_WRITE = 'Unnamed write';\nconst UNNAMED_SCROLL = 'Unnamed scroll';\nconst DEADLOCK_TIMEOUT = 1500;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any).__getRenderCoordinatorPendingFrames = function(): number {\n  return RenderCoordinator.pendingFramesCount();\n};\n\nexport class RenderCoordinator extends EventTarget {\n  static instance({forceNew = false} = {}): RenderCoordinator {\n    if (!renderCoordinatorInstance || forceNew) {\n      renderCoordinatorInstance = new RenderCoordinator();\n    }\n\n    return renderCoordinatorInstance;\n  }\n\n  static pendingFramesCount(): number {\n    if (!renderCoordinatorInstance) {\n      throw new Error('No render coordinator instance found.');\n    }\n\n    return renderCoordinatorInstance.pendingFramesCount();\n  }\n\n  // Toggle on to start tracking. You must call takeRecords() to\n  // obtain the records. Please note: records are limited by maxRecordSize below.\n  observe = false;\n  recordStorageLimit = 100;\n\n  // If true, only log activity with an explicit label.\n  // This does not affect logging frames or queue empty events.\n  observeOnlyNamed = true;\n\n  readonly #logInternal: CoordinatorLogEntry[] = [];\n\n  readonly #pendingWorkFrames: CoordinatorFrame[] = [];\n  readonly #resolvers = new WeakMap<CoordinatorCallback, RenderCoordinatorResolverCallback>();\n  readonly #rejectors = new WeakMap<CoordinatorCallback, RenderCoordinatorRejectorCallback>();\n  readonly #labels = new WeakMap<CoordinatorCallback, string>();\n  #scheduledWorkId = 0;\n\n  pendingFramesCount(): number {\n    return this.#pendingWorkFrames.length;\n  }\n\n  done(): Promise<void> {\n    if (this.#pendingWorkFrames.length === 0) {\n      this.#logIfEnabled('[Queue empty]');\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this.addEventListener('renderqueueempty', () => resolve(), {once: true}));\n  }\n\n  async read<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async read<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Read called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_READ);\n  }\n\n  async write<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async write<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Write called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.WRITE, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.WRITE, UNNAMED_WRITE);\n  }\n\n  takeRecords(): CoordinatorLogEntry[] {\n    const logs = [...this.#logInternal];\n    this.#logInternal.length = 0;\n    return logs;\n  }\n\n  /**\n   * We offer a convenience function for scroll-based activity, but often triggering a scroll\n   * requires a layout pass, thus it is better handled as a read activity, i.e. we wait until\n   * the layout-triggering work has been completed then it should be possible to scroll without\n   * first forcing layout.\n   */\n  async scroll<T extends unknown>(callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(label: string, callback: CoordinatorCallback): Promise<T>;\n  async scroll<T extends unknown>(labelOrCallback: CoordinatorCallback|string, callback?: CoordinatorCallback):\n      Promise<T> {\n    if (typeof labelOrCallback === 'string') {\n      if (!callback) {\n        throw new Error('Scroll called with label but no callback');\n      }\n      return this.#enqueueHandler<T>(callback, ACTION.READ, labelOrCallback);\n    }\n\n    return this.#enqueueHandler<T>(labelOrCallback, ACTION.READ, UNNAMED_SCROLL);\n  }\n\n  #enqueueHandler<T = unknown>(callback: CoordinatorCallback, action: ACTION, label = ''): Promise<T> {\n    this.#labels.set(callback, `${action === ACTION.READ ? '[Read]' : '[Write]'}: ${label}`);\n\n    if (this.#pendingWorkFrames.length === 0) {\n      this.#pendingWorkFrames.push({\n        readers: [],\n        writers: [],\n      });\n    }\n\n    const frame = this.#pendingWorkFrames[0];\n    if (!frame) {\n      throw new Error('No frame available');\n    }\n\n    switch (action) {\n      case ACTION.READ:\n        frame.readers.push(callback);\n        break;\n\n      case ACTION.WRITE:\n        frame.writers.push(callback);\n        break;\n\n      default:\n        throw new Error(`Unknown action: ${action}`);\n    }\n\n    const resolverPromise = new Promise((resolve, reject) => {\n      this.#resolvers.set(callback, resolve);\n      this.#rejectors.set(callback, reject);\n    });\n\n    this.#scheduleWork();\n    return resolverPromise as Promise<T>;\n  }\n\n  async #handleWork(handler: CoordinatorCallback): Promise<void> {\n    const resolver = this.#resolvers.get(handler);\n    this.#resolvers.delete(handler);\n    this.#rejectors.delete(handler);\n    const data = await handler.call(undefined);\n    if (!resolver) {\n      throw new Error('Unable to locate resolver');\n    }\n\n    resolver.call(undefined, data);\n  }\n\n  #scheduleWork(): void {\n    const hasScheduledWork = this.#scheduledWorkId !== 0;\n    if (hasScheduledWork) {\n      return;\n    }\n\n    this.#scheduledWorkId = requestAnimationFrame(async () => {\n      const hasPendingFrames = this.#pendingWorkFrames.length > 0;\n      if (!hasPendingFrames) {\n        // No pending frames means all pending work has completed.\n        // The events dispatched below are mostly for testing contexts.\n        // The first is for cases where we have a direct reference to\n        // the render coordinator. The second is for other test contexts\n        // where we don't, and instead we listen for an event on the window.\n        this.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n        window.dispatchEvent(new RenderCoordinatorQueueEmptyEvent());\n\n        this.#logIfEnabled('[Queue empty]');\n        this.#scheduledWorkId = 0;\n        return;\n      }\n\n      this.dispatchEvent(new RenderCoordinatorNewFrameEvent());\n      this.#logIfEnabled('[New frame]');\n\n      const frame = this.#pendingWorkFrames.shift();\n      if (!frame) {\n        return;\n      }\n\n      // Start with all the readers and allow them\n      // to proceed together.\n      const readers: Promise<unknown>[] = [];\n      for (const reader of frame.readers) {\n        this.#logIfEnabled(this.#labels.get(reader));\n        readers.push(this.#handleWork(reader));\n      }\n\n      // Wait for them all to be done.\n      try {\n        await Promise.race([\n          Promise.all(readers),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Readers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.readers, err);\n      }\n\n      // Next do all the writers as a block.\n      const writers: Promise<unknown>[] = [];\n      for (const writer of frame.writers) {\n        this.#logIfEnabled(this.#labels.get(writer));\n        writers.push(this.#handleWork(writer));\n      }\n\n      // And wait for them to be done, too.\n      try {\n        await Promise.race([\n          Promise.all(writers),\n          new Promise((_, reject) => {\n            window.setTimeout(\n                () => reject(new Error(`Writers took over ${DEADLOCK_TIMEOUT}ms. Possible deadlock?`)),\n                DEADLOCK_TIMEOUT);\n          }),\n        ]);\n      } catch (err) {\n        this.#rejectAll(frame.writers, err);\n      }\n\n      // Since there may have been more work requested in\n      // the callback of a reader / writer, we attempt to schedule\n      // it at this point.\n      this.#scheduledWorkId = 0;\n      this.#scheduleWork();\n    });\n  }\n\n  #rejectAll(handlers: CoordinatorCallback[], error: Error): void {\n    for (const handler of handlers) {\n      const rejector = this.#rejectors.get(handler);\n      if (!rejector) {\n        continue;\n      }\n\n      rejector.call(undefined, error);\n      this.#resolvers.delete(handler);\n      this.#rejectors.delete(handler);\n    }\n  }\n\n  #logIfEnabled(value: string|undefined): void {\n    if (!this.observe || !value) {\n      return;\n    }\n    const hasNoName = value.endsWith(UNNAMED_READ) || value.endsWith(UNNAMED_WRITE) || value.endsWith(UNNAMED_SCROLL);\n    if (hasNoName && this.observeOnlyNamed) {\n      return;\n    }\n\n    this.#logInternal.push({time: performance.now(), value});\n\n    // Keep the log at the log size.\n    while (this.#logInternal.length > this.recordStorageLimit) {\n      this.#logInternal.shift();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
