{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryInspector.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport linearMemoryInspectorStyles from './linearMemoryInspector.css.js';\n\nconst {render, html} = LitHtml;\n\nimport type {\n  AddressInputChangedEvent, HistoryNavigationEvent, LinearMemoryNavigatorData, PageNavigationEvent} from\n  './LinearMemoryNavigator.js';\nimport {Mode, Navigation, LinearMemoryNavigator} from './LinearMemoryNavigator.js';\nimport type {\n  EndiannessChangedEvent, LinearMemoryValueInterpreterData, ValueTypeToggledEvent} from\n  './LinearMemoryValueInterpreter.js';\nimport {LinearMemoryValueInterpreter} from './LinearMemoryValueInterpreter.js';\nimport type {ByteSelectedEvent, LinearMemoryViewerData, ResizeEvent} from './LinearMemoryViewer.js';\nimport type {ValueType, ValueTypeMode} from './ValueInterpreterDisplayUtils.js';\nimport {\n  VALUE_INTEPRETER_MAX_NUM_BYTES,\n  Endianness,\n  getDefaultValueTypeMapping,\n} from './ValueInterpreterDisplayUtils.js';\nimport {formatAddress, parseAddress} from './LinearMemoryInspectorUtils.js';\nimport type {JumpToPointerAddressEvent, ValueTypeModeChangedEvent} from './ValueInterpreterDisplay.js';\nimport {LinearMemoryViewer} from './LinearMemoryViewer.js';\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nconst UIStrings = {\n  /**\n  *@description Tooltip text that appears when hovering over an invalid address in the address line in the Linear Memory Inspector\n  *@example {0x00000000} PH1\n  *@example {0x00400000} PH2\n  */\n  addressHasToBeANumberBetweenSAnd: 'Address has to be a number between {PH1} and {PH2}',\n};\nconst str_ = i18n.i18n.registerUIStrings('ui/components/linear_memory_inspector/LinearMemoryInspector.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n// If the LinearMemoryInspector only receives a portion\n// of the original Uint8Array to show, it requires information\n// on the 1. memoryOffset (at which index this portion starts),\n// and on the 2. outerMemoryLength (length of the original Uint8Array).\nexport interface LinearMemoryInspectorData {\n  memory: Uint8Array;\n  address: number;\n  memoryOffset: number;\n  outerMemoryLength: number;\n  valueTypes?: Set<ValueType>;\n  valueTypeModes?: Map<ValueType, ValueTypeMode>;\n  endianness?: Endianness;\n}\n\nexport type Settings = {\n  valueTypes: Set<ValueType>,\n  modes: Map<ValueType, ValueTypeMode>,\n  endianness: Endianness,\n};\n\nexport class MemoryRequestEvent extends Event {\n  static readonly eventName = 'memoryrequest';\n  data: {start: number, end: number, address: number};\n\n  constructor(start: number, end: number, address: number) {\n    super(MemoryRequestEvent.eventName);\n    this.data = {start, end, address};\n  }\n}\n\nexport class AddressChangedEvent extends Event {\n  static readonly eventName = 'addresschanged';\n  data: number;\n\n  constructor(address: number) {\n    super(AddressChangedEvent.eventName);\n    this.data = address;\n  }\n}\n\nexport class SettingsChangedEvent extends Event {\n  static readonly eventName = 'settingschanged';\n  data: Settings;\n\n  constructor(settings: Settings) {\n    super(SettingsChangedEvent.eventName);\n    this.data = settings;\n  }\n}\n\nclass AddressHistoryEntry implements Common.SimpleHistoryManager.HistoryEntry {\n  #address = 0;\n  #callback;\n\n  constructor(address: number, callback: (x: number) => void) {\n    if (address < 0) {\n      throw new Error('Address should be a greater or equal to zero');\n    }\n    this.#address = address;\n    this.#callback = callback;\n  }\n\n  valid(): boolean {\n    return true;\n  }\n\n  reveal(): void {\n    this.#callback(this.#address);\n  }\n}\n\nexport class LinearMemoryInspector extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-linear-memory-inspector-inspector`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #history = new Common.SimpleHistoryManager.SimpleHistoryManager(10);\n\n  #memory = new Uint8Array();\n  #memoryOffset = 0;\n  #outerMemoryLength = 0;\n\n  #address = -1;\n\n  #currentNavigatorMode = Mode.Submitted;\n  #currentNavigatorAddressLine = `${this.#address}`;\n\n  #numBytesPerPage = 4;\n\n  #valueTypeModes = getDefaultValueTypeMapping();\n  #valueTypes = new Set(this.#valueTypeModes.keys());\n  #endianness = Endianness.Little;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [linearMemoryInspectorStyles];\n  }\n\n  set data(data: LinearMemoryInspectorData) {\n    if (data.address < data.memoryOffset || data.address > data.memoryOffset + data.memory.length || data.address < 0) {\n      throw new Error('Address is out of bounds.');\n    }\n\n    if (data.memoryOffset < 0) {\n      throw new Error('Memory offset has to be greater or equal to zero.');\n    }\n\n    this.#memory = data.memory;\n    this.#memoryOffset = data.memoryOffset;\n    this.#outerMemoryLength = data.outerMemoryLength;\n    this.#valueTypeModes = data.valueTypeModes || this.#valueTypeModes;\n    this.#valueTypes = data.valueTypes || this.#valueTypes;\n    this.#endianness = data.endianness || this.#endianness;\n    this.#setAddress(data.address);\n    this.#render();\n  }\n\n  #render(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n\n    const navigatorAddressToShow = this.#currentNavigatorMode === Mode.Submitted ? formatAddress(this.#address) :\n                                                                                   this.#currentNavigatorAddressLine;\n    const navigatorAddressIsValid = this.#isValidAddress(navigatorAddressToShow);\n\n    const invalidAddressMsg = i18nString(\n        UIStrings.addressHasToBeANumberBetweenSAnd,\n        {PH1: formatAddress(0), PH2: formatAddress(this.#outerMemoryLength)});\n\n    const errorMsg = navigatorAddressIsValid ? undefined : invalidAddressMsg;\n\n    const canGoBackInHistory = this.#history.canRollback();\n    const canGoForwardInHistory = this.#history.canRollover();\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    render(html`\n      <div class=\"view\">\n        <${LinearMemoryNavigator.litTagName}\n          .data=${{address: navigatorAddressToShow, valid: navigatorAddressIsValid, mode: this.#currentNavigatorMode, error: errorMsg, canGoBackInHistory, canGoForwardInHistory} as LinearMemoryNavigatorData}\n          @refreshrequested=${this.#onRefreshRequest}\n          @addressinputchanged=${this.#onAddressChange}\n          @pagenavigation=${this.#navigatePage}\n          @historynavigation=${this.#navigateHistory}></${LinearMemoryNavigator.litTagName}>\n        <${LinearMemoryViewer.litTagName}\n          .data=${{memory: this.#memory.slice(start - this.#memoryOffset, end - this.#memoryOffset), address: this.#address, memoryOffset: start, focus: this.#currentNavigatorMode === Mode.Submitted} as LinearMemoryViewerData}\n          @byteselected=${this.#onByteSelected}\n          @resize=${this.#resize}>\n        </${LinearMemoryViewer.litTagName}>\n      </div>\n      <div class=\"value-interpreter\">\n        <${LinearMemoryValueInterpreter.litTagName}\n          .data=${{\n            value: this.#memory.slice(this.#address - this.#memoryOffset, this.#address + VALUE_INTEPRETER_MAX_NUM_BYTES).buffer,\n            valueTypes: this.#valueTypes,\n            valueTypeModes: this.#valueTypeModes,\n            endianness: this.#endianness,\n            memoryLength: this.#outerMemoryLength } as LinearMemoryValueInterpreterData}\n          @valuetypetoggled=${this.#onValueTypeToggled}\n          @valuetypemodechanged=${this.#onValueTypeModeChanged}\n          @endiannesschanged=${this.#onEndiannessChanged}\n          @jumptopointeraddress=${this.#onJumpToPointerAddress}\n          >\n        </${LinearMemoryValueInterpreter.litTagName}/>\n      </div>\n      `, this.#shadow, {\n      host: this,\n    });\n    // clang-format on\n  }\n\n  #onJumpToPointerAddress(e: JumpToPointerAddressEvent): void {\n    // Stop event from bubbling up, since no element further up needs the event.\n    e.stopPropagation();\n    this.#currentNavigatorMode = Mode.Submitted;\n    const addressInRange = Math.max(0, Math.min(e.data, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #onRefreshRequest(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n    this.dispatchEvent(new MemoryRequestEvent(start, end, this.#address));\n  }\n\n  #onByteSelected(e: ByteSelectedEvent): void {\n    this.#currentNavigatorMode = Mode.Submitted;\n    const addressInRange = Math.max(0, Math.min(e.data, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #createSettings(): Settings {\n    return {valueTypes: this.#valueTypes, modes: this.#valueTypeModes, endianness: this.#endianness};\n  }\n\n  #onEndiannessChanged(e: EndiannessChangedEvent): void {\n    this.#endianness = e.data;\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #isValidAddress(address: string): boolean {\n    const newAddress = parseAddress(address);\n    return newAddress !== undefined && newAddress >= 0 && newAddress < this.#outerMemoryLength;\n  }\n\n  #onAddressChange(e: AddressInputChangedEvent): void {\n    const {address, mode} = e.data;\n    const isValid = this.#isValidAddress(address);\n    const newAddress = parseAddress(address);\n    this.#currentNavigatorAddressLine = address;\n\n    if (newAddress !== undefined && isValid) {\n      this.#currentNavigatorMode = mode;\n      this.#jumpToAddress(newAddress);\n      return;\n    }\n\n    if (mode === Mode.Submitted && !isValid) {\n      this.#currentNavigatorMode = Mode.InvalidSubmit;\n    } else {\n      this.#currentNavigatorMode = Mode.Edit;\n    }\n\n    this.#render();\n  }\n\n  #onValueTypeToggled(e: ValueTypeToggledEvent): void {\n    const {type, checked} = e.data;\n    if (checked) {\n      this.#valueTypes.add(type);\n    } else {\n      this.#valueTypes.delete(type);\n    }\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #onValueTypeModeChanged(e: ValueTypeModeChangedEvent): void {\n    e.stopImmediatePropagation();\n    const {type, mode} = e.data;\n    this.#valueTypeModes.set(type, mode);\n    this.dispatchEvent(new SettingsChangedEvent(this.#createSettings()));\n    this.#render();\n  }\n\n  #navigateHistory(e: HistoryNavigationEvent): boolean {\n    return e.data === Navigation.Forward ? this.#history.rollover() : this.#history.rollback();\n  }\n\n  #navigatePage(e: PageNavigationEvent): void {\n    const newAddress =\n        e.data === Navigation.Forward ? this.#address + this.#numBytesPerPage : this.#address - this.#numBytesPerPage;\n    const addressInRange = Math.max(0, Math.min(newAddress, this.#outerMemoryLength - 1));\n    this.#jumpToAddress(addressInRange);\n  }\n\n  #jumpToAddress(address: number): void {\n    if (address < 0 || address >= this.#outerMemoryLength) {\n      console.warn(`Specified address is out of bounds: ${address}`);\n      return;\n    }\n    this.#setAddress(address);\n    this.#update();\n  }\n\n  #getPageRangeForAddress(address: number, numBytesPerPage: number): {start: number, end: number} {\n    const pageNumber = Math.floor(address / numBytesPerPage);\n    const pageStartAddress = pageNumber * numBytesPerPage;\n    const pageEndAddress = Math.min(pageStartAddress + numBytesPerPage, this.#outerMemoryLength);\n    return {start: pageStartAddress, end: pageEndAddress};\n  }\n\n  #resize(event: ResizeEvent): void {\n    this.#numBytesPerPage = event.data;\n    this.#update();\n  }\n\n  #update(): void {\n    const {start, end} = this.#getPageRangeForAddress(this.#address, this.#numBytesPerPage);\n    if (start < this.#memoryOffset || end > this.#memoryOffset + this.#memory.length) {\n      this.dispatchEvent(new MemoryRequestEvent(start, end, this.#address));\n    } else {\n      this.#render();\n    }\n  }\n\n  #setAddress(address: number): void {\n    // If we are already showing the address that is requested, no need to act upon it.\n    if (this.#address === address) {\n      return;\n    }\n    const historyEntry = new AddressHistoryEntry(address, () => this.#jumpToAddress(address));\n    this.#history.push(historyEntry);\n    this.#address = address;\n    this.dispatchEvent(new AddressChangedEvent(this.#address));\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-linear-memory-inspector-inspector', LinearMemoryInspector);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-linear-memory-inspector-inspector': LinearMemoryInspector;\n  }\n\n  interface HTMLElementEventMap {\n    'memoryrequest': MemoryRequestEvent;\n    'addresschanged': AddressChangedEvent;\n    'settingschanged': SettingsChangedEvent;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
