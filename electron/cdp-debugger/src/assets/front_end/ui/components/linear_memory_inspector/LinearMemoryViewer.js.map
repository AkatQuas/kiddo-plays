{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryViewer.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\n\nimport {toHexString} from './LinearMemoryInspectorUtils.js';\nimport linearMemoryViewerStyles from './linearMemoryViewer.css.js';\n\nconst {render, html} = LitHtml;\n\nexport interface LinearMemoryViewerData {\n  memory: Uint8Array;\n  address: number;\n  memoryOffset: number;\n  focus: boolean;\n}\n\nexport class ByteSelectedEvent extends Event {\n  static readonly eventName = 'byteselected';\n  data: number;\n\n  constructor(address: number) {\n    super(ByteSelectedEvent.eventName);\n    this.data = address;\n  }\n}\n\nexport class ResizeEvent extends Event {\n  static readonly eventName = 'resize';\n  data: number;\n\n  constructor(numBytesPerPage: number) {\n    super(ResizeEvent.eventName);\n    this.data = numBytesPerPage;\n  }\n}\n\nconst BYTE_GROUP_MARGIN = 8;\nconst BYTE_GROUP_SIZE = 4;\n\nexport class LinearMemoryViewer extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-linear-memory-inspector-viewer`;\n\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  readonly #resizeObserver = new ResizeObserver(() => this.#resize());\n  #isObservingResize = false;\n\n  #memory = new Uint8Array();\n  #address = 0;\n  #memoryOffset = 0;\n\n  #numRows = 1;\n  #numBytesInRow = BYTE_GROUP_SIZE;\n\n  #focusOnByte = true;\n\n  #lastKeyUpdateSent: number|undefined = undefined;\n\n  set data(data: LinearMemoryViewerData) {\n    if (data.address < data.memoryOffset || data.address > data.memoryOffset + data.memory.length || data.address < 0) {\n      throw new Error('Address is out of bounds.');\n    }\n\n    if (data.memoryOffset < 0) {\n      throw new Error('Memory offset has to be greater or equal to zero.');\n    }\n\n    this.#memory = data.memory;\n    this.#address = data.address;\n    this.#memoryOffset = data.memoryOffset;\n    this.#focusOnByte = data.focus;\n    this.#update();\n  }\n\n  connectedCallback(): void {\n    ComponentHelpers.SetCSSProperty.set(this, '--byte-group-margin', `${BYTE_GROUP_MARGIN}px`);\n    this.#shadow.adoptedStyleSheets = [linearMemoryViewerStyles];\n  }\n\n  disconnectedCallback(): void {\n    this.#isObservingResize = false;\n    this.#resizeObserver.disconnect();\n  }\n\n  #update(): void {\n    this.#updateDimensions();\n    this.#render();\n    this.#focusOnView();\n    this.#engageResizeObserver();\n  }\n\n  #focusOnView(): void {\n    if (this.#focusOnByte) {\n      const view = this.#shadow.querySelector<HTMLDivElement>('.view');\n      if (view) {\n        view.focus();\n      }\n    }\n  }\n\n  #resize(): void {\n    this.#update();\n    this.dispatchEvent(new ResizeEvent(this.#numBytesInRow * this.#numRows));\n  }\n\n  /** Recomputes the number of rows and (byte) columns that fit into the current view. */\n  #updateDimensions(): void {\n    if (this.clientWidth === 0 || this.clientHeight === 0 || !this.shadowRoot) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n\n    // We initially just plot one row with one byte group (here: byte group size of 4).\n    // Depending on that initially plotted row we can determine how many rows and\n    // bytes per row we can fit.\n    // >    0000000 | b0 b1 b2 b4 | a0 a1 a2 a3    <\n    //      ^-------^ ^-^           ^-^\n    //          |     byteCellWidth textCellWidth\n    //          |\n    //     addressTextAndDividerWidth\n    //  ^--^   +     ^----------------------------^\n    //      widthToFill\n\n    const firstByteCell = this.shadowRoot.querySelector('.byte-cell');\n    const textCell = this.shadowRoot.querySelector('.text-cell');\n    const divider = this.shadowRoot.querySelector('.divider');\n    const rowElement = this.shadowRoot.querySelector('.row');\n    const addressText = this.shadowRoot.querySelector('.address');\n\n    if (!firstByteCell || !textCell || !divider || !rowElement || !addressText) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n\n    // Calculate the width required for each (unsplittable) group of bytes.\n    const byteCellWidth = firstByteCell.getBoundingClientRect().width;\n    const textCellWidth = textCell.getBoundingClientRect().width;\n    const groupWidth = BYTE_GROUP_SIZE * (byteCellWidth + textCellWidth) + BYTE_GROUP_MARGIN;\n\n    // Calculate the width to fill.\n    const dividerWidth = divider.getBoundingClientRect().width;\n    const addressTextAndDividerWidth =\n        firstByteCell.getBoundingClientRect().left - addressText.getBoundingClientRect().left;\n\n    // this.clientWidth is rounded, while the other values are not. Subtract 1 to make\n    // sure that we correctly calculate the widths.\n    const widthToFill = this.clientWidth - 1 - addressTextAndDividerWidth - dividerWidth;\n\n    if (widthToFill < groupWidth) {\n      this.#numBytesInRow = BYTE_GROUP_SIZE;\n      this.#numRows = 1;\n      return;\n    }\n    this.#numBytesInRow = Math.floor(widthToFill / groupWidth) * BYTE_GROUP_SIZE;\n    this.#numRows = Math.floor(this.clientHeight / rowElement.clientHeight);\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#resizeObserver || this.#isObservingResize) {\n      return;\n    }\n\n    this.#resizeObserver.observe(this);\n    this.#isObservingResize = true;\n  }\n\n  #render(): void {\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    render(html`\n      <div class=\"view\" tabindex=\"0\" @keydown=${this.#onKeyDown}>\n          ${this.#renderView()}\n      </div>\n      `, this.#shadow, {host: this});\n  }\n\n  #onKeyDown(event: Event): void {\n    const keyboardEvent = event as KeyboardEvent;\n    let newAddress = undefined;\n    if (keyboardEvent.code === 'ArrowUp') {\n      newAddress = this.#address - this.#numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowDown') {\n      newAddress = this.#address + this.#numBytesInRow;\n    } else if (keyboardEvent.code === 'ArrowLeft') {\n      newAddress = this.#address - 1;\n    } else if (keyboardEvent.code === 'ArrowRight') {\n      newAddress = this.#address + 1;\n    } else if (keyboardEvent.code === 'PageUp') {\n      newAddress = this.#address - this.#numBytesInRow * this.#numRows;\n    } else if (keyboardEvent.code === 'PageDown') {\n      newAddress = this.#address + this.#numBytesInRow * this.#numRows;\n    }\n\n    if (newAddress !== undefined && newAddress !== this.#lastKeyUpdateSent) {\n      this.#lastKeyUpdateSent = newAddress;\n      this.dispatchEvent(new ByteSelectedEvent(newAddress));\n    }\n  }\n\n  #renderView(): LitHtml.TemplateResult {\n    const itemTemplates = [];\n    for (let i = 0; i < this.#numRows; ++i) {\n      itemTemplates.push(this.#renderRow(i));\n    }\n    return html`${itemTemplates}`;\n  }\n\n  #renderRow(row: number): LitHtml.TemplateResult {\n    const {startIndex, endIndex} = {startIndex: row * this.#numBytesInRow, endIndex: (row + 1) * this.#numBytesInRow};\n\n    const classMap = {\n      address: true,\n      selected: Math.floor((this.#address - this.#memoryOffset) / this.#numBytesInRow) === row,\n    };\n    return html`\n    <div class=\"row\">\n      <span class=${LitHtml.Directives.classMap(classMap)}>${toHexString({number: startIndex + this.#memoryOffset, pad: 8, prefix: false})}</span>\n      <span class=\"divider\"></span>\n      ${this.#renderByteValues(startIndex, endIndex)}\n      <span class=\"divider\"></span>\n      ${this.#renderCharacterValues(startIndex, endIndex)}\n    </div>\n    `;\n  }\n\n  #renderByteValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      // Add margin after each group of bytes of size byteGroupSize.\n      const addMargin = i !== startIndex && (i - startIndex) % BYTE_GROUP_SIZE === 0;\n      const selected = i === this.#address - this.#memoryOffset;\n      const classMap = {\n        'cell': true,\n        'byte-cell': true,\n        'byte-group-margin': addMargin,\n        selected,\n      };\n      const isSelectableCell = i < this.#memory.length;\n      const byteValue = isSelectableCell ? html`${toHexString({number: this.#memory[i], pad: 2, prefix: false})}` : '';\n      const actualIndex = i + this.#memoryOffset;\n      const onSelectedByte = isSelectableCell ? this.#onSelectedByte.bind(this, actualIndex) : '';\n      cells.push(html`<span class=${LitHtml.Directives.classMap(classMap)} @click=${onSelectedByte}>${byteValue}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  #renderCharacterValues(startIndex: number, endIndex: number): LitHtml.TemplateResult {\n    const cells = [];\n    for (let i = startIndex; i < endIndex; ++i) {\n      const classMap = {\n        'cell': true,\n        'text-cell': true,\n        selected: this.#address - this.#memoryOffset === i,\n      };\n      const isSelectableCell = i < this.#memory.length;\n      const value = isSelectableCell ? html`${this.#toAscii(this.#memory[i])}` : '';\n      const onSelectedByte = isSelectableCell ? this.#onSelectedByte.bind(this, i + this.#memoryOffset) : '';\n      cells.push(html`<span class=${LitHtml.Directives.classMap(classMap)} @click=${onSelectedByte}>${value}</span>`);\n    }\n    return html`${cells}`;\n  }\n\n  #toAscii(byte: number): string {\n    if (byte >= 20 && byte <= 0x7F) {\n      return String.fromCharCode(byte);\n    }\n    return '.';\n  }\n\n  #onSelectedByte(index: number): void {\n    this.dispatchEvent(new ByteSelectedEvent(index));\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-linear-memory-inspector-viewer', LinearMemoryViewer);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface HTMLElementTagNameMap {\n    'devtools-linear-memory-inspector-viewer': LinearMemoryViewer;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
