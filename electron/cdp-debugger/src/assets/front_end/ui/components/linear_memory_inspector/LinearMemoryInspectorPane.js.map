{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryInspectorPane.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport type {AddressChangedEvent, MemoryRequestEvent, Settings, SettingsChangedEvent} from './LinearMemoryInspector.js';\nimport {LinearMemoryInspector} from './LinearMemoryInspector.js';\nimport type {LazyUint8Array} from './LinearMemoryInspectorController.js';\nimport {LinearMemoryInspectorController} from './LinearMemoryInspectorController.js';\n\nconst UIStrings = {\n  /**\n  *@description Label in the Linear Memory Inspector tool that serves as a placeholder if no inspections are open (i.e. nothing to see here).\n  *             Inspection hereby refers to viewing, navigating and understanding the memory through this tool.\n  */\n  noOpenInspections: 'No open inspections',\n};\nconst str_ =\n    i18n.i18n.registerUIStrings('ui/components/linear_memory_inspector/LinearMemoryInspectorPane.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nlet inspectorInstance: LinearMemoryInspectorPaneImpl;\n\nlet wrapperInstance: Wrapper;\n\nexport class Wrapper extends UI.Widget.VBox {\n  view: LinearMemoryInspectorPaneImpl;\n  private constructor() {\n    super();\n    this.view = LinearMemoryInspectorPaneImpl.instance();\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): Wrapper {\n    const {forceNew} = opts;\n    if (!wrapperInstance || forceNew) {\n      wrapperInstance = new Wrapper();\n    }\n\n    return wrapperInstance;\n  }\n\n  wasShown(): void {\n    this.view.show(this.contentElement);\n  }\n}\n\nexport class LinearMemoryInspectorPaneImpl extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(\n    UI.Widget.VBox) {\n  readonly #tabbedPane: UI.TabbedPane.TabbedPane;\n  readonly #tabIdToInspectorView: Map<string, LinearMemoryInspectorView>;\n  constructor() {\n    super(false);\n    const placeholder = document.createElement('div');\n    placeholder.textContent = i18nString(UIStrings.noOpenInspections);\n    placeholder.style.display = 'flex';\n    this.#tabbedPane = new UI.TabbedPane.TabbedPane();\n    this.#tabbedPane.setPlaceholderElement(placeholder);\n    this.#tabbedPane.setCloseableTabs(true);\n    this.#tabbedPane.setAllowTabReorder(true, true);\n    this.#tabbedPane.addEventListener(UI.TabbedPane.Events.TabClosed, this.#tabClosed, this);\n    this.#tabbedPane.show(this.contentElement);\n\n    this.#tabIdToInspectorView = new Map();\n  }\n\n  static instance(): LinearMemoryInspectorPaneImpl {\n    if (!inspectorInstance) {\n      inspectorInstance = new LinearMemoryInspectorPaneImpl();\n    }\n    return inspectorInstance;\n  }\n\n  create(tabId: string, title: string, arrayWrapper: LazyUint8Array, address?: number): void {\n    const inspectorView = new LinearMemoryInspectorView(arrayWrapper, address);\n    this.#tabIdToInspectorView.set(tabId, inspectorView);\n    this.#tabbedPane.appendTab(tabId, title, inspectorView, undefined, false, true);\n    this.#tabbedPane.selectTab(tabId);\n  }\n\n  close(tabId: string): void {\n    this.#tabbedPane.closeTab(tabId, false);\n  }\n\n  reveal(tabId: string, address?: number): void {\n    const view = this.#tabIdToInspectorView.get(tabId);\n    if (!view) {\n      throw new Error(`No linear memory inspector view for given tab id: ${tabId}`);\n    }\n\n    if (address !== undefined) {\n      view.updateAddress(address);\n    }\n    this.refreshView(tabId);\n    this.#tabbedPane.selectTab(tabId);\n  }\n\n  refreshView(tabId: string): void {\n    const view = this.#tabIdToInspectorView.get(tabId);\n    if (!view) {\n      throw new Error(`View for specified tab id does not exist: ${tabId}`);\n    }\n    view.refreshData();\n  }\n\n  #tabClosed(event: Common.EventTarget.EventTargetEvent<UI.TabbedPane.EventData>): void {\n    const {tabId} = event.data;\n    this.#tabIdToInspectorView.delete(tabId);\n    this.dispatchEventToListeners(Events.ViewClosed, tabId);\n  }\n}\n\nexport const enum Events {\n  ViewClosed = 'ViewClosed',\n}\n\nexport type EventTypes = {\n  [Events.ViewClosed]: string,\n};\n\nclass LinearMemoryInspectorView extends UI.Widget.VBox {\n  #memoryWrapper: LazyUint8Array;\n  #address: number;\n  #inspector: LinearMemoryInspector;\n  firstTimeOpen: boolean;\n  constructor(memoryWrapper: LazyUint8Array, address: number|undefined = 0) {\n    super(false);\n\n    if (address < 0 || address >= memoryWrapper.length()) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    this.#memoryWrapper = memoryWrapper;\n    this.#address = address;\n    this.#inspector = new LinearMemoryInspector();\n    this.#inspector.addEventListener('memoryrequest', (event: MemoryRequestEvent) => {\n      this.#memoryRequested(event);\n    });\n    this.#inspector.addEventListener('addresschanged', (event: AddressChangedEvent) => {\n      this.updateAddress(event.data);\n    });\n    this.#inspector.addEventListener('settingschanged', (event: SettingsChangedEvent) => {\n      // Stop event from bubbling up, since no element further up needs the event.\n      event.stopPropagation();\n      this.saveSettings(event.data);\n    });\n    this.contentElement.appendChild(this.#inspector);\n    this.firstTimeOpen = true;\n  }\n\n  wasShown(): void {\n    this.refreshData();\n  }\n\n  saveSettings(settings: Settings): void {\n    LinearMemoryInspectorController.instance().saveSettings(settings);\n  }\n\n  updateAddress(address: number): void {\n    if (address < 0 || address >= this.#memoryWrapper.length()) {\n      throw new Error('Requested address is out of bounds.');\n    }\n    this.#address = address;\n  }\n\n  refreshData(): void {\n    void LinearMemoryInspectorController.getMemoryForAddress(this.#memoryWrapper, this.#address).then(({\n                                                                                                        memory,\n                                                                                                        offset,\n                                                                                                      }) => {\n      let valueTypes;\n      let valueTypeModes;\n      let endianness;\n      if (this.firstTimeOpen) {\n        const settings = LinearMemoryInspectorController.instance().loadSettings();\n        valueTypes = settings.valueTypes;\n        valueTypeModes = settings.modes;\n        endianness = settings.endianness;\n        this.firstTimeOpen = false;\n      }\n      this.#inspector.data = {\n        memory,\n        address: this.#address,\n        memoryOffset: offset,\n        outerMemoryLength: this.#memoryWrapper.length(),\n        valueTypes,\n        valueTypeModes,\n        endianness,\n      };\n    });\n  }\n\n  #memoryRequested(event: MemoryRequestEvent): void {\n    const {start, end, address} = event.data;\n    if (address < start || address >= end) {\n      throw new Error('Requested address is out of bounds.');\n    }\n\n    void LinearMemoryInspectorController.getMemoryRange(this.#memoryWrapper, start, end).then(memory => {\n      this.#inspector.data = {\n        memory: memory,\n        address: address,\n        memoryOffset: start,\n        outerMemoryLength: this.#memoryWrapper.length(),\n      };\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
