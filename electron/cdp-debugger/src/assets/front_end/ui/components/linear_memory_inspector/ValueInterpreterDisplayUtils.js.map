{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/linear_memory_inspector/ValueInterpreterDisplayUtils.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nconst UIStrings = {\n  /**\n  *@description Text that is shown in the LinearMemoryInspector if a value could not be correctly formatted\n  *             for the requested mode (e.g. we do not floats to be represented as hexadecimal numbers).\n  *             Abbreviation stands for 'not applicable'.\n  */\n  notApplicable: 'N/A',\n};\nconst str_ =\n    i18n.i18n.registerUIStrings('ui/components/linear_memory_inspector/ValueInterpreterDisplayUtils.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport const VALUE_INTEPRETER_MAX_NUM_BYTES = 8;\n\nexport const enum ValueType {\n  Int8 = 'Integer 8-bit',\n  Int16 = 'Integer 16-bit',\n  Int32 = 'Integer 32-bit',\n  Int64 = 'Integer 64-bit',\n  Float32 = 'Float 32-bit',\n  Float64 = 'Float 64-bit',\n  Pointer32 = 'Pointer 32-bit',\n  Pointer64 = 'Pointer 64-bit',\n}\n\nexport const enum Endianness {\n  Little = 'Little Endian',\n  Big = 'Big Endian',\n}\n\nexport const enum ValueTypeMode {\n  Decimal = 'dec',\n  Hexadecimal = 'hex',\n  Octal = 'oct',\n  Scientific = 'sci',\n}\n\nexport function getDefaultValueTypeMapping(): Map<ValueType, ValueTypeMode> {\n  return new Map(DEFAULT_MODE_MAPPING);\n}\n\nconst DEFAULT_MODE_MAPPING = new Map([\n  [ValueType.Int8, ValueTypeMode.Decimal],\n  [ValueType.Int16, ValueTypeMode.Decimal],\n  [ValueType.Int32, ValueTypeMode.Decimal],\n  [ValueType.Int64, ValueTypeMode.Decimal],\n  [ValueType.Float32, ValueTypeMode.Decimal],\n  [ValueType.Float64, ValueTypeMode.Decimal],\n  [ValueType.Pointer32, ValueTypeMode.Hexadecimal],\n  [ValueType.Pointer64, ValueTypeMode.Hexadecimal],\n]);\n\nexport const VALUE_TYPE_MODE_LIST = [\n  ValueTypeMode.Decimal,\n  ValueTypeMode.Hexadecimal,\n  ValueTypeMode.Octal,\n  ValueTypeMode.Scientific,\n];\n\nexport function valueTypeToLocalizedString(valueType: ValueType): string {\n  return i18n.i18n.lockedString(valueType);\n}\n\nexport function isValidMode(type: ValueType, mode: ValueTypeMode): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n      return mode === ValueTypeMode.Decimal || mode === ValueTypeMode.Hexadecimal || mode === ValueTypeMode.Octal;\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return mode === ValueTypeMode.Scientific || mode === ValueTypeMode.Decimal;\n    case ValueType.Pointer32:  // fallthrough\n    case ValueType.Pointer64:\n      return mode === ValueTypeMode.Hexadecimal;\n    default:\n      return Platform.assertNever(type, `Unknown value type: ${type}`);\n  }\n}\n\nexport function isNumber(type: ValueType): boolean {\n  switch (type) {\n    case ValueType.Int8:\n    case ValueType.Int16:\n    case ValueType.Int32:\n    case ValueType.Int64:\n    case ValueType.Float32:\n    case ValueType.Float64:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function getPointerAddress(type: ValueType, buffer: ArrayBuffer, endianness: Endianness): number|bigint {\n  if (!isPointer(type)) {\n    console.error(`Requesting address of a non-pointer type: ${type}.\\n`);\n    return NaN;\n  }\n  try {\n    const dataView = new DataView(buffer);\n    const isLittleEndian = endianness === Endianness.Little;\n    return type === ValueType.Pointer32 ? dataView.getUint32(0, isLittleEndian) :\n                                          dataView.getBigUint64(0, isLittleEndian);\n  } catch (e) {\n    return NaN;\n  }\n}\n\nexport function isPointer(type: ValueType): boolean {\n  return type === ValueType.Pointer32 || type === ValueType.Pointer64;\n}\nexport interface FormatData {\n  buffer: ArrayBuffer;\n  type: ValueType;\n  endianness: Endianness;\n  signed: boolean;\n  mode?: ValueTypeMode;\n}\n\nexport function format(formatData: FormatData): string {\n  if (!formatData.mode) {\n    console.error(`No known way of showing value for ${formatData.type}`);\n    return i18nString(UIStrings.notApplicable);\n  }\n  const valueView = new DataView(formatData.buffer);\n  const isLittleEndian = formatData.endianness === Endianness.Little;\n  let value;\n\n  try {\n    switch (formatData.type) {\n      case ValueType.Int8:\n        value = formatData.signed ? valueView.getInt8(0) : valueView.getUint8(0);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int16:\n        value = formatData.signed ? valueView.getInt16(0, isLittleEndian) : valueView.getUint16(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int32:\n        value = formatData.signed ? valueView.getInt32(0, isLittleEndian) : valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Int64:\n        value =\n            formatData.signed ? valueView.getBigInt64(0, isLittleEndian) : valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, formatData.mode);\n      case ValueType.Float32:\n        value = valueView.getFloat32(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.Float64:\n        value = valueView.getFloat64(0, isLittleEndian);\n        return formatFloat(value, formatData.mode);\n      case ValueType.Pointer32:\n        value = valueView.getUint32(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.Hexadecimal);\n      case ValueType.Pointer64:\n        value = valueView.getBigUint64(0, isLittleEndian);\n        return formatInteger(value, ValueTypeMode.Hexadecimal);\n      default:\n        return Platform.assertNever(formatData.type, `Unknown value type: ${formatData.type}`);\n    }\n  } catch (e) {\n    return i18nString(UIStrings.notApplicable);\n  }\n}\n\nexport function formatFloat(value: number, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toFixed(2).toString();\n    case ValueTypeMode.Scientific:\n      return value.toExponential(2).toString();\n    default:\n      throw new Error(`Unknown mode for floats: ${mode}.`);\n  }\n}\n\nexport function formatInteger(value: number|bigint, mode: ValueTypeMode): string {\n  switch (mode) {\n    case ValueTypeMode.Decimal:\n      return value.toString();\n    case ValueTypeMode.Hexadecimal:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return '0x' + value.toString(16).toUpperCase();\n    case ValueTypeMode.Octal:\n      if (value < 0) {\n        return i18nString(UIStrings.notApplicable);\n      }\n      return value.toString(8);\n    default:\n      throw new Error(`Unknown mode for integers: ${mode}.`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
