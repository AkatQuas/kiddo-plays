{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/text_editor/javascript.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport * as Formatter from '../../../models/formatter/formatter.js';\nimport * as JavaScriptMetaData from '../../../models/javascript_metadata/javascript_metadata.js';\nimport * as CodeMirror from '../../../third_party/codemirror.next/codemirror.next.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport {type ArgumentHintsTooltip, closeTooltip, cursorTooltip} from './cursor_tooltip.js';\n\nexport function completion(): CodeMirror.Extension {\n  return CodeMirror.javascript.javascriptLanguage.data.of({\n    autocomplete: javascriptCompletionSource,\n  });\n}\n\nexport async function completeInContext(\n    textBefore: string, query: string, force: boolean = false): Promise<UI.SuggestBox.Suggestions> {\n  const state = CodeMirror.EditorState.create({\n    doc: textBefore + query,\n    selection: {anchor: textBefore.length},\n    extensions: CodeMirror.javascript.javascriptLanguage,\n  });\n  const result = await javascriptCompletionSource(new CodeMirror.CompletionContext(state, state.doc.length, force));\n  return result ?\n      result.options.filter((o): boolean => o.label.startsWith(query)).map((o): UI.SuggestBox.Suggestion => ({\n                                                                             text: o.label,\n                                                                             priority: 100 + (o.boost || 0),\n                                                                             isSecondary: o.type === 'secondary',\n                                                                           })) :\n      [];\n}\n\nclass CompletionSet {\n  constructor(\n      readonly completions: CodeMirror.Completion[] = [],\n      readonly seen: Set<string> = new Set(),\n  ) {\n  }\n\n  add(completion: CodeMirror.Completion): void {\n    if (!this.seen.has(completion.label)) {\n      this.seen.add(completion.label);\n      this.completions.push(completion);\n    }\n  }\n\n  copy(): CompletionSet {\n    return new CompletionSet(this.completions.slice(), new Set(this.seen));\n  }\n}\n\nconst javascriptKeywords = [\n  'async',      'await', 'break',  'case',    'catch', 'class',   'const',  'continue', 'debugger', 'default', 'delete',\n  'do',         'else',  'export', 'extends', 'false', 'finally', 'for',    'function', 'if',       'import',  'in',\n  'instanceof', 'let',   'new',    'null',    'of',    'return',  'static', 'super',    'switch',   'this',    'throw',\n  'true',       'try',   'typeof', 'var',     'void',  'while',   'with',   'yield',\n];\nconst consoleBuiltinFunctions = [\n  'clear',\n  'copy',\n  'debug',\n  'dir',\n  'dirxml',\n  'getEventListeners',\n  'inspect',\n  'keys',\n  'monitor',\n  'monitorEvents',\n  'profile',\n  'profileEnd',\n  'queryObjects',\n  'table',\n  'undebug',\n  'unmonitor',\n  'unmonitorEvents',\n  'values',\n];\nconst consoleBuiltinVariables = ['$', '$$', '$x', '$0', '$_'];\n\nconst baseCompletions = new CompletionSet();\nfor (const kw of javascriptKeywords) {\n  baseCompletions.add({label: kw, type: 'keyword'});\n}\nfor (const builtin of consoleBuiltinFunctions) {\n  baseCompletions.add({label: builtin, type: 'function'});\n}\nfor (const varName of consoleBuiltinVariables) {\n  baseCompletions.add({label: varName, type: 'variable'});\n}\n\nconst dontCompleteIn = new Set([\n  'TemplateString',\n  'LineComment',\n  'BlockComment',\n  'TypeDefinition',\n  'VariableDefinition',\n  'PropertyDefinition',\n  'TypeName',\n]);\n\nexport const enum QueryType {\n  Expression = 0,\n  PropertyName = 1,\n  PropertyExpression = 2,\n  PotentiallyRetrievingFromMap = 3,\n}\n\nexport function getQueryType(tree: CodeMirror.Tree, pos: number, doc: CodeMirror.Text): {\n  type: QueryType,\n  from?: number,\n  relatedNode?: CodeMirror.SyntaxNode,\n}|null {\n  let node = tree.resolveInner(pos, -1);\n  const parent = node.parent;\n  if (dontCompleteIn.has(node.name)) {\n    return null;\n  }\n\n  if (node.name === 'PropertyName' || node.name === 'PrivatePropertyName') {\n    return parent?.name !== 'MemberExpression' ? null :\n                                                 {type: QueryType.PropertyName, from: node.from, relatedNode: parent};\n  }\n  if (node.name === 'VariableName' ||\n      // Treat alphabetic keywords as variables\n      !node.firstChild && node.to - node.from < 20 && !/[^a-z]/.test(doc.sliceString(node.from, node.to))) {\n    return {type: QueryType.Expression, from: node.from};\n  }\n  if (node.name === 'String') {\n    const parent = node.parent;\n    return parent?.name === 'MemberExpression' && parent.childBefore(node.from)?.name === '[' ?\n        {type: QueryType.PropertyExpression, from: node.from, relatedNode: parent} :\n        null;\n  }\n  // Enter unfinished nodes before the position.\n  node = node.enterUnfinishedNodesBefore(pos);\n  // Normalize to parent node when pointing after a child of a member expr.\n  if (node.to === pos && node.parent?.name === 'MemberExpression') {\n    node = node.parent;\n  }\n  if (node.name === 'MemberExpression') {\n    const before = node.childBefore(Math.min(pos, node.to));\n    if (before?.name === '[') {\n      return {type: QueryType.PropertyExpression, relatedNode: node};\n    }\n    if (before?.name === '.' || before?.name === '?.') {\n      return {type: QueryType.PropertyName, relatedNode: node};\n    }\n  }\n  if (node.name === '(') {\n    // map.get(<auto-complete>\n    if (parent?.name === 'ArgList' && parent?.parent?.name === 'CallExpression') {\n      // map.get\n      const callReceiver = parent?.parent?.firstChild;\n      if (callReceiver?.name === 'MemberExpression') {\n        // get\n        const propertyExpression = callReceiver?.lastChild;\n        if (propertyExpression && doc.sliceString(propertyExpression.from, propertyExpression.to) === 'get') {\n          // map\n          const potentiallyMapObject = callReceiver?.firstChild;\n          return {type: QueryType.PotentiallyRetrievingFromMap, relatedNode: potentiallyMapObject || undefined};\n        }\n      }\n    }\n  }\n  return {type: QueryType.Expression};\n}\n\nexport async function javascriptCompletionSource(cx: CodeMirror.CompletionContext):\n    Promise<CodeMirror.CompletionResult|null> {\n  const query = getQueryType(CodeMirror.syntaxTree(cx.state), cx.pos, cx.state.doc);\n  if (!query || query.from === undefined && !cx.explicit && query.type === QueryType.Expression) {\n    return null;\n  }\n\n  let result: CompletionSet;\n  let quote: string|undefined = undefined;\n  if (query.type === QueryType.Expression) {\n    const [scope, global] = await Promise.all([\n      completeExpressionInScope(),\n      completeExpressionGlobal(),\n    ]);\n    if (scope.completions.length) {\n      result = scope;\n      for (const r of global.completions) {\n        result.add(r);\n      }\n    } else {\n      result = global;\n    }\n  } else if (query.type === QueryType.PropertyName || query.type === QueryType.PropertyExpression) {\n    const objectExpr = (query.relatedNode as CodeMirror.SyntaxNode).getChild('Expression');\n    if (query.type === QueryType.PropertyExpression) {\n      quote = query.from === undefined ? '\\'' : cx.state.sliceDoc(query.from, query.from + 1);\n    }\n    if (!objectExpr) {\n      return null;\n    }\n    result = await completeProperties(\n        cx.state.sliceDoc(objectExpr.from, objectExpr.to), quote, cx.state.sliceDoc(cx.pos, cx.pos + 1) === ']');\n  } else if (query.type === QueryType.PotentiallyRetrievingFromMap) {\n    const potentialMapObject = query.relatedNode;\n    if (!potentialMapObject) {\n      return null;\n    }\n    result = await maybeCompleteKeysFromMap(cx.state.sliceDoc(potentialMapObject.from, potentialMapObject.to));\n  } else {\n    return null;\n  }\n  return {\n    from: query.from ?? cx.pos,\n    options: result.completions,\n    validFor: !quote ? SPAN_IDENT : quote === '\\'' ? SPAN_SINGLE_QUOTE : SPAN_DOUBLE_QUOTE,\n  };\n}\n\nconst SPAN_IDENT = /^#?(?:[$_\\p{ID_Start}])(?:[$_\\u200C\\u200D\\p{ID_Continue}])*$/u,\n      SPAN_SINGLE_QUOTE = /^\\'(\\\\.|[^\\\\'\\n])*'?$/, SPAN_DOUBLE_QUOTE = /^\"(\\\\.|[^\\\\\"\\n])*\"?$/;\n\nfunction getExecutionContext(): SDK.RuntimeModel.ExecutionContext|null {\n  return UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n}\n\nasync function evaluateExpression(\n    context: SDK.RuntimeModel.ExecutionContext,\n    expression: string,\n    group: string,\n    ): Promise<SDK.RemoteObject.RemoteObject|null> {\n  const result = await context.evaluate(\n      {\n        expression,\n        objectGroup: group,\n        includeCommandLineAPI: true,\n        silent: true,\n        returnByValue: false,\n        generatePreview: false,\n        throwOnSideEffect: true,\n        timeout: 500,\n      },\n      false, false);\n  if ('error' in result || result.exceptionDetails || !result.object) {\n    return null;\n  }\n  return result.object;\n}\n\nconst primitivePrototypes = new Map<string, string>([\n  ['string', 'String'],\n  ['symbol', 'Symbol'],\n  ['number', 'Number'],\n  ['boolean', 'Boolean'],\n  ['bigint', 'BigInt'],\n]);\n\nconst maxCacheAge = 30_000;\n\nlet cacheInstance: PropertyCache|null = null;\n\n// Store recent collections of property completions. The empty string\n// is used to store the set of global bindings.\nclass PropertyCache {\n  readonly #cache: Map<string, Promise<CompletionSet>> = new Map();\n\n  constructor() {\n    const clear = (): void => this.#cache.clear();\n    SDK.ConsoleModel.ConsoleModel.instance().addEventListener(SDK.ConsoleModel.Events.CommandEvaluated, clear);\n    UI.Context.Context.instance().addFlavorChangeListener(SDK.RuntimeModel.ExecutionContext, clear);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerResumed, clear);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerPaused, clear);\n  }\n\n  get(expression: string): Promise<CompletionSet>|undefined {\n    return this.#cache.get(expression);\n  }\n\n  set(expression: string, value: Promise<CompletionSet>): void {\n    this.#cache.set(expression, value);\n    window.setTimeout(() => {\n      if (this.#cache.get(expression) === value) {\n        this.#cache.delete(expression);\n      }\n    }, maxCacheAge);\n  }\n\n  static instance(): PropertyCache {\n    if (!cacheInstance) {\n      cacheInstance = new PropertyCache();\n    }\n    return cacheInstance;\n  }\n}\n\nasync function maybeCompleteKeysFromMap(objectVariable: string): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  const context = getExecutionContext();\n  if (!context) {\n    return result;\n  }\n  const maybeRetrieveKeys =\n      await evaluateExpression(context, `[...Map.prototype.keys.call(${objectVariable})]`, 'completion');\n  if (!maybeRetrieveKeys) {\n    return result;\n  }\n  const properties = SDK.RemoteObject.RemoteArray.objectAsArray(maybeRetrieveKeys);\n  const numProperties = properties.length();\n  for (let i = 0; i < numProperties; i++) {\n    result.add({\n      label: `\"${(await properties.at(i)).value}\")`,\n      type: 'constant',\n      boost: i * -1,\n    });\n  }\n  return result;\n}\n\nasync function completeProperties(\n    expression: string,\n    quoted?: string,\n    hasBracket: boolean = false,\n    ): Promise<CompletionSet> {\n  const cache = PropertyCache.instance();\n  if (!quoted) {\n    const cached = cache.get(expression);\n    if (cached) {\n      return cached;\n    }\n  }\n  const context = getExecutionContext();\n  if (!context) {\n    return new CompletionSet();\n  }\n  const result = completePropertiesInner(expression, context, quoted, hasBracket);\n  if (!quoted) {\n    cache.set(expression, result);\n  }\n  return result;\n}\n\nasync function completePropertiesInner(\n    expression: string,\n    context: SDK.RuntimeModel.ExecutionContext,\n    quoted?: string,\n    hasBracket: boolean = false,\n    ): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  if (!context) {\n    return result;\n  }\n  let object = await evaluateExpression(context, expression, 'completion');\n  if (!object) {\n    return result;\n  }\n\n  while (object.type === 'object' && object.subtype === 'proxy') {\n    const properties = await object.getOwnProperties(false);\n    const innerObject = properties.internalProperties?.find(p => p.name === '[[Target]]')?.value;\n    if (!innerObject) {\n      break;\n    }\n    object = innerObject as SDK.RemoteObject.RemoteObject;\n  }\n\n  const toPrototype = primitivePrototypes.get(object.type);\n  if (toPrototype) {\n    object = await evaluateExpression(context, toPrototype + '.prototype', 'completion');\n  }\n\n  const functionType = expression === 'globalThis' ? 'function' : 'method';\n  const otherType = expression === 'globalThis' ? 'variable' : 'property';\n  if (object && (object.type === 'object' || object.type === 'function')) {\n    const properties = await object.getAllProperties(\n        /* accessorPropertiesOnly */ false, /* generatePreview */ false, /* nonIndexedPropertiesOnly */ true);\n    const isFunction = object.type === 'function';\n    for (const prop of properties.properties || []) {\n      if (!prop.symbol && !(isFunction && (prop.name === 'arguments' || prop.name === 'caller')) &&\n          (!prop.private || expression === 'this') && (quoted || SPAN_IDENT.test(prop.name))) {\n        const label =\n            quoted ? quoted + prop.name.replaceAll('\\\\', '\\\\\\\\').replaceAll(quoted, '\\\\' + quoted) + quoted : prop.name;\n        const apply = (quoted && !hasBracket) ? `${label}]` : undefined;\n        const boost = 2 * Number(prop.isOwn) + 1 * Number(prop.enumerable);\n        const type = prop.value?.type === 'function' ? functionType : otherType;\n        result.add({apply, label, type, boost});\n      }\n    }\n  }\n  context.runtimeModel.releaseObjectGroup('completion');\n  return result;\n}\n\nasync function completeExpressionInScope(): Promise<CompletionSet> {\n  const result = new CompletionSet();\n  const selectedFrame = getExecutionContext()?.debuggerModel.selectedCallFrame();\n  if (!selectedFrame) {\n    return result;\n  }\n\n  const frames =\n      await Promise.all(selectedFrame.scopeChain().map(scope => scope.object().getAllProperties(false, false)));\n  for (const frame of frames) {\n    for (const property of frame.properties || []) {\n      result.add({\n        label: property.name,\n        type: property.value?.type === 'function' ? 'function' : 'variable',\n      });\n    }\n  }\n  return result;\n}\n\nasync function completeExpressionGlobal(): Promise<CompletionSet> {\n  const cache = PropertyCache.instance();\n  const cached = cache.get('');\n  if (cached) {\n    return cached;\n  }\n\n  const context = getExecutionContext();\n  if (!context) {\n    return baseCompletions;\n  }\n  const result = baseCompletions.copy();\n\n  const fetchNames = completePropertiesInner('globalThis', context).then(fromWindow => {\n    return context.globalLexicalScopeNames().then(globals => {\n      for (const option of fromWindow.completions) {\n        result.add(option);\n      }\n      for (const name of globals || []) {\n        result.add({label: name, type: 'variable'});\n      }\n      return result;\n    });\n  });\n  cache.set('', fetchNames);\n  return fetchNames;\n}\n\nexport async function isExpressionComplete(expression: string): Promise<boolean> {\n  const currentExecutionContext = UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n  if (!currentExecutionContext) {\n    return true;\n  }\n  const result =\n      await currentExecutionContext.runtimeModel.compileScript(expression, '', false, currentExecutionContext.id);\n  if (!result || !result.exceptionDetails || !result.exceptionDetails.exception) {\n    return true;\n  }\n  const description = result.exceptionDetails.exception.description;\n  if (description) {\n    return !description.startsWith('SyntaxError: Unexpected end of input') &&\n        !description.startsWith('SyntaxError: Unterminated template literal');\n  }\n  return false;\n}\n\nexport function argumentHints(): ArgumentHintsTooltip {\n  return cursorTooltip(getArgumentHints);\n}\n\nexport function closeArgumentsHintsTooltip(\n    view: CodeMirror.EditorView, tooltip: CodeMirror.StateField<CodeMirror.Tooltip|null>): boolean {\n  // If the tooltip is currently showing, the state will reflect its properties.\n  // If it isn't showing, the state is explicitly set to `null`.\n  if (view.state.field(tooltip) === null) {\n    return false;\n  }\n  view.dispatch({effects: closeTooltip.of(null)});\n  return true;\n}\n\nasync function getArgumentHints(\n    state: CodeMirror.EditorState, pos: number): Promise<(() => CodeMirror.TooltipView)|null> {\n  const node = CodeMirror.syntaxTree(state).resolveInner(pos).enterUnfinishedNodesBefore(pos);\n\n  if (node.name !== 'ArgList') {\n    return null;\n  }\n  const callee = node.parent?.getChild('Expression');\n  if (!callee) {\n    return null;\n  }\n  const argumentList = await getArgumentsForExpression(callee, state.doc);\n  if (!argumentList) {\n    return null;\n  }\n\n  let argumentIndex = 0;\n  for (let scanPos = pos;;) {\n    const before = node.childBefore(scanPos);\n    if (!before) {\n      break;\n    }\n    if (before.type.is('Expression')) {\n      argumentIndex++;\n    }\n    scanPos = before.from;\n  }\n  return (): {dom: HTMLElement} => tooltipBuilder(argumentList, argumentIndex);\n}\n\nasync function getArgumentsForExpression(\n    callee: CodeMirror.SyntaxNode, doc: CodeMirror.Text): Promise<string[][]|null> {\n  const context = getExecutionContext();\n  if (!context) {\n    return null;\n  }\n  const expression = doc.sliceString(callee.from, callee.to);\n  const result = await evaluateExpression(context, expression, 'argumentsHint');\n  if (!result || result.type !== 'function') {\n    return null;\n  }\n  const objGetter = async(): Promise<SDK.RemoteObject.RemoteObject|null> => {\n    const first = callee.firstChild;\n    if (!first || callee.name !== 'MemberExpression') {\n      return null;\n    }\n    return evaluateExpression(context, doc.sliceString(first.from, first.to), 'argumentsHint');\n  };\n  return getArgumentsForFunctionValue(result, objGetter, expression)\n      .finally(() => context.runtimeModel.releaseObjectGroup('argumentsHint'));\n}\n\nasync function getArgumentsForFunctionValue(\n    object: SDK.RemoteObject.RemoteObject,\n    receiverObjGetter: () => Promise<SDK.RemoteObject.RemoteObject|null>,\n    functionName?: string,\n    ): Promise<string[][]|null> {\n  const description = object.description;\n  if (!description) {\n    return null;\n  }\n  if (!description.endsWith('{ [native code] }')) {\n    return [await Formatter.FormatterWorkerPool.formatterWorkerPool().argumentsList(description)];\n  }\n\n  // Check if this is a bound function.\n  if (description === 'function () { [native code] }') {\n    const fromBound = await getArgumentsForBoundFunction(object);\n    if (fromBound) {\n      return fromBound;\n    }\n  }\n\n  const javaScriptMetadata = JavaScriptMetaData.JavaScriptMetadata.JavaScriptMetadataImpl.instance();\n\n  const descriptionRegexResult = /^function ([^(]*)\\(/.exec(description);\n  const name = descriptionRegexResult && descriptionRegexResult[1] || functionName;\n  if (!name) {\n    return null;\n  }\n  const uniqueSignatures = javaScriptMetadata.signaturesForNativeFunction(name);\n  if (uniqueSignatures) {\n    return uniqueSignatures;\n  }\n  const receiverObj = await receiverObjGetter();\n  if (!receiverObj) {\n    return null;\n  }\n  const className = receiverObj.className;\n  if (className) {\n    const instanceMethods = javaScriptMetadata.signaturesForInstanceMethod(name, className);\n    if (instanceMethods) {\n      return instanceMethods;\n    }\n  }\n\n  // Check for static methods on a constructor.\n  if (receiverObj.description && receiverObj.type === 'function' &&\n      receiverObj.description.endsWith('{ [native code] }')) {\n    const receiverDescriptionRegexResult = /^function ([^(]*)\\(/.exec(receiverObj.description);\n    if (receiverDescriptionRegexResult) {\n      const receiverName = receiverDescriptionRegexResult[1];\n      const staticSignatures = javaScriptMetadata.signaturesForStaticMethod(name, receiverName);\n      if (staticSignatures) {\n        return staticSignatures;\n      }\n    }\n  }\n\n  for (const proto of await prototypesFromObject(receiverObj)) {\n    const instanceSignatures = javaScriptMetadata.signaturesForInstanceMethod(name, proto);\n    if (instanceSignatures) {\n      return instanceSignatures;\n    }\n  }\n  return null;\n}\n\nasync function prototypesFromObject(object: SDK.RemoteObject.RemoteObject): Promise<string[]> {\n  if (object.type === 'number') {\n    return ['Number', 'Object'];\n  }\n  if (object.type === 'string') {\n    return ['String', 'Object'];\n  }\n  if (object.type === 'symbol') {\n    return ['Symbol', 'Object'];\n  }\n  if (object.type === 'bigint') {\n    return ['BigInt', 'Object'];\n  }\n  if (object.type === 'boolean') {\n    return ['Boolean', 'Object'];\n  }\n  if (object.type === 'undefined' || object.subtype === 'null') {\n    return [];\n  }\n  return await object.callFunctionJSON(function() {\n    const result = [];\n    for (let object: Object = this; object; object = Object.getPrototypeOf(object)) {\n      if (typeof object === 'object' && object.constructor && object.constructor.name) {\n        result[result.length] = object.constructor.name;\n      }\n    }\n    return result;\n  }, []);\n}\n\n// Given a function object that is probably a bound function, try to\n// retrieve the argument list from its target function.\nasync function getArgumentsForBoundFunction(object: SDK.RemoteObject.RemoteObject): Promise<string[][]|null> {\n  const {internalProperties} = await object.getOwnProperties(false);\n  if (!internalProperties) {\n    return null;\n  }\n  const target = internalProperties.find(p => p.name === '[[TargetFunction]]')?.value;\n  const args = internalProperties.find(p => p.name === '[[BoundArgs]]')?.value;\n  const thisValue = internalProperties.find(p => p.name === '[[BoundThis]]')?.value;\n  if (!thisValue || !target || !args) {\n    return null;\n  }\n  const originalSignatures = await getArgumentsForFunctionValue(target, () => Promise.resolve(thisValue));\n  const boundArgsLength = SDK.RemoteObject.RemoteObject.arrayLength(args);\n  if (!originalSignatures) {\n    return null;\n  }\n  return originalSignatures.map(signature => {\n    const restIndex = signature.findIndex(arg => arg.startsWith('...'));\n    return restIndex > -1 && restIndex < boundArgsLength ? signature.slice(restIndex) :\n                                                           signature.slice(boundArgsLength);\n  });\n}\n\nfunction tooltipBuilder(signatures: string[][], currentIndex: number): {dom: HTMLElement} {\n  const tooltip = document.createElement('div');\n  tooltip.className = 'cm-argumentHints';\n  for (const args of signatures) {\n    const argumentsElement = document.createElement('span');\n    for (let i = 0; i < args.length; i++) {\n      if (i === currentIndex || (i < currentIndex && args[i].startsWith('...'))) {\n        const argElement = argumentsElement.appendChild(document.createElement('b'));\n        argElement.appendChild(document.createTextNode(args[i]));\n      } else {\n        argumentsElement.appendChild(document.createTextNode(args[i]));\n      }\n      if (i < args.length - 1) {\n        argumentsElement.appendChild(document.createTextNode(', '));\n      }\n    }\n    const signatureElement = tooltip.appendChild(document.createElement('div'));\n    signatureElement.className = 'source-code';\n    signatureElement.appendChild(document.createTextNode('\\u0192('));\n    signatureElement.appendChild(argumentsElement);\n    signatureElement.appendChild(document.createTextNode(')'));\n  }\n  return {dom: tooltip};\n}\n"],
  "mappings": "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",
  "names": []
}
