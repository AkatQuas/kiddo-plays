{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/helpers/scheduled-render.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\nconst pendingRenders = new WeakSet<HTMLElement>();\nconst activeRenders = new WeakSet<HTMLElement>();\nconst subsequentRender = new WeakMap<HTMLElement, () => void>();\nconst wrappedCallbacks = new WeakMap<() => void, () => void>();\nexport async function scheduleRender(component: HTMLElement, callback: () => void): Promise<void> {\n  // If scheduleRender is called when there is already a render scheduled for this\n  // component, store the callback against the renderer for after the current\n  // call has finished.\n  if (activeRenders.has(component)) {\n    subsequentRender.set(component, callback);\n    return;\n  }\n\n  // If this render was already scheduled but hasn't started yet, just return.\n  if (pendingRenders.has(component)) {\n    return;\n  }\n\n  pendingRenders.add(component);\n\n  // Create a wrapper around the callback so that we know that it has moved from\n  // pending to active. When it has completed we remove it from the active renderers.\n  let wrappedCallback = wrappedCallbacks.get(callback);\n  if (!wrappedCallback) {\n    wrappedCallback = async(): Promise<void> => {\n      pendingRenders.delete(component);\n      activeRenders.add(component);\n      await callback.call(component);\n      activeRenders.delete(component);\n    };\n\n    // Store it for next time so we aren't creating wrappers unnecessarily.\n    wrappedCallbacks.set(callback, wrappedCallback);\n  }\n\n  // Track that there is render rendering, wait for it to finish, and stop tracking.\n  await coordinator.write(wrappedCallback);\n\n  // If during the render there was another schedule render call, get\n  // the callback and schedule it to happen now.\n  if (subsequentRender.has(component)) {\n    const newCallback = subsequentRender.get(component);\n    subsequentRender.delete(component);\n    if (!newCallback) {\n      return;\n    }\n\n    void scheduleRender(component, newCallback);\n  }\n}\n\nexport function isScheduledRender(component: HTMLElement): boolean {\n  return activeRenders.has(component);\n}\n"],
  "mappings": "AAGA;AAEA,MAAM,cAAc,YAAY,kBAAkB,kBAAkB;AACpE,MAAM,iBAAiB,oBAAI;AAC3B,MAAM,gBAAgB,oBAAI;AAC1B,MAAM,mBAAmB,oBAAI;AAC7B,MAAM,mBAAmB,oBAAI;AAC7B,qCAAqC,WAAwB,UAAqC;AAIhG,MAAI,cAAc,IAAI,YAAY;AAChC,qBAAiB,IAAI,WAAW;AAChC;AAAA;AAIF,MAAI,eAAe,IAAI,YAAY;AACjC;AAAA;AAGF,iBAAe,IAAI;AAInB,MAAI,kBAAkB,iBAAiB,IAAI;AAC3C,MAAI,CAAC,iBAAiB;AACpB,sBAAkB,YAA0B;AAC1C,qBAAe,OAAO;AACtB,oBAAc,IAAI;AAClB,YAAM,SAAS,KAAK;AACpB,oBAAc,OAAO;AAAA;AAIvB,qBAAiB,IAAI,UAAU;AAAA;AAIjC,QAAM,YAAY,MAAM;AAIxB,MAAI,iBAAiB,IAAI,YAAY;AACnC,UAAM,cAAc,iBAAiB,IAAI;AACzC,qBAAiB,OAAO;AACxB,QAAI,CAAC,aAAa;AAChB;AAAA;AAGF,SAAK,eAAe,WAAW;AAAA;AAAA;AAI5B,kCAA2B,WAAiC;AACjE,SAAO,cAAc,IAAI;AAAA;",
  "names": []
}
