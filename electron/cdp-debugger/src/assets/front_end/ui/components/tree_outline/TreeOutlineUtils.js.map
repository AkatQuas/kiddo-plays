{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/tree_outline/TreeOutlineUtils.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\n\nexport type TreeNodeId = string;\n\ninterface BaseTreeNode<TreeNodeDataType> {\n  treeNodeData: TreeNodeDataType;\n  renderer?: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => LitHtml.TemplateResult;\n  id: TreeNodeId;\n}\n\nexport interface TreeNodeWithChildren<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children: () => Promise<TreeNode<TreeNodeDataType>[]>;\n}\n\ninterface LeafNode<TreeNodeDataType> extends BaseTreeNode<TreeNodeDataType> {\n  children?: never;\n}\n\nexport type TreeNode<TreeNodeDataType> = TreeNodeWithChildren<TreeNodeDataType>|LeafNode<TreeNodeDataType>;\n\nexport function isExpandableNode<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>):\n    node is TreeNodeWithChildren<TreeNodeDataType> {\n  return 'children' in node;\n}\n\n/**\n * This is a custom lit-html directive that lets us track the DOM nodes that Lit\n * creates and maps them to the tree node that was given to us. This means we\n * can navigate between real DOM node and structural tree node easily in code.\n */\n\nclass TrackDOMNodeToTreeNode extends LitHtml.Directive.Directive {\n  constructor(partInfo: LitHtml.Directive.PartInfo) {\n    super(partInfo);\n\n    if (partInfo.type !== LitHtml.Directive.PartType.ATTRIBUTE) {\n      throw new Error('TrackDOMNodeToTreeNode directive must be used as an attribute.');\n    }\n  }\n\n  update(part: LitHtml.Directive.ElementPart, [weakMap, treeNode]: LitHtml.Directive.DirectiveParameters<this>): void {\n    const elem = part.element;\n    if (!(elem instanceof HTMLLIElement)) {\n      throw new Error('trackTreeNodeToDOMNode must be used on <li> elements.');\n    }\n    weakMap.set(elem, treeNode);\n  }\n\n  /*\n   * Because this directive doesn't render anything, there's no implementation\n   * here for the render method. But we need it to state the params the\n   * directive takes so the update() method's types are correct. Unfortunately\n   * we have to pass any as the generic type because we can't define this class\n   * using a generic - the generic gets lost when wrapped in the directive call\n   * below.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  render(_weakmap: WeakMap<HTMLLIElement, TreeNode<any>>, _treeNode: TreeNode<any>): void {\n  }\n}\n\nexport const trackDOMNodeToTreeNode = LitHtml.Directive.directive(TrackDOMNodeToTreeNode);\n\n/**\n * Finds the next sibling of the node's parent, recursing up the tree if\n * required.\n * Given:\n * A\n *   * B\n *     * C\n * D\n * If called on B, this will return D. If called on C, this will also return D.\n */\nconst findNextParentSibling = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  // We go up two parents here because the structure is:\n  // <li treeitem> => <ul group> => <li treeitem>\n  // So if we are on the last treeitem (furthest to the right), we need to find its parent tree item, which is two parents up.\n  const currentDOMNodeParentListItem = currentDOMNode.parentElement?.parentElement;\n\n  if (currentDOMNodeParentListItem && currentDOMNodeParentListItem instanceof HTMLLIElement) {\n    const parentNodeSibling = currentDOMNodeParentListItem.nextElementSibling;\n    // If this parent doesn't have a sibling, recurse up the tree to look for\n    // the nearest parent that does have a sibling.\n    if (parentNodeSibling && parentNodeSibling instanceof HTMLLIElement) {\n      return parentNodeSibling;\n    }\n    return findNextParentSibling(currentDOMNodeParentListItem);\n  }\n  return null;\n};\n\nconst getFirstChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const firstChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:first-child');\n  if (!firstChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n  return firstChild;\n};\n\nconst domNodeIsExpandable = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNode.getAttribute('aria-expanded') !== null;\n};\n\nconst domNodeIsLeafNode = (domNode: HTMLLIElement): boolean => {\n  return !domNodeIsExpandable(domNode);\n};\n\nconst domNodeIsExpanded = (domNode: HTMLLIElement): boolean => {\n  // Nodes with no children are not given the aria-expanded attributes.\n  // Nodes with children are given aria-expanded = true/false.\n  return domNodeIsExpandable(domNode) && domNode.getAttribute('aria-expanded') === 'true';\n};\n\nconst getDeepLastChildOfExpandedTreeNode = (currentDOMNode: HTMLLIElement): HTMLLIElement => {\n  const lastChild =\n      currentDOMNode.querySelector<HTMLLIElement>(':scope > [role=\"group\"] > [role=\"treeitem\"]:last-child');\n  if (!lastChild) {\n    throw new Error('Could not find child of expanded node.');\n  }\n\n  if (domNodeIsExpanded(lastChild)) {\n    return getDeepLastChildOfExpandedTreeNode(lastChild);\n  }\n  return lastChild;\n};\n\nconst getNextSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.nextElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getPreviousSiblingOfCurrentDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  const currentNodeSibling = currentDOMNode.previousElementSibling;\n  if (currentNodeSibling && currentNodeSibling instanceof HTMLLIElement) {\n    return currentNodeSibling;\n  }\n  return null;\n};\n\nconst getParentListItemForDOMNode = (currentDOMNode: HTMLLIElement): HTMLLIElement|null => {\n  let parentNode = currentDOMNode.parentElement;\n  if (!parentNode) {\n    return null;\n  }\n  while (parentNode && parentNode.getAttribute('role') !== 'treeitem' &&\n         (parentNode instanceof HTMLLIElement) === false) {\n    parentNode = parentNode.parentElement;\n  }\n  return parentNode as HTMLLIElement;\n};\n\n/**\n * We cache a tree node's children; they are lazily evaluated and if two code\n * paths get the children, we need to make sure they get the same objects.\n *\n * We're OK to use <unknown> here as the weakmap doesn't care and a TreeOutline that\n * adds nodes of type X to the map will always then get children of that type\n * back as that's enforced by the TreeOutline types elsewhere. We can't make\n * this WeakMap easily generic as it's a top level variable.\n */\nconst treeNodeChildrenWeakMap = new WeakMap<TreeNode<unknown>, TreeNode<unknown>[]>();\nexport const getNodeChildren =\n    async<TreeNodeDataType>(node: TreeNode<TreeNodeDataType>): Promise<TreeNode<TreeNodeDataType>[]> => {\n  if (!node.children) {\n    throw new Error('Asked for children of node that does not have any children.');\n  }\n\n  const cachedChildren = treeNodeChildrenWeakMap.get(node as TreeNode<unknown>);\n  if (cachedChildren) {\n    return cachedChildren as unknown as TreeNode<TreeNodeDataType>[];\n  }\n\n  const children = await node.children();\n  treeNodeChildrenWeakMap.set(node as TreeNode<unknown>, children as TreeNode<unknown>[]);\n  return children;\n};\n\n/**\n * Searches the tree and returns a path to the given node.\n * e.g. if the tree is:\n * A\n * - B\n *   - C\n * - D\n *   - E\n *   - F\n *\n * And you look for F, you'll get back [A, D, F]\n */\nexport const getPathToTreeNode =\n    async<TreeNodeDataType>(tree: readonly TreeNode<TreeNodeDataType>[], nodeIdToFind: TreeNodeId):\n        Promise<TreeNode<TreeNodeDataType>[]|null> => {\n          for (const rootNode of tree) {\n            const foundPathOrNull = await getPathToTreeNodeRecursively(rootNode, nodeIdToFind, [rootNode]);\n            if (foundPathOrNull !== null) {\n              return foundPathOrNull;\n            }\n          }\n          return null;\n        };\n\nconst getPathToTreeNodeRecursively = async<TreeNodeDataType>(\n    currentNode: TreeNode<TreeNodeDataType>, nodeIdToFind: TreeNodeId,\n    pathToNode: TreeNode<TreeNodeDataType>[]): Promise<TreeNode<TreeNodeDataType>[]|null> => {\n  if (currentNode.id === nodeIdToFind) {\n    return pathToNode;\n  }\n\n  if (currentNode.children) {\n    const children = await getNodeChildren(currentNode);\n    for (const child of children) {\n      const foundPathOrNull = await getPathToTreeNodeRecursively(child, nodeIdToFind, [...pathToNode, child]);\n      if (foundPathOrNull !== null) {\n        return foundPathOrNull;\n      }\n    }\n  }\n  return null;\n};\n\ninterface KeyboardNavigationOptions<TreeNodeDataType> {\n  currentDOMNode: HTMLLIElement;\n  currentTreeNode: TreeNode<TreeNodeDataType>;\n  direction: Platform.KeyboardUtilities.ArrowKey;\n  setNodeExpandedState: (treeNode: TreeNode<TreeNodeDataType>, expanded: boolean) => void;\n}\n\nexport const findNextNodeForTreeOutlineKeyboardNavigation =\n    <TreeNodeDataType>(options: KeyboardNavigationOptions<TreeNodeDataType>): HTMLLIElement => {\n      const {\n        currentDOMNode,\n        currentTreeNode,\n        direction,\n        setNodeExpandedState,\n      } = options;\n      if (!currentTreeNode) {\n        return currentDOMNode;\n      }\n\n      if (direction === Platform.KeyboardUtilities.ArrowKey.DOWN) {\n        // If the node has expanded children, down takes you into that list.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // If the node has a sibling, we go to that.\n        const currentNodeSibling = getNextSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodeSibling) {\n          return currentNodeSibling;\n        }\n\n        // If the Node's parent has a sibling then we go to that.\n        const parentSibling = findNextParentSibling(currentDOMNode);\n        if (parentSibling) {\n          return parentSibling;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.RIGHT) {\n        if (domNodeIsLeafNode(currentDOMNode)) {\n          // If the node cannot be expanded, we have nothing to do and we leave everything as is.\n          return currentDOMNode;\n        }\n\n        // If the current node is expanded, move and focus into the first child\n        if (domNodeIsExpanded(currentDOMNode)) {\n          return getFirstChildOfExpandedTreeNode(currentDOMNode);\n        }\n        // Else, we expand the Node (but leave focus where it is)\n        setNodeExpandedState(currentTreeNode, true);\n        return currentDOMNode;\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.UP) {\n        // First see if there is a previous sibling\n        const currentNodePreviousSibling = getPreviousSiblingOfCurrentDOMNode(currentDOMNode);\n        if (currentNodePreviousSibling) {\n          // We now find the nested node within our previous sibling; if it has\n          // children that are expanded, we want to find the last child and\n          // highlight that, else we'll highlight our sibling directly.\n          if (domNodeIsExpanded(currentNodePreviousSibling)) {\n            return getDeepLastChildOfExpandedTreeNode(currentNodePreviousSibling);\n          }\n          // Otherwise, if we have a previous sibling with no children, focus it.\n          return currentNodePreviousSibling;\n        }\n\n        // Otherwise, let's go to the direct parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      } else if (direction === Platform.KeyboardUtilities.ArrowKey.LEFT) {\n        // If the node is expanded, we close it.\n        if (domNodeIsExpanded(currentDOMNode)) {\n          setNodeExpandedState(currentTreeNode, false);\n          return currentDOMNode;\n        }\n\n        // Otherwise, let's go to the parent if there is one.\n        const parentNode = getParentListItemForDOMNode(currentDOMNode);\n        if (parentNode && parentNode instanceof HTMLLIElement) {\n          return parentNode;\n        }\n      }\n\n      // If we got here, there's no other option than to stay put.\n      return currentDOMNode;\n    };\n"],
  "mappings": "AAGA;AACA;AAoBO,iCAA4C,MACA;AACjD,SAAO,cAAc;AAAA;AASvB,qCAAqC,QAAQ,UAAU,UAAU;AAAA,EAC/D,YAAY,UAAsC;AAChD,UAAM;AAEN,QAAI,SAAS,SAAS,QAAQ,UAAU,SAAS,WAAW;AAC1D,YAAM,IAAI,MAAM;AAAA;AAAA;AAAA,EAIpB,OAAO,MAAqC,CAAC,SAAS,WAA8D;AAClH,UAAM,OAAO,KAAK;AAClB,QAAI,CAAE,iBAAgB,gBAAgB;AACpC,YAAM,IAAI,MAAM;AAAA;AAElB,YAAQ,IAAI,MAAM;AAAA;AAAA,EAYpB,OAAO,UAAiD,WAAgC;AAAA;AAAA;AAInF,aAAM,yBAAyB,QAAQ,UAAU,UAAU;AAYlE,MAAM,wBAAwB,CAAC,mBAAsD;AAInF,QAAM,+BAA+B,eAAe,eAAe;AAEnE,MAAI,gCAAgC,wCAAwC,eAAe;AACzF,UAAM,oBAAoB,6BAA6B;AAGvD,QAAI,qBAAqB,6BAA6B,eAAe;AACnE,aAAO;AAAA;AAET,WAAO,sBAAsB;AAAA;AAE/B,SAAO;AAAA;AAGT,MAAM,kCAAkC,CAAC,mBAAiD;AACxF,QAAM,aACF,eAAe,cAA6B;AAChD,MAAI,CAAC,YAAY;AACf,UAAM,IAAI,MAAM;AAAA;AAElB,SAAO;AAAA;AAGT,MAAM,sBAAsB,CAAC,YAAoC;AAG/D,SAAO,QAAQ,aAAa,qBAAqB;AAAA;AAGnD,MAAM,oBAAoB,CAAC,YAAoC;AAC7D,SAAO,CAAC,oBAAoB;AAAA;AAG9B,MAAM,oBAAoB,CAAC,YAAoC;AAG7D,SAAO,oBAAoB,YAAY,QAAQ,aAAa,qBAAqB;AAAA;AAGnF,MAAM,qCAAqC,CAAC,mBAAiD;AAC3F,QAAM,YACF,eAAe,cAA6B;AAChD,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM;AAAA;AAGlB,MAAI,kBAAkB,YAAY;AAChC,WAAO,mCAAmC;AAAA;AAE5C,SAAO;AAAA;AAGT,MAAM,iCAAiC,CAAC,mBAAsD;AAC5F,QAAM,qBAAqB,eAAe;AAC1C,MAAI,sBAAsB,8BAA8B,eAAe;AACrE,WAAO;AAAA;AAET,SAAO;AAAA;AAGT,MAAM,qCAAqC,CAAC,mBAAsD;AAChG,QAAM,qBAAqB,eAAe;AAC1C,MAAI,sBAAsB,8BAA8B,eAAe;AACrE,WAAO;AAAA;AAET,SAAO;AAAA;AAGT,MAAM,8BAA8B,CAAC,mBAAsD;AACzF,MAAI,aAAa,eAAe;AAChC,MAAI,CAAC,YAAY;AACf,WAAO;AAAA;AAET,SAAO,cAAc,WAAW,aAAa,YAAY,cACjD,sBAAsB,kBAAmB,OAAO;AACtD,iBAAa,WAAW;AAAA;AAE1B,SAAO;AAAA;AAYT,MAAM,0BAA0B,oBAAI;AAC7B,aAAM,kBACT,OAAwB,SAA4E;AACtG,MAAI,CAAC,KAAK,UAAU;AAClB,UAAM,IAAI,MAAM;AAAA;AAGlB,QAAM,iBAAiB,wBAAwB,IAAI;AACnD,MAAI,gBAAgB;AAClB,WAAO;AAAA;AAGT,QAAM,WAAW,MAAM,KAAK;AAC5B,0BAAwB,IAAI,MAA2B;AACvD,SAAO;AAAA;AAeF,aAAM,oBACT,OAAwB,MAA6C,iBACnB;AAC5C,aAAW,YAAY,MAAM;AAC3B,UAAM,kBAAkB,MAAM,6BAA6B,UAAU,cAAc,CAAC;AACpF,QAAI,oBAAoB,MAAM;AAC5B,aAAO;AAAA;AAAA;AAGX,SAAO;AAAA;AAGjB,MAAM,+BAA+B,OACjC,aAAyC,cACzC,eAAyF;AAC3F,MAAI,YAAY,OAAO,cAAc;AACnC,WAAO;AAAA;AAGT,MAAI,YAAY,UAAU;AACxB,UAAM,WAAW,MAAM,gBAAgB;AACvC,eAAW,SAAS,UAAU;AAC5B,YAAM,kBAAkB,MAAM,6BAA6B,OAAO,cAAc,CAAC,GAAG,YAAY;AAChG,UAAI,oBAAoB,MAAM;AAC5B,eAAO;AAAA;AAAA;AAAA;AAIb,SAAO;AAAA;AAUF,aAAM,+CACT,CAAmB,YAAwE;AACzF,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,MACE;AACJ,MAAI,CAAC,iBAAiB;AACpB,WAAO;AAAA;AAGT,MAAI,cAAc,SAAS,kBAAkB,SAAS,MAAM;AAE1D,QAAI,kBAAkB,iBAAiB;AACrC,aAAO,gCAAgC;AAAA;AAGzC,UAAM,qBAAqB,+BAA+B;AAC1D,QAAI,oBAAoB;AACtB,aAAO;AAAA;AAIT,UAAM,gBAAgB,sBAAsB;AAC5C,QAAI,eAAe;AACjB,aAAO;AAAA;AAAA,aAEA,cAAc,SAAS,kBAAkB,SAAS,OAAO;AAClE,QAAI,kBAAkB,iBAAiB;AAErC,aAAO;AAAA;AAIT,QAAI,kBAAkB,iBAAiB;AACrC,aAAO,gCAAgC;AAAA;AAGzC,yBAAqB,iBAAiB;AACtC,WAAO;AAAA,aACE,cAAc,SAAS,kBAAkB,SAAS,IAAI;AAE/D,UAAM,6BAA6B,mCAAmC;AACtE,QAAI,4BAA4B;AAI9B,UAAI,kBAAkB,6BAA6B;AACjD,eAAO,mCAAmC;AAAA;AAG5C,aAAO;AAAA;AAIT,UAAM,aAAa,4BAA4B;AAC/C,QAAI,cAAc,sBAAsB,eAAe;AACrD,aAAO;AAAA;AAAA,aAEA,cAAc,SAAS,kBAAkB,SAAS,MAAM;AAEjE,QAAI,kBAAkB,iBAAiB;AACrC,2BAAqB,iBAAiB;AACtC,aAAO;AAAA;AAIT,UAAM,aAAa,4BAA4B;AAC/C,QAAI,cAAc,sBAAsB,eAAe;AACrD,aAAO;AAAA;AAAA;AAKX,SAAO;AAAA;",
  "names": []
}
