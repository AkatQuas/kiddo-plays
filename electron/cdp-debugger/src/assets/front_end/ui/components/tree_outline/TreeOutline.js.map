{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/tree_outline/TreeOutline.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as LitHtml from '../../lit-html/lit-html.js';\nimport * as CodeHighlighter from '../code_highlighter/code_highlighter.js';\nimport * as ComponentHelpers from '../helpers/helpers.js';\nimport * as Coordinator from '../render_coordinator/render_coordinator.js';\n\nimport treeOutlineStyles from './treeOutline.css.js';\n\nimport type {TreeNodeId, TreeNode, TreeNodeWithChildren} from './TreeOutlineUtils.js';\nimport {\n  findNextNodeForTreeOutlineKeyboardNavigation,\n  getNodeChildren,\n  getPathToTreeNode,\n  isExpandableNode,\n  trackDOMNodeToTreeNode,\n} from './TreeOutlineUtils.js';\n\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nexport interface TreeOutlineData<TreeNodeDataType> {\n  defaultRenderer: (node: TreeNode<TreeNodeDataType>, state: {isExpanded: boolean}) => LitHtml.TemplateResult;\n  /**\n   * Note: it is important that all the TreeNode objects are unique. They are\n   * used internally to the TreeOutline as keys to track state (such as if a\n   * node is expanded or not), and providing the same object multiple times will\n   * cause issues in the TreeOutline.\n   */\n  tree: readonly TreeNode<TreeNodeDataType>[];\n  filter?: (node: TreeNodeDataType) => FilterOption;\n  compact?: boolean;\n}\n\nexport function defaultRenderer(node: TreeNode<string>): LitHtml.TemplateResult {\n  return LitHtml.html`${node.treeNodeData}`;\n}\n\nexport class ItemSelectedEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemselected';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemSelectedEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOverEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseover';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOverEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\nexport class ItemMouseOutEvent<TreeNodeDataType> extends Event {\n  static readonly eventName = 'itemmouseout';\n  data: {\n    node: TreeNode<TreeNodeDataType>,\n  };\n\n  constructor(node: TreeNode<TreeNodeDataType>) {\n    super(ItemMouseOutEvent.eventName, {bubbles: true, composed: true});\n    this.data = {node};\n  }\n}\n\n/**\n *\n * The tree can be filtered by providing a custom filter function.\n * The filter is applied on every node when constructing the tree\n * and proceeds as follows:\n * - If the filter return SHOW for a node, the node is included in the tree.\n * - If the filter returns FLATTEN, the node is ignored but its subtree is included.\n */\nexport const enum FilterOption {\n  SHOW = 'SHOW',\n  FLATTEN = 'FLATTEN',\n}\n\nexport class TreeOutline<TreeNodeDataType> extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-tree-outline`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  #treeData: readonly TreeNode<TreeNodeDataType>[] = [];\n  #nodeExpandedMap: Map<string, boolean> = new Map();\n  #domNodeToTreeNodeMap: WeakMap<HTMLLIElement, TreeNode<TreeNodeDataType>> = new WeakMap();\n  #hasRenderedAtLeastOnce = false;\n  /**\n   * If we have expanded to a certain node, we want to focus it once we've\n   * rendered. But we render lazily and wrapped in LitHtml.until, so we can't\n   * know for sure when that node will be rendered. This variable tracks the\n   * node that we want focused but may not yet have been rendered.\n   */\n  #nodeIdPendingFocus: TreeNodeId|null = null;\n  #selectedTreeNode: TreeNode<TreeNodeDataType>|null = null;\n  #defaultRenderer = (node: TreeNode<TreeNodeDataType>, _state: {isExpanded: boolean}): LitHtml.TemplateResult => {\n    if (typeof node.treeNodeData !== 'string') {\n      console.warn(`The default TreeOutline renderer simply stringifies its given value. You passed in ${\n          JSON.stringify(\n              node.treeNodeData, null,\n              2)}. Consider providing a different defaultRenderer that can handle nodes of this type.`);\n    }\n    return LitHtml.html`${String(node.treeNodeData)}`;\n  };\n  #nodeFilter?: ((node: TreeNodeDataType) => FilterOption);\n  #compact = false;\n\n  /**\n   * scheduledRender = render() has been called and scheduled a render.\n   */\n  #scheduledRender = false;\n  /**\n   * enqueuedRender = render() was called mid-way through an existing render.\n   */\n  #enqueuedRender = false;\n\n  static get observedAttributes(): string[] {\n    return ['nowrap', 'toplevelbordercolor'];\n  }\n\n  attributeChangedCallback(name: 'nowrap'|'toplevelbordercolor', oldValue: string|null, newValue: string|null): void {\n    switch (name) {\n      case 'nowrap': {\n        this.#setNodeKeyNoWrapCSSVariable(newValue);\n        break;\n      }\n      case 'toplevelbordercolor': {\n        this.#setTopLevelNodeBorderColorCSSVariable(newValue);\n        break;\n      }\n    }\n  }\n\n  connectedCallback(): void {\n    this.#setTopLevelNodeBorderColorCSSVariable(this.getAttribute('toplevelbordercolor'));\n    this.#setNodeKeyNoWrapCSSVariable(this.getAttribute('nowrap'));\n    this.#shadow.adoptedStyleSheets = [treeOutlineStyles, CodeHighlighter.Style.default];\n  }\n\n  get data(): TreeOutlineData<TreeNodeDataType> {\n    return {\n      tree: this.#treeData as TreeNode<TreeNodeDataType>[],\n      defaultRenderer: this.#defaultRenderer,\n    };\n  }\n\n  set data(data: TreeOutlineData<TreeNodeDataType>) {\n    this.#defaultRenderer = data.defaultRenderer;\n    this.#treeData = data.tree;\n    this.#nodeFilter = data.filter;\n    this.#compact = data.compact || false;\n\n    if (!this.#hasRenderedAtLeastOnce) {\n      this.#selectedTreeNode = this.#treeData[0];\n    }\n    void this.#render();\n  }\n\n  /**\n   * Recursively expands the tree from the root nodes, to a max depth. The max\n   * depth is 0 indexed - so a maxDepth of 2 (default) will expand 3 levels: 0,\n   * 1 and 2.\n   */\n  async expandRecursively(maxDepth = 2): Promise<void> {\n    await Promise.all(this.#treeData.map(rootNode => this.#expandAndRecurse(rootNode, 0, maxDepth)));\n    await this.#render();\n  }\n\n  /**\n   * Collapses all nodes in the tree.\n   */\n  async collapseAllNodes(): Promise<void> {\n    this.#nodeExpandedMap.clear();\n    await this.#render();\n  }\n\n  /**\n   * Takes a TreeNode, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNode(targetTreeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    return this.expandToAndSelectTreeNodeId(targetTreeNode.id);\n  }\n\n  /**\n   * Takes a TreeNode ID, expands the outline to reveal it, and focuses it.\n   */\n  async expandToAndSelectTreeNodeId(targetTreeNodeId: TreeNodeId): Promise<void> {\n    const pathToTreeNode = await getPathToTreeNode(this.#treeData, targetTreeNodeId);\n\n    if (pathToTreeNode === null) {\n      throw new Error(`Could not find node with id ${targetTreeNodeId} in the tree.`);\n    }\n    pathToTreeNode.forEach((node, index) => {\n      // We don't expand the very last node, which was the target node.\n      if (index < pathToTreeNode.length - 1) {\n        this.#setNodeExpandedState(node, true);\n      }\n    });\n\n    // Mark the node as pending focus so when it is rendered into the DOM we can focus it\n    this.#nodeIdPendingFocus = targetTreeNodeId;\n    await this.#render();\n  }\n\n  /**\n   * Takes a list of TreeNode IDs and expands the corresponding nodes.\n   */\n  expandNodeIds(nodeIds: TreeNodeId[]): Promise<void> {\n    nodeIds.forEach(id => this.#nodeExpandedMap.set(id, true));\n    return this.#render();\n  }\n\n  /**\n   * Takes a TreeNode ID and focuses the corresponding node.\n   */\n  focusNodeId(nodeId: TreeNodeId): Promise<void> {\n    this.#nodeIdPendingFocus = nodeId;\n    return this.#render();\n  }\n\n  async collapseChildrenOfNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    await this.#recursivelyCollapseTreeNodeChildren(treeNode);\n    await this.#render();\n  }\n\n  #setNodeKeyNoWrapCSSVariable(attributeValue: string|null): void {\n    ComponentHelpers.SetCSSProperty.set(\n        this, '--override-key-whitespace-wrapping', attributeValue !== null ? 'nowrap' : 'initial');\n  }\n\n  #setTopLevelNodeBorderColorCSSVariable(attributeValue: string|null): void {\n    ComponentHelpers.SetCSSProperty.set(\n        this, '--override-top-node-border', attributeValue ? `1px solid ${attributeValue}` : '');\n  }\n\n  async #recursivelyCollapseTreeNodeChildren(treeNode: TreeNode<TreeNodeDataType>): Promise<void> {\n    if (!isExpandableNode(treeNode) || !this.#nodeIsExpanded(treeNode)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(treeNode);\n    const childRecursions = Promise.all(children.map(child => this.#recursivelyCollapseTreeNodeChildren(child)));\n    await childRecursions;\n    this.#setNodeExpandedState(treeNode, false);\n  }\n\n  #getSelectedTreeNode(): TreeNode<TreeNodeDataType> {\n    if (!this.#selectedTreeNode) {\n      throw new Error('getSelectedNode was called but selectedTreeNode is null');\n    }\n    return this.#selectedTreeNode;\n  }\n\n  async #flattenSubtree(node: TreeNodeWithChildren<TreeNodeDataType>, filter: (node: TreeNodeDataType) => FilterOption):\n      Promise<TreeNode<TreeNodeDataType>[]> {\n    const children = await getNodeChildren(node);\n    const filteredChildren = [];\n    for (const child of children) {\n      const filtering = filter(child.treeNodeData);\n      // We always include the selected node in the tree, regardless of its filtering status.\n      const toBeSelected = this.#isSelectedNode(child) || child.id === this.#nodeIdPendingFocus;\n      // If a node is already expanded we should not flatten it away.\n      const expanded = this.#nodeExpandedMap.get(child.id);\n      if (filtering === FilterOption.SHOW || toBeSelected || expanded) {\n        filteredChildren.push(child);\n      } else if (filtering === FilterOption.FLATTEN && isExpandableNode(child)) {\n        const grandChildren = await this.#flattenSubtree(child, filter);\n        filteredChildren.push(...grandChildren);\n      }\n    }\n    return filteredChildren;\n  }\n\n  async #fetchNodeChildren(node: TreeNodeWithChildren<TreeNodeDataType>): Promise<TreeNode<TreeNodeDataType>[]> {\n    const children = await getNodeChildren(node);\n    const filter = this.#nodeFilter;\n    if (!filter) {\n      return children;\n    }\n    const filteredDescendants = await this.#flattenSubtree(node, filter);\n    return filteredDescendants.length ? filteredDescendants : children;\n  }\n\n  #setNodeExpandedState(node: TreeNode<TreeNodeDataType>, newExpandedState: boolean): void {\n    this.#nodeExpandedMap.set(node.id, newExpandedState);\n  }\n\n  #nodeIsExpanded(node: TreeNode<TreeNodeDataType>): boolean {\n    return this.#nodeExpandedMap.get(node.id) || false;\n  }\n\n  async #expandAndRecurse(node: TreeNode<TreeNodeDataType>, currentDepth: number, maxDepth: number): Promise<void> {\n    if (!isExpandableNode(node)) {\n      return;\n    }\n    this.#setNodeExpandedState(node, true);\n    if (currentDepth === maxDepth || !isExpandableNode(node)) {\n      return;\n    }\n    const children = await this.#fetchNodeChildren(node);\n    await Promise.all(children.map(child => this.#expandAndRecurse(child, currentDepth + 1, maxDepth)));\n  }\n\n  #onArrowClick(node: TreeNode<TreeNodeDataType>): ((e: Event) => void) {\n    return (event: Event): void => {\n      event.stopPropagation();\n      if (isExpandableNode(node)) {\n        this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n        void this.#render();\n      }\n    };\n  }\n\n  #onNodeClick(event: Event): void {\n    // Avoid it bubbling up to parent tree elements, else clicking a node deep in the tree will toggle it + all its ancestor's visibility.\n    event.stopPropagation();\n    const nodeClickExpandsOrContracts = this.getAttribute('clickabletitle') !== null;\n    const domNode = event.currentTarget as HTMLLIElement;\n    const node = this.#domNodeToTreeNodeMap.get(domNode);\n    if (nodeClickExpandsOrContracts && node && isExpandableNode(node)) {\n      this.#setNodeExpandedState(node, !this.#nodeIsExpanded(node));\n    }\n    void this.#focusTreeNode(domNode);\n  }\n\n  async #focusTreeNode(domNode: HTMLLIElement): Promise<void> {\n    const treeNode = this.#domNodeToTreeNodeMap.get(domNode);\n    if (!treeNode) {\n      return;\n    }\n    this.#selectedTreeNode = treeNode;\n    await this.#render();\n    this.dispatchEvent(new ItemSelectedEvent(treeNode));\n    void coordinator.write('DOMNode focus', () => {\n      domNode.focus();\n    });\n  }\n\n  #processHomeAndEndKeysNavigation(key: 'Home'|'End'): void {\n    if (key === 'Home') {\n      const firstRootNode = this.#shadow.querySelector<HTMLLIElement>('ul[role=\"tree\"] > li[role=\"treeitem\"]');\n      if (firstRootNode) {\n        void this.#focusTreeNode(firstRootNode);\n      }\n    } else if (key === 'End') {\n      /**\n       * The End key takes the user to the last visible node in the tree - you\n       * can think of this as the one that's rendered closest to the bottom of\n       * the page.\n       *\n       * We could walk our tree and compute this - but it will also be the last\n       * li[role=\"treeitem\"] in the DOM because we only render visible nodes.\n       * Therefore we can select all the nodes and pick the last one.\n       */\n      const allTreeItems = this.#shadow.querySelectorAll<HTMLLIElement>('li[role=\"treeitem\"]');\n      const lastTreeItem = allTreeItems[allTreeItems.length - 1];\n      if (lastTreeItem) {\n        void this.#focusTreeNode(lastTreeItem);\n      }\n    }\n  }\n\n  async #processArrowKeyNavigation(key: Platform.KeyboardUtilities.ArrowKey, currentDOMNode: HTMLLIElement):\n      Promise<void> {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n\n    const domNode = findNextNodeForTreeOutlineKeyboardNavigation({\n      currentDOMNode,\n      currentTreeNode,\n      direction: key,\n      setNodeExpandedState: (node, expanded) => this.#setNodeExpandedState(node, expanded),\n    });\n    await this.#focusTreeNode(domNode);\n  }\n\n  #processEnterOrSpaceNavigation(currentDOMNode: HTMLLIElement): void {\n    const currentTreeNode = this.#domNodeToTreeNodeMap.get(currentDOMNode);\n    if (!currentTreeNode) {\n      return;\n    }\n    if (isExpandableNode(currentTreeNode)) {\n      const currentExpandedState = this.#nodeIsExpanded(currentTreeNode);\n      this.#setNodeExpandedState(currentTreeNode, !currentExpandedState);\n      void this.#render();\n    }\n  }\n\n  async #onTreeKeyDown(event: KeyboardEvent): Promise<void> {\n    if (!(event.target instanceof HTMLLIElement)) {\n      throw new Error('event.target was not an <li> element');\n    }\n\n    if (event.key === 'Home' || event.key === 'End') {\n      event.preventDefault();\n      this.#processHomeAndEndKeysNavigation(event.key);\n    } else if (Platform.KeyboardUtilities.keyIsArrowKey(event.key)) {\n      event.preventDefault();\n      await this.#processArrowKeyNavigation(event.key, event.target);\n    } else if (event.key === 'Enter' || event.key === ' ') {\n      event.preventDefault();\n      this.#processEnterOrSpaceNavigation(event.target);\n    }\n  }\n\n  #focusPendingNode(domNode: HTMLLIElement): void {\n    this.#nodeIdPendingFocus = null;\n    void this.#focusTreeNode(domNode);\n  }\n\n  #isSelectedNode(node: TreeNode<TreeNodeDataType>): boolean {\n    if (this.#selectedTreeNode) {\n      return node.id === this.#selectedTreeNode.id;\n    }\n    return false;\n  }\n\n  #renderNode(node: TreeNode<TreeNodeDataType>, {depth, setSize, positionInSet}: {\n    depth: number,\n    setSize: number,\n    positionInSet: number,\n  }): LitHtml.TemplateResult {\n    let childrenToRender;\n    const nodeIsExpanded = this.#nodeIsExpanded(node);\n    if (!isExpandableNode(node) || !nodeIsExpanded) {\n      childrenToRender = LitHtml.nothing;\n    } else {\n      const childNodes = this.#fetchNodeChildren(node).then(children => {\n        return children.map((childNode, index) => {\n          return this.#renderNode(childNode, {depth: depth + 1, setSize: children.length, positionInSet: index});\n        });\n      });\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      childrenToRender = LitHtml.html`<ul role=\"group\">${LitHtml.Directives.until(childNodes)}</ul>`;\n      // clang-format on\n    }\n\n    const nodeIsFocusable = this.#getSelectedTreeNode() === node;\n    const tabIndex = nodeIsFocusable ? 0 : -1;\n    const listItemClasses = LitHtml.Directives.classMap({\n      expanded: isExpandableNode(node) && nodeIsExpanded,\n      parent: isExpandableNode(node),\n      selected: this.#isSelectedNode(node),\n      'is-top-level': depth === 0,\n      compact: this.#compact,\n    });\n    const ariaExpandedAttribute =\n        LitHtml.Directives.ifDefined(isExpandableNode(node) ? String(nodeIsExpanded) : undefined);\n\n    let renderedNodeKey: LitHtml.TemplateResult;\n    if (node.renderer) {\n      renderedNodeKey = node.renderer(node, {isExpanded: nodeIsExpanded});\n    } else {\n      renderedNodeKey = this.#defaultRenderer(node, {isExpanded: nodeIsExpanded});\n    }\n\n    // Disabled until https://crbug.com/1079231 is fixed.\n    // clang-format off\n    return LitHtml.html`\n      <li role=\"treeitem\"\n        tabindex=${tabIndex}\n        aria-setsize=${setSize}\n        aria-expanded=${ariaExpandedAttribute}\n        aria-level=${depth + 1}\n        aria-posinset=${positionInSet + 1}\n        class=${listItemClasses}\n        @click=${this.#onNodeClick}\n        track-dom-node-to-tree-node=${trackDOMNodeToTreeNode(this.#domNodeToTreeNodeMap, node)}\n        on-render=${ComponentHelpers.Directives.nodeRenderedCallback(domNode => {\n         /**\n           * Because TreeNodes are lazily rendered, you can call\n           * `outline.expandToAndSelect(NodeX)`, but `NodeX` will be rendered at some\n           * later point, once it's been fully resolved, within a LitHtml.until\n           * directive. That means we don't have a direct hook into when it's\n           * rendered, which we need because we want to focus the element, so we use this directive to receive a callback when the node is rendered.\n           */\n          if (!(domNode instanceof HTMLLIElement)) {\n            return;\n          }\n\n          if (this.#nodeIdPendingFocus && node.id === this.#nodeIdPendingFocus) {\n            this.#focusPendingNode(domNode);\n          }\n        })}\n      >\n        <span class=\"arrow-and-key-wrapper\"\n          @mouseover=${(): void => {\n            this.dispatchEvent(new ItemMouseOverEvent(node));\n          }}\n          @mouseout=${(): void => {\n            this.dispatchEvent(new ItemMouseOutEvent(node));\n          }}\n        >\n          <span class=\"arrow-icon\" @click=${this.#onArrowClick(node)}>\n          </span>\n          <span class=\"tree-node-key\" data-node-key=${node.treeNodeData}>${renderedNodeKey}</span>\n        </span>\n        ${childrenToRender}\n      </li>\n    `;\n    // clang-format on\n  }\n\n  async #render(): Promise<void> {\n    if (this.#scheduledRender) {\n      // If we are already rendering, don't render again immediately, but\n      // enqueue it to be run after we're done on our current render.\n      this.#enqueuedRender = true;\n      return;\n    }\n\n    this.#scheduledRender = true;\n\n    await coordinator.write('TreeOutline render', () => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(LitHtml.html`\n      <div class=\"wrapping-container\">\n        <ul role=\"tree\" @keydown=${this.#onTreeKeyDown}>\n          ${this.#treeData.map((topLevelNode, index) => {\n            return this.#renderNode(topLevelNode, {\n              depth: 0,\n              setSize: this.#treeData.length,\n              positionInSet: index,\n            });\n          })}\n        </ul>\n      </div>\n      `, this.#shadow, {\n        host: this,\n      });\n    });\n    // clang-format on\n    this.#hasRenderedAtLeastOnce = true;\n    this.#scheduledRender = false;\n\n    // If render() was called when we were already mid-render, let's re-render\n    // to ensure we're not rendering any stale UI.\n    if (this.#enqueuedRender) {\n      this.#enqueuedRender = false;\n      return this.#render();\n    }\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-tree-outline', TreeOutline);\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface HTMLElementTagNameMap {\n    'devtools-tree-outline': TreeOutline<unknown>;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
