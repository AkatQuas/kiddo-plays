{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/formatter_worker/HTMLFormatter.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {CSSFormatter} from './CSSFormatter.js';\nimport type {FormattedContentBuilder} from './FormattedContentBuilder.js';\nimport {AbortTokenization, createTokenizer} from './FormatterWorker.js';\nimport {JavaScriptFormatter} from './JavaScriptFormatter.js';\n\nexport class HTMLFormatter {\n  readonly #builder: FormattedContentBuilder;\n  readonly #jsFormatter: JavaScriptFormatter;\n  readonly #cssFormatter: CSSFormatter;\n  #text?: string;\n  #lineEndings?: number[];\n  #model?: HTMLModel;\n\n  constructor(builder: FormattedContentBuilder) {\n    this.#builder = builder;\n    this.#jsFormatter = new JavaScriptFormatter(builder);\n    this.#cssFormatter = new CSSFormatter(builder);\n  }\n\n  format(text: string, lineEndings: number[]): void {\n    this.#text = text;\n    this.#lineEndings = lineEndings;\n    this.#model = new HTMLModel(text);\n    this.#walk(this.#model.document());\n  }\n\n  #formatTokensTill(element: FormatterElement, offset: number): void {\n    if (!this.#model) {\n      return;\n    }\n\n    let nextToken = this.#model.peekToken();\n    while (nextToken && nextToken.startOffset < offset) {\n      const token = (this.#model.nextToken() as Token);\n      this.#formatToken(element, token);\n      nextToken = this.#model.peekToken();\n    }\n  }\n\n  #walk(element: FormatterElement): void {\n    if (!element.openTag || !element.closeTag) {\n      throw new Error('Element is missing open or close tag');\n    }\n\n    if (element.parent) {\n      this.#formatTokensTill(element.parent, element.openTag.startOffset);\n    }\n    this.#beforeOpenTag(element);\n    this.#formatTokensTill(element, element.openTag.endOffset);\n    this.#afterOpenTag(element);\n    for (let i = 0; i < element.children.length; ++i) {\n      this.#walk(element.children[i]);\n    }\n\n    this.#formatTokensTill(element, element.closeTag.startOffset);\n    this.#beforeCloseTag(element);\n    this.#formatTokensTill(element, element.closeTag.endOffset);\n    this.#afterCloseTag(element);\n  }\n\n  #beforeOpenTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.addNewLine();\n  }\n\n  #afterOpenTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.increaseNestingLevel();\n    this.#builder.addNewLine();\n  }\n\n  #beforeCloseTag(element: FormatterElement): void {\n    if (!this.#model) {\n      return;\n    }\n\n    if (!element.children.length || element === this.#model.document()) {\n      return;\n    }\n    this.#builder.decreaseNestingLevel();\n    this.#builder.addNewLine();\n  }\n\n  #afterCloseTag(_element: FormatterElement): void {\n    this.#builder.addNewLine();\n  }\n\n  #formatToken(element: FormatterElement, token: Token): void {\n    if (Platform.StringUtilities.isWhitespace(token.value)) {\n      return;\n    }\n    if (hasTokenInSet(token.type, 'comment') || hasTokenInSet(token.type, 'meta')) {\n      this.#builder.addNewLine();\n      this.#builder.addToken(token.value.trim(), token.startOffset);\n      this.#builder.addNewLine();\n      return;\n    }\n\n    if (!element.openTag || !element.closeTag) {\n      return;\n    }\n\n    const isBodyToken =\n        element.openTag.endOffset <= token.startOffset && token.startOffset < element.closeTag.startOffset;\n    if (isBodyToken && element.name === 'style') {\n      this.#builder.addNewLine();\n      this.#builder.increaseNestingLevel();\n      this.#cssFormatter.format(this.#text || '', this.#lineEndings || [], token.startOffset, token.endOffset);\n      this.#builder.decreaseNestingLevel();\n      return;\n    }\n    if (isBodyToken && element.name === 'script') {\n      this.#builder.addNewLine();\n      this.#builder.increaseNestingLevel();\n      if (this.#scriptTagIsJavaScript(element)) {\n        this.#jsFormatter.format(this.#text || '', this.#lineEndings || [], token.startOffset, token.endOffset);\n      } else {\n        this.#builder.addToken(token.value, token.startOffset);\n        this.#builder.addNewLine();\n      }\n      this.#builder.decreaseNestingLevel();\n      return;\n    }\n\n    if (!isBodyToken && hasTokenInSet(token.type, 'attribute')) {\n      this.#builder.addSoftSpace();\n    }\n\n    this.#builder.addToken(token.value, token.startOffset);\n  }\n\n  #scriptTagIsJavaScript(element: FormatterElement): boolean {\n    if (!element.openTag) {\n      return true;\n    }\n\n    if (!element.openTag.attributes.has('type')) {\n      return true;\n    }\n\n    let type = element.openTag.attributes.get('type');\n    if (!type) {\n      return true;\n    }\n\n    type = type.toLowerCase();\n    const isWrappedInQuotes = /^([\"\\'])(.*)\\1$/.exec(type.trim());\n    if (isWrappedInQuotes) {\n      type = isWrappedInQuotes[2];\n    }\n    return HTMLFormatter.SupportedJavaScriptMimeTypes.has(type.trim());\n  }\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static readonly SupportedJavaScriptMimeTypes = new Set([\n    'application/ecmascript',\n    'application/javascript',\n    'application/x-ecmascript',\n    'application/x-javascript',\n    'text/ecmascript',\n    'text/javascript',\n    'text/javascript1.0',\n    'text/javascript1.1',\n    'text/javascript1.2',\n    'text/javascript1.3',\n    'text/javascript1.4',\n    'text/javascript1.5',\n    'text/jscript',\n    'text/livescript',\n    'text/x-ecmascript',\n    'text/x-javascript',\n  ]);\n}\n\nfunction hasTokenInSet(tokenTypes: Set<string>, type: string): boolean {\n  // We prefix the CodeMirror HTML tokenizer with the xml- prefix\n  // in a full version. When running in a worker context, this\n  // prefix is not appended, as the global is only overridden\n  // in CodeMirrorTextEditor.js.\n  return tokenTypes.has(type) || tokenTypes.has(`xml-${type}`);\n}\n\nexport class HTMLModel {\n  #state: ParseState;\n  readonly #documentInternal: FormatterElement;\n  #stack: FormatterElement[];\n  readonly #tokens: Token[];\n  #tokenIndex: number;\n  #attributes: Map<string, string>;\n  #attributeName: string;\n  #tagName: string;\n  #isOpenTag: boolean;\n  #tagStartOffset?: number|null;\n  #tagEndOffset?: number|null;\n\n  constructor(text: string) {\n    this.#state = ParseState.Initial;\n    this.#documentInternal = new FormatterElement('document');\n    this.#documentInternal.openTag = new Tag('document', 0, 0, new Map(), true, false);\n    this.#documentInternal.closeTag = new Tag('document', text.length, text.length, new Map(), false, false);\n\n    this.#stack = [this.#documentInternal];\n\n    this.#tokens = [];\n    this.#tokenIndex = 0;\n    this.#build(text);\n\n    this.#attributes = new Map();\n    this.#attributeName = '';\n    this.#tagName = '';\n    this.#isOpenTag = false;\n  }\n\n  #build(text: string): void {\n    const tokenizer = createTokenizer('text/html');\n    let lastOffset = 0;\n    const lowerCaseText = text.toLowerCase();\n\n    while (true) {\n      tokenizer(text.substring(lastOffset), processToken.bind(this, lastOffset));\n      if (lastOffset >= text.length) {\n        break;\n      }\n      const element = this.#stack[this.#stack.length - 1];\n      if (!element) {\n        break;\n      }\n\n      lastOffset = lowerCaseText.indexOf('</' + element.name, lastOffset);\n      if (lastOffset === -1) {\n        lastOffset = text.length;\n      }\n\n      if (!element.openTag) {\n        break;\n      }\n\n      const tokenStart = element.openTag.endOffset;\n      const tokenEnd = lastOffset;\n      const tokenValue = text.substring(tokenStart, tokenEnd);\n      this.#tokens.push(new Token(tokenValue, new Set(), tokenStart, tokenEnd));\n    }\n\n    while (this.#stack.length > 1) {\n      const element = this.#stack[this.#stack.length - 1];\n      if (!element) {\n        break;\n      }\n\n      this.#popElement(new Tag(element.name, text.length, text.length, new Map(), false, false));\n    }\n\n    function processToken(\n        this: HTMLModel, baseOffset: number, tokenValue: string, type: string|null, tokenStart: number,\n        tokenEnd: number): Object|undefined {\n      tokenStart += baseOffset;\n      tokenEnd += baseOffset;\n      lastOffset = tokenEnd;\n\n      const tokenType = type ? new Set<string>(type.split(' ')) : new Set<string>();\n      const token = new Token(tokenValue, tokenType, tokenStart, tokenEnd);\n      this.#tokens.push(token);\n      this.#updateDOM(token);\n\n      const element = this.#stack[this.#stack.length - 1];\n      if (element && (element.name === 'script' || element.name === 'style') && element.openTag &&\n          element.openTag.endOffset === lastOffset) {\n        return AbortTokenization;\n      }\n\n      return;\n    }\n  }\n\n  #updateDOM(token: Token): void {\n    const value = token.value;\n    const type = token.type;\n    switch (this.#state) {\n      case ParseState.Initial:\n        if (hasTokenInSet(type, 'bracket') && (value === '<' || value === '</')) {\n          this.#onStartTag(token);\n          this.#state = ParseState.Tag;\n        }\n        return;\n      case ParseState.Tag:\n        if (hasTokenInSet(type, 'tag') && !hasTokenInSet(type, 'bracket')) {\n          this.#tagName = value.trim().toLowerCase();\n        } else if (hasTokenInSet(type, 'attribute')) {\n          this.#attributeName = value.trim().toLowerCase();\n          this.#attributes.set(this.#attributeName, '');\n          this.#state = ParseState.AttributeName;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.Initial;\n        }\n        return;\n      case ParseState.AttributeName:\n        if (!type.size && value === '=') {\n          this.#state = ParseState.AttributeValue;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.Initial;\n        }\n        return;\n      case ParseState.AttributeValue:\n        if (hasTokenInSet(type, 'string')) {\n          this.#attributes.set(this.#attributeName, value);\n          this.#state = ParseState.Tag;\n        } else if (hasTokenInSet(type, 'bracket') && (value === '>' || value === '/>')) {\n          this.#onEndTag(token);\n          this.#state = ParseState.Initial;\n        }\n        return;\n    }\n  }\n\n  #onStartTag(token: Token): void {\n    this.#tagName = '';\n    this.#tagStartOffset = token.startOffset;\n    this.#tagEndOffset = null;\n    this.#attributes = new Map();\n    this.#attributeName = '';\n    this.#isOpenTag = token.value === '<';\n  }\n\n  #onEndTag(token: Token): void {\n    this.#tagEndOffset = token.endOffset;\n    const selfClosingTag = token.value === '/>' || SelfClosingTags.has(this.#tagName);\n    const tag = new Tag(\n        this.#tagName, this.#tagStartOffset || 0, this.#tagEndOffset, this.#attributes, this.#isOpenTag,\n        selfClosingTag);\n    this.#onTagComplete(tag);\n  }\n\n  #onTagComplete(tag: Tag): void {\n    if (tag.isOpenTag) {\n      const topElement = this.#stack[this.#stack.length - 1];\n      if (topElement) {\n        const tagSet = AutoClosingTags.get(topElement.name);\n        if (topElement !== this.#documentInternal && topElement.openTag && topElement.openTag.selfClosingTag) {\n          this.#popElement(autocloseTag(topElement, topElement.openTag.endOffset));\n        } else if (tagSet && tagSet.has(tag.name)) {\n          this.#popElement(autocloseTag(topElement, tag.startOffset));\n        }\n        this.#pushElement(tag);\n      }\n      return;\n    }\n\n    let lastTag = this.#stack[this.#stack.length - 1];\n    while (this.#stack.length > 1 && lastTag && lastTag.name !== tag.name) {\n      this.#popElement(autocloseTag(lastTag, tag.startOffset));\n      lastTag = this.#stack[this.#stack.length - 1];\n    }\n    if (this.#stack.length === 1) {\n      return;\n    }\n    this.#popElement(tag);\n\n    function autocloseTag(element: FormatterElement, offset: number): Tag {\n      return new Tag(element.name, offset, offset, new Map(), false, false);\n    }\n  }\n\n  #popElement(closeTag: Tag): void {\n    const element = this.#stack.pop();\n    if (!element) {\n      return;\n    }\n    element.closeTag = closeTag;\n  }\n\n  #pushElement(openTag: Tag): void {\n    const topElement = this.#stack[this.#stack.length - 1];\n    const newElement = new FormatterElement(openTag.name);\n    if (topElement) {\n      newElement.parent = topElement;\n      topElement.children.push(newElement);\n    }\n    newElement.openTag = openTag;\n    this.#stack.push(newElement);\n  }\n\n  peekToken(): Token|null {\n    return this.#tokenIndex < this.#tokens.length ? this.#tokens[this.#tokenIndex] : null;\n  }\n\n  nextToken(): Token|null {\n    return this.#tokens[this.#tokenIndex++];\n  }\n\n  document(): FormatterElement {\n    return this.#documentInternal;\n  }\n}\n\nconst SelfClosingTags = new Set<string>([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]);\n\n// @see https://www.w3.org/TR/html/syntax.html 8.1.2.4 Optional tags\nconst AutoClosingTags = new Map([\n  ['head', new Set(['body'])],\n  ['li', new Set(['li'])],\n  ['dt', new Set(['dt', 'dd'])],\n  ['dd', new Set(['dt', 'dd'])],\n  [\n    'p',\n    new Set([\n      'address', 'article', 'aside', 'blockquote', 'div', 'dl',      'fieldset', 'footer', 'form',\n      'h1',      'h2',      'h3',    'h4',         'h5',  'h6',      'header',   'hgroup', 'hr',\n      'main',    'nav',     'ol',    'p',          'pre', 'section', 'table',    'ul',\n    ]),\n  ],\n  ['rb', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['rt', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['rtc', new Set(['rb', 'rtc', 'rp'])],\n  ['rp', new Set(['rb', 'rt', 'rtc', 'rp'])],\n  ['optgroup', new Set(['optgroup'])],\n  ['option', new Set(['option', 'optgroup'])],\n  ['colgroup', new Set(['colgroup'])],\n  ['thead', new Set(['tbody', 'tfoot'])],\n  ['tbody', new Set(['tbody', 'tfoot'])],\n  ['tfoot', new Set(['tbody'])],\n  ['tr', new Set(['tr'])],\n  ['td', new Set(['td', 'th'])],\n  ['th', new Set(['td', 'th'])],\n]);\n\nconst enum ParseState {\n  Initial = 'Initial',\n  Tag = 'Tag',\n  AttributeName = 'AttributeName',\n  AttributeValue = 'AttributeValue',\n}\n\nclass Token {\n  value: string;\n  type: Set<string>;\n  startOffset: number;\n  endOffset: number;\n\n  constructor(value: string, type: Set<string>, startOffset: number, endOffset: number) {\n    this.value = value;\n    this.type = type;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n  }\n}\n\nclass Tag {\n  name: string;\n  startOffset: number;\n  endOffset: number;\n  attributes: Map<string, string>;\n  isOpenTag: boolean;\n  selfClosingTag: boolean;\n\n  constructor(\n      name: string, startOffset: number, endOffset: number, attributes: Map<string, string>, isOpenTag: boolean,\n      selfClosingTag: boolean) {\n    this.name = name;\n    this.startOffset = startOffset;\n    this.endOffset = endOffset;\n    this.attributes = attributes;\n    this.isOpenTag = isOpenTag;\n    this.selfClosingTag = selfClosingTag;\n  }\n}\n\nclass FormatterElement {\n  name: string;\n  children: FormatterElement[] = [];\n  parent: FormatterElement|null = null;\n  openTag: Tag|null = null;\n  closeTag: Tag|null = null;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
