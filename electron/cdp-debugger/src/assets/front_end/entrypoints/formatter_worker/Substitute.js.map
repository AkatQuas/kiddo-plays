{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/formatter_worker/Substitute.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\nimport {ECMA_VERSION} from './AcornTokenizer.js';\nimport {DefinitionKind} from './FormatterActions.js';\nimport {ScopeVariableAnalysis} from './ScopeParser.js';\n\nexport function substituteExpression(expression: string, nameMap: Map<string, string>): string {\n  const replacements = computeSubstitution(expression, nameMap);\n  return applySubstitution(expression, replacements);\n}\n\ninterface Replacement {\n  from: string;\n  to: string;\n  offset: number;\n  isShorthandAssignmentProperty: boolean;\n}\n\n// Given an |expression| and a mapping from names to new names, the |computeSubstitution|\n// function returns a list of replacements sorted by the offset. The function throws if\n// it cannot parse the expression or the substitution is impossible to perform (for example\n// if the substitution target is 'this' within a function, it would become bound there).\nfunction computeSubstitution(expression: string, nameMap: Map<string, string>): Replacement[] {\n  // Parse the expression and find variables and scopes.\n  const root = Acorn.parse(expression, {ecmaVersion: ECMA_VERSION, allowAwaitOutsideFunction: true, ranges: false}) as\n      Acorn.ESTree.Node;\n  const scopeVariables = new ScopeVariableAnalysis(root);\n  scopeVariables.run();\n  const freeVariables = scopeVariables.getFreeVariables();\n  const result: Replacement[] = [];\n\n  // Prepare the machinery for generating fresh names (to avoid variable captures).\n  const allNames = scopeVariables.getAllNames();\n  for (const rename of nameMap.values()) {\n    allNames.add(rename);\n  }\n  function getNewName(base: string): string {\n    let i = 1;\n    while (allNames.has(`${base}_${i}`)) {\n      i++;\n    }\n    const newName = `${base}_${i}`;\n    allNames.add(newName);\n    return newName;\n  }\n\n  // Perform the substitutions.\n  for (const [name, rename] of nameMap.entries()) {\n    const defUse = freeVariables.get(name);\n    if (!defUse) {\n      continue;\n    }\n\n    const binders = [];\n    for (const use of defUse) {\n      result.push({\n        from: name,\n        to: rename,\n        offset: use.offset,\n        isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n      });\n      binders.push(...use.scope.findBinders(rename));\n    }\n    // If there is a capturing binder, rename the bound variable.\n    for (const binder of binders) {\n      if (binder.definitionKind === DefinitionKind.Fixed) {\n        // If the identifier is bound to a fixed name, such as 'this',\n        // then refuse to do the substitution.\n        throw new Error(`Cannot avoid capture of '${rename}'`);\n      }\n      const newName = getNewName(rename);\n      for (const use of binder.uses) {\n        result.push({\n          from: rename,\n          to: newName,\n          offset: use.offset,\n          isShorthandAssignmentProperty: use.isShorthandAssignmentProperty,\n        });\n      }\n    }\n  }\n  result.sort((l, r) => l.offset - r.offset);\n  return result;\n}\n\nfunction applySubstitution(expression: string, replacements: Replacement[]): string {\n  const accumulator = [];\n  let last = 0;\n  for (const r of replacements) {\n    accumulator.push(expression.slice(last, r.offset));\n    let replacement = r.to;\n    if (r.isShorthandAssignmentProperty) {\n      // Let us expand the shorthand to full assignment.\n      replacement = `${r.from}: ${r.to}`;\n    }\n    accumulator.push(replacement);\n    last = r.offset + r.from.length;\n  }\n  accumulator.push(expression.slice(last));\n  return accumulator.join('');\n}\n"],
  "mappings": "AAIA;AAEA;AACA;AACA;AAEO,qCAA8B,YAAoB,SAAsC;AAC7F,QAAM,eAAe,oBAAoB,YAAY;AACrD,SAAO,kBAAkB,YAAY;AAAA;AAcvC,6BAA6B,YAAoB,SAA6C;AAE5F,QAAM,OAAO,MAAM,MAAM,YAAY,EAAC,aAAa,cAAc,2BAA2B,MAAM,QAAQ;AAE1G,QAAM,iBAAiB,IAAI,sBAAsB;AACjD,iBAAe;AACf,QAAM,gBAAgB,eAAe;AACrC,QAAM,SAAwB;AAG9B,QAAM,WAAW,eAAe;AAChC,aAAW,UAAU,QAAQ,UAAU;AACrC,aAAS,IAAI;AAAA;AAEf,sBAAoB,MAAsB;AACxC,QAAI,IAAI;AACR,WAAO,SAAS,IAAI,GAAG,QAAQ,MAAM;AACnC;AAAA;AAEF,UAAM,UAAU,GAAG,QAAQ;AAC3B,aAAS,IAAI;AACb,WAAO;AAAA;AAIT,aAAW,CAAC,MAAM,WAAW,QAAQ,WAAW;AAC9C,UAAM,SAAS,cAAc,IAAI;AACjC,QAAI,CAAC,QAAQ;AACX;AAAA;AAGF,UAAM,UAAU;AAChB,eAAW,OAAO,QAAQ;AACxB,aAAO,KAAK;AAAA,QACV,MAAM;AAAA,QACN,IAAI;AAAA,QACJ,QAAQ,IAAI;AAAA,QACZ,+BAA+B,IAAI;AAAA;AAErC,cAAQ,KAAK,GAAG,IAAI,MAAM,YAAY;AAAA;AAGxC,eAAW,UAAU,SAAS;AAC5B,UAAI,OAAO,mBAAmB,eAAe,OAAO;AAGlD,cAAM,IAAI,MAAM,4BAA4B;AAAA;AAE9C,YAAM,UAAU,WAAW;AAC3B,iBAAW,OAAO,OAAO,MAAM;AAC7B,eAAO,KAAK;AAAA,UACV,MAAM;AAAA,UACN,IAAI;AAAA,UACJ,QAAQ,IAAI;AAAA,UACZ,+BAA+B,IAAI;AAAA;AAAA;AAAA;AAAA;AAK3C,SAAO,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE;AACnC,SAAO;AAAA;AAGT,2BAA2B,YAAoB,cAAqC;AAClF,QAAM,cAAc;AACpB,MAAI,OAAO;AACX,aAAW,KAAK,cAAc;AAC5B,gBAAY,KAAK,WAAW,MAAM,MAAM,EAAE;AAC1C,QAAI,cAAc,EAAE;AACpB,QAAI,EAAE,+BAA+B;AAEnC,oBAAc,GAAG,EAAE,SAAS,EAAE;AAAA;AAEhC,gBAAY,KAAK;AACjB,WAAO,EAAE,SAAS,EAAE,KAAK;AAAA;AAE3B,cAAY,KAAK,WAAW,MAAM;AAClC,SAAO,YAAY,KAAK;AAAA;",
  "names": []
}
