{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/formatter_worker/FormatterWorker.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as Acorn from '../../third_party/acorn/acorn.js';\n\n// This file is required to bring some types into scope, even though it\n// is not used.\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type * as CodeMirrorModule from '../../third_party/codemirror/codemirror-legacy.js';\n\nimport {AcornTokenizer, ECMA_VERSION} from './AcornTokenizer.js';\nimport {CSSFormatter} from './CSSFormatter.js';\nimport {ESTreeWalker} from './ESTreeWalker.js';\nimport {FormattedContentBuilder} from './FormattedContentBuilder.js';\nimport type {FormatResult} from './FormatterActions.js';\nimport {HTMLFormatter} from './HTMLFormatter.js';\nimport {IdentityFormatter} from './IdentityFormatter.js';\nimport {JavaScriptFormatter} from './JavaScriptFormatter.js';\nimport {JSONFormatter} from './JSONFormatter.js';\nimport {substituteExpression} from './Substitute.js';\n\nexport interface Chunk {\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk: any[];\n  isLastChunk: boolean;\n}\n\nexport type ChunkCallback = (arg0: Chunk) => void;\n\nexport function createTokenizer(mimeType: string): (\n    arg0: string, arg1: (arg0: string, arg1: string|null, arg2: number, arg3: number) => (Object | undefined | void)) =>\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    any {\n  const mode = CodeMirror.getMode({indentUnit: 2}, mimeType);\n  const state = CodeMirror.startState(mode);\n\n  if (!mode || mode.name === 'null') {\n    throw new Error(`Could not find CodeMirror mode for MimeType: ${mimeType}`);\n  }\n\n  if (!mode.token) {\n    throw new Error(`Could not find CodeMirror mode with token method: ${mimeType}`);\n  }\n\n  return (line: string,\n          callback: (arg0: string, arg1: string|null, arg2: number, arg3: number) => void|Object|undefined): void => {\n    const stream = new CodeMirror.StringStream(line);\n    while (!stream.eol()) {\n      // @ts-expect-error TypeScript can't determine that `mode.token` is defined based on lines above\n      const style = mode.token(stream, state);\n      const value = stream.current();\n      if (callback(value, style, stream.start, stream.start + value.length) === AbortTokenization) {\n        return;\n      }\n      stream.start = stream.pos;\n    }\n  };\n}\n\nexport const AbortTokenization = {};\n\nexport function evaluatableJavaScriptSubstring(content: string): string {\n  try {\n    const tokenizer = Acorn.tokenizer(content, {ecmaVersion: ECMA_VERSION});\n    let token = tokenizer.getToken();\n    while (AcornTokenizer.punctuator(token)) {\n      token = tokenizer.getToken();\n    }\n\n    const startIndex = token.start;\n    let endIndex = token.end;\n    while (token.type !== Acorn.tokTypes.eof) {\n      const isIdentifier = token.type === Acorn.tokTypes.name || token.type === Acorn.tokTypes.privateId;\n      const isThis = AcornTokenizer.keyword(token, 'this');\n      const isString = token.type === Acorn.tokTypes.string;\n      if (!isThis && !isIdentifier && !isString) {\n        break;\n      }\n\n      endIndex = token.end;\n      token = tokenizer.getToken();\n\n      while (AcornTokenizer.punctuator(token, '[')) {\n        let openBracketCounter = 0;\n        do {\n          if (AcornTokenizer.punctuator(token, '[')) {\n            ++openBracketCounter;\n          }\n          token = tokenizer.getToken();\n          if (AcornTokenizer.punctuator(token, ']')) {\n            if (--openBracketCounter === 0) {\n              endIndex = token.end;\n              token = tokenizer.getToken();\n              break;\n            }\n          }\n        } while (token.type !== Acorn.tokTypes.eof);\n      }\n\n      if (!AcornTokenizer.punctuator(token, '.')) {\n        break;\n      }\n\n      token = tokenizer.getToken();\n    }\n    return content.substring(startIndex, endIndex);\n  } catch (e) {\n    console.error(e);\n    return '';\n  }\n}\n\nexport function javaScriptIdentifiers(content: string): {\n  name: (string|undefined),\n  offset: number,\n}[] {\n  let root: Acorn.ESTree.Node|null = null;\n  try {\n    root = Acorn.parse(content, {ecmaVersion: ECMA_VERSION, ranges: false}) as Acorn.ESTree.Node | null;\n  } catch (e) {\n  }\n\n  const identifiers: Acorn.ESTree.Node[] = [];\n  const walker = new ESTreeWalker(beforeVisit);\n\n  function isFunction(node: Acorn.ESTree.Node): boolean {\n    return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' ||\n        node.type === 'ArrowFunctionExpression';\n  }\n\n  function beforeVisit(node: Acorn.ESTree.Node): Object|undefined {\n    if (isFunction(node)) {\n      if (node.id) {\n        identifiers.push(node.id);\n      }\n      return ESTreeWalker.SkipSubtree;\n    }\n\n    if (node.type !== 'Identifier') {\n      return;\n    }\n\n    if (node.parent && node.parent.type === 'MemberExpression') {\n      const parent = (node.parent as Acorn.ESTree.MemberExpression);\n      if (parent.property === node && !parent.computed) {\n        return;\n      }\n    }\n    identifiers.push(node);\n    return;\n  }\n\n  if (!root || root.type !== 'Program' || root.body.length !== 1 || !isFunction(root.body[0])) {\n    return [];\n  }\n\n  const functionNode = (root.body[0] as Acorn.ESTree.FunctionDeclaration);\n  for (const param of functionNode.params) {\n    walker.walk(param);\n  }\n  walker.walk(functionNode.body);\n  return identifiers.map(id => ({name: 'name' in id && id.name || undefined, offset: id.start}));\n}\n\nexport function format(mimeType: string, text: string, indentString?: string): FormatResult {\n  // Default to a 4-space indent.\n  indentString = indentString || '    ';\n\n  let result: FormatResult;\n  const builder = new FormattedContentBuilder(indentString);\n  const lineEndings = Platform.StringUtilities.findLineEndingIndexes(text);\n  try {\n    switch (mimeType) {\n      case 'text/html': {\n        const formatter = new HTMLFormatter(builder);\n        formatter.format(text, lineEndings);\n        break;\n      }\n      case 'text/x-scss':\n      case 'text/css': {\n        const formatter = new CSSFormatter(builder);\n        formatter.format(text, lineEndings, 0, text.length);\n        break;\n      }\n      case 'text/javascript':\n      case 'application/javascript': {\n        const formatter = new JavaScriptFormatter(builder);\n        formatter.format(text, lineEndings, 0, text.length);\n        break;\n      }\n      case 'application/json': {\n        const formatter = new JSONFormatter(builder);\n        formatter.format(text, lineEndings, 0, text.length);\n        break;\n      }\n      default: {\n        const formatter = new IdentityFormatter(builder);\n        formatter.format(text, lineEndings, 0, text.length);\n      }\n    }\n    result = {\n      mapping: builder.mapping,\n      content: builder.content(),\n    };\n  } catch (e) {\n    console.error(e);\n    result = {\n      mapping: {original: [0], formatted: [0]},\n      content: text,\n    };\n  }\n  return result;\n}\n\nexport function argumentsList(content: string): string[] {\n  if (content.length > 10000) {\n    return [];\n  }\n  let parsed: Acorn.ESTree.Node|null = null;\n  try {\n    parsed = Acorn.parse(`(${content})`, {ecmaVersion: ECMA_VERSION}) as Acorn.ESTree.Node | null;\n  } catch (e) {\n  }\n  if (!parsed) {\n    try {\n      parsed = Acorn.parse(`({${content}})`, {ecmaVersion: ECMA_VERSION}) as Acorn.ESTree.Node | null;\n    } catch (e) {\n    }\n  }\n  if (!parsed || !('body' in parsed) || !Array.isArray(parsed.body) || !parsed.body[0] ||\n      !('expression' in parsed.body[0])) {\n    return [];\n  }\n  const expression = parsed.body[0].expression;\n  let params: Acorn.ESTree.Pattern[]|null = null;\n  switch (expression.type) {\n    case 'ClassExpression': {\n      if (!expression.body.body) {\n        break;\n      }\n      const constructor =\n          expression.body.body.find(method => method.type === 'MethodDefinition' && method.kind === 'constructor') as\n          Acorn.ESTree.MethodDefinition;\n      if (constructor) {\n        params = constructor.value.params;\n      }\n      break;\n    }\n    case 'ObjectExpression': {\n      if (!expression.properties[0] || !('value' in expression.properties[0]) ||\n          !('params' in expression.properties[0].value)) {\n        break;\n      }\n      params = expression.properties[0].value.params;\n      break;\n    }\n    case 'FunctionExpression':\n    case 'ArrowFunctionExpression': {\n      params = expression.params;\n      break;\n    }\n  }\n  if (!params) {\n    return [];\n  }\n  return params.map(paramName);\n\n  function paramName(param: Acorn.ESTree.Node): string {\n    switch (param.type) {\n      case 'Identifier':\n        return param.name;\n      case 'AssignmentPattern':\n        return '?' + paramName(param.left);\n      case 'ObjectPattern':\n        return 'obj';\n      case 'ArrayPattern':\n        return 'arr';\n      case 'RestElement':\n        return '...' + paramName(param.argument);\n    }\n    return '?';\n  }\n}\n\n(function disableLoggingForTest(): void {\n  if (Root.Runtime.Runtime.queryParam('test')) {\n    console.error = (): undefined => undefined;\n  }\n})();\n\nexport {substituteExpression};\n"],
  "mappings": "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",
  "names": []
}
