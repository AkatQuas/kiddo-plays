{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/use_private_class_members */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\n\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  protected readonly edges: Uint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this.snapshot = snapshot;\n    this.edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this.snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this.snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this.snapshot.edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this.edges[this.edgeIndex + this.snapshot.edgeToNodeOffset];\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this.snapshot.edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this.snapshot.edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this.edges[this.edgeIndex + this.snapshot.edgeTypeOffset];\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n}\n\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this.#node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this.#node.nodeIndex = index;\n    return this.#node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this.#edge.edgeIndex = index;\n    return this.#edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  readonly #retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this.#retainerEdge.setRetainerIndex(index);\n    return this.#retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this.#sourceNode = node;\n    this.edge = node.snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this.#sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge.snapshot.edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge.snapshot.edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  protected snapshot: HeapSnapshot;\n  #retainerIndexInternal!: number;\n  #globalEdgeIndex!: number;\n  #retainingNodeIndex?: number;\n  #edgeInstance?: JSHeapSnapshotEdge|null;\n  #nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this.snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this.snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this.edge().hasStringName();\n  }\n\n  name(): string {\n    return this.edge().name();\n  }\n\n  node(): HeapSnapshotNode {\n    return this.nodeInternal();\n  }\n\n  nodeIndex(): number {\n    if (typeof this.#retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this.#retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this.#retainerIndexInternal) {\n      return;\n    }\n\n    if (!this.snapshot.retainingEdges || !this.snapshot.retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this.#retainerIndexInternal = retainerIndex;\n    this.#globalEdgeIndex = this.snapshot.retainingEdges[retainerIndex];\n    this.#retainingNodeIndex = this.snapshot.retainingNodes[retainerIndex];\n    this.#edgeInstance = null;\n    this.#nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  private nodeInternal(): HeapSnapshotNode {\n    if (!this.#nodeInstance) {\n      this.#nodeInstance = this.snapshot.createNode(this.#retainingNodeIndex);\n    }\n    return this.#nodeInstance;\n  }\n\n  protected edge(): JSHeapSnapshotEdge {\n    if (!this.#edgeInstance) {\n      this.#edgeInstance = this.snapshot.createEdge(this.#globalEdgeIndex);\n    }\n    return this.#edgeInstance;\n  }\n\n  toString(): string {\n    return this.edge().toString();\n  }\n\n  itemIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.#globalEdgeIndex);\n  }\n\n  type(): string {\n    return this.edge().type();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode.snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot.firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot.firstRetainerIndex[retainedNodeOrdinal];\n    this.#retainersEnd = snapshot.firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this.#retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this.snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this.snapshot.nodeDistances[this.nodeIndex / this.snapshot.nodeFieldCount];\n  }\n\n  className(): string {\n    throw new Error('Not implemented');\n  }\n\n  classIndex(): number {\n    throw new Error('Not implemented');\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this.snapshot.nodeFieldCount;\n    return this.snapshot.dominatorsTree[this.nodeIndex / this.snapshot.nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this.snapshot.edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    throw new Error('Not implemented');\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this.snapshot.rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this.snapshot.strings[this.nameInternal()];\n  }\n\n  retainedSize(): number {\n    return this.snapshot.retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this.snapshot;\n    const ordinal = this.ordinal();\n    return snapshot.firstRetainerIndex[ordinal + 1] - snapshot.firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot.nodeSelfSizeOffset];\n  }\n\n  type(): string {\n    return this.snapshot.nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot.nodeTraceNodeIdOffset];\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  private nameInternal(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot.nodeNameOffset];\n  }\n\n  edgeIndexesStart(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this.snapshot.nodeFieldCount;\n  }\n\n  nextNodeIndex(): number {\n    return this.nodeIndex + this.snapshot.nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot.nodeTypeOffset];\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  readonly #nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this.#nodesLength = node.snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this.#nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node.nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  readonly #itemProvider: HeapSnapshotItemIndexProvider;\n  readonly #indexes: number[]|Uint32Array;\n  #position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this.#itemProvider = itemProvider;\n    this.#indexes = indexes;\n    this.#position = 0;\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this.#indexes[this.#position];\n    return this.#itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this.#position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  #iterator: HeapSnapshotItemIterator;\n  #filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this.#iterator = iterator;\n    this.#filter = filter;\n    this.skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this.#iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this.#iterator.item();\n  }\n\n  next(): void {\n    this.#iterator.next();\n    this.skipFilteredItems();\n  }\n\n  private skipFilteredItems(): void {\n    while (this.#iterator.hasNext() && this.#filter && !this.#filter(this.#iterator.item())) {\n      this.#iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  readonly #dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this.#dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  private sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\nexport class HeapSnapshotProblemReport {\n  readonly #errors: string[];\n  constructor(title: string) {\n    this.#errors = [title];\n  }\n\n  addError(error: string): void {\n    if (this.#errors.length > 100) {\n      return;\n    }\n    this.#errors.push(error);\n  }\n\n  toString(): string {\n    return this.#errors.join('\\n  ');\n  }\n}\nexport interface Profile {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  root_index: number;\n  nodes: Uint32Array;\n  edges: Uint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  trace_function_infos: Uint32Array;\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  trace_tree: Object;\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  Unknown = 0,\n  Attached = 1,\n  Detached = 2,\n}\n\nexport abstract class HeapSnapshot {\n  nodes: Uint32Array;\n  containmentEdges: Uint32Array;\n  readonly #metaNode: HeapSnapshotMetainfo;\n  readonly #rawSamples: number[];\n  #samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null;\n  strings: string[];\n  readonly #locations: number[];\n  readonly #progress: HeapSnapshotProgress;\n  readonly #noDistance: number;\n  rootNodeIndexInternal: number;\n  #snapshotDiffs: {\n    [x: string]: {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    },\n  };\n  #aggregatesForDiffInternal!: {\n    [x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n  };\n  #aggregates: {\n    [x: string]: {\n      [x: string]: AggregatedInfo,\n    },\n  };\n  #aggregatesSortedFlags: {\n    [x: string]: boolean,\n  };\n  #profile: Profile;\n  nodeTypeOffset!: number;\n  nodeNameOffset!: number;\n  nodeIdOffset!: number;\n  nodeSelfSizeOffset!: number;\n  #nodeEdgeCountOffset!: number;\n  nodeTraceNodeIdOffset!: number;\n  nodeFieldCount!: number;\n  nodeTypes!: string[];\n  nodeArrayType!: number;\n  nodeHiddenType!: number;\n  nodeObjectType!: number;\n  nodeNativeType!: number;\n  nodeConsStringType!: number;\n  nodeSlicedStringType!: number;\n  nodeCodeType!: number;\n  nodeSyntheticType!: number;\n  edgeFieldsCount!: number;\n  edgeTypeOffset!: number;\n  edgeNameOffset!: number;\n  edgeToNodeOffset!: number;\n  edgeTypes!: string[];\n  edgeElementType!: number;\n  edgeHiddenType!: number;\n  edgeInternalType!: number;\n  edgeShortcutType!: number;\n  edgeWeakType!: number;\n  edgeInvisibleType!: number;\n  #locationIndexOffset!: number;\n  #locationScriptIdOffset!: number;\n  #locationLineOffset!: number;\n  #locationColumnOffset!: number;\n  #locationFieldCount!: number;\n  nodeCount!: number;\n  #edgeCount!: number;\n  retainedSizes!: Float64Array;\n  firstEdgeIndexes!: Uint32Array;\n  retainingNodes!: Uint32Array;\n  retainingEdges!: Uint32Array;\n  firstRetainerIndex!: Uint32Array;\n  nodeDistances!: Int32Array;\n  firstDominatedNodeIndex!: Uint32Array;\n  dominatedNodes!: Uint32Array;\n  dominatorsTree!: Uint32Array;\n  #allocationProfile!: AllocationProfile;\n  #nodeDetachednessOffset!: number;\n  #locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  lazyStringCache!: {\n    [x: string]: string,\n  };\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this.#metaNode = profile.snapshot.meta;\n    this.#rawSamples = profile.samples;\n    this.#samples = null;\n    this.strings = profile.strings;\n    this.#locations = profile.locations;\n    this.#progress = progress;\n\n    this.#noDistance = -5;\n    this.rootNodeIndexInternal = 0;\n    if (profile.snapshot.root_index) {\n      this.rootNodeIndexInternal = profile.snapshot.root_index;\n    }\n\n    this.#snapshotDiffs = {};\n\n    this.#aggregates = {};\n\n    this.#aggregatesSortedFlags = {};\n    this.#profile = profile;\n  }\n\n  initialize(): void {\n    const meta = this.#metaNode;\n\n    this.nodeTypeOffset = meta.node_fields.indexOf('type');\n    this.nodeNameOffset = meta.node_fields.indexOf('name');\n    this.nodeIdOffset = meta.node_fields.indexOf('id');\n    this.nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this.#nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this.nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this.#nodeDetachednessOffset = meta.node_fields.indexOf('detachedness');\n    this.nodeFieldCount = meta.node_fields.length;\n\n    this.nodeTypes = meta.node_types[this.nodeTypeOffset];\n    this.nodeArrayType = this.nodeTypes.indexOf('array');\n    this.nodeHiddenType = this.nodeTypes.indexOf('hidden');\n    this.nodeObjectType = this.nodeTypes.indexOf('object');\n    this.nodeNativeType = this.nodeTypes.indexOf('native');\n    this.nodeConsStringType = this.nodeTypes.indexOf('concatenated string');\n    this.nodeSlicedStringType = this.nodeTypes.indexOf('sliced string');\n    this.nodeCodeType = this.nodeTypes.indexOf('code');\n    this.nodeSyntheticType = this.nodeTypes.indexOf('synthetic');\n\n    this.edgeFieldsCount = meta.edge_fields.length;\n    this.edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this.edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this.edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this.edgeTypes = meta.edge_types[this.edgeTypeOffset];\n    this.edgeTypes.push('invisible');\n    this.edgeElementType = this.edgeTypes.indexOf('element');\n    this.edgeHiddenType = this.edgeTypes.indexOf('hidden');\n    this.edgeInternalType = this.edgeTypes.indexOf('internal');\n    this.edgeShortcutType = this.edgeTypes.indexOf('shortcut');\n    this.edgeWeakType = this.edgeTypes.indexOf('weak');\n    this.edgeInvisibleType = this.edgeTypes.indexOf('invisible');\n\n    const locationFields = meta.location_fields || [];\n\n    this.#locationIndexOffset = locationFields.indexOf('object_index');\n    this.#locationScriptIdOffset = locationFields.indexOf('script_id');\n    this.#locationLineOffset = locationFields.indexOf('line');\n    this.#locationColumnOffset = locationFields.indexOf('column');\n    this.#locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this.nodeFieldCount;\n    this.#edgeCount = this.containmentEdges.length / this.edgeFieldsCount;\n\n    this.retainedSizes = new Float64Array(this.nodeCount);\n    this.firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this.retainingNodes = new Uint32Array(this.#edgeCount);\n    this.retainingEdges = new Uint32Array(this.#edgeCount);\n    this.firstRetainerIndex = new Uint32Array(this.nodeCount + 1);\n    this.nodeDistances = new Int32Array(this.nodeCount);\n    this.firstDominatedNodeIndex = new Uint32Array(this.nodeCount + 1);\n    this.dominatedNodes = new Uint32Array(this.nodeCount - 1);\n\n    this.#progress.updateStatus('Building edge indexes\u2026');\n    this.buildEdgeIndexes();\n    this.#progress.updateStatus('Building retainers\u2026');\n    this.buildRetainers();\n    this.#progress.updateStatus('Propagating DOM state\u2026');\n    this.propagateDOMState();\n    this.#progress.updateStatus('Calculating node flags\u2026');\n    this.calculateFlags();\n    this.#progress.updateStatus('Calculating distances\u2026');\n    this.calculateDistances();\n    this.#progress.updateStatus('Building postorder index\u2026');\n    const result = this.buildPostOrderIndex();\n    // Actually it is array that maps node ordinal number to dominator node ordinal number.\n    this.#progress.updateStatus('Building dominator tree\u2026');\n    this.dominatorsTree = this.buildDominatorTree(result.postOrderIndex2NodeOrdinal, result.nodeOrdinal2PostOrderIndex);\n    this.#progress.updateStatus('Calculating retained sizes\u2026');\n    this.calculateRetainedSizes(result.postOrderIndex2NodeOrdinal);\n    this.#progress.updateStatus('Building dominated nodes\u2026');\n    this.buildDominatedNodes();\n    this.#progress.updateStatus('Calculating statistics\u2026');\n    this.calculateStatistics();\n    this.#progress.updateStatus('Calculating samples\u2026');\n    this.buildSamples();\n    this.#progress.updateStatus('Building locations\u2026');\n    this.buildLocationMap();\n    this.#progress.updateStatus('Finished processing.');\n\n    if (this.#profile.snapshot.trace_function_count) {\n      this.#progress.updateStatus('Building allocation statistics\u2026');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this.nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: {[x: number]: {count: number, size: number, ids: number[]}} = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this.#allocationProfile = new AllocationProfile(this.#profile, liveObjects);\n      this.#progress.updateStatus('done');\n    }\n  }\n\n  private buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeEdgeCountOffset = this.#nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes[nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset] * edgeFieldsCount;\n    }\n  }\n\n  private buildRetainers(): void {\n    const retainingNodes = this.retainingNodes;\n    const retainingEdges = this.retainingEdges;\n    // Index of the first retainer in the retainingNodes and retainingEdges\n    // arrays. Addressed by retained node index.\n    const firstRetainerIndex = this.firstRetainerIndex;\n\n    const containmentEdges = this.containmentEdges;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeCount = this.nodeCount;\n\n    for (let toNodeFieldIndex = edgeToNodeOffset, l = containmentEdges.length; toNodeFieldIndex < l;\n         toNodeFieldIndex += edgeFieldsCount) {\n      const toNodeIndex = containmentEdges[toNodeFieldIndex];\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      ++firstRetainerIndex[toNodeIndex / nodeFieldCount];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        if (toNodeIndex % nodeFieldCount) {\n          throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n        }\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeIndex / nodeFieldCount];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  private allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this.rootNodeIndexInternal);\n  }\n\n  get rootNodeIndex(): number {\n    return this.rootNodeIndexInternal;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize();\n  }\n\n  private getDominatedIndex(nodeIndex: number): number {\n    if (nodeIndex % this.nodeFieldCount) {\n      throw new Error('Invalid nodeIndex: ' + nodeIndex);\n    }\n    return this.firstDominatedNodeIndex[nodeIndex / this.nodeFieldCount];\n  }\n\n  private createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const minNodeId = nodeFilter.minNodeId;\n    const maxNodeId = nodeFilter.maxNodeId;\n    const allocationNodeId = nodeFilter.allocationNodeId;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this.createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-ignore key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this.createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-ignore key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp =\n        searchConfig.isRegex ? new RegExp(query) : Platform.StringUtilities.createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const stringFilter = (searchConfig.isRegex || !searchConfig.caseSensitive) ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    if (!stringIndexes.size) {\n      return [];\n    }\n\n    const filter = this.createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this.nodeNameOffset;\n    const nodeIdOffset = this.nodeIdOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (stringIndexes.has(nodes[nodeIndex + nodeNameOffset])) {\n        nodeIds.push(nodes[nodeIndex + nodeIdOffset]);\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const filter = this.createFilter(nodeFilter);\n    // @ts-ignore key is added in createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.getAggregatesByClassName(false, key, filter);\n  }\n\n  private createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  private createAllocationStackFilter(bottomUpAllocationNodeId: number):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this.#allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this.#allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: {[x: number]: boolean} = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  getAggregatesByClassName(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate} {\n    const aggregates = this.buildAggregates(filter);\n\n    let aggregatesByClassName;\n    if (key && this.#aggregates[key]) {\n      aggregatesByClassName = this.#aggregates[key];\n    } else {\n      this.calculateClassesRetainedSize(aggregates.aggregatesByClassIndex, filter);\n      aggregatesByClassName = aggregates.aggregatesByClassName;\n      if (key) {\n        this.#aggregates[key] = aggregatesByClassName;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this.#aggregatesSortedFlags[key])) {\n      this.sortAggregateIndexes(aggregates.aggregatesByClassName);\n      if (key) {\n        this.#aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregatesByClassName as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n    };\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this.#allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this.#allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this.#allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(): {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff} {\n    if (this.#aggregatesForDiffInternal) {\n      return this.#aggregatesForDiffInternal;\n    }\n\n    const aggregatesByClassName = this.getAggregatesByClassName(true, 'allObjects');\n    this.#aggregatesForDiffInternal = {};\n\n    const node = this.createNode();\n    for (const className in aggregatesByClassName) {\n      const aggregate = aggregatesByClassName[className];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      this.#aggregatesForDiffInternal[className] = {indexes: indexes, ids: ids, selfSizes: selfSizes};\n    }\n    return this.#aggregatesForDiffInternal;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateDistances(filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n    const distances = this.nodeDistances;\n    const noDistance = this.#noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  private bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this.edgeWeakType;\n    const noDistance = this.#noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  private buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      {aggregatesByClassName: {[x: string]: AggregatedInfo}, aggregatesByClassIndex: {[x: number]: AggregatedInfo}} {\n    const aggregates: {[x: number]: AggregatedInfo} = {};\n\n    const aggregatesByClassName: {[x: string]: AggregatedInfo} = {};\n\n    const classIndexes = [];\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeFieldCount = this.nodeFieldCount;\n    const selfSizeOffset = this.nodeSelfSizeOffset;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this.nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes[nodeIndex + selfSizeOffset];\n      if (!selfSize && nodes[nodeIndex + nodeTypeOffset] !== nodeNativeType) {\n        continue;\n      }\n      const classIndex = node.classIndex();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      if (!(classIndex in aggregates)) {\n        const nodeType = node.type();\n        const nameMatters = nodeType === 'object' || nodeType === 'native';\n        const value = {\n          count: 1,\n          distance: distance,\n          self: selfSize,\n          maxRet: 0,\n          type: nodeType,\n          name: nameMatters ? node.name() : null,\n          idxs: [nodeIndex],\n        };\n        aggregates[classIndex] = value;\n        classIndexes.push(classIndex);\n        aggregatesByClassName[node.className()] = value;\n      } else {\n        const clss = aggregates[classIndex];\n        if (!clss) {\n          continue;\n        }\n        clss.distance = Math.min(clss.distance, distance);\n        ++clss.count;\n        clss.self += selfSize;\n        clss.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (let i = 0, l = classIndexes.length; i < l; ++i) {\n      const classIndex = classIndexes[i];\n      const classIndexValues = aggregates[classIndex];\n      if (!classIndexValues) {\n        continue;\n      }\n      classIndexValues.idxs = classIndexValues.idxs.slice();\n    }\n\n    return {aggregatesByClassName: aggregatesByClassName, aggregatesByClassIndex: aggregates};\n  }\n\n  private calculateClassesRetainedSize(\n      aggregates: {[x: number]: AggregatedInfo}, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this.rootNodeIndexInternal;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classes = [];\n\n    const seenClassNameIndexes = new Map<number, boolean>();\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const dominatedNodes = this.dominatedNodes;\n    const nodes = this.nodes;\n    const firstDominatedNodeIndex = this.firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classIndex = node.classIndex();\n      const seen = Boolean(seenClassNameIndexes.get(classIndex));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) &&\n          (node.selfSize() || nodes[nodeIndex + nodeTypeOffset] === nodeNativeType)) {\n        aggregates[classIndex].maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassNameIndexes.set(classIndex, true);\n          sizes.push(list.length);\n          classes.push(classIndex);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classIndex = (classes.pop() as number);\n        seenClassNameIndexes.set(classIndex, false);\n      }\n    }\n  }\n\n  private sortAggregateIndexes(aggregates: {[x: string]: AggregatedInfo}): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  /**\n   * The function checks is the edge should be considered during building\n   * postorder iterator and dominator tree.\n   */\n  private isEssentialEdge(nodeIndex: number, edgeType: number): boolean {\n    // Shortcuts at the root node have special meaning of marking user global objects.\n    return edgeType !== this.edgeWeakType &&\n        (edgeType !== this.edgeShortcutType || nodeIndex === this.rootNodeIndexInternal);\n  }\n\n  private buildPostOrderIndex(): {postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array} {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeCount = this.nodeCount;\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const stackNodes = new Uint32Array(nodeCount);\n    const stackCurrentEdge = new Uint32Array(nodeCount);\n    const postOrderIndex2NodeOrdinal = new Uint32Array(nodeCount);\n    const nodeOrdinal2PostOrderIndex = new Uint32Array(nodeCount);\n    const visited = new Uint8Array(nodeCount);\n    let postOrderIndex = 0;\n\n    let stackTop = 0;\n    stackNodes[0] = rootNodeOrdinal;\n    stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal];\n    visited[rootNodeOrdinal] = 1;\n\n    let iteration = 0;\n    while (true) {\n      ++iteration;\n      while (stackTop >= 0) {\n        const nodeOrdinal = stackNodes[stackTop];\n        const edgeIndex = stackCurrentEdge[stackTop];\n        const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n\n        if (edgeIndex < edgesEnd) {\n          stackCurrentEdge[stackTop] += edgeFieldsCount;\n          const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n          if (!this.isEssentialEdge(nodeOrdinal * nodeFieldCount, edgeType)) {\n            continue;\n          }\n          const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n          const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n          if (visited[childNodeOrdinal]) {\n            continue;\n          }\n          const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n          const childNodeFlag = !flags || (flags[childNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (nodeOrdinal !== rootNodeOrdinal && childNodeFlag && !nodeFlag) {\n            continue;\n          }\n          ++stackTop;\n          stackNodes[stackTop] = childNodeOrdinal;\n          stackCurrentEdge[stackTop] = firstEdgeIndexes[childNodeOrdinal];\n          visited[childNodeOrdinal] = 1;\n        } else {\n          // Done with all the node children\n          nodeOrdinal2PostOrderIndex[nodeOrdinal] = postOrderIndex;\n          postOrderIndex2NodeOrdinal[postOrderIndex++] = nodeOrdinal;\n          --stackTop;\n        }\n      }\n\n      if (postOrderIndex === nodeCount || iteration > 1) {\n        break;\n      }\n      const errors = new HeapSnapshotProblemReport(`Heap snapshot: ${\n          nodeCount - postOrderIndex} nodes are unreachable from the root. Following nodes have only weak retainers:`);\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      stackTop = 0;\n      stackNodes[0] = rootNodeOrdinal;\n      stackCurrentEdge[0] = firstEdgeIndexes[rootNodeOrdinal + 1];  // no need to reiterate its edges\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i] || !this.hasOnlyWeakRetainers(i)) {\n          continue;\n        }\n\n        // Add all nodes that have only weak retainers to traverse their subgraphs.\n        stackNodes[++stackTop] = i;\n        stackCurrentEdge[stackTop] = firstEdgeIndexes[i];\n        visited[i] = 1;\n\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        const retainers = [];\n        for (let it = dumpNode.retainers(); it.hasNext(); it.next()) {\n          retainers.push(`${it.item().node().name()}@${it.item().node().id()}.${it.item().name()}`);\n        }\n        errors.addError(`${dumpNode.name()} @${dumpNode.id()}  weak retainers: ${retainers.join(', ')}`);\n      }\n      console.warn(errors.toString());\n    }\n\n    // If we already processed all orphan nodes that have only weak retainers and still have some orphans...\n    if (postOrderIndex !== nodeCount) {\n      const errors = new HeapSnapshotProblemReport(\n          'Still found ' + (nodeCount - postOrderIndex) + ' unreachable nodes in heap snapshot:');\n      const dumpNode = this.rootNode();\n      // Remove root from the result (last node in the array) and put it at the bottom of the stack so that it is\n      // visited after all orphan nodes and their subgraphs.\n      --postOrderIndex;\n      for (let i = 0; i < nodeCount; ++i) {\n        if (visited[i]) {\n          continue;\n        }\n        dumpNode.nodeIndex = i * nodeFieldCount;\n        errors.addError(dumpNode.name() + ' @' + dumpNode.id());\n        // Fix it by giving the node a postorder index anyway.\n        nodeOrdinal2PostOrderIndex[i] = postOrderIndex;\n        postOrderIndex2NodeOrdinal[postOrderIndex++] = i;\n      }\n      nodeOrdinal2PostOrderIndex[rootNodeOrdinal] = postOrderIndex;\n      postOrderIndex2NodeOrdinal[postOrderIndex++] = rootNodeOrdinal;\n      console.warn(errors.toString());\n    }\n\n    return {\n      postOrderIndex2NodeOrdinal: postOrderIndex2NodeOrdinal,\n      nodeOrdinal2PostOrderIndex: nodeOrdinal2PostOrderIndex,\n    };\n  }\n\n  private hasOnlyWeakRetainers(nodeOrdinal: number): boolean {\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeWeakType = this.edgeWeakType;\n    const edgeShortcutType = this.edgeShortcutType;\n    const containmentEdges = this.containmentEdges;\n    const retainingEdges = this.retainingEdges;\n    const beginRetainerIndex = this.firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = this.firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n      if (retainerEdgeType !== edgeWeakType && retainerEdgeType !== edgeShortcutType) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm is based on the article:\n  // K. Cooper, T. Harvey and K. Kennedy \"A Simple, Fast Dominance Algorithm\"\n  // Softw. Pract. Exper. 4 (2001), pp. 1-10.\n  private buildDominatorTree(postOrderIndex2NodeOrdinal: Uint32Array, nodeOrdinal2PostOrderIndex: Uint32Array):\n      Uint32Array {\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstRetainerIndex = this.firstRetainerIndex;\n    const retainingNodes = this.retainingNodes;\n    const retainingEdges = this.retainingEdges;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const rootNodeIndex = this.rootNodeIndexInternal;\n\n    const mapAndFlag = this.userObjectsMapAndFlag();\n    const flags = mapAndFlag ? mapAndFlag.map : null;\n    const flag = mapAndFlag ? mapAndFlag.flag : 0;\n\n    const nodesCount = postOrderIndex2NodeOrdinal.length;\n    const rootPostOrderedIndex = nodesCount - 1;\n    const noEntry = nodesCount;\n    const dominators = new Uint32Array(nodesCount);\n    for (let i = 0; i < rootPostOrderedIndex; ++i) {\n      dominators[i] = noEntry;\n    }\n    dominators[rootPostOrderedIndex] = rootPostOrderedIndex;\n\n    // The affected array is used to mark entries which dominators\n    // have to be racalculated because of changes in their retainers.\n    const affected = new Uint8Array(nodesCount);\n    let nodeOrdinal;\n\n    {  // Mark the root direct children as affected.\n      nodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = firstEdgeIndexes[nodeOrdinal]; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (!this.isEssentialEdge(this.rootNodeIndexInternal, edgeType)) {\n          continue;\n        }\n        const childNodeOrdinal = containmentEdges[edgeIndex + edgeToNodeOffset] / nodeFieldCount;\n        affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n      }\n    }\n\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (let postOrderIndex = rootPostOrderedIndex - 1; postOrderIndex >= 0; --postOrderIndex) {\n        if (affected[postOrderIndex] === 0) {\n          continue;\n        }\n        affected[postOrderIndex] = 0;\n        // If dominator of the entry has already been set to root,\n        // then it can't propagate any further.\n        if (dominators[postOrderIndex] === rootPostOrderedIndex) {\n          continue;\n        }\n        nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n        const nodeFlag = !flags || (flags[nodeOrdinal] & flag);\n        let newDominatorIndex: number = noEntry;\n        const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n        const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n        let orphanNode = true;\n        for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n          const retainerEdgeIndex = retainingEdges[retainerIndex];\n          const retainerEdgeType = containmentEdges[retainerEdgeIndex + edgeTypeOffset];\n          const retainerNodeIndex = retainingNodes[retainerIndex];\n          if (!this.isEssentialEdge(retainerNodeIndex, retainerEdgeType)) {\n            continue;\n          }\n          orphanNode = false;\n          const retainerNodeOrdinal = retainerNodeIndex / nodeFieldCount;\n          const retainerNodeFlag = !flags || (flags[retainerNodeOrdinal] & flag);\n          // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n          // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n          if (retainerNodeIndex !== rootNodeIndex && nodeFlag && !retainerNodeFlag) {\n            continue;\n          }\n          let retanerPostOrderIndex: number = nodeOrdinal2PostOrderIndex[retainerNodeOrdinal];\n          if (dominators[retanerPostOrderIndex] !== noEntry) {\n            if (newDominatorIndex === noEntry) {\n              newDominatorIndex = retanerPostOrderIndex;\n            } else {\n              while (retanerPostOrderIndex !== newDominatorIndex) {\n                while (retanerPostOrderIndex < newDominatorIndex) {\n                  retanerPostOrderIndex = dominators[retanerPostOrderIndex];\n                }\n                while (newDominatorIndex < retanerPostOrderIndex) {\n                  newDominatorIndex = dominators[newDominatorIndex];\n                }\n              }\n            }\n            // If idom has already reached the root, it doesn't make sense\n            // to check other retainers.\n            if (newDominatorIndex === rootPostOrderedIndex) {\n              break;\n            }\n          }\n        }\n        // Make root dominator of orphans.\n        if (orphanNode) {\n          newDominatorIndex = rootPostOrderedIndex;\n        }\n        if (newDominatorIndex !== noEntry && dominators[postOrderIndex] !== newDominatorIndex) {\n          dominators[postOrderIndex] = newDominatorIndex;\n          changed = true;\n          nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n          const beginEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal] + edgeToNodeOffset;\n          const endEdgeToNodeFieldIndex = firstEdgeIndexes[nodeOrdinal + 1];\n          for (let toNodeFieldIndex = beginEdgeToNodeFieldIndex; toNodeFieldIndex < endEdgeToNodeFieldIndex;\n               toNodeFieldIndex += edgeFieldsCount) {\n            const childNodeOrdinal = containmentEdges[toNodeFieldIndex] / nodeFieldCount;\n            affected[nodeOrdinal2PostOrderIndex[childNodeOrdinal]] = 1;\n          }\n        }\n      }\n    }\n\n    const dominatorsTree = new Uint32Array(nodesCount);\n    for (let postOrderIndex = 0, l = dominators.length; postOrderIndex < l; ++postOrderIndex) {\n      nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      dominatorsTree[nodeOrdinal] = postOrderIndex2NodeOrdinal[dominators[postOrderIndex]];\n    }\n    return dominatorsTree;\n  }\n\n  private calculateRetainedSizes(postOrderIndex2NodeOrdinal: Uint32Array): void {\n    const nodeCount = this.nodeCount;\n    const nodes = this.nodes;\n    const nodeSelfSizeOffset = this.nodeSelfSizeOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatorsTree = this.dominatorsTree;\n    const retainedSizes = this.retainedSizes;\n\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      retainedSizes[nodeOrdinal] = nodes[nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset];\n    }\n\n    // Propagate retained sizes for each node excluding root.\n    for (let postOrderIndex = 0; postOrderIndex < nodeCount - 1; ++postOrderIndex) {\n      const nodeOrdinal = postOrderIndex2NodeOrdinal[postOrderIndex];\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n  }\n\n  private buildDominatedNodes(): void {\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = this.firstDominatedNodeIndex;\n    // All nodes except the root have dominators.\n    const dominatedNodes = this.dominatedNodes;\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatorsTree = this.dominatorsTree;\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = this.nodeCount;\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = this.nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[this.nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  private iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this.firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this.firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this.edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges[edgeIndex + this.edgeToNodeOffset];\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const type = this.containmentEdges[edgeIndex + this.edgeTypeOffset];\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  private addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n    * The phase propagates whether a node is attached or detached through the\n    * graph and adjusts the low-level representation of nodes.\n    *\n    * State propagation:\n    * 1. Any object reachable from an attached object is itself attached.\n    * 2. Any object reachable from a detached object that is not already\n    *    attached is considered detached.\n    *\n    * Representation:\n    * - Name of any detached node is changed from \"<Name>\"\" to\n    *   \"Detached <Name>\".\n    */\n  private propagateDOMState(): void {\n    if (this.#nodeDetachednessOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes[nodeIndex + snapshot.nodeNameOffset];\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot.addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes[nodeIndex + snapshot.nodeNameOffset] = newStringIndex;\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot.nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes[nodeIndex + snapshot.nodeTypeOffset] !== snapshot.nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      snapshot.nodes[nodeIndex + snapshot.#nodeDetachednessOffset] = newState;\n\n      if (newState === DOMLinkState.Attached) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.Detached) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot.iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType => ![snapshot.edgeHiddenType, snapshot.edgeInvisibleType, snapshot.edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      const state = this.nodes[nodeOrdinal * this.nodeFieldCount + this.#nodeDetachednessOffset];\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.Unknown) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.Attached);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      const nodeState = this.nodes[nodeOrdinal * this.nodeFieldCount + this.#nodeDetachednessOffset];\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.Attached) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.Detached);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  private buildSamples(): void {\n    const samples = this.#rawSamples;\n    if (!samples || !samples.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this.#metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this.#metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this.#samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  private buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this.#locations;\n\n    for (let i = 0; i < locations.length; i += this.#locationFieldCount) {\n      const nodeIndex = locations[i + this.#locationIndexOffset];\n      const scriptId = locations[i + this.#locationScriptIdOffset];\n      const line = locations[i + this.#locationLineOffset];\n      const col = locations[i + this.#locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this.#locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this.#locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this.#samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff}):\n      {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff} {\n    let snapshotDiff: {[x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff}|{\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    } = this.#snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as {\n      [x: string]: HeapSnapshotModel.HeapSnapshotModel.Diff,\n    });\n\n    const aggregates = this.getAggregatesByClassName(true, 'allObjects');\n    for (const className in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[className];\n      const diff = this.calculateDiffForClass(baseAggregate, aggregates[className]);\n      if (diff) {\n        snapshotDiff[className] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const className in aggregates) {\n      if (className in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this.calculateDiffForClass(emptyBaseAggregate, aggregates[className]);\n      if (classDiff) {\n        snapshotDiff[className] = classDiff;\n      }\n    }\n\n    this.#snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  private calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff();\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  private nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  nodeClassName(snapshotObjectId: number): string|null {\n    const node = this.nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return node.className();\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, className: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this.#snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[className];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(className: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[className].idxs);\n  }\n\n  private maxJsNodeId(): number {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this.nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes[nodeIndex];\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this.rootNodeIndexInternal, this.totalSize, this.maxJsNodeId());\n  }\n}\n\nclass HeapSnapshotMetainfo {\n  location_fields: string[] = [];              // eslint-disable-line @typescript-eslint/naming-convention\n  node_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  node_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  edge_fields: string[] = [];                  // eslint-disable-line @typescript-eslint/naming-convention\n  edge_types: string[][] = [];                 // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_info_fields: string[] = [];   // eslint-disable-line @typescript-eslint/naming-convention\n  trace_node_fields: string[] = [];            // eslint-disable-line @typescript-eslint/naming-convention\n  sample_fields: string[] = [];                // eslint-disable-line @typescript-eslint/naming-convention\n  type_strings: {[key: string]: string} = {};  // eslint-disable-line @typescript-eslint/naming-convention\n}\n\nexport class HeapSnapshotHeader {\n  title: string;\n  meta: HeapSnapshotMetainfo;\n  node_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  edge_count: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  trace_function_count: number;  // eslint-disable-line @typescript-eslint/naming-convention\n  root_index: number;            // eslint-disable-line @typescript-eslint/naming-convention\n  constructor() {\n    // New format.\n    this.title = '';\n    this.meta = new HeapSnapshotMetainfo();\n    this.node_count = 0;\n    this.edge_count = 0;\n    this.trace_function_count = 0;\n    this.root_index = 0;\n  }\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  protected readonly iterator: HeapSnapshotItemIterator;\n  readonly #indexProvider: HeapSnapshotItemIndexProvider;\n  readonly #isEmptyInternal: boolean;\n  protected iterationOrder: number[]|null;\n  protected currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  #sortedPrefixLength: number;\n  #sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this.iterator = iterator;\n    this.#indexProvider = indexProvider;\n    this.#isEmptyInternal = !iterator.hasNext();\n    this.iterationOrder = null;\n    this.currentComparator = null;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  protected createIterationOrder(): void {\n    if (this.iterationOrder) {\n      return;\n    }\n    this.iterationOrder = [];\n    for (let iterator = this.iterator; iterator.hasNext(); iterator.next()) {\n      this.iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.#isEmptyInternal;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this.createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this.iterationOrder.length) {\n      end = this.iterationOrder.length;\n    }\n    if (this.#sortedPrefixLength < end && begin < this.iterationOrder.length - this.#sortedSuffixLength &&\n        this.currentComparator) {\n      const currentComparator = this.currentComparator;\n      this.sort(\n          currentComparator, this.#sortedPrefixLength, this.iterationOrder.length - 1 - this.#sortedSuffixLength, begin,\n          end - 1);\n      if (begin <= this.#sortedPrefixLength) {\n        this.#sortedPrefixLength = end;\n      }\n      if (end >= this.iterationOrder.length - this.#sortedSuffixLength) {\n        this.#sortedSuffixLength = this.iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this.iterationOrder[position++];\n      const item = this.#indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this.iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this.currentComparator = comparator;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this.iterator.item() as HeapSnapshotEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeFieldName(ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      if (edgeB.name() === '__proto__') {\n        return -1;\n      }\n      if (edgeA.name() === '__proto__') {\n        return 1;\n      }\n      const result = edgeA.hasStringName() === edgeB.hasStringName() ?\n          (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n          (edgeA.hasStringName() ? -1 : 1);\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeFieldName(ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeFieldName(ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    if (fieldName1 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    } else if (fieldName2 === '!edgeName') {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this.createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this.iterationOrder.length; i++) {\n      node.nodeIndex = this.iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this.iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this.iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this.currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this.buildCompareFunction(currentComparator);\n    for (let i = 0; i < this.iterationOrder.length; i++) {\n      if (compare(this.iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  private buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    function sortByNodeField(fieldAccessor: () => void, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this.iterationOrder, this.buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  readonly nodeFlags: {\n    // bit flags\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  lazyStringCache: {};\n  private flags!: Uint32Array;\n  #statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    super(profile, progress);\n    this.nodeFlags = {\n      // bit flags\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n    this.lazyStringCache = {};\n    this.initialize();\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  calculateFlags(): void {\n    this.flags = new Uint32Array(this.nodeCount);\n    this.markDetachedDOMTreeNodes();\n    this.markQueriableHeapObjects();\n    this.markPageOwnedNodes();\n  }\n\n  calculateDistances(): void {\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden()) {\n        return edge.name() !== 'sloppy_function_map' || node.rawName() !== 'system / NativeContext';\n      }\n      if (node.isArray()) {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        if (node.rawName() !== '(map descriptors)') {\n          return true;\n        }\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      return true;\n    }\n    super.calculateDistances(filter);\n  }\n\n  isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  userObjectsMapAndFlag(): {map: Uint32Array, flag: number}|null {\n    return {map: this.flags, flag: this.nodeFlags.pageObject};\n  }\n\n  flagsOfNode(node: HeapSnapshotNode): number {\n    return this.flags[node.nodeIndex / this.nodeFieldCount];\n  }\n\n  private markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const flag = this.nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this.flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  private markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to insonsistent state of internal properties of wrappers.\n    const flag = this.nodeFlags.canBeQueried;\n    const hiddenEdgeType = this.edgeHiddenType;\n    const internalEdgeType = this.edgeInternalType;\n    const invisibleEdgeType = this.edgeInvisibleType;\n    const weakEdgeType = this.edgeWeakType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n\n    const flags = (this.flags as Uint32Array);\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  private markPageOwnedNodes(): void {\n    const edgeShortcutType = this.edgeShortcutType;\n    const edgeElementType = this.edgeElementType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeWeakType = this.edgeWeakType;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = (this.flags as Uint32Array);\n    const pageObjectFlag = this.nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      const nodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges[edgeIndex + edgeTypeOffset];\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  calculateStatistics(): void {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeSizeOffset = this.nodeSelfSizeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeCodeType = this.nodeCodeType;\n    const nodeConsStringType = this.nodeConsStringType;\n    const nodeSlicedStringType = this.nodeSlicedStringType;\n    const distances = this.nodeDistances;\n    let sizeNative = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes[nodeIndex + nodeSizeOffset];\n      const ordinal = nodeIndex / nodeFieldCount;\n      if (distances[ordinal] >= HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      const nodeType = nodes[nodeIndex + nodeTypeOffset];\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || node.type() === 'string') {\n        sizeStrings += nodeSize;\n      } else if (node.name() === 'Array') {\n        sizeJSArrays += this.calculateArraySize(node);\n      }\n    }\n    this.#statistics = new HeapSnapshotModel.HeapSnapshotModel.Statistics();\n    this.#statistics.total = this.totalSize;\n    this.#statistics.v8heap = this.totalSize - sizeNative;\n    this.#statistics.native = sizeNative;\n    this.#statistics.code = sizeCode;\n    this.#statistics.jsArrays = sizeJSArrays;\n    this.#statistics.strings = sizeStrings;\n    this.#statistics.system = sizeSystem;\n  }\n\n  private calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeNameOffset = this.edgeNameOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeInternalType = this.edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges[edgeIndex + edgeTypeOffset];\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges[edgeIndex + edgeNameOffset]];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges[edgeIndex + edgeToNodeOffset];\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return this.#statistics as HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  constructor(snapshot: JSHeapSnapshot, nodeIndex?: number) {\n    super(snapshot, nodeIndex);\n  }\n\n  canBeQueried(): boolean {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    return Boolean(flags & snapshot.nodeFlags.canBeQueried);\n  }\n\n  rawName(): string {\n    return super.name();\n  }\n\n  name(): string {\n    const snapshot = this.snapshot;\n    if (this.rawType() === snapshot.nodeConsStringType) {\n      let string: string = snapshot.lazyStringCache[this.nodeIndex];\n      if (typeof string === 'undefined') {\n        string = this.consStringName();\n        snapshot.lazyStringCache[this.nodeIndex] = string;\n      }\n      return string;\n    }\n    return this.rawName();\n  }\n\n  private consStringName(): string {\n    const snapshot = this.snapshot;\n    const consStringType = snapshot.nodeConsStringType;\n    const edgeInternalType = snapshot.edgeInternalType;\n    const edgeFieldsCount = snapshot.edgeFieldsCount;\n    const edgeToNodeOffset = snapshot.edgeToNodeOffset;\n    const edgeTypeOffset = snapshot.edgeTypeOffset;\n    const edgeNameOffset = snapshot.edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot.firstEdgeIndexes;\n    const nodeFieldCount = snapshot.nodeFieldCount;\n    const nodeTypeOffset = snapshot.nodeTypeOffset;\n    const nodeNameOffset = snapshot.nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes[nodeIndex + nodeTypeOffset] !== consStringType) {\n        name += strings[nodes[nodeIndex + nodeNameOffset]];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges[edgeIndex + edgeTypeOffset];\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges[edgeIndex + edgeNameOffset]];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges[edgeIndex + edgeToNodeOffset];\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  className(): string {\n    const type = this.type();\n    switch (type) {\n      case 'hidden':\n        return '(system)';\n      case 'object':\n      case 'native':\n        return this.name();\n      case 'code':\n        return '(compiled code)';\n      default:\n        return '(' + type + ')';\n    }\n  }\n\n  classIndex(): number {\n    const snapshot = this.snapshot;\n    const nodes = snapshot.nodes;\n    const type = nodes[this.nodeIndex + snapshot.nodeTypeOffset];\n    if (type === snapshot.nodeObjectType || type === snapshot.nodeNativeType) {\n      return nodes[this.nodeIndex + snapshot.nodeNameOffset];\n    }\n    return -1 - type;\n  }\n\n  id(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes[this.nodeIndex + snapshot.nodeIdOffset];\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.nodeHiddenType;\n  }\n\n  isArray(): boolean {\n    return this.rawType() === this.snapshot.nodeArrayType;\n  }\n\n  isSynthetic(): boolean {\n    return this.rawType() === this.snapshot.nodeSyntheticType;\n  }\n\n  isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.name() === '(Document DOM trees)';\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    if (flags & snapshot.nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot.nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  constructor(snapshot: JSHeapSnapshot, edgeIndex?: number) {\n    super(snapshot, edgeIndex);\n  }\n\n  clone(): JSHeapSnapshotEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this.hasStringNameInternal();\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    return isNaN(parseInt(this.nameInternal(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this.snapshot.edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.edgeHiddenType;\n  }\n\n  isWeak(): boolean {\n    return this.rawType() === this.snapshot.edgeWeakType;\n  }\n\n  isInternal(): boolean {\n    return this.rawType() === this.snapshot.edgeInternalType;\n  }\n\n  isInvisible(): boolean {\n    return this.rawType() === this.snapshot.edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this.snapshot.edgeShortcutType;\n  }\n\n  name(): string {\n    const name = this.nameInternal();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-ignore parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  private hasStringNameInternal(): boolean {\n    const type = this.rawType();\n    const snapshot = this.snapshot;\n    return type !== snapshot.edgeElementType && type !== snapshot.edgeHiddenType;\n  }\n\n  private nameInternal(): string|number {\n    return this.hasStringNameInternal() ? this.snapshot.strings[this.nameOrIndex()] : this.nameOrIndex();\n  }\n\n  private nameOrIndex(): number {\n    return this.edges[this.edgeIndex + this.snapshot.edgeNameOffset];\n  }\n\n  rawType(): number {\n    return this.edges[this.edgeIndex + this.snapshot.edgeTypeOffset];\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  constructor(snapshot: JSHeapSnapshot, retainerIndex: number) {\n    super(snapshot, retainerIndex);\n  }\n\n  clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this.edge().isHidden();\n  }\n\n  isInternal(): boolean {\n    return this.edge().isInternal();\n  }\n\n  isInvisible(): boolean {\n    return this.edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this.edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this.edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string|null;\n  idxs: number[];\n}\n"],
  "mappings": "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",
  "names": []
}
