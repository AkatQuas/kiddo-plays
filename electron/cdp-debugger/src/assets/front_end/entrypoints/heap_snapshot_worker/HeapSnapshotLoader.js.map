{
  "version": 3,
  "sources": ["../../../../../../front_end/entrypoints/heap_snapshot_worker/HeapSnapshotLoader.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport {HeapSnapshotProgress, JSHeapSnapshot} from './HeapSnapshot.js';\nimport type {HeapSnapshotHeader, Profile} from './HeapSnapshot.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport class HeapSnapshotLoader {\n  readonly #progress: HeapSnapshotProgress;\n  #buffer: string;\n  #dataCallback: ((value: string|PromiseLike<string>) => void)|null;\n  #done: boolean;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #snapshot?: {[x: string]: any};\n  #array!: number[]|Uint32Array|null;\n  #arrayIndex!: number;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #json?: any;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #jsonTokenizer?: any;\n  constructor(dispatcher: HeapSnapshotWorkerDispatcher) {\n    this.#reset();\n    this.#progress = new HeapSnapshotProgress(dispatcher);\n    this.#buffer = '';\n    this.#dataCallback = null;\n    this.#done = false;\n    void this.#parseInput();\n  }\n\n  dispose(): void {\n    this.#reset();\n  }\n\n  #reset(): void {\n    this.#json = '';\n    this.#snapshot = undefined;\n  }\n\n  close(): void {\n    this.#done = true;\n    if (this.#dataCallback) {\n      this.#dataCallback('');\n    }\n  }\n\n  buildSnapshot(): JSHeapSnapshot {\n    this.#snapshot = this.#snapshot || {};\n\n    this.#progress.updateStatus('Processing snapshot\u2026');\n    const result = new JSHeapSnapshot((this.#snapshot as Profile), this.#progress);\n    this.#reset();\n    return result;\n  }\n\n  #parseUintArray(): boolean {\n    let index = 0;\n    const char0 = '0'.charCodeAt(0);\n    const char9 = '9'.charCodeAt(0);\n    const closingBracket = ']'.charCodeAt(0);\n    const length = this.#json.length;\n    while (true) {\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 <= code && code <= char9) {\n          break;\n        } else if (code === closingBracket) {\n          this.#json = this.#json.slice(index + 1);\n          return false;\n        }\n        ++index;\n      }\n      if (index === length) {\n        this.#json = '';\n        return true;\n      }\n      let nextNumber = 0;\n      const startIndex = index;\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 > code || code > char9) {\n          break;\n        }\n        nextNumber *= 10;\n        nextNumber += (code - char0);\n        ++index;\n      }\n      if (index === length) {\n        this.#json = this.#json.slice(startIndex);\n        return true;\n      }\n      if (!this.#array) {\n        throw new Error('Array not instantiated');\n      }\n      this.#array[this.#arrayIndex++] = nextNumber;\n    }\n  }\n\n  #parseStringsArray(): void {\n    this.#progress.updateStatus('Parsing strings\u2026');\n    const closingBracketIndex = this.#json.lastIndexOf(']');\n    if (closingBracketIndex === -1) {\n      throw new Error('Incomplete JSON');\n    }\n    this.#json = this.#json.slice(0, closingBracketIndex + 1);\n\n    if (!this.#snapshot) {\n      throw new Error('No snapshot in parseStringsArray');\n    }\n    this.#snapshot.strings = JSON.parse(this.#json);\n  }\n\n  write(chunk: string): void {\n    this.#buffer += chunk;\n    if (!this.#dataCallback) {\n      return;\n    }\n    this.#dataCallback(this.#buffer);\n    this.#dataCallback = null;\n    this.#buffer = '';\n  }\n\n  #fetchChunk(): Promise<string> {\n    return this.#done ? Promise.resolve(this.#buffer) : new Promise(r => {\n      this.#dataCallback = r;\n    });\n  }\n\n  async #findToken(token: string, startIndex?: number): Promise<number> {\n    while (true) {\n      const pos = this.#json.indexOf(token, startIndex || 0);\n      if (pos !== -1) {\n        return pos;\n      }\n      startIndex = this.#json.length - token.length + 1;\n      this.#json += await this.#fetchChunk();\n    }\n  }\n\n  async #parseArray(name: string, title: string, length?: number): Promise<number[]|Uint32Array> {\n    const nameIndex = await this.#findToken(name);\n    const bracketIndex = await this.#findToken('[', nameIndex);\n    this.#json = this.#json.slice(bracketIndex + 1);\n    this.#array = length ? new Uint32Array(length) : [];\n    this.#arrayIndex = 0;\n    while (this.#parseUintArray()) {\n      if (length) {\n        this.#progress.updateProgress(title, this.#arrayIndex, this.#array.length);\n      } else {\n        this.#progress.updateStatus(title);\n      }\n      this.#json += await this.#fetchChunk();\n    }\n    const result = this.#array;\n    this.#array = null;\n    return result;\n  }\n\n  async #parseInput(): Promise<void> {\n    const snapshotToken = '\"snapshot\"';\n    const snapshotTokenIndex = await this.#findToken(snapshotToken);\n    if (snapshotTokenIndex === -1) {\n      throw new Error('Snapshot token not found');\n    }\n\n    this.#progress.updateStatus('Loading snapshot info\u2026');\n    const json = this.#json.slice(snapshotTokenIndex + snapshotToken.length + 1);\n    this.#jsonTokenizer = new TextUtils.TextUtils.BalancedJSONTokenizer(metaJSON => {\n      this.#json = this.#jsonTokenizer.remainder();\n      this.#jsonTokenizer = null;\n\n      this.#snapshot = this.#snapshot || {};\n      this.#snapshot.snapshot = (JSON.parse(metaJSON) as HeapSnapshotHeader);\n    });\n    this.#jsonTokenizer.write(json);\n    while (this.#jsonTokenizer) {\n      this.#jsonTokenizer.write(await this.#fetchChunk());\n    }\n\n    this.#snapshot = this.#snapshot || {};\n    const nodes = await this.#parseArray(\n        '\"nodes\"', 'Loading nodes\u2026 {PH1}%',\n        this.#snapshot.snapshot.meta.node_fields.length * this.#snapshot.snapshot.node_count);\n    this.#snapshot.nodes = (nodes as Uint32Array);\n\n    const edges = await this.#parseArray(\n        '\"edges\"', 'Loading edges\u2026 {PH1}%',\n        this.#snapshot.snapshot.meta.edge_fields.length * this.#snapshot.snapshot.edge_count);\n    this.#snapshot.edges = (edges as Uint32Array);\n\n    if (this.#snapshot.snapshot.trace_function_count) {\n      const traceFunctionInfos = await this.#parseArray(\n          '\"trace_function_infos\"', 'Loading allocation traces\u2026 {PH1}%',\n          this.#snapshot.snapshot.meta.trace_function_info_fields.length *\n              this.#snapshot.snapshot.trace_function_count);\n      this.#snapshot.trace_function_infos = (traceFunctionInfos as Uint32Array);\n\n      const thisTokenEndIndex = await this.#findToken(':');\n      const nextTokenIndex = await this.#findToken('\"', thisTokenEndIndex);\n      const openBracketIndex = this.#json.indexOf('[');\n      const closeBracketIndex = this.#json.lastIndexOf(']', nextTokenIndex);\n      this.#snapshot.trace_tree = JSON.parse(this.#json.substring(openBracketIndex, closeBracketIndex + 1));\n      this.#json = this.#json.slice(closeBracketIndex + 1);\n    }\n\n    if (this.#snapshot.snapshot.meta.sample_fields) {\n      const samples = await this.#parseArray('\"samples\"', 'Loading samples\u2026');\n      this.#snapshot.samples = (samples as number[]);\n    }\n\n    if (this.#snapshot.snapshot.meta['location_fields']) {\n      const locations = await this.#parseArray('\"locations\"', 'Loading locations\u2026');\n      this.#snapshot.locations = (locations as number[]);\n    } else {\n      this.#snapshot.locations = [];\n    }\n\n    this.#progress.updateStatus('Loading strings\u2026');\n    const stringsTokenIndex = await this.#findToken('\"strings\"');\n    const bracketIndex = await this.#findToken('[', stringsTokenIndex);\n    this.#json = this.#json.slice(bracketIndex);\n    while (!this.#done) {\n      this.#json += await this.#fetchChunk();\n    }\n    this.#parseStringsArray();\n  }\n}\n"],
  "mappings": "AA8BA;AACA;AAIO,gCAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgB9B,YAAY,YAA0C;AACpD;AACA,qBAAiB,IAAI,qBAAqB;AAC1C,mBAAe;AACf,yBAAqB;AACrB,iBAAa;AACb,SAAK;AAAA;AAAA,EAGP,UAAgB;AACd;AAAA;AAAA,WAGa;AACb,iBAAa;AACb,qBAAiB;AAAA;AAAA,EAGnB,QAAc;AACZ,iBAAa;AACb,QAAI,oBAAoB;AACtB,yBAAmB;AAAA;AAAA;AAAA,EAIvB,gBAAgC;AAC9B,qBAAiB,kBAAkB;AAEnC,mBAAe,aAAa;AAC5B,UAAM,SAAS,IAAI,eAAgB,gBAA4B;AAC/D;AACA,WAAO;AAAA;AAAA,oBAGkB;AACzB,QAAI,QAAQ;AACZ,UAAM,QAAQ,IAAI,WAAW;AAC7B,UAAM,QAAQ,IAAI,WAAW;AAC7B,UAAM,iBAAiB,IAAI,WAAW;AACtC,UAAM,SAAS,WAAW;AAC1B,WAAO,MAAM;AACX,aAAO,QAAQ,QAAQ;AACrB,cAAM,OAAO,WAAW,WAAW;AACnC,YAAI,SAAS,QAAQ,QAAQ,OAAO;AAClC;AAAA,mBACS,SAAS,gBAAgB;AAClC,uBAAa,WAAW,MAAM,QAAQ;AACtC,iBAAO;AAAA;AAET,UAAE;AAAA;AAEJ,UAAI,UAAU,QAAQ;AACpB,qBAAa;AACb,eAAO;AAAA;AAET,UAAI,aAAa;AACjB,YAAM,aAAa;AACnB,aAAO,QAAQ,QAAQ;AACrB,cAAM,OAAO,WAAW,WAAW;AACnC,YAAI,QAAQ,QAAQ,OAAO,OAAO;AAChC;AAAA;AAEF,sBAAc;AACd,sBAAe,OAAO;AACtB,UAAE;AAAA;AAEJ,UAAI,UAAU,QAAQ;AACpB,qBAAa,WAAW,MAAM;AAC9B,eAAO;AAAA;AAET,UAAI,CAAC,aAAa;AAChB,cAAM,IAAI,MAAM;AAAA;AAElB,kBAAY,sBAAsB;AAAA;AAAA;AAAA,uBAIX;AACzB,mBAAe,aAAa;AAC5B,UAAM,sBAAsB,WAAW,YAAY;AACnD,QAAI,wBAAwB,IAAI;AAC9B,YAAM,IAAI,MAAM;AAAA;AAElB,iBAAa,WAAW,MAAM,GAAG,sBAAsB;AAEvD,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI,MAAM;AAAA;AAElB,mBAAe,UAAU,KAAK,MAAM;AAAA;AAAA,EAGtC,MAAM,OAAqB;AACzB,oBAAgB;AAChB,QAAI,CAAC,oBAAoB;AACvB;AAAA;AAEF,uBAAmB;AACnB,yBAAqB;AACrB,mBAAe;AAAA;AAAA,gBAGc;AAC7B,WAAO,aAAa,QAAQ,QAAQ,gBAAgB,IAAI,QAAQ,OAAK;AACnE,2BAAqB;AAAA;AAAA;AAAA,mBAIR,OAAe,YAAsC;AACpE,WAAO,MAAM;AACX,YAAM,MAAM,WAAW,QAAQ,OAAO,cAAc;AACpD,UAAI,QAAQ,IAAI;AACd,eAAO;AAAA;AAET,mBAAa,WAAW,SAAS,MAAM,SAAS;AAChD,oBAAc,MAAM;AAAA;AAAA;AAAA,oBAIN,MAAc,OAAe,QAAgD;AAC7F,UAAM,YAAY,MAAM,gBAAgB;AACxC,UAAM,eAAe,MAAM,gBAAgB,KAAK;AAChD,iBAAa,WAAW,MAAM,eAAe;AAC7C,kBAAc,SAAS,IAAI,YAAY,UAAU;AACjD,uBAAmB;AACnB,WAAO,wBAAwB;AAC7B,UAAI,QAAQ;AACV,uBAAe,eAAe,OAAO,kBAAkB,YAAY;AAAA,aAC9D;AACL,uBAAe,aAAa;AAAA;AAE9B,oBAAc,MAAM;AAAA;AAEtB,UAAM,SAAS;AACf,kBAAc;AACd,WAAO;AAAA;AAAA,sBAG0B;AACjC,UAAM,gBAAgB;AACtB,UAAM,qBAAqB,MAAM,gBAAgB;AACjD,QAAI,uBAAuB,IAAI;AAC7B,YAAM,IAAI,MAAM;AAAA;AAGlB,mBAAe,aAAa;AAC5B,UAAM,OAAO,WAAW,MAAM,qBAAqB,cAAc,SAAS;AAC1E,0BAAsB,IAAI,UAAU,UAAU,sBAAsB,cAAY;AAC9E,mBAAa,oBAAoB;AACjC,4BAAsB;AAEtB,uBAAiB,kBAAkB;AACnC,qBAAe,WAAY,KAAK,MAAM;AAAA;AAExC,wBAAoB,MAAM;AAC1B,WAAO,qBAAqB;AAC1B,0BAAoB,MAAM,MAAM;AAAA;AAGlC,qBAAiB,kBAAkB;AACnC,UAAM,QAAQ,MAAM,iBAChB,WAAW,8BACX,eAAe,SAAS,KAAK,YAAY,SAAS,eAAe,SAAS;AAC9E,mBAAe,QAAS;AAExB,UAAM,QAAQ,MAAM,iBAChB,WAAW,8BACX,eAAe,SAAS,KAAK,YAAY,SAAS,eAAe,SAAS;AAC9E,mBAAe,QAAS;AAExB,QAAI,eAAe,SAAS,sBAAsB;AAChD,YAAM,qBAAqB,MAAM,iBAC7B,0BAA0B,0CAC1B,eAAe,SAAS,KAAK,2BAA2B,SACpD,eAAe,SAAS;AAChC,qBAAe,uBAAwB;AAEvC,YAAM,oBAAoB,MAAM,gBAAgB;AAChD,YAAM,iBAAiB,MAAM,gBAAgB,KAAK;AAClD,YAAM,mBAAmB,WAAW,QAAQ;AAC5C,YAAM,oBAAoB,WAAW,YAAY,KAAK;AACtD,qBAAe,aAAa,KAAK,MAAM,WAAW,UAAU,kBAAkB,oBAAoB;AAClG,mBAAa,WAAW,MAAM,oBAAoB;AAAA;AAGpD,QAAI,eAAe,SAAS,KAAK,eAAe;AAC9C,YAAM,UAAU,MAAM,iBAAiB,aAAa;AACpD,qBAAe,UAAW;AAAA;AAG5B,QAAI,eAAe,SAAS,KAAK,oBAAoB;AACnD,YAAM,YAAY,MAAM,iBAAiB,eAAe;AACxD,qBAAe,YAAa;AAAA,WACvB;AACL,qBAAe,YAAY;AAAA;AAG7B,mBAAe,aAAa;AAC5B,UAAM,oBAAoB,MAAM,gBAAgB;AAChD,UAAM,eAAe,MAAM,gBAAgB,KAAK;AAChD,iBAAa,WAAW,MAAM;AAC9B,WAAO,CAAC,YAAY;AAClB,oBAAc,MAAM;AAAA;AAEtB;AAAA;AAAA;",
  "names": []
}
