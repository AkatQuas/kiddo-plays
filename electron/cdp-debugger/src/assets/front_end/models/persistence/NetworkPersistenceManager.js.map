{
  "version": 3,
  "sources": ["../../../../../../front_end/models/persistence/NetworkPersistenceManager.ts"],
  "sourcesContent": ["// Copyright (c) 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nimport type {FileSystem} from './FileSystemWorkspaceBinding.js';\nimport {FileSystemWorkspaceBinding} from './FileSystemWorkspaceBinding.js';\nimport {PersistenceBinding, PersistenceImpl} from './PersistenceImpl.js';\n\nlet networkPersistenceManagerInstance: NetworkPersistenceManager|null;\n\nexport class NetworkPersistenceManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDK.TargetManager.Observer {\n  private bindings: WeakMap<Workspace.UISourceCode.UISourceCode, PersistenceBinding>;\n  private readonly originalResponseContentPromises: WeakMap<Workspace.UISourceCode.UISourceCode, Promise<string|null>>;\n  private savingForOverrides: WeakSet<Workspace.UISourceCode.UISourceCode>;\n  private readonly savingSymbol: symbol;\n  private enabledSetting: Common.Settings.Setting<boolean>;\n  private readonly workspace: Workspace.Workspace.WorkspaceImpl;\n  private readonly networkUISourceCodeForEncodedPath:\n      Map<Platform.DevToolsPath.EncodedPathString, Workspace.UISourceCode.UISourceCode>;\n  private readonly interceptionHandlerBound:\n      (interceptedRequest: SDK.NetworkManager.InterceptedRequest) => Promise<void>;\n  private readonly updateInterceptionThrottler: Common.Throttler.Throttler;\n  private projectInternal: Workspace.Workspace.Project|null;\n  private readonly activeProject: Workspace.Workspace.Project|null;\n  private activeInternal: boolean;\n  private enabled: boolean;\n  private eventDescriptors: Common.EventTarget.EventDescriptor[];\n  #headerOverridesMap: Map<Platform.DevToolsPath.EncodedPathString, HeaderOverrideWithRegex[]> = new Map();\n  readonly #sourceCodeToBindProcessMutex = new WeakMap<Workspace.UISourceCode.UISourceCode, Common.Mutex.Mutex>();\n\n  private constructor(workspace: Workspace.Workspace.WorkspaceImpl) {\n    super();\n    this.bindings = new WeakMap();\n    this.originalResponseContentPromises = new WeakMap();\n    this.savingForOverrides = new WeakSet();\n    this.savingSymbol = Symbol('SavingForOverrides');\n\n    this.enabledSetting = Common.Settings.Settings.instance().moduleSetting('persistenceNetworkOverridesEnabled');\n    this.enabledSetting.addChangeListener(this.enabledChanged, this);\n\n    this.workspace = workspace;\n\n    this.networkUISourceCodeForEncodedPath = new Map();\n    this.interceptionHandlerBound = this.interceptionHandler.bind(this);\n    this.updateInterceptionThrottler = new Common.Throttler.Throttler(50);\n\n    this.projectInternal = null;\n    this.activeProject = null;\n\n    this.activeInternal = false;\n    this.enabled = false;\n\n    this.workspace.addEventListener(Workspace.Workspace.Events.ProjectAdded, event => {\n      void this.onProjectAdded(event.data);\n    });\n    this.workspace.addEventListener(Workspace.Workspace.Events.ProjectRemoved, event => {\n      void this.onProjectRemoved(event.data);\n    });\n\n    PersistenceImpl.instance().addNetworkInterceptor(this.canHandleNetworkUISourceCode.bind(this));\n    Bindings.BreakpointManager.BreakpointManager.instance().addUpdateBindingsCallback(\n        this.networkUISourceCodeAdded.bind(this));\n\n    this.eventDescriptors = [];\n    void this.enabledChanged();\n\n    SDK.TargetManager.TargetManager.instance().observeTargets(this);\n  }\n\n  targetAdded(): void {\n    void this.updateActiveProject();\n  }\n  targetRemoved(): void {\n    void this.updateActiveProject();\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n    workspace: Workspace.Workspace.WorkspaceImpl|null,\n  } = {forceNew: null, workspace: null}): NetworkPersistenceManager {\n    const {forceNew, workspace} = opts;\n    if (!networkPersistenceManagerInstance || forceNew) {\n      if (!workspace) {\n        throw new Error('Missing workspace for NetworkPersistenceManager');\n      }\n      networkPersistenceManagerInstance = new NetworkPersistenceManager(workspace);\n    }\n\n    return networkPersistenceManagerInstance;\n  }\n\n  active(): boolean {\n    return this.activeInternal;\n  }\n\n  project(): Workspace.Workspace.Project|null {\n    return this.projectInternal;\n  }\n\n  originalContentForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<string|null>|null {\n    const binding = this.bindings.get(uiSourceCode);\n    if (!binding) {\n      return null;\n    }\n    const fileSystemUISourceCode = binding.fileSystem;\n    return this.originalResponseContentPromises.get(fileSystemUISourceCode) || null;\n  }\n\n  private async enabledChanged(): Promise<void> {\n    if (this.enabled === this.enabledSetting.get()) {\n      return;\n    }\n    this.enabled = this.enabledSetting.get();\n    if (this.enabled) {\n      this.eventDescriptors = [\n        Workspace.Workspace.WorkspaceImpl.instance().addEventListener(\n            Workspace.Workspace.Events.UISourceCodeRenamed,\n            event => {\n              void this.uiSourceCodeRenamedListener(event);\n            }),\n        Workspace.Workspace.WorkspaceImpl.instance().addEventListener(\n            Workspace.Workspace.Events.UISourceCodeAdded,\n            event => {\n              void this.uiSourceCodeAdded(event);\n            }),\n        Workspace.Workspace.WorkspaceImpl.instance().addEventListener(\n            Workspace.Workspace.Events.UISourceCodeRemoved,\n            event => {\n              void this.uiSourceCodeRemovedListener(event);\n            }),\n        Workspace.Workspace.WorkspaceImpl.instance().addEventListener(\n            Workspace.Workspace.Events.WorkingCopyCommitted,\n            event => this.onUISourceCodeWorkingCopyCommitted(event.data.uiSourceCode)),\n      ];\n      await this.updateActiveProject();\n    } else {\n      Common.EventTarget.removeEventListeners(this.eventDescriptors);\n      await this.updateActiveProject();\n    }\n  }\n\n  private async uiSourceCodeRenamedListener(\n      event: Common.EventTarget.EventTargetEvent<Workspace.Workspace.UISourceCodeRenamedEvent>): Promise<void> {\n    const uiSourceCode = event.data.uiSourceCode;\n    await this.onUISourceCodeRemoved(uiSourceCode);\n    await this.onUISourceCodeAdded(uiSourceCode);\n  }\n\n  private async uiSourceCodeRemovedListener(\n      event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): Promise<void> {\n    await this.onUISourceCodeRemoved(event.data);\n  }\n\n  private async uiSourceCodeAdded(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>):\n      Promise<void> {\n    await this.onUISourceCodeAdded(event.data);\n  }\n\n  private async updateActiveProject(): Promise<void> {\n    const wasActive = this.activeInternal;\n    this.activeInternal = Boolean(\n        this.enabledSetting.get() && SDK.TargetManager.TargetManager.instance().mainTarget() && this.projectInternal);\n    if (this.activeInternal === wasActive) {\n      return;\n    }\n\n    if (this.activeInternal && this.projectInternal) {\n      await Promise.all(\n          this.projectInternal.uiSourceCodes().map(uiSourceCode => this.filesystemUISourceCodeAdded(uiSourceCode)));\n\n      const networkProjects = this.workspace.projectsForType(Workspace.Workspace.projectTypes.Network);\n      for (const networkProject of networkProjects) {\n        await Promise.all(\n            networkProject.uiSourceCodes().map(uiSourceCode => this.networkUISourceCodeAdded(uiSourceCode)));\n      }\n    } else if (this.projectInternal) {\n      await Promise.all(\n          this.projectInternal.uiSourceCodes().map(uiSourceCode => this.filesystemUISourceCodeRemoved(uiSourceCode)));\n      this.networkUISourceCodeForEncodedPath.clear();\n    }\n    PersistenceImpl.instance().refreshAutomapping();\n  }\n\n  encodedPathFromUrl(url: Platform.DevToolsPath.UrlString, ignoreInactive?: boolean):\n      Platform.DevToolsPath.EncodedPathString {\n    return Common.ParsedURL.ParsedURL.rawPathToEncodedPathString(this.rawPathFromUrl(url, ignoreInactive));\n  }\n\n  rawPathFromUrl(url: Platform.DevToolsPath.UrlString, ignoreInactive?: boolean): Platform.DevToolsPath.RawPathString {\n    if ((!this.activeInternal && !ignoreInactive) || !this.projectInternal) {\n      return Platform.DevToolsPath.EmptyRawPathString;\n    }\n    let initialEncodedPath = Common.ParsedURL.ParsedURL.urlWithoutHash(url.replace(/^https?:\\/\\//, '')) as\n        Platform.DevToolsPath.EncodedPathString;\n    if (initialEncodedPath.endsWith('/') && initialEncodedPath.indexOf('?') === -1) {\n      initialEncodedPath = Common.ParsedURL.ParsedURL.concatenate(initialEncodedPath, 'index.html');\n    }\n    let encodedPathParts = encodeEncodedPathToLocalPathParts(initialEncodedPath);\n    const projectPath =\n        FileSystemWorkspaceBinding.fileSystemPath(this.projectInternal.id() as Platform.DevToolsPath.UrlString);\n    const encodedPath = encodedPathParts.join('/');\n    if (projectPath.length + encodedPath.length > 200) {\n      const domain = encodedPathParts[0];\n      const encodedFileName = encodedPathParts[encodedPathParts.length - 1];\n      const shortFileName = encodedFileName ? encodedFileName.substr(0, 10) + '-' : '';\n      const extension = Common.ParsedURL.ParsedURL.extractExtension(initialEncodedPath);\n      const extensionPart = extension ? '.' + extension.substr(0, 10) : '';\n      encodedPathParts = [\n        domain,\n        'longurls',\n        shortFileName + Platform.StringUtilities.hashCode(encodedPath).toString(16) + extensionPart,\n      ];\n    }\n    return Common.ParsedURL.ParsedURL.join(encodedPathParts as Platform.DevToolsPath.RawPathString[], '/');\n\n    function encodeEncodedPathToLocalPathParts(encodedPath: Platform.DevToolsPath.EncodedPathString): string[] {\n      const encodedParts = [];\n      for (const pathPart of fileNamePartsFromEncodedPath(encodedPath)) {\n        if (!pathPart) {\n          continue;\n        }\n        // encodeURI() escapes all the unsafe filename characters except '/' and '*'\n        let encodedName =\n            encodeURI(pathPart).replace(/[\\/\\*]/g, match => '%' + match[0].charCodeAt(0).toString(16).toUpperCase());\n        if (Host.Platform.isWin()) {\n          // Windows does not allow ':' and '?' in filenames\n          encodedName = encodedName.replace(/[:\\?]/g, match => '%' + match[0].charCodeAt(0).toString(16).toUpperCase());\n          // Windows does not allow a small set of filenames.\n          if (RESERVED_FILENAMES.has(encodedName.toLowerCase())) {\n            encodedName =\n                encodedName.split('').map(char => '%' + char.charCodeAt(0).toString(16).toUpperCase()).join('');\n          }\n          // Windows does not allow the file to end in a space or dot (space should already be encoded).\n          const lastChar = encodedName.charAt(encodedName.length - 1);\n          if (lastChar === '.') {\n            encodedName = encodedName.substr(0, encodedName.length - 1) + '%2E';\n          }\n        }\n        encodedParts.push(encodedName);\n      }\n      return encodedParts;\n    }\n\n    function fileNamePartsFromEncodedPath(encodedPath: Platform.DevToolsPath.EncodedPathString): string[] {\n      encodedPath = Common.ParsedURL.ParsedURL.urlWithoutHash(encodedPath) as Platform.DevToolsPath.EncodedPathString;\n      const queryIndex = encodedPath.indexOf('?');\n      if (queryIndex === -1) {\n        return encodedPath.split('/');\n      }\n      if (queryIndex === 0) {\n        return [encodedPath];\n      }\n      const endSection = encodedPath.substr(queryIndex);\n      const parts = encodedPath.substr(0, encodedPath.length - endSection.length).split('/');\n      parts[parts.length - 1] += endSection;\n      return parts;\n    }\n  }\n\n  fileUrlFromNetworkUrl(url: Platform.DevToolsPath.UrlString, ignoreInactive?: boolean):\n      Platform.DevToolsPath.UrlString {\n    if (!this.projectInternal) {\n      return Platform.DevToolsPath.EmptyUrlString;\n    }\n    return Common.ParsedURL.ParsedURL.concatenate(\n        (this.projectInternal as FileSystem).fileSystemPath(), '/', this.encodedPathFromUrl(url, ignoreInactive));\n  }\n\n  private getHeadersUISourceCodeFromUrl(url: Platform.DevToolsPath.UrlString): Workspace.UISourceCode.UISourceCode\n      |null {\n    const fileUrlFromRequest = this.fileUrlFromNetworkUrl(url, /* ignoreNoActive */ true);\n    const folderUrlFromRequest =\n        Common.ParsedURL.ParsedURL.substring(fileUrlFromRequest, 0, fileUrlFromRequest.lastIndexOf('/'));\n    const headersFileUrl = Common.ParsedURL.ParsedURL.concatenate(folderUrlFromRequest, '/', HEADERS_FILENAME);\n    return Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURL(headersFileUrl);\n  }\n\n  async getOrCreateHeadersUISourceCodeFromUrl(url: Platform.DevToolsPath.UrlString):\n      Promise<Workspace.UISourceCode.UISourceCode|null> {\n    let uiSourceCode = this.getHeadersUISourceCodeFromUrl(url);\n    if (!uiSourceCode && this.projectInternal) {\n      const encodedFilePath = this.encodedPathFromUrl(url, /* ignoreNoActive */ true);\n      const encodedPath = Common.ParsedURL.ParsedURL.substring(encodedFilePath, 0, encodedFilePath.lastIndexOf('/'));\n      uiSourceCode = await this.projectInternal.createFile(encodedPath, HEADERS_FILENAME, '');\n    }\n    return uiSourceCode;\n  }\n\n  private decodeLocalPathToUrlPath(path: string): string {\n    try {\n      return unescape(path);\n    } catch (e) {\n      console.error(e);\n    }\n    return path;\n  }\n\n  async #unbind(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const binding = this.bindings.get(uiSourceCode);\n    if (binding) {\n      const mutex = this.#getOrCreateMutex(binding.network);\n      const release = await mutex.acquire();\n      try {\n        await this.#innerUnbind(binding);\n      } finally {\n        release();\n      }\n    }\n  }\n\n  async #unbindUnguarded(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const binding = this.bindings.get(uiSourceCode);\n    if (binding) {\n      await this.#innerUnbind(binding);\n    }\n  }\n\n  #innerUnbind(binding: PersistenceBinding): Promise<void> {\n    this.bindings.delete(binding.network);\n    this.bindings.delete(binding.fileSystem);\n    return PersistenceImpl.instance().removeBinding(binding);\n  }\n\n  async #bind(\n      networkUISourceCode: Workspace.UISourceCode.UISourceCode,\n      fileSystemUISourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const mutex = this.#getOrCreateMutex(networkUISourceCode);\n    const release = await mutex.acquire();\n    try {\n      const existingBinding = this.bindings.get(networkUISourceCode);\n      if (existingBinding) {\n        const {network, fileSystem} = existingBinding;\n        if (networkUISourceCode === network && fileSystemUISourceCode === fileSystem) {\n          return;\n        }\n        await this.#unbindUnguarded(networkUISourceCode);\n        await this.#unbindUnguarded(fileSystemUISourceCode);\n      }\n\n      await this.#innerAddBinding(networkUISourceCode, fileSystemUISourceCode);\n    } finally {\n      release();\n    }\n  }\n\n  #getOrCreateMutex(networkUISourceCode: Workspace.UISourceCode.UISourceCode): Common.Mutex.Mutex {\n    let mutex = this.#sourceCodeToBindProcessMutex.get(networkUISourceCode);\n    if (!mutex) {\n      mutex = new Common.Mutex.Mutex();\n      this.#sourceCodeToBindProcessMutex.set(networkUISourceCode, mutex);\n    }\n    return mutex;\n  }\n\n  async #innerAddBinding(\n      networkUISourceCode: Workspace.UISourceCode.UISourceCode,\n      fileSystemUISourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    const binding = new PersistenceBinding(networkUISourceCode, fileSystemUISourceCode);\n    this.bindings.set(networkUISourceCode, binding);\n    this.bindings.set(fileSystemUISourceCode, binding);\n    await PersistenceImpl.instance().addBinding(binding);\n    const uiSourceCodeOfTruth =\n        this.savingForOverrides.has(networkUISourceCode) ? networkUISourceCode : fileSystemUISourceCode;\n    const [{content}, encoded] =\n        await Promise.all([uiSourceCodeOfTruth.requestContent(), uiSourceCodeOfTruth.contentEncoded()]);\n    PersistenceImpl.instance().syncContent(uiSourceCodeOfTruth, content || '', encoded);\n  }\n\n  private onUISourceCodeWorkingCopyCommitted(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    void this.saveUISourceCodeForOverrides(uiSourceCode);\n  }\n\n  canSaveUISourceCodeForOverrides(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    return this.activeInternal && uiSourceCode.project().type() === Workspace.Workspace.projectTypes.Network &&\n        !this.bindings.has(uiSourceCode) && !this.savingForOverrides.has(uiSourceCode);\n  }\n\n  async saveUISourceCodeForOverrides(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (!this.canSaveUISourceCodeForOverrides(uiSourceCode)) {\n      return;\n    }\n    this.savingForOverrides.add(uiSourceCode);\n    let encodedPath = this.encodedPathFromUrl(uiSourceCode.url());\n    const content = (await uiSourceCode.requestContent()).content || '';\n    const encoded = await uiSourceCode.contentEncoded();\n    const lastIndexOfSlash = encodedPath.lastIndexOf('/');\n    const encodedFileName = Common.ParsedURL.ParsedURL.substring(encodedPath, lastIndexOfSlash + 1);\n    const rawFileName = Common.ParsedURL.ParsedURL.encodedPathToRawPathString(encodedFileName);\n    encodedPath = Common.ParsedURL.ParsedURL.substr(encodedPath, 0, lastIndexOfSlash);\n    if (this.projectInternal) {\n      await this.projectInternal.createFile(encodedPath, rawFileName, content, encoded);\n    }\n    this.fileCreatedForTest(encodedPath, rawFileName);\n    this.savingForOverrides.delete(uiSourceCode);\n  }\n\n  private fileCreatedForTest(_path: Platform.DevToolsPath.EncodedPathString, _fileName: string): void {\n  }\n\n  private patternForFileSystemUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): string {\n    const relativePathParts = FileSystemWorkspaceBinding.relativePath(uiSourceCode);\n    if (relativePathParts.length < 2) {\n      return '';\n    }\n    if (relativePathParts[1] === 'longurls' && relativePathParts.length !== 2) {\n      return 'http?://' + relativePathParts[0] + '/*';\n    }\n    // 'relativePath' returns an encoded string of the local file name which itself is already encoded.\n    // We therefore need to decode twice to get the raw path.\n    return 'http?://' + this.decodeLocalPathToUrlPath(this.decodeLocalPathToUrlPath(relativePathParts.join('/')));\n  }\n\n  private async onUISourceCodeAdded(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    await this.networkUISourceCodeAdded(uiSourceCode);\n    await this.filesystemUISourceCodeAdded(uiSourceCode);\n  }\n\n  private canHandleNetworkUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    return this.activeInternal && !uiSourceCode.url().startsWith('snippet://');\n  }\n\n  private async networkUISourceCodeAdded(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (uiSourceCode.project().type() !== Workspace.Workspace.projectTypes.Network ||\n        !this.canHandleNetworkUISourceCode(uiSourceCode)) {\n      return;\n    }\n    const url = Common.ParsedURL.ParsedURL.urlWithoutHash(uiSourceCode.url()) as Platform.DevToolsPath.UrlString;\n    this.networkUISourceCodeForEncodedPath.set(this.encodedPathFromUrl(url), uiSourceCode);\n\n    const project = this.projectInternal as FileSystem;\n    const fileSystemUISourceCode = project.uiSourceCodeForURL(this.fileUrlFromNetworkUrl(url));\n    if (fileSystemUISourceCode) {\n      await this.#bind(uiSourceCode, fileSystemUISourceCode);\n    }\n  }\n\n  private async filesystemUISourceCodeAdded(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (!this.activeInternal || uiSourceCode.project() !== this.projectInternal) {\n      return;\n    }\n    this.updateInterceptionPatterns();\n\n    const relativePath = FileSystemWorkspaceBinding.relativePath(uiSourceCode);\n    const networkUISourceCode =\n        this.networkUISourceCodeForEncodedPath.get(Common.ParsedURL.ParsedURL.join(relativePath, '/'));\n    if (networkUISourceCode) {\n      await this.#bind(networkUISourceCode, uiSourceCode);\n    }\n  }\n\n  async generateHeaderPatterns(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<{\n    headerPatterns: Set<string>,\n    path: Platform.DevToolsPath.EncodedPathString,\n    overridesWithRegex: HeaderOverrideWithRegex[],\n  }> {\n    const headerPatterns = new Set<string>();\n    const content = (await uiSourceCode.requestContent()).content || '[]';\n    let headerOverrides: HeaderOverride[] = [];\n    try {\n      headerOverrides = JSON.parse(content) as HeaderOverride[];\n      if (!headerOverrides.every(isHeaderOverride)) {\n        throw 'Type mismatch after parsing';\n      }\n    } catch (e) {\n      console.error('Failed to parse', uiSourceCode.url(), 'for locally overriding headers.');\n      return {headerPatterns, path: Platform.DevToolsPath.EmptyEncodedPathString, overridesWithRegex: []};\n    }\n    const relativePath = FileSystemWorkspaceBinding.relativePath(uiSourceCode).join('/');\n    // 'relativePath' returns an encoded string of the local file name which itself is already encoded.\n    // e.g. relativePath: 'www.example.com%253A443/path/.headers '\n    // singlyDecodedPath: 'www.example.com%3A443/path/'\n    // decodedPath: 'www.example.com:443/path'\n    const singlyDecodedPath = this.decodeLocalPathToUrlPath(relativePath).slice(0, -HEADERS_FILENAME.length) as\n        Platform.DevToolsPath.EncodedPathString;\n    const decodedPath = this.decodeLocalPathToUrlPath(singlyDecodedPath) as Platform.DevToolsPath.RawPathString;\n\n    const overridesWithRegex: HeaderOverrideWithRegex[] = [];\n    for (const headerOverride of headerOverrides) {\n      headerPatterns.add('http?://' + decodedPath + headerOverride.applyTo);\n\n      // Most servers have the concept of a \"directory index\", which is a\n      // default resource name for a request targeting a \"directory\", e. g.\n      // requesting \"example.com/path/\" would result in the same response as\n      // requesting \"example.com/path/index.html\". To match this behavior we\n      // generate an additional pattern without \"index.html\" as the longer\n      // pattern would not match against a shorter request.\n      const {head, tail} = extractDirectoryIndex(headerOverride.applyTo);\n      if (tail) {\n        headerPatterns.add('http?://' + decodedPath + head);\n\n        const pattern = escapeRegex(decodedPath + head) + '(' + escapeRegex(tail) + ')?';\n        const regex = new RegExp('^https?:\\/\\/' + pattern + '$');\n        overridesWithRegex.push({\n          applyToRegex: regex,\n          headers: headerOverride.headers,\n        });\n      } else {\n        const regex = new RegExp('^https?:\\/\\/' + escapeRegex(decodedPath + headerOverride.applyTo) + '$');\n        overridesWithRegex.push({\n          applyToRegex: regex,\n          headers: headerOverride.headers,\n        });\n      }\n    }\n    return {headerPatterns, path: singlyDecodedPath, overridesWithRegex};\n  }\n\n  async updateInterceptionPatternsForTests(): Promise<void> {\n    await this.#innerUpdateInterceptionPatterns();\n  }\n\n  updateInterceptionPatterns(): void {\n    void this.updateInterceptionThrottler.schedule(this.#innerUpdateInterceptionPatterns.bind(this));\n  }\n\n  async #innerUpdateInterceptionPatterns(): Promise<void> {\n    this.#headerOverridesMap.clear();\n    if (!this.activeInternal || !this.projectInternal) {\n      return SDK.NetworkManager.MultitargetNetworkManager.instance().setInterceptionHandlerForPatterns(\n          [], this.interceptionHandlerBound);\n    }\n    let patterns = new Set<string>();\n    for (const uiSourceCode of this.projectInternal.uiSourceCodes()) {\n      const pattern = this.patternForFileSystemUISourceCode(uiSourceCode);\n      if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.HEADER_OVERRIDES) &&\n          uiSourceCode.name() === HEADERS_FILENAME) {\n        const {headerPatterns, path, overridesWithRegex} = await this.generateHeaderPatterns(uiSourceCode);\n        if (headerPatterns.size > 0) {\n          patterns = new Set([...patterns, ...headerPatterns]);\n          this.#headerOverridesMap.set(path, overridesWithRegex);\n        }\n      } else {\n        patterns.add(pattern);\n      }\n      // Most servers have the concept of a \"directory index\", which is a\n      // default resource name for a request targeting a \"directory\", e. g.\n      // requesting \"example.com/path/\" would result in the same response as\n      // requesting \"example.com/path/index.html\". To match this behavior we\n      // generate an additional pattern without \"index.html\" as the longer\n      // pattern would not match against a shorter request.\n      const {head, tail} = extractDirectoryIndex(pattern);\n      if (tail) {\n        patterns.add(head);\n      }\n    }\n\n    return SDK.NetworkManager.MultitargetNetworkManager.instance().setInterceptionHandlerForPatterns(\n        Array.from(patterns).map(\n            pattern => ({urlPattern: pattern, requestStage: Protocol.Fetch.RequestStage.Response})),\n        this.interceptionHandlerBound);\n  }\n\n  private async onUISourceCodeRemoved(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    await this.networkUISourceCodeRemoved(uiSourceCode);\n    await this.filesystemUISourceCodeRemoved(uiSourceCode);\n  }\n\n  private async networkUISourceCodeRemoved(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (uiSourceCode.project().type() === Workspace.Workspace.projectTypes.Network) {\n      await this.#unbind(uiSourceCode);\n      this.#sourceCodeToBindProcessMutex.delete(uiSourceCode);\n      this.networkUISourceCodeForEncodedPath.delete(this.encodedPathFromUrl(uiSourceCode.url()));\n    }\n  }\n\n  private async filesystemUISourceCodeRemoved(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    if (uiSourceCode.project() !== this.projectInternal) {\n      return;\n    }\n    this.updateInterceptionPatterns();\n    this.originalResponseContentPromises.delete(uiSourceCode);\n    await this.#unbind(uiSourceCode);\n  }\n\n  async setProject(project: Workspace.Workspace.Project|null): Promise<void> {\n    if (project === this.projectInternal) {\n      return;\n    }\n\n    if (this.projectInternal) {\n      await Promise.all(\n          this.projectInternal.uiSourceCodes().map(uiSourceCode => this.filesystemUISourceCodeRemoved(uiSourceCode)));\n    }\n\n    this.projectInternal = project;\n\n    if (this.projectInternal) {\n      await Promise.all(\n          this.projectInternal.uiSourceCodes().map(uiSourceCode => this.filesystemUISourceCodeAdded(uiSourceCode)));\n    }\n\n    await this.updateActiveProject();\n    this.dispatchEventToListeners(Events.ProjectChanged, this.projectInternal);\n  }\n\n  private async onProjectAdded(project: Workspace.Workspace.Project): Promise<void> {\n    if (project.type() !== Workspace.Workspace.projectTypes.FileSystem ||\n        FileSystemWorkspaceBinding.fileSystemType(project) !== 'overrides') {\n      return;\n    }\n    const fileSystemPath = FileSystemWorkspaceBinding.fileSystemPath(project.id() as Platform.DevToolsPath.UrlString);\n    if (!fileSystemPath) {\n      return;\n    }\n    if (this.projectInternal) {\n      this.projectInternal.remove();\n    }\n\n    await this.setProject(project);\n  }\n\n  private async onProjectRemoved(project: Workspace.Workspace.Project): Promise<void> {\n    if (project === this.projectInternal) {\n      await this.setProject(null);\n    }\n  }\n\n  mergeHeaders(baseHeaders: Protocol.Fetch.HeaderEntry[], overrideHeaders: Protocol.Network.Headers):\n      Protocol.Fetch.HeaderEntry[] {\n    const result: Protocol.Fetch.HeaderEntry[] = [];\n    const headerMap = new Map<string, string>();\n    for (const header of baseHeaders) {\n      headerMap.set(header.name, header.value);\n    }\n    for (const [headerName, headerValue] of Object.entries(overrideHeaders)) {\n      headerMap.set(headerName, headerValue);\n    }\n    headerMap.forEach((headerValue, headerName) => {\n      result.push({name: headerName, value: headerValue});\n    });\n    return result;\n  }\n\n  #maybeMergeHeadersForPathSegment(\n      path: Platform.DevToolsPath.EncodedPathString, requestUrl: Platform.DevToolsPath.UrlString,\n      headers: Protocol.Fetch.HeaderEntry[]): Protocol.Fetch.HeaderEntry[] {\n    const headerOverrides = this.#headerOverridesMap.get(path) || [];\n    for (const headerOverride of headerOverrides) {\n      if (headerOverride.applyToRegex.test(requestUrl)) {\n        headers = this.mergeHeaders(headers, headerOverride.headers);\n      }\n    }\n    return headers;\n  }\n\n  handleHeaderInterception(interceptedRequest: SDK.NetworkManager.InterceptedRequest): Protocol.Fetch.HeaderEntry[] {\n    let result: Protocol.Fetch.HeaderEntry[] = interceptedRequest.responseHeaders || [];\n    // 'rawPathFromUrl()''s return value is already (singly-)encoded, so we can\n    // treat it as an 'EncodedPathString' here.\n    const urlSegments =\n        this.rawPathFromUrl(interceptedRequest.request.url as Platform.DevToolsPath.UrlString).split('/') as\n        Platform.DevToolsPath.EncodedPathString[];\n    // Traverse the hierarchy of overrides from the most general to the most\n    // specific. Check with empty string first to match overrides applying to\n    // all domains.\n    // e.g. '', 'www.example.com/', 'www.example.com/path/', ...\n    let path = Platform.DevToolsPath.EmptyEncodedPathString;\n    result = this.#maybeMergeHeadersForPathSegment(\n        path, interceptedRequest.request.url as Platform.DevToolsPath.UrlString, result);\n    for (const segment of urlSegments) {\n      path = Common.ParsedURL.ParsedURL.concatenate(path, segment, '/');\n      result = this.#maybeMergeHeadersForPathSegment(\n          path, interceptedRequest.request.url as Platform.DevToolsPath.UrlString, result);\n    }\n    return result;\n  }\n\n  private async interceptionHandler(interceptedRequest: SDK.NetworkManager.InterceptedRequest): Promise<void> {\n    const method = interceptedRequest.request.method;\n    if (!this.activeInternal || (method !== 'GET' && method !== 'POST')) {\n      return;\n    }\n    const proj = this.projectInternal as FileSystem;\n    const path = this.fileUrlFromNetworkUrl(interceptedRequest.request.url as Platform.DevToolsPath.UrlString);\n    const fileSystemUISourceCode = proj.uiSourceCodeForURL(path);\n    let responseHeaders: Protocol.Fetch.HeaderEntry[] = [];\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.HEADER_OVERRIDES)) {\n      responseHeaders = this.handleHeaderInterception(interceptedRequest);\n    }\n    if (!fileSystemUISourceCode && !responseHeaders.length) {\n      return;\n    }\n    if (!responseHeaders.length) {\n      responseHeaders = interceptedRequest.responseHeaders || [];\n    }\n\n    let mimeType = '';\n    if (interceptedRequest.responseHeaders) {\n      for (const header of interceptedRequest.responseHeaders) {\n        if (header.name.toLowerCase() === 'content-type') {\n          mimeType = header.value;\n          break;\n        }\n      }\n    }\n\n    if (!mimeType) {\n      const expectedResourceType =\n          Common.ResourceType.resourceTypes[interceptedRequest.resourceType] || Common.ResourceType.resourceTypes.Other;\n      mimeType = fileSystemUISourceCode?.mimeType() || '';\n      if (Common.ResourceType.ResourceType.fromMimeType(mimeType) !== expectedResourceType) {\n        mimeType = expectedResourceType.canonicalMimeType();\n      }\n    }\n\n    if (fileSystemUISourceCode) {\n      this.originalResponseContentPromises.set(\n          fileSystemUISourceCode, interceptedRequest.responseBody().then(response => {\n            if (response.error || response.content === null) {\n              return null;\n            }\n            if (response.encoded) {\n              const text = atob(response.content);\n              const data = new Uint8Array(text.length);\n              for (let i = 0; i < text.length; ++i) {\n                data[i] = text.charCodeAt(i);\n              }\n              return new TextDecoder('utf-8').decode(data);\n            }\n            return response.content;\n          }));\n\n      const project = fileSystemUISourceCode.project() as FileSystem;\n      const blob = await project.requestFileBlob(fileSystemUISourceCode);\n      if (blob) {\n        void interceptedRequest.continueRequestWithContent(\n            new Blob([blob], {type: mimeType}), /* encoded */ false, responseHeaders);\n      }\n    } else {\n      const responseBody = await interceptedRequest.responseBody();\n      if (!responseBody.error && responseBody.content) {\n        void interceptedRequest.continueRequestWithContent(\n            new Blob([responseBody.content], {type: mimeType}), /* encoded */ true, responseHeaders);\n      }\n    }\n  }\n}\n\nconst RESERVED_FILENAMES = new Set<string>([\n  'con',  'prn',  'aux',  'nul',  'com1', 'com2', 'com3', 'com4', 'com5', 'com6', 'com7',\n  'com8', 'com9', 'lpt1', 'lpt2', 'lpt3', 'lpt4', 'lpt5', 'lpt6', 'lpt7', 'lpt8', 'lpt9',\n]);\n\nexport const HEADERS_FILENAME = '.headers';\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  ProjectChanged = 'ProjectChanged',\n}\n\nexport type EventTypes = {\n  [Events.ProjectChanged]: Workspace.Workspace.Project|null,\n};\n\nexport interface HeaderOverride {\n  applyTo: string;\n  headers: Protocol.Network.Headers;\n}\n\ninterface HeaderOverrideWithRegex {\n  applyToRegex: RegExp;\n  headers: Protocol.Network.Headers;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isHeaderOverride(arg: any): arg is HeaderOverride {\n  if (!(arg && arg.applyTo && typeof (arg.applyTo === 'string') && arg.headers && Object.keys(arg.headers).length)) {\n    return false;\n  }\n  return Object.values(arg.headers).every(value => typeof value === 'string');\n}\n\nexport function escapeRegex(pattern: string): string {\n  return Platform.StringUtilities.escapeCharacters(pattern, '[]{}()\\\\.^$+|-,?').replaceAll('*', '.*');\n}\n\nexport function extractDirectoryIndex(pattern: string): {head: string, tail?: string} {\n  const lastSlash = pattern.lastIndexOf('/');\n  const tail = lastSlash >= 0 ? pattern.slice(lastSlash + 1) : pattern;\n  const head = lastSlash >= 0 ? pattern.slice(0, lastSlash + 1) : '';\n  const regex = new RegExp('^' + escapeRegex(tail) + '$');\n  if (regex.test('index.html') || regex.test('index.htm') || regex.test('index.php')) {\n    return {head, tail};\n  }\n  return {head: pattern};\n}\n"],
  "mappings": "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",
  "names": []
}
