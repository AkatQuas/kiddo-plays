{
  "version": 3,
  "sources": ["../../../../../../front_end/models/source_map_scopes/NamesResolver.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as Formatter from '../formatter/formatter.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\nimport type * as Workspace from '../workspace/workspace.js';\nimport * as Protocol from '../../generated/protocol.js';\n\ninterface CachedScopeMap {\n  sourceMap: SDK.SourceMap.SourceMap|null;\n  mappingPromise: Promise<{variableMapping: Map<string, string>, thisMapping: string|null}>;\n}\n\nconst scopeToCachedIdentifiersMap = new WeakMap<SDK.DebuggerModel.ScopeChainEntry, CachedScopeMap>();\nconst cachedMapByCallFrame = new WeakMap<SDK.DebuggerModel.CallFrame, Map<string, string>>();\n\nexport class IdentifierPositions {\n  name: string;\n  positions: {lineNumber: number, columnNumber: number}[];\n\n  constructor(name: string, positions: {lineNumber: number, columnNumber: number}[] = []) {\n    this.name = name;\n    this.positions = positions;\n  }\n\n  addPosition(lineNumber: number, columnNumber: number): void {\n    this.positions.push({lineNumber, columnNumber});\n  }\n}\n\nconst computeScopeTree = async function(functionScope: SDK.DebuggerModel.ScopeChainEntry): Promise<{\n  scopeTree: Formatter.FormatterWorkerPool.ScopeTreeNode, text: TextUtils.Text.Text, slide: number,\n}|null> {\n  const functionStartLocation = functionScope.startLocation();\n  const functionEndLocation = functionScope.endLocation();\n  if (!functionStartLocation || !functionEndLocation) {\n    return null;\n  }\n  const script = functionStartLocation.script();\n  if (!script || !script.sourceMapURL || script !== functionEndLocation.script()) {\n    return null;\n  }\n  const {content} = await script.requestContent();\n  if (!content) {\n    return null;\n  }\n\n  const text = new TextUtils.Text.Text(content);\n  const scopeRange = new TextUtils.TextRange.TextRange(\n      functionStartLocation.lineNumber, functionStartLocation.columnNumber, functionEndLocation.lineNumber,\n      functionEndLocation.columnNumber);\n  const scopeText = text.extract(scopeRange);\n  const scopeStart = text.toSourceRange(scopeRange).offset;\n  // We wrap the scope in a class constructor. This handles the case where the\n  // scope is a (non-arrow) function and the case where it is a constructor\n  // (so that parsing 'super' calls succeeds).\n  let prefix = 'class DummyClass extends DummyBase { constructor';\n  let suffix = '}';\n  let scopeTree =\n      await Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptScopeTree(prefix + scopeText + suffix);\n  if (!scopeTree) {\n    // Try to parse the function as an arrow function.\n    prefix = '';\n    suffix = '';\n    scopeTree =\n        await Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptScopeTree(prefix + scopeText + suffix);\n  }\n  if (!scopeTree) {\n    return null;\n  }\n  return {scopeTree, text, slide: scopeStart - prefix.length};\n};\n\nexport const scopeIdentifiers = async function(\n    functionScope: SDK.DebuggerModel.ScopeChainEntry|null, scope: SDK.DebuggerModel.ScopeChainEntry): Promise<{\n  freeVariables: IdentifierPositions[], boundVariables: IdentifierPositions[],\n}|null> {\n  if (!functionScope) {\n    return null;\n  }\n\n  const startLocation = scope.startLocation();\n  const endLocation = scope.endLocation();\n  if (!startLocation || !endLocation) {\n    return null;\n  }\n\n  // Parse the function scope to get the scope tree.\n  const scopeTreeAndStart = await computeScopeTree(functionScope);\n  if (!scopeTreeAndStart) {\n    return null;\n  }\n  const {scopeTree, text, slide} = scopeTreeAndStart;\n\n  // Compute the offset within the scope tree coordinate space.\n  const scopeOffsets = {\n    start: text.offsetFromPosition(startLocation.lineNumber, startLocation.columnNumber) - slide,\n    end: text.offsetFromPosition(endLocation.lineNumber, endLocation.columnNumber) - slide,\n  };\n\n  if (!contains(scopeTree, scopeOffsets)) {\n    return null;\n  }\n\n  // Find the corresponding scope in the scope tree.\n  let containingScope = scopeTree;\n  const ancestorScopes = [];\n  while (true) {\n    let childFound = false;\n    for (const child of containingScope.children) {\n      if (contains(child, scopeOffsets)) {\n        // We found a nested containing scope, continue with search there.\n        ancestorScopes.push(containingScope);\n        containingScope = child;\n        childFound = true;\n        break;\n      }\n      // Sanity check: |scope| should not straddle any of the scopes in the tree. That is:\n      // Either |scope| is disjoint from |child| or |child| must be inside |scope|.\n      // (Or the |scope| is inside |child|, but that case is covered above.)\n      if (!disjoint(scopeOffsets, child) && !contains(scopeOffsets, child)) {\n        console.error('Wrong nesting of scopes');\n        return null;\n      }\n    }\n    if (!childFound) {\n      // We found the deepest scope in the tree that contains our scope chain entry.\n      break;\n    }\n  }\n\n  // Now we have containing scope. Collect all the scope variables.\n  const boundVariables = [];\n  const cursor = new TextUtils.TextCursor.TextCursor(text.lineEndings());\n  for (const variable of containingScope.variables) {\n    // Skip the fixed-kind variable (i.e., 'this' or 'arguments') if we only found their \"definition\"\n    // without any uses.\n    if (variable.kind === Formatter.FormatterWorkerPool.DefinitionKind.Fixed && variable.offsets.length <= 1) {\n      continue;\n    }\n\n    const identifier = new IdentifierPositions(variable.name);\n    for (const offset of variable.offsets) {\n      const start = offset + slide;\n      cursor.resetTo(start);\n      identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n    }\n    boundVariables.push(identifier);\n  }\n\n  // Compute free variables by collecting all the ancestor variables that are used in |containingScope|.\n  const freeVariables = [];\n  for (const ancestor of ancestorScopes) {\n    for (const ancestorVariable of ancestor.variables) {\n      let identifier = null;\n      for (const offset of ancestorVariable.offsets) {\n        if (offset >= containingScope.start && offset < containingScope.end) {\n          if (!identifier) {\n            identifier = new IdentifierPositions(ancestorVariable.name);\n          }\n          const start = offset + slide;\n          cursor.resetTo(start);\n          identifier.addPosition(cursor.lineNumber(), cursor.columnNumber());\n        }\n      }\n      if (identifier) {\n        freeVariables.push(identifier);\n      }\n    }\n  }\n  return {boundVariables, freeVariables};\n\n  function contains(scope: {start: number, end: number}, candidate: {start: number, end: number}): boolean {\n    return (scope.start <= candidate.start) && (scope.end >= candidate.end);\n  }\n  function disjoint(scope: {start: number, end: number}, other: {start: number, end: number}): boolean {\n    return (scope.end <= other.start) || (other.end <= scope.start);\n  }\n};\n\nconst identifierAndPunctuationRegExp = /^\\s*([A-Za-z_$][A-Za-z_$0-9]*)\\s*([.;,=]?)\\s*$/;\n\nconst enum Punctuation {\n  None = 'none',\n  Comma = 'comma',\n  Dot = 'dot',\n  Semicolon = 'semicolon',\n  Equals = 'equals',\n}\n\nconst resolveScope =\n    async(scope: SDK.DebuggerModel\n              .ScopeChainEntry): Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n  let cachedScopeMap = scopeToCachedIdentifiersMap.get(scope);\n  const script = scope.callFrame().script;\n  const sourceMap = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().sourceMapForScript(script);\n\n  if (!cachedScopeMap || cachedScopeMap.sourceMap !== sourceMap) {\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const identifiersPromise =\n        (async(): Promise<{variableMapping: Map<string, string>, thisMapping: string | null}> => {\n          const variableMapping = new Map<string, string>();\n          let thisMapping = null;\n\n          if (!sourceMap) {\n            return {variableMapping, thisMapping};\n          }\n          const textCache = new Map<string, TextUtils.Text.Text>();\n          // Extract as much as possible from SourceMap and resolve\n          // missing identifier names from SourceMap ranges.\n          const promises: Promise<void>[] = [];\n\n          const resolveEntry = (id: IdentifierPositions, handler: (sourceName: string) => void): void => {\n            // First see if we have a source map entry with a name for the identifier.\n            for (const position of id.positions) {\n              const entry = sourceMap.findEntry(position.lineNumber, position.columnNumber);\n              if (entry && entry.name) {\n                handler(entry.name);\n                return;\n              }\n            }\n            // If there is no entry with the name field, try to infer the name from the source positions.\n            async function resolvePosition(): Promise<void> {\n              if (!sourceMap) {\n                return;\n              }\n              // Let us find the first non-empty mapping of |id| and return that. Ideally, we would\n              // try to compute all the mappings and only use the mapping if all the non-empty\n              // mappings agree. However, that can be expensive for identifiers with many uses,\n              // so we iterate sequentially, stopping at the first non-empty mapping.\n              for (const position of id.positions) {\n                const sourceName = await resolveSourceName(script, sourceMap, id.name, position, textCache);\n                if (sourceName) {\n                  handler(sourceName);\n                  return;\n                }\n              }\n            }\n            promises.push(resolvePosition());\n          };\n\n          const functionScope = findFunctionScope();\n          const parsedVariables = await scopeIdentifiers(functionScope, scope);\n          if (!parsedVariables) {\n            return {variableMapping, thisMapping};\n          }\n          for (const id of parsedVariables.boundVariables) {\n            resolveEntry(id, sourceName => {\n              // Let use ignore 'this' mappings - those are handled separately.\n              if (sourceName !== 'this') {\n                variableMapping.set(id.name, sourceName);\n              }\n            });\n          }\n          for (const id of parsedVariables.freeVariables) {\n            resolveEntry(id, sourceName => {\n              if (sourceName === 'this') {\n                thisMapping = id.name;\n              }\n            });\n          }\n          await Promise.all(promises).then(getScopeResolvedForTest());\n          return {variableMapping, thisMapping};\n        })();\n    cachedScopeMap = {sourceMap, mappingPromise: identifiersPromise};\n    scopeToCachedIdentifiersMap.set(scope, {sourceMap, mappingPromise: identifiersPromise});\n  }\n  return await cachedScopeMap.mappingPromise;\n\n  async function resolveSourceName(\n      script: SDK.Script.Script, sourceMap: SDK.SourceMap.SourceMap, name: string,\n      position: {lineNumber: number, columnNumber: number},\n      textCache: Map<string, TextUtils.Text.Text>): Promise<string|null> {\n    const ranges = sourceMap.findEntryRanges(position.lineNumber, position.columnNumber);\n    if (!ranges) {\n      return null;\n    }\n    // Extract the underlying text from the compiled code's range and make sure that\n    // it starts with the identifier |name|.\n    const uiSourceCode =\n        Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiSourceCodeForSourceMapSourceURL(\n            script.debuggerModel, ranges.sourceURL, script.isContentScript());\n    if (!uiSourceCode) {\n      return null;\n    }\n    const compiledText = getTextFor((await script.requestContent()).content);\n    if (!compiledText) {\n      return null;\n    }\n    const compiledToken = compiledText.extract(ranges.range);\n    const parsedCompiledToken = extractIdentifier(compiledToken);\n    if (!parsedCompiledToken) {\n      return null;\n    }\n    const {name: compiledName, punctuation: compiledPunctuation} = parsedCompiledToken;\n    if (compiledName !== name) {\n      return null;\n    }\n\n    // Extract the mapped name from the source code range and ensure that the punctuation\n    // matches the one from the compiled code.\n    const sourceText = getTextFor((await uiSourceCode.requestContent()).content);\n    if (!sourceText) {\n      return null;\n    }\n    const sourceToken = sourceText.extract(ranges.sourceRange);\n    const parsedSourceToken = extractIdentifier(sourceToken);\n    if (!parsedSourceToken) {\n      return null;\n    }\n    const {name: sourceName, punctuation: sourcePunctuation} = parsedSourceToken;\n    // Accept the source name if it is followed by the same punctuation.\n    if (compiledPunctuation === sourcePunctuation) {\n      return sourceName;\n    }\n    // Let us also allow semicolons into commas since that it is a common transformation.\n    if (compiledPunctuation === Punctuation.Comma && sourcePunctuation === Punctuation.Semicolon) {\n      return sourceName;\n    }\n\n    return null;\n\n    function extractIdentifier(token: string): {name: string, punctuation: Punctuation}|null {\n      const match = token.match(identifierAndPunctuationRegExp);\n      if (!match) {\n        return null;\n      }\n\n      const name = match[1];\n      let punctuation: Punctuation|null = null;\n      switch (match[2]) {\n        case '.':\n          punctuation = Punctuation.Dot;\n          break;\n        case ',':\n          punctuation = Punctuation.Comma;\n          break;\n        case ';':\n          punctuation = Punctuation.Semicolon;\n          break;\n        case '=':\n          punctuation = Punctuation.Equals;\n          break;\n        case '':\n          punctuation = Punctuation.None;\n          break;\n        default:\n          console.error(`Name token parsing error: unexpected token \"${match[2]}\"`);\n          return null;\n      }\n\n      return {name, punctuation};\n    }\n\n    function getTextFor(content: string|null): TextUtils.Text.Text|null {\n      if (!content) {\n        return null;\n      }\n      let text = textCache.get(content);\n      if (!text) {\n        text = new TextUtils.Text.Text(content);\n        textCache.set(content, text);\n      }\n      return text;\n    }\n  }\n\n  function findFunctionScope(): SDK.DebuggerModel.ScopeChainEntry|null {\n    // First find the scope in the callframe's scope chain and then find the containing function scope (closure or local).\n    const scopeChain = scope.callFrame().scopeChain();\n    let scopeIndex = 0;\n    for (scopeIndex; scopeIndex < scopeChain.length; scopeIndex++) {\n      if (scopeChain[scopeIndex] === scope) {\n        break;\n      }\n    }\n    for (scopeIndex; scopeIndex < scopeChain.length; scopeIndex++) {\n      const kind = scopeChain[scopeIndex].type();\n      if (kind === Protocol.Debugger.ScopeType.Local || kind === Protocol.Debugger.ScopeType.Closure) {\n        break;\n      }\n    }\n    return scopeIndex === scopeChain.length ? null : scopeChain[scopeIndex];\n  }\n};\n\nexport const resolveScopeChain =\n    async function(callFrame: SDK.DebuggerModel.CallFrame|null): Promise<SDK.DebuggerModel.ScopeChainEntry[]|null> {\n  if (!callFrame) {\n    return null;\n  }\n  const {pluginManager} = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance();\n  if (pluginManager) {\n    const scopeChain = await pluginManager.resolveScopeChain(callFrame);\n    if (scopeChain) {\n      return scopeChain;\n    }\n  }\n  return callFrame.scopeChain();\n};\n\nexport const allVariablesInCallFrame = async(callFrame: SDK.DebuggerModel.CallFrame): Promise<Map<string, string>> => {\n  const cachedMap = cachedMapByCallFrame.get(callFrame);\n  if (cachedMap) {\n    return cachedMap;\n  }\n\n  const scopeChain = callFrame.scopeChain();\n  const nameMappings = await Promise.all(scopeChain.map(resolveScope));\n  const reverseMapping = new Map<string, string>();\n  for (const {variableMapping} of nameMappings) {\n    for (const [compiledName, originalName] of variableMapping) {\n      if (originalName && !reverseMapping.has(originalName)) {\n        reverseMapping.set(originalName, compiledName);\n      }\n    }\n  }\n  cachedMapByCallFrame.set(callFrame, reverseMapping);\n  return reverseMapping;\n};\n\nexport const resolveExpression = async(\n    callFrame: SDK.DebuggerModel.CallFrame, originalText: string, uiSourceCode: Workspace.UISourceCode.UISourceCode,\n    lineNumber: number, startColumnNumber: number, endColumnNumber: number): Promise<string> => {\n  if (uiSourceCode.mimeType() === 'application/wasm') {\n    // For WebAssembly disassembly, lookup the different possiblities.\n    return `memories[\"${originalText}\"] ?? locals[\"${originalText}\"] ?? tables[\"${originalText}\"] ?? functions[\"${\n        originalText}\"] ?? globals[\"${originalText}\"]`;\n  }\n  if (!uiSourceCode.contentType().isFromSourceMap()) {\n    return '';\n  }\n  const reverseMapping = await allVariablesInCallFrame(callFrame);\n  if (reverseMapping.has(originalText)) {\n    return reverseMapping.get(originalText) as string;\n  }\n  const rawLocations =\n      await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(\n          uiSourceCode, lineNumber, startColumnNumber);\n  const rawLocation = rawLocations.find(location => location.debuggerModel === callFrame.debuggerModel);\n  if (!rawLocation) {\n    return '';\n  }\n  const script = rawLocation.script();\n  if (!script) {\n    return '';\n  }\n  const sourceMap =\n      (Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().sourceMapForScript(script) as\n       SDK.SourceMap.TextSourceMap);\n  if (!sourceMap) {\n    return '';\n  }\n  const {content} = await script.requestContent();\n  if (!content) {\n    return '';\n  }\n  const text = new TextUtils.Text.Text(content);\n  const textRange = sourceMap.reverseMapTextRange(\n      uiSourceCode.url(),\n      new TextUtils.TextRange.TextRange(lineNumber, startColumnNumber, lineNumber, endColumnNumber));\n  if (!textRange) {\n    return '';\n  }\n  const subjectText = text.extract(textRange);\n  if (!subjectText) {\n    return '';\n  }\n  return await Formatter.FormatterWorkerPool.formatterWorkerPool().evaluatableJavaScriptSubstring(subjectText);\n};\n\nexport const resolveThisObject =\n    async(callFrame: SDK.DebuggerModel.CallFrame|null): Promise<SDK.RemoteObject.RemoteObject|null> => {\n  if (!callFrame) {\n    return null;\n  }\n  const scopeChain = callFrame.scopeChain();\n  if (scopeChain.length === 0) {\n    return callFrame.thisObject();\n  }\n\n  const {thisMapping} = await resolveScope(scopeChain[0]);\n  if (!thisMapping) {\n    return callFrame.thisObject();\n  }\n\n  const result = await callFrame.evaluate(({\n    expression: thisMapping,\n    objectGroup: 'backtrace',\n    includeCommandLineAPI: false,\n    silent: true,\n    returnByValue: false,\n    generatePreview: true,\n  } as SDK.RuntimeModel.EvaluationOptions));\n  if ('exceptionDetails' in result) {\n    return !result.exceptionDetails && result.object ? result.object : callFrame.thisObject();\n  }\n  return null;\n};\n\nexport const resolveScopeInObject = function(scope: SDK.DebuggerModel.ScopeChainEntry): SDK.RemoteObject.RemoteObject {\n  const startLocation = scope.startLocation();\n  const endLocation = scope.endLocation();\n  const startLocationScript = startLocation ? startLocation.script() : null;\n\n  if (scope.type() === Protocol.Debugger.ScopeType.Global || !startLocationScript || !endLocation ||\n      !startLocationScript.sourceMapURL || startLocationScript !== endLocation.script()) {\n    return scope.object();\n  }\n\n  return new RemoteObject(scope);\n};\n\nexport class RemoteObject extends SDK.RemoteObject.RemoteObject {\n  private readonly scope: SDK.DebuggerModel.ScopeChainEntry;\n  private readonly object: SDK.RemoteObject.RemoteObject;\n  constructor(scope: SDK.DebuggerModel.ScopeChainEntry) {\n    super();\n    this.scope = scope;\n    this.object = scope.object();\n  }\n\n  customPreview(): Protocol.Runtime.CustomPreview|null {\n    return this.object.customPreview();\n  }\n\n  get objectId(): Protocol.Runtime.RemoteObjectId|undefined {\n    return this.object.objectId;\n  }\n\n  get type(): string {\n    return this.object.type;\n  }\n\n  get subtype(): string|undefined {\n    return this.object.subtype;\n  }\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get value(): any {\n    return this.object.value;\n  }\n\n  get description(): string|undefined {\n    return this.object.description;\n  }\n\n  get hasChildren(): boolean {\n    return this.object.hasChildren;\n  }\n\n  get preview(): Protocol.Runtime.ObjectPreview|undefined {\n    return this.object.preview;\n  }\n\n  arrayLength(): number {\n    return this.object.arrayLength();\n  }\n\n  getOwnProperties(generatePreview: boolean): Promise<SDK.RemoteObject.GetPropertiesResult> {\n    return this.object.getOwnProperties(generatePreview);\n  }\n\n  async getAllProperties(accessorPropertiesOnly: boolean, generatePreview: boolean):\n      Promise<SDK.RemoteObject.GetPropertiesResult> {\n    const allProperties = await this.object.getAllProperties(accessorPropertiesOnly, generatePreview);\n    const {variableMapping} = await resolveScope(this.scope);\n\n    const properties = allProperties.properties;\n    const internalProperties = allProperties.internalProperties;\n    const newProperties = [];\n    if (properties) {\n      for (let i = 0; i < properties.length; ++i) {\n        const property = properties[i];\n        const name = variableMapping.get(property.name) || properties[i].name;\n        if (!property.value) {\n          continue;\n        }\n        newProperties.push(new SDK.RemoteObject.RemoteObjectProperty(\n            name, property.value, property.enumerable, property.writable, property.isOwn, property.wasThrown,\n            property.symbol, property.synthetic));\n      }\n    }\n    return {properties: newProperties, internalProperties: internalProperties};\n  }\n\n  async setPropertyValue(argumentName: string|Protocol.Runtime.CallArgument, value: string): Promise<string|undefined> {\n    const {variableMapping} = await resolveScope(this.scope);\n\n    let name;\n    if (typeof argumentName === 'string') {\n      name = argumentName;\n    } else {\n      name = (argumentName.value as string);\n    }\n\n    let actualName: string = name;\n    for (const compiledName of variableMapping.keys()) {\n      if (variableMapping.get(compiledName) === name) {\n        actualName = compiledName;\n        break;\n      }\n    }\n    return this.object.setPropertyValue(actualName, value);\n  }\n\n  async deleteProperty(name: Protocol.Runtime.CallArgument): Promise<string|undefined> {\n    return this.object.deleteProperty(name);\n  }\n\n  callFunction<T>(functionDeclaration: (this: Object, ...arg1: unknown[]) => T, args?: Protocol.Runtime.CallArgument[]):\n      Promise<SDK.RemoteObject.CallFunctionResult> {\n    return this.object.callFunction(functionDeclaration, args);\n  }\n\n  callFunctionJSON<T>(\n      functionDeclaration: (this: Object, ...arg1: unknown[]) => T,\n      args?: Protocol.Runtime.CallArgument[]): Promise<T> {\n    return this.object.callFunctionJSON(functionDeclaration, args);\n  }\n\n  release(): void {\n    this.object.release();\n  }\n\n  debuggerModel(): SDK.DebuggerModel.DebuggerModel {\n    return this.object.debuggerModel();\n  }\n\n  runtimeModel(): SDK.RuntimeModel.RuntimeModel {\n    return this.object.runtimeModel();\n  }\n\n  isNode(): boolean {\n    return this.object.isNode();\n  }\n}\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\nlet _scopeResolvedForTest: (...arg0: any[]) => void = function(): void {};\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\nexport const getScopeResolvedForTest = (): (...arg0: any[]) => void => {\n  return _scopeResolvedForTest;\n};\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n// eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\nexport const setScopeResolvedForTest = (scope: (...arg0: any[]) => void): void => {\n  _scopeResolvedForTest = scope;\n};\n"],
  "mappings": "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",
  "names": []
}
