{
  "version": 3,
  "sources": ["../../../../../../front_end/models/text_utils/TextUtils.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {SearchMatch} from './ContentProvider.js';\nimport {Text} from './Text.js';\n\nexport const Utils = {\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get _keyValueFilterRegex(): RegExp {\n    return /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\n  },\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get _regexFilterRegex(): RegExp {\n    return /(?:^|\\s)(\\-)?\\/([^\\s]+)\\//;\n  },\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get _textFilterRegex(): RegExp {\n    return /(?:^|\\s)(\\-)?([^\\s]+)/;\n  },\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get _SpaceCharRegex(): RegExp {\n    return /\\s/;\n  },\n  /**\n   * @enum {string}\n   */\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get Indent(): {TwoSpaces: '  ', FourSpaces: '    ', EightSpaces: '        ', TabCharacter: '\\t'} {\n    return {TwoSpaces: '  ', FourSpaces: '    ', EightSpaces: '        ', TabCharacter: '\\t'};\n  },\n\n  isStopChar: function(char: string): boolean {\n    return (char > ' ' && char < '0') || (char > '9' && char < 'A') || (char > 'Z' && char < '_') ||\n        (char > '_' && char < 'a') || (char > 'z' && char <= '~');\n  },\n\n  isWordChar: function(char: string): boolean {\n    return !Utils.isStopChar(char) && !Utils.isSpaceChar(char);\n  },\n\n  isSpaceChar: function(char: string): boolean {\n    return Utils._SpaceCharRegex.test(char);\n  },\n\n  isWord: function(word: string): boolean {\n    for (let i = 0; i < word.length; ++i) {\n      if (!Utils.isWordChar(word.charAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  isOpeningBraceChar: function(char: string): boolean {\n    return char === '(' || char === '{';\n  },\n\n  isClosingBraceChar: function(char: string): boolean {\n    return char === ')' || char === '}';\n  },\n\n  isBraceChar: function(char: string): boolean {\n    return Utils.isOpeningBraceChar(char) || Utils.isClosingBraceChar(char);\n  },\n\n  textToWords: function(text: string, isWordChar: (arg0: string) => boolean, wordCallback: (arg0: string) => void):\n      void {\n        let startWord = -1;\n        for (let i = 0; i < text.length; ++i) {\n          if (!isWordChar(text.charAt(i))) {\n            if (startWord !== -1) {\n              wordCallback(text.substring(startWord, i));\n            }\n            startWord = -1;\n          } else if (startWord === -1) {\n            startWord = i;\n          }\n        }\n        if (startWord !== -1) {\n          wordCallback(text.substring(startWord));\n        }\n      },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  isUpperCase: function(text: string): boolean {\n    return text === text.toUpperCase();\n  },\n\n  isLowerCase: function(text: string): boolean {\n    return text === text.toLowerCase();\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): {\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }[] {\n    const matches: {\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: (string|undefined)[],\n    }[] = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex: regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters = Utils.splitStringByRegexes(\n        query, [Utils._keyValueFilterRegex, Utils._regexFilterRegex, Utils._textFilterRegex]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'i'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch (e) {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\nexport interface TokenizerFactory {\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createTokenizer(mimeType: string):\n      (arg0: string, arg1: (arg0: string, arg1: string|null, arg2: number, arg3: number) => void) => void;\n}\n\nexport function isMinified(text: string): boolean {\n  const kMaxNonMinifiedLength = 500;\n  let linesToCheck = 10;\n  let lastPosition = 0;\n  do {\n    let eolIndex = text.indexOf('\\n', lastPosition);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    if (eolIndex - lastPosition > kMaxNonMinifiedLength && text.substr(lastPosition, 3) !== '//#') {\n      return true;\n    }\n    lastPosition = eolIndex + 1;\n  } while (--linesToCheck >= 0 && lastPosition < text.length);\n\n  // Check the end of the text as well\n  linesToCheck = 10;\n  lastPosition = text.length;\n  do {\n    let eolIndex = text.lastIndexOf('\\n', lastPosition);\n    if (eolIndex < 0) {\n      eolIndex = 0;\n    }\n    if (lastPosition - eolIndex > kMaxNonMinifiedLength && text.substr(lastPosition, 3) !== '//#') {\n      return true;\n    }\n    lastPosition = eolIndex - 1;\n  } while (--linesToCheck >= 0 && lastPosition > 0);\n  return false;\n}\n\nexport const performSearchInContent = function(\n    content: string, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const text = new Text(content);\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    regex.lastIndex = 0;\n    const match = regex.exec(lineContent);\n    if (match) {\n      result.push(new SearchMatch(i, lineContent, match.index));\n    }\n  }\n  return result;\n};\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
