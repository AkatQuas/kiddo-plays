{
  "version": 3,
  "sources": ["../../../../../../front_end/models/timeline_model/TimelineFrameModel.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {RecordType, TimelineData} from './TimelineModel.js';\nimport type {TracingLayerPayload, TracingLayerTile} from './TracingLayerTree.js';\nimport {TracingLayerTree} from './TracingLayerTree.js';\n\nexport class TimelineFrameModel {\n  private readonly categoryMapper: (arg0: SDK.TracingModel.Event) => string;\n  private frames!: TimelineFrame[];\n  private frameById!: {\n    [x: number]: TimelineFrame,\n  };\n  private beginFrameQueue!: TimelineFrameBeginFrameQueue;\n  private minimumRecordTime!: number;\n  private lastFrame!: TimelineFrame|null;\n  private mainFrameCommitted!: boolean;\n  private mainFrameRequested!: boolean;\n  private lastLayerTree!: TracingFrameLayerTree|null;\n  private framePendingActivation!: PendingFrame|null;\n  private currentTaskTimeByCategory!: {\n    [x: string]: number,\n  };\n  private target!: SDK.Target.Target|null;\n  private framePendingCommit?: PendingFrame|null;\n  private lastBeginFrame?: number|null;\n  private lastDroppedFrame?: number|null;\n  private lastNeedsBeginFrame?: number|null;\n  private lastTaskBeginTime?: number|null;\n  private layerTreeId?: number|null;\n  private currentProcessMainThread?: SDK.TracingModel.Thread|null;\n\n  constructor(categoryMapper: (arg0: SDK.TracingModel.Event) => string) {\n    this.categoryMapper = categoryMapper;\n\n    this.reset();\n  }\n\n  getFrames(): TimelineFrame[] {\n    return this.frames;\n  }\n\n  getFramesWithinWindow(startTime: number, endTime: number): TimelineFrame[] {\n    const firstFrame =\n        Platform.ArrayUtilities.lowerBound(this.frames, startTime || 0, (time, frame) => time - frame.endTime);\n    const lastFrame =\n        Platform.ArrayUtilities.lowerBound(this.frames, endTime || Infinity, (time, frame) => time - frame.startTime);\n    return this.frames.slice(firstFrame, lastFrame);\n  }\n\n  hasRasterTile(rasterTask: SDK.TracingModel.Event): boolean {\n    const data = rasterTask.args['tileData'];\n    if (!data) {\n      return false;\n    }\n    const frameId = data['sourceFrameNumber'];\n    const frame = frameId && this.frameById[frameId];\n    if (!frame || !frame.layerTree) {\n      return false;\n    }\n    return true;\n  }\n\n  rasterTilePromise(rasterTask: SDK.TracingModel.Event): Promise<{\n    rect: Protocol.DOM.Rect,\n    snapshot: SDK.PaintProfiler.PaintProfilerSnapshot,\n  }|null> {\n    if (!this.target) {\n      return Promise.resolve(null);\n    }\n    const data = rasterTask.args['tileData'];\n    const frameId = (data['sourceFrameNumber'] as number);\n    const tileId = data['tileId'] && data['tileId']['id_ref'];\n    const frame = frameId && this.frameById[frameId];\n    if (!frame || !frame.layerTree || !tileId) {\n      return Promise.resolve(null);\n    }\n\n    return frame.layerTree.layerTreePromise().then(layerTree => layerTree && layerTree.pictureForRasterTile(tileId));\n  }\n\n  reset(): void {\n    this.minimumRecordTime = Infinity;\n    this.frames = [];\n    this.frameById = {};\n    this.beginFrameQueue = new TimelineFrameBeginFrameQueue();\n    this.lastFrame = null;\n    this.lastLayerTree = null;\n    this.mainFrameCommitted = false;\n    this.mainFrameRequested = false;\n    this.framePendingCommit = null;\n    this.lastBeginFrame = null;\n    this.lastDroppedFrame = null;\n    this.lastNeedsBeginFrame = null;\n    this.framePendingActivation = null;\n    this.lastTaskBeginTime = null;\n    this.target = null;\n    this.layerTreeId = null;\n    this.currentTaskTimeByCategory = {};\n  }\n\n  handleBeginFrame(startTime: number, seqId: number): void {\n    if (!this.lastFrame) {\n      this.startFrame(startTime);\n    }\n    this.lastBeginFrame = startTime;\n\n    this.beginFrameQueue.addFrameIfNotExists(seqId, startTime, false, false);\n  }\n\n  handleDroppedFrame(startTime: number, seqId: number, isPartial: boolean): void {\n    if (!this.lastFrame) {\n      this.startFrame(startTime);\n    }\n\n    // This line handles the case where no BeginFrame event is issued for\n    // the dropped frame. In this situation, add a BeginFrame to the queue\n    // as if it actually occurred.\n    this.beginFrameQueue.addFrameIfNotExists(seqId, startTime, true, isPartial);\n    this.beginFrameQueue.setDropped(seqId, true);\n    this.beginFrameQueue.setPartial(seqId, isPartial);\n  }\n\n  handleDrawFrame(startTime: number, seqId: number): void {\n    if (!this.lastFrame) {\n      this.startFrame(startTime);\n      return;\n    }\n\n    // - if it wasn't drawn, it didn't happen!\n    // - only show frames that either did not wait for the main thread frame or had one committed.\n    if (this.mainFrameCommitted || !this.mainFrameRequested) {\n      if (this.lastNeedsBeginFrame) {\n        const idleTimeEnd = this.framePendingActivation ? this.framePendingActivation.triggerTime :\n                                                          (this.lastBeginFrame || this.lastNeedsBeginFrame);\n        if (idleTimeEnd > this.lastFrame.startTime) {\n          this.lastFrame.idle = true;\n          this.lastBeginFrame = null;\n        }\n        this.lastNeedsBeginFrame = null;\n      }\n\n      const framesToVisualize = this.beginFrameQueue.processPendingBeginFramesOnDrawFrame(seqId);\n\n      // Visualize the current frame and all pending frames before it.\n      for (const frame of framesToVisualize) {\n        const isLastFrameIdle = this.lastFrame.idle;\n\n        // If |frame| is the first frame after an idle period, the CPU time\n        // will be logged (\"committed\") under |frame| if applicable.\n        this.startFrame(frame.startTime);\n        if (isLastFrameIdle && this.framePendingActivation) {\n          this.commitPendingFrame();\n        }\n        if (frame.isDropped) {\n          this.lastFrame.dropped = true;\n        }\n        if (frame.isPartial) {\n          this.lastFrame.isPartial = true;\n        }\n      }\n    }\n    this.mainFrameCommitted = false;\n  }\n\n  handleActivateLayerTree(): void {\n    if (!this.lastFrame) {\n      return;\n    }\n    if (this.framePendingActivation && !this.lastNeedsBeginFrame) {\n      this.commitPendingFrame();\n    }\n  }\n\n  handleRequestMainThreadFrame(): void {\n    if (!this.lastFrame) {\n      return;\n    }\n    this.mainFrameRequested = true;\n  }\n\n  handleCompositeLayers(): void {\n    if (!this.framePendingCommit) {\n      return;\n    }\n    this.framePendingActivation = this.framePendingCommit;\n    this.framePendingCommit = null;\n    this.mainFrameRequested = false;\n    this.mainFrameCommitted = true;\n  }\n\n  handleLayerTreeSnapshot(layerTree: TracingFrameLayerTree): void {\n    this.lastLayerTree = layerTree;\n  }\n\n  handleNeedFrameChanged(startTime: number, needsBeginFrame: boolean): void {\n    if (needsBeginFrame) {\n      this.lastNeedsBeginFrame = startTime;\n    }\n  }\n\n  private startFrame(startTime: number): void {\n    if (this.lastFrame) {\n      this.flushFrame(this.lastFrame, startTime);\n    }\n    this.lastFrame = new TimelineFrame(startTime, startTime - this.minimumRecordTime);\n  }\n\n  private flushFrame(frame: TimelineFrame, endTime: number): void {\n    frame.setLayerTree(this.lastLayerTree);\n    frame.setEndTime(endTime);\n    if (this.lastLayerTree) {\n      this.lastLayerTree.setPaints(frame.paints);\n    }\n    const lastFrame = this.frames[this.frames.length - 1];\n    if (this.frames.length && lastFrame && (frame.startTime !== lastFrame.endTime || frame.startTime > frame.endTime)) {\n      console.assert(\n          false, `Inconsistent frame time for frame ${this.frames.length} (${frame.startTime} - ${frame.endTime})`);\n    }\n    this.frames.push(frame);\n    if (typeof frame.mainFrameId === 'number') {\n      this.frameById[frame.mainFrameId] = frame;\n    }\n  }\n\n  private commitPendingFrame(): void {\n    if (!this.framePendingActivation || !this.lastFrame) {\n      return;\n    }\n\n    this.lastFrame.addTimeForCategories(this.framePendingActivation.timeByCategory);\n    this.lastFrame.paints = this.framePendingActivation.paints;\n    this.lastFrame.mainFrameId = this.framePendingActivation.mainFrameId;\n    this.framePendingActivation = null;\n  }\n\n  addTraceEvents(target: SDK.Target.Target|null, events: SDK.TracingModel.Event[], threadData: {\n    thread: SDK.TracingModel.Thread,\n    time: number,\n  }[]): void {\n    this.target = target;\n    let j = 0;\n    this.currentProcessMainThread = threadData.length && threadData[0].thread || null;\n    for (let i = 0; i < events.length; ++i) {\n      while (j + 1 < threadData.length && threadData[j + 1].time <= events[i].startTime) {\n        this.currentProcessMainThread = threadData[++j].thread;\n      }\n      this.addTraceEvent(events[i]);\n    }\n    this.currentProcessMainThread = null;\n  }\n\n  private addTraceEvent(event: SDK.TracingModel.Event): void {\n    if (event.startTime && event.startTime < this.minimumRecordTime) {\n      this.minimumRecordTime = event.startTime;\n    }\n\n    if (event.name === RecordType.SetLayerTreeId) {\n      this.layerTreeId = event.args['layerTreeId'] || event.args['data']['layerTreeId'];\n    } else if (\n        event.id && event.phase === SDK.TracingModel.Phase.SnapshotObject &&\n        event.name === RecordType.LayerTreeHostImplSnapshot && Number(event.id) === this.layerTreeId && this.target) {\n      const snapshot = (event as SDK.TracingModel.ObjectSnapshot);\n      this.handleLayerTreeSnapshot(new TracingFrameLayerTree(this.target, snapshot));\n    } else {\n      this.processCompositorEvents(event);\n      if (event.thread === this.currentProcessMainThread) {\n        this.addMainThreadTraceEvent(event);\n      } else if (this.lastFrame && event.selfTime && !SDK.TracingModel.TracingModel.isTopLevelEvent(event)) {\n        this.lastFrame.addTimeForCategory(this.categoryMapper(event), event.selfTime);\n      }\n    }\n  }\n\n  private processCompositorEvents(event: SDK.TracingModel.Event): void {\n    if (event.args['layerTreeId'] !== this.layerTreeId) {\n      return;\n    }\n\n    const timestamp = event.startTime;\n    if (event.name === RecordType.BeginFrame) {\n      this.handleBeginFrame(timestamp, event.args['frameSeqId']);\n    } else if (event.name === RecordType.DrawFrame) {\n      this.handleDrawFrame(timestamp, event.args['frameSeqId']);\n    } else if (event.name === RecordType.ActivateLayerTree) {\n      this.handleActivateLayerTree();\n    } else if (event.name === RecordType.RequestMainThreadFrame) {\n      this.handleRequestMainThreadFrame();\n    } else if (event.name === RecordType.NeedsBeginFrameChanged) {\n      this.handleNeedFrameChanged(timestamp, event.args['data'] && event.args['data']['needsBeginFrame']);\n    } else if (event.name === RecordType.DroppedFrame) {\n      this.handleDroppedFrame(timestamp, event.args['frameSeqId'], event.args['hasPartialUpdate']);\n    }\n  }\n\n  private addMainThreadTraceEvent(event: SDK.TracingModel.Event): void {\n    if (SDK.TracingModel.TracingModel.isTopLevelEvent(event)) {\n      this.currentTaskTimeByCategory = {};\n      this.lastTaskBeginTime = event.startTime;\n    }\n    if (!this.framePendingCommit && TimelineFrameModel.mainFrameMarkers.indexOf(event.name as RecordType) >= 0) {\n      this.framePendingCommit =\n          new PendingFrame(this.lastTaskBeginTime || event.startTime, this.currentTaskTimeByCategory);\n    }\n    if (!this.framePendingCommit) {\n      this.addTimeForCategory(this.currentTaskTimeByCategory, event);\n      return;\n    }\n    this.addTimeForCategory(this.framePendingCommit.timeByCategory, event);\n\n    if (event.name === RecordType.BeginMainThreadFrame && event.args['data'] && event.args['data']['frameId']) {\n      this.framePendingCommit.mainFrameId = event.args['data']['frameId'];\n    }\n    if (event.name === RecordType.Paint && event.args['data']['layerId'] && TimelineData.forEvent(event).picture &&\n        this.target) {\n      this.framePendingCommit.paints.push(new LayerPaintEvent(event, this.target));\n    }\n    if (event.name === RecordType.CompositeLayers && event.args['layerTreeId'] === this.layerTreeId) {\n      this.handleCompositeLayers();\n    }\n  }\n\n  private addTimeForCategory(\n      timeByCategory: {\n        [x: string]: number,\n      },\n      event: SDK.TracingModel.Event): void {\n    if (!event.selfTime) {\n      return;\n    }\n    const categoryName = this.categoryMapper(event);\n    timeByCategory[categoryName] = (timeByCategory[categoryName] || 0) + event.selfTime;\n  }\n\n  private static readonly mainFrameMarkers: RecordType[] = [\n    RecordType.ScheduleStyleRecalculation,\n    RecordType.InvalidateLayout,\n    RecordType.BeginMainThreadFrame,\n    RecordType.ScrollLayer,\n  ];\n}\n\nexport class TracingFrameLayerTree {\n  private readonly target: SDK.Target.Target;\n  private readonly snapshot: SDK.TracingModel.ObjectSnapshot;\n  private paintsInternal!: LayerPaintEvent[]|undefined;\n\n  constructor(target: SDK.Target.Target, snapshot: SDK.TracingModel.ObjectSnapshot) {\n    this.target = target;\n    this.snapshot = snapshot;\n  }\n\n  async layerTreePromise(): Promise<TracingLayerTree|null> {\n    const result = (await this.snapshot.objectPromise() as unknown as {\n      active_tiles: TracingLayerTile[],\n      device_viewport_size: {\n        width: number,\n        height: number,\n      },\n      active_tree: {\n        root_layer: TracingLayerPayload,\n        layers: TracingLayerPayload[],\n      },\n    });\n    if (!result) {\n      return null;\n    }\n    const viewport = result['device_viewport_size'];\n    const tiles = result['active_tiles'];\n    const rootLayer = result['active_tree']['root_layer'];\n    const layers = result['active_tree']['layers'];\n    const layerTree = new TracingLayerTree(this.target);\n    layerTree.setViewportSize(viewport);\n    layerTree.setTiles(tiles);\n\n    await layerTree.setLayers(rootLayer, layers, this.paintsInternal || []);\n    return layerTree;\n  }\n\n  paints(): LayerPaintEvent[] {\n    return this.paintsInternal || [];\n  }\n\n  setPaints(paints: LayerPaintEvent[]): void {\n    this.paintsInternal = paints;\n  }\n}\n\nexport class TimelineFrame {\n  startTime: number;\n  startTimeOffset: number;\n  endTime: number;\n  duration: number;\n  timeByCategory: {\n    [x: string]: number,\n  };\n  cpuTime: number;\n  idle: boolean;\n  dropped: boolean;\n  isPartial: boolean;\n  layerTree: TracingFrameLayerTree|null;\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n\n  constructor(startTime: number, startTimeOffset: number) {\n    this.startTime = startTime;\n    this.startTimeOffset = startTimeOffset;\n    this.endTime = this.startTime;\n    this.duration = 0;\n    this.timeByCategory = {};\n    this.cpuTime = 0;\n    this.idle = false;\n    this.dropped = false;\n    this.isPartial = false;\n    this.layerTree = null;\n    this.paints = [];\n    this.mainFrameId = undefined;\n  }\n\n  hasWarnings(): boolean {\n    return false;\n  }\n\n  setEndTime(endTime: number): void {\n    this.endTime = endTime;\n    this.duration = this.endTime - this.startTime;\n  }\n\n  setLayerTree(layerTree: TracingFrameLayerTree|null): void {\n    this.layerTree = layerTree;\n  }\n\n  addTimeForCategories(timeByCategory: {\n    [x: string]: number,\n  }): void {\n    for (const category in timeByCategory) {\n      this.addTimeForCategory(category, timeByCategory[category]);\n    }\n  }\n\n  addTimeForCategory(category: string, time: number): void {\n    this.timeByCategory[category] = (this.timeByCategory[category] || 0) + time;\n    this.cpuTime += time;\n  }\n}\n\nexport class LayerPaintEvent {\n  private readonly eventInternal: SDK.TracingModel.Event;\n  private readonly target: SDK.Target.Target|null;\n\n  constructor(event: SDK.TracingModel.Event, target: SDK.Target.Target|null) {\n    this.eventInternal = event;\n    this.target = target;\n  }\n\n  layerId(): string {\n    return this.eventInternal.args['data']['layerId'];\n  }\n\n  event(): SDK.TracingModel.Event {\n    return this.eventInternal;\n  }\n\n  picturePromise(): Promise<{\n    rect: Array<number>,\n    serializedPicture: string,\n  }|null> {\n    const picture = TimelineData.forEvent(this.eventInternal).picture;\n    if (!picture) {\n      return Promise.resolve(null);\n    }\n\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return picture.objectPromise().then((result: any) => {\n      if (!result) {\n        return null;\n      }\n      const rect = result['params'] && result['params']['layer_rect'];\n      const picture = result['skp64'];\n      return rect && picture ? {rect: rect, serializedPicture: picture} : null;\n    });\n  }\n\n  async snapshotPromise(): Promise<{\n    rect: Array<number>,\n    snapshot: SDK.PaintProfiler.PaintProfilerSnapshot,\n  }|null> {\n    const paintProfilerModel = this.target && this.target.model(SDK.PaintProfiler.PaintProfilerModel);\n    const picture = await this.picturePromise();\n    if (!picture || !paintProfilerModel) {\n      return null;\n    }\n    const snapshot = await paintProfilerModel.loadSnapshot(picture.serializedPicture);\n    return snapshot ? {rect: picture.rect, snapshot: snapshot} : null;\n  }\n}\n\nexport class PendingFrame {\n  timeByCategory: {\n    [x: string]: number,\n  };\n  paints: LayerPaintEvent[];\n  mainFrameId: number|undefined;\n  triggerTime: number;\n  constructor(triggerTime: number, timeByCategory: {\n    [x: string]: number,\n  }) {\n    this.timeByCategory = timeByCategory;\n    this.paints = [];\n    this.mainFrameId = undefined;\n    this.triggerTime = triggerTime;\n  }\n}\n\n// The parameters of an impl-side BeginFrame.\nclass BeginFrameInfo {\n  seqId: number;\n  startTime: number;\n  isDropped: boolean;\n  isPartial: boolean;\n  constructor(seqId: number, startTime: number, isDropped: boolean, isPartial: boolean) {\n    this.seqId = seqId;\n    this.startTime = startTime;\n    this.isDropped = isDropped;\n    this.isPartial = isPartial;\n  }\n}\n\n// A queue of BeginFrames pending visualization.\n// BeginFrames are added into this queue as they occur; later when their\n// corresponding DrawFrames occur (or lack thereof), the BeginFrames are removed\n// from the queue and their timestamps are used for visualization.\nexport class TimelineFrameBeginFrameQueue {\n  private queueFrames!: number[];\n\n  // Maps frameSeqId to BeginFrameInfo.\n  private mapFrames!: {\n    [x: number]: BeginFrameInfo,\n  };\n\n  constructor() {\n    this.queueFrames = [];\n    this.mapFrames = {};\n  }\n\n  // Add a BeginFrame to the queue, if it does not already exit.\n  addFrameIfNotExists(seqId: number, startTime: number, isDropped: boolean, isPartial: boolean): void {\n    if (!(seqId in this.mapFrames)) {\n      this.mapFrames[seqId] = new BeginFrameInfo(seqId, startTime, isDropped, isPartial);\n      this.queueFrames.push(seqId);\n    }\n  }\n\n  // Set a BeginFrame in queue as dropped.\n  setDropped(seqId: number, isDropped: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isDropped = isDropped;\n    }\n  }\n\n  setPartial(seqId: number, isPartial: boolean): void {\n    if (seqId in this.mapFrames) {\n      this.mapFrames[seqId].isPartial = isPartial;\n    }\n  }\n\n  processPendingBeginFramesOnDrawFrame(seqId: number): BeginFrameInfo[] {\n    const framesToVisualize: BeginFrameInfo[] = [];\n\n    // Do not visualize this frame in the rare case where the current DrawFrame\n    // does not have a corresponding BeginFrame.\n    if (seqId in this.mapFrames) {\n      // Pop all BeginFrames before the current frame, and add only the dropped\n      // ones in |frames_to_visualize|.\n      // Non-dropped frames popped here are BeginFrames that are never\n      // drawn (but not considered dropped either for some reason).\n      // Those frames do not require an proactive visualization effort and will\n      // be naturally presented as continuationss of other frames.\n      while (this.queueFrames[0] !== seqId) {\n        const currentSeqId = this.queueFrames[0];\n        if (this.mapFrames[currentSeqId].isDropped) {\n          framesToVisualize.push(this.mapFrames[currentSeqId]);\n        }\n\n        delete this.mapFrames[currentSeqId];\n        this.queueFrames.shift();\n      }\n\n      // Pop the BeginFrame associated with the current DrawFrame.\n      framesToVisualize.push(this.mapFrames[seqId]);\n      delete this.mapFrames[seqId];\n      this.queueFrames.shift();\n    }\n    return framesToVisualize;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
