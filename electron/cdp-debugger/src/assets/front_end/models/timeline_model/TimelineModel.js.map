{
  "version": 3,
  "sources": ["../../../../../../front_end/models/timeline_model/TimelineModel.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport {TimelineJSProfileProcessor} from './TimelineJSProfile.js';\n\nconst UIStrings = {\n  /**\n  *@description Text for the name of a thread of the page\n  *@example {1} PH1\n  */\n  threadS: 'Thread {PH1}',\n  /**\n  *@description Title of a worker in the timeline flame chart of the Performance panel\n  *@example {https://google.com} PH1\n  */\n  workerS: '`Worker` \u2014 {PH1}',\n  /**\n  *@description Title of a worker in the timeline flame chart of the Performance panel\n  */\n  dedicatedWorker: 'Dedicated `Worker`',\n  /**\n  *@description Title of a worker in the timeline flame chart of the Performance panel\n  *@example {FormatterWorker} PH1\n  *@example {https://google.com} PH2\n  */\n  workerSS: '`Worker`: {PH1} \u2014 {PH2}',\n};\nconst str_ = i18n.i18n.registerUIStrings('models/timeline_model/TimelineModel.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class TimelineModelImpl {\n  private isGenericTraceInternal!: boolean;\n  private tracksInternal!: Track[];\n  private namedTracks!: Map<TrackType, Track>;\n  private inspectedTargetEventsInternal!: SDK.TracingModel.Event[];\n  private timeMarkerEventsInternal!: SDK.TracingModel.Event[];\n  private sessionId!: string|null;\n  private mainFrameNodeId!: number|null;\n  private pageFrames!: Map<Protocol.Page.FrameId, PageFrame>;\n  private cpuProfilesInternal!: SDK.CPUProfileDataModel.CPUProfileDataModel[];\n  private workerIdByThread!: WeakMap<SDK.TracingModel.Thread, string>;\n  private requestsFromBrowser!: Map<string, SDK.TracingModel.Event>;\n  private mainFrame!: PageFrame;\n  private minimumRecordTimeInternal: number;\n  private maximumRecordTimeInternal: number;\n  private totalBlockingTimeInternal: number;\n  private estimatedTotalBlockingTime: number;\n  private asyncEventTracker!: TimelineAsyncEventTracker;\n  private invalidationTracker!: InvalidationTracker;\n  private layoutInvalidate!: {\n    [x: string]: SDK.TracingModel.Event|null,\n  };\n  private lastScheduleStyleRecalculation!: {\n    [x: string]: SDK.TracingModel.Event,\n  };\n  private paintImageEventByPixelRefId!: {\n    [x: string]: SDK.TracingModel.Event,\n  };\n  private lastPaintForLayer!: {\n    [x: string]: SDK.TracingModel.Event,\n  };\n  private lastRecalculateStylesEvent!: SDK.TracingModel.Event|null;\n  private currentScriptEvent!: SDK.TracingModel.Event|null;\n  private eventStack!: SDK.TracingModel.Event[];\n  private browserFrameTracking!: boolean;\n  private persistentIds!: boolean;\n  private legacyCurrentPage!: any;\n  private currentTaskLayoutAndRecalcEvents: SDK.TracingModel.Event[];\n  private tracingModelInternal: SDK.TracingModel.TracingModel|null;\n  private mainFrameLayerTreeId?: any;\n\n  constructor() {\n    this.minimumRecordTimeInternal = 0;\n    this.maximumRecordTimeInternal = 0;\n    this.totalBlockingTimeInternal = 0;\n    this.estimatedTotalBlockingTime = 0;\n\n    this.reset();\n    this.resetProcessingState();\n\n    this.currentTaskLayoutAndRecalcEvents = [];\n    this.tracingModelInternal = null;\n  }\n\n  static forEachEvent(\n      events: SDK.TracingModel.Event[], onStartEvent: (arg0: SDK.TracingModel.Event) => void,\n      onEndEvent: (arg0: SDK.TracingModel.Event) => void,\n      onInstantEvent?: ((arg0: SDK.TracingModel.Event, arg1: SDK.TracingModel.Event|null) => void), startTime?: number,\n      endTime?: number, filter?: ((arg0: SDK.TracingModel.Event) => boolean)): void {\n    startTime = startTime || 0;\n    endTime = endTime || Infinity;\n    const stack: SDK.TracingModel.Event[] = [];\n    const startEvent = TimelineModelImpl.topLevelEventEndingAfter(events, startTime);\n    for (let i = startEvent; i < events.length; ++i) {\n      const e = events[i];\n      if ((e.endTime || e.startTime) < startTime) {\n        continue;\n      }\n      if (e.startTime >= endTime) {\n        break;\n      }\n      if (SDK.TracingModel.TracingModel.isAsyncPhase(e.phase) || SDK.TracingModel.TracingModel.isFlowPhase(e.phase)) {\n        continue;\n      }\n      let last: SDK.TracingModel.Event = stack[stack.length - 1];\n      while (last && last.endTime !== undefined && last.endTime <= e.startTime) {\n        stack.pop();\n        onEndEvent(last);\n        last = stack[stack.length - 1];\n      }\n      if (filter && !filter(e)) {\n        continue;\n      }\n      if (e.duration) {\n        onStartEvent(e);\n        stack.push(e);\n      } else {\n        onInstantEvent && onInstantEvent(e, stack[stack.length - 1] || null);\n      }\n    }\n    while (stack.length) {\n      const last = stack.pop();\n      if (last) {\n        onEndEvent(last);\n      }\n    }\n  }\n\n  private static topLevelEventEndingAfter(events: SDK.TracingModel.Event[], time: number): number {\n    let index = Platform.ArrayUtilities.upperBound(events, time, (time, event) => time - event.startTime) - 1;\n    while (index > 0 && !SDK.TracingModel.TracingModel.isTopLevelEvent(events[index])) {\n      index--;\n    }\n    return Math.max(index, 0);\n  }\n\n  isMarkerEvent(event: SDK.TracingModel.Event): boolean {\n    switch (event.name) {\n      case RecordType.TimeStamp:\n        return true;\n      case RecordType.MarkFirstPaint:\n      case RecordType.MarkFCP:\n        return Boolean(this.mainFrame) && event.args.frame === this.mainFrame.frameId && Boolean(event.args.data);\n      case RecordType.MarkDOMContent:\n      case RecordType.MarkLoad:\n      case RecordType.MarkLCPCandidate:\n      case RecordType.MarkLCPInvalidate:\n        return Boolean(event.args['data']['isOutermostMainFrame'] ?? event.args['data']['isMainFrame']);\n      default:\n        return false;\n    }\n  }\n\n  isInteractiveTimeEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.InteractiveTime;\n  }\n\n  isLayoutShiftEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.LayoutShift;\n  }\n\n  isUserTimingEvent(event: SDK.TracingModel.Event): boolean {\n    return event.categoriesString === TimelineModelImpl.Category.UserTiming;\n  }\n  isParseHTMLEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.ParseHTML;\n  }\n\n  isLCPCandidateEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.MarkLCPCandidate &&\n        Boolean(event.args['data']['isOutermostMainFrame'] ?? event.args['data']['isMainFrame']);\n  }\n\n  isLCPInvalidateEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.MarkLCPInvalidate &&\n        Boolean(event.args['data']['isOutermostMainFrame'] ?? event.args['data']['isMainFrame']);\n  }\n\n  isFCPEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.MarkFCP && Boolean(this.mainFrame) &&\n        event.args['frame'] === this.mainFrame.frameId;\n  }\n\n  isLongRunningTask(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.Task &&\n        TimelineData.forEvent(event).warning === TimelineModelImpl.WarningType.LongTask;\n  }\n\n  isNavigationStartEvent(event: SDK.TracingModel.Event): boolean {\n    return event.name === RecordType.NavigationStart;\n  }\n\n  isMainFrameNavigationStartEvent(event: SDK.TracingModel.Event): boolean {\n    return this.isNavigationStartEvent(event) &&\n        (event.args['data']['isOutermostMainFrame'] ?? event.args['data']['isLoadingMainFrame']) &&\n        event.args['data']['documentLoaderURL'];\n  }\n\n  static globalEventId(event: SDK.TracingModel.Event, field: string): string {\n    const data = event.args['data'] || event.args['beginData'];\n    const id = data && data[field];\n    if (!id) {\n      return '';\n    }\n    return `${event.thread.process().id()}.${id}`;\n  }\n\n  static eventFrameId(event: SDK.TracingModel.Event): Protocol.Page.FrameId|null {\n    const data = event.args['data'] || event.args['beginData'];\n    return data && data['frame'] || null;\n  }\n\n  cpuProfiles(): SDK.CPUProfileDataModel.CPUProfileDataModel[] {\n    return this.cpuProfilesInternal;\n  }\n\n  totalBlockingTime(): {\n    time: number,\n    estimated: boolean,\n  } {\n    if (this.totalBlockingTimeInternal === -1) {\n      return {time: this.estimatedTotalBlockingTime, estimated: true};\n    }\n\n    return {time: this.totalBlockingTimeInternal, estimated: false};\n  }\n\n  targetByEvent(event: SDK.TracingModel.Event): SDK.Target.Target|null {\n    // FIXME: Consider returning null for loaded traces.\n    const workerId = this.workerIdByThread.get(event.thread);\n    const mainTarget = SDK.TargetManager.TargetManager.instance().mainTarget();\n    return workerId ? SDK.TargetManager.TargetManager.instance().targetById(workerId) : mainTarget;\n  }\n\n  navStartTimes(): Map<string, SDK.TracingModel.Event> {\n    if (!this.tracingModelInternal) {\n      return new Map();\n    }\n\n    return this.tracingModelInternal.navStartTimes();\n  }\n\n  setEvents(tracingModel: SDK.TracingModel.TracingModel): void {\n    this.reset();\n    this.resetProcessingState();\n    this.tracingModelInternal = tracingModel;\n\n    this.minimumRecordTimeInternal = tracingModel.minimumRecordTime();\n    this.maximumRecordTimeInternal = tracingModel.maximumRecordTime();\n\n    // Remove LayoutShift events from the main thread list of events because they are\n    // represented in the experience track. This is done prior to the main thread being processed for its own events.\n    const layoutShiftEvents = [];\n    for (const process of tracingModel.sortedProcesses()) {\n      if (process.name() !== 'Renderer') {\n        continue;\n      }\n\n      for (const thread of process.sortedThreads()) {\n        const shifts = thread.removeEventsByName(RecordType.LayoutShift);\n        layoutShiftEvents.push(...shifts);\n      }\n    }\n\n    this.processSyncBrowserEvents(tracingModel);\n    if (this.browserFrameTracking) {\n      this.processThreadsForBrowserFrames(tracingModel);\n    } else {\n      // The next line is for loading legacy traces recorded before M67.\n      // TODO(alph): Drop the support at some point.\n      const metadataEvents = this.processMetadataEvents(tracingModel);\n      this.isGenericTraceInternal = !metadataEvents;\n      if (metadataEvents) {\n        this.processMetadataAndThreads(tracingModel, metadataEvents);\n      } else {\n        this.processGenericTrace(tracingModel);\n      }\n    }\n    this.inspectedTargetEventsInternal.sort(SDK.TracingModel.Event.compareStartTime);\n    this.processAsyncBrowserEvents(tracingModel);\n    this.buildGPUEvents(tracingModel);\n    this.buildLoadingEvents(tracingModel, layoutShiftEvents);\n    this.resetProcessingState();\n  }\n\n  private processGenericTrace(tracingModel: SDK.TracingModel.TracingModel): void {\n    let browserMainThread = SDK.TracingModel.TracingModel.browserMainThread(tracingModel);\n    if (!browserMainThread && tracingModel.sortedProcesses().length) {\n      browserMainThread = tracingModel.sortedProcesses()[0].sortedThreads()[0];\n    }\n    for (const process of tracingModel.sortedProcesses()) {\n      for (const thread of process.sortedThreads()) {\n        this.processThreadEvents(\n            tracingModel, [{from: 0, to: Infinity}], thread, thread === browserMainThread, false, true, null);\n      }\n    }\n  }\n\n  private processMetadataAndThreads(tracingModel: SDK.TracingModel.TracingModel, metadataEvents: MetadataEvents): void {\n    let startTime = 0;\n    for (let i = 0, length = metadataEvents.page.length; i < length; i++) {\n      const metaEvent = metadataEvents.page[i];\n      const process = metaEvent.thread.process();\n      const endTime = i + 1 < length ? metadataEvents.page[i + 1].startTime : Infinity;\n      if (startTime === endTime) {\n        continue;\n      }\n      this.legacyCurrentPage = metaEvent.args['data'] && metaEvent.args['data']['page'];\n      for (const thread of process.sortedThreads()) {\n        let workerUrl: Platform.DevToolsPath.UrlString|null = null;\n        if (thread.name() === TimelineModelImpl.WorkerThreadName ||\n            thread.name() === TimelineModelImpl.WorkerThreadNameLegacy) {\n          const workerMetaEvent = metadataEvents.workers.find(e => {\n            if (e.args['data']['workerThreadId'] !== thread.id()) {\n              return false;\n            }\n            // This is to support old traces.\n            if (e.args['data']['sessionId'] === this.sessionId) {\n              return true;\n            }\n            const frameId = TimelineModelImpl.eventFrameId(e);\n            return frameId ? Boolean(this.pageFrames.get(frameId)) : false;\n          });\n          if (!workerMetaEvent) {\n            continue;\n          }\n          const workerId = workerMetaEvent.args['data']['workerId'];\n          if (workerId) {\n            this.workerIdByThread.set(thread, workerId);\n          }\n          workerUrl = workerMetaEvent.args['data']['url'] || Platform.DevToolsPath.EmptyUrlString;\n        }\n        this.processThreadEvents(\n            tracingModel, [{from: startTime, to: endTime}], thread, thread === metaEvent.thread, Boolean(workerUrl),\n            true, workerUrl);\n      }\n      startTime = endTime;\n    }\n  }\n\n  private processThreadsForBrowserFrames(tracingModel: SDK.TracingModel.TracingModel): void {\n    const processData = new Map<number, {\n      from: number,\n      to: number,\n      main: boolean,\n      url: Platform.DevToolsPath.UrlString,\n    }[]>();\n    for (const frame of this.pageFrames.values()) {\n      for (let i = 0; i < frame.processes.length; i++) {\n        const pid = frame.processes[i].processId;\n        let data = processData.get(pid);\n        if (!data) {\n          data = [];\n          processData.set(pid, data);\n        }\n        const to = i === frame.processes.length - 1 ? (frame.deletedTime || Infinity) : frame.processes[i + 1].time;\n        data.push({from: frame.processes[i].time, to: to, main: !frame.parent, url: frame.processes[i].url});\n      }\n    }\n    const allMetadataEvents = tracingModel.devToolsMetadataEvents();\n    for (const process of tracingModel.sortedProcesses()) {\n      const data = processData.get(process.id());\n      if (!data) {\n        continue;\n      }\n      data.sort((a, b) => a.from - b.from || a.to - b.to);\n      const ranges = [];\n      let lastUrl: Platform.DevToolsPath.UrlString|null = null;\n      let lastMainUrl: Platform.DevToolsPath.UrlString|null = null;\n      let hasMain = false;\n      for (const item of data) {\n        const last = ranges[ranges.length - 1];\n        if (!last || item.from > last.to) {\n          ranges.push({from: item.from, to: item.to});\n        } else {\n          last.to = item.to;\n        }\n        if (item.main) {\n          hasMain = true;\n        }\n        if (item.url) {\n          if (item.main) {\n            lastMainUrl = item.url;\n          }\n          lastUrl = item.url;\n        }\n      }\n\n      for (const thread of process.sortedThreads()) {\n        if (thread.name() === TimelineModelImpl.RendererMainThreadName) {\n          this.processThreadEvents(\n              tracingModel, ranges, thread, true /* isMainThread */, false /* isWorker */, hasMain,\n              hasMain ? lastMainUrl : lastUrl);\n        } else if (\n            thread.name() === TimelineModelImpl.WorkerThreadName ||\n            thread.name() === TimelineModelImpl.WorkerThreadNameLegacy) {\n          const workerMetaEvent = allMetadataEvents.find(e => {\n            if (e.name !== TimelineModelImpl.DevToolsMetadataEvent.TracingSessionIdForWorker) {\n              return false;\n            }\n            if (e.thread.process() !== process) {\n              return false;\n            }\n            if (e.args['data']['workerThreadId'] !== thread.id()) {\n              return false;\n            }\n            const frameId = TimelineModelImpl.eventFrameId(e);\n            return frameId ? Boolean(this.pageFrames.get(frameId)) : false;\n          });\n          if (!workerMetaEvent) {\n            continue;\n          }\n          this.workerIdByThread.set(thread, workerMetaEvent.args['data']['workerId'] || '');\n          this.processThreadEvents(\n              tracingModel, ranges, thread, false /* isMainThread */, true /* isWorker */, false /* forMainFrame */,\n              workerMetaEvent.args['data']['url'] || Platform.DevToolsPath.EmptyUrlString);\n        } else {\n          this.processThreadEvents(\n              tracingModel, ranges, thread, false /* isMainThread */, false /* isWorker */, false /* forMainFrame */,\n              null);\n        }\n      }\n    }\n  }\n\n  private processMetadataEvents(tracingModel: SDK.TracingModel.TracingModel): MetadataEvents|null {\n    const metadataEvents = tracingModel.devToolsMetadataEvents();\n\n    const pageDevToolsMetadataEvents = [];\n    const workersDevToolsMetadataEvents = [];\n    for (const event of metadataEvents) {\n      if (event.name === TimelineModelImpl.DevToolsMetadataEvent.TracingStartedInPage) {\n        pageDevToolsMetadataEvents.push(event);\n        if (event.args['data'] && event.args['data']['persistentIds']) {\n          this.persistentIds = true;\n        }\n        const frames = ((event.args['data'] && event.args['data']['frames']) || [] as PageFrame[]);\n        frames.forEach((payload: PageFrame) => this.addPageFrame(event, payload));\n        this.mainFrame = this.rootFrames()[0];\n      } else if (event.name === TimelineModelImpl.DevToolsMetadataEvent.TracingSessionIdForWorker) {\n        workersDevToolsMetadataEvents.push(event);\n      } else if (event.name === TimelineModelImpl.DevToolsMetadataEvent.TracingStartedInBrowser) {\n        console.assert(!this.mainFrameNodeId, 'Multiple sessions in trace');\n        this.mainFrameNodeId = event.args['frameTreeNodeId'];\n      }\n    }\n    if (!pageDevToolsMetadataEvents.length) {\n      return null;\n    }\n\n    const sessionId =\n        pageDevToolsMetadataEvents[0].args['sessionId'] || pageDevToolsMetadataEvents[0].args['data']['sessionId'];\n    this.sessionId = sessionId;\n\n    const mismatchingIds = new Set<any>();\n    function checkSessionId(event: SDK.TracingModel.Event): boolean {\n      let args = event.args;\n      // FIXME: put sessionId into args[\"data\"] for TracingStartedInPage event.\n      if (args['data']) {\n        args = args['data'];\n      }\n      const id = args['sessionId'];\n      if (id === sessionId) {\n        return true;\n      }\n      mismatchingIds.add(id);\n      return false;\n    }\n    const result = {\n      page: pageDevToolsMetadataEvents.filter(checkSessionId).sort(SDK.TracingModel.Event.compareStartTime),\n      workers: workersDevToolsMetadataEvents.sort(SDK.TracingModel.Event.compareStartTime),\n    };\n    if (mismatchingIds.size) {\n      Common.Console.Console.instance().error(\n          'Timeline recording was started in more than one page simultaneously. Session id mismatch: ' +\n          this.sessionId + ' and ' + [...mismatchingIds] + '.');\n    }\n    return result;\n  }\n\n  private processSyncBrowserEvents(tracingModel: SDK.TracingModel.TracingModel): void {\n    const browserMain = SDK.TracingModel.TracingModel.browserMainThread(tracingModel);\n    if (browserMain) {\n      browserMain.events().forEach(this.processBrowserEvent, this);\n    }\n  }\n\n  private processAsyncBrowserEvents(tracingModel: SDK.TracingModel.TracingModel): void {\n    const browserMain = SDK.TracingModel.TracingModel.browserMainThread(tracingModel);\n    if (browserMain) {\n      this.processAsyncEvents(browserMain, [{from: 0, to: Infinity}]);\n    }\n  }\n\n  private buildGPUEvents(tracingModel: SDK.TracingModel.TracingModel): void {\n    const thread = tracingModel.getThreadByName('GPU Process', 'CrGpuMain');\n    if (!thread) {\n      return;\n    }\n    const gpuEventName = RecordType.GPUTask;\n    const track = this.ensureNamedTrack(TrackType.GPU);\n    track.thread = thread;\n    track.events = thread.events().filter(event => event.name === gpuEventName);\n  }\n\n  private buildLoadingEvents(tracingModel: SDK.TracingModel.TracingModel, events: SDK.TracingModel.Event[]): void {\n    const thread = tracingModel.getThreadByName('Renderer', 'CrRendererMain');\n    if (!thread) {\n      return;\n    }\n    const experienceCategory = 'experience';\n    const track = this.ensureNamedTrack(TrackType.Experience);\n    track.thread = thread;\n    track.events = events;\n\n    // Even though the event comes from 'loading', in order to color it differently we\n    // rename its category.\n    for (const trackEvent of track.events) {\n      trackEvent.categoriesString = experienceCategory;\n      if (trackEvent.name === RecordType.LayoutShift) {\n        const eventData = trackEvent.args['data'] || trackEvent.args['beginData'] || {};\n        const timelineData = TimelineData.forEvent(trackEvent);\n        if (eventData['impacted_nodes']) {\n          for (let i = 0; i < eventData['impacted_nodes'].length; ++i) {\n            timelineData.backendNodeIds.push(eventData['impacted_nodes'][i]['node_id']);\n          }\n        }\n      }\n    }\n  }\n\n  private resetProcessingState(): void {\n    this.asyncEventTracker = new TimelineAsyncEventTracker();\n    this.invalidationTracker = new InvalidationTracker();\n    this.layoutInvalidate = {};\n    this.lastScheduleStyleRecalculation = {};\n    this.paintImageEventByPixelRefId = {};\n    this.lastPaintForLayer = {};\n    this.lastRecalculateStylesEvent = null;\n    this.currentScriptEvent = null;\n    this.eventStack = [];\n    this.browserFrameTracking = false;\n    this.persistentIds = false;\n    this.legacyCurrentPage = null;\n  }\n\n  private extractCpuProfile(tracingModel: SDK.TracingModel.TracingModel, thread: SDK.TracingModel.Thread):\n      SDK.CPUProfileDataModel.CPUProfileDataModel|null {\n    const events = thread.events();\n    let cpuProfile;\n    let target: (SDK.Target.Target|null)|null = null;\n\n    // Check for legacy CpuProfile event format first.\n    let cpuProfileEvent: (SDK.TracingModel.Event|undefined)|SDK.TracingModel.Event = events[events.length - 1];\n    if (cpuProfileEvent && cpuProfileEvent.name === RecordType.CpuProfile) {\n      const eventData = cpuProfileEvent.args['data'];\n      cpuProfile = (eventData && eventData['cpuProfile'] as Protocol.Profiler.Profile | null);\n      target = this.targetByEvent(cpuProfileEvent);\n    }\n\n    if (!cpuProfile) {\n      cpuProfileEvent = events.find(e => e.name === RecordType.Profile);\n      if (!cpuProfileEvent) {\n        return null;\n      }\n      target = this.targetByEvent(cpuProfileEvent);\n      const profileGroup = tracingModel.profileGroup(cpuProfileEvent);\n      if (!profileGroup) {\n        Common.Console.Console.instance().error('Invalid CPU profile format.');\n        return null;\n      }\n      cpuProfile = ({\n        startTime: cpuProfileEvent.startTime * 1000,\n        endTime: 0,\n        nodes: [],\n        samples: [],\n        timeDeltas: [],\n        lines: [],\n      } as any);\n      for (const profileEvent of profileGroup.children) {\n        const eventData = profileEvent.args['data'];\n        if ('startTime' in eventData) {\n          // Do not use |eventData['startTime']| as it is in CLOCK_MONOTONIC domain,\n          // but use |profileEvent.startTime| (|ts| in the trace event) which has\n          // been translated to Perfetto's clock domain.\n          //\n          // Also convert from ms to us.\n          cpuProfile.startTime = profileEvent.startTime * 1000;\n        }\n        if ('endTime' in eventData) {\n          // Do not use |eventData['endTime']| as it is in CLOCK_MONOTONIC domain,\n          // but use |profileEvent.startTime| (|ts| in the trace event) which has\n          // been translated to Perfetto's clock domain.\n          //\n          // Despite its name, |profileEvent.startTime| was recorded right after\n          // |eventData['endTime']| within v8 and is a reasonable substitute.\n          //\n          // Also convert from ms to us.\n          cpuProfile.endTime = profileEvent.startTime * 1000;\n        }\n        const nodesAndSamples = eventData['cpuProfile'] || {};\n        const samples = nodesAndSamples['samples'] || [];\n        const lines = eventData['lines'] || Array(samples.length).fill(0);\n        cpuProfile.nodes.push(...(nodesAndSamples['nodes'] || []));\n        cpuProfile.lines.push(...lines);\n        if (cpuProfile.samples) {\n          cpuProfile.samples.push(...samples);\n        }\n        if (cpuProfile.timeDeltas) {\n          cpuProfile.timeDeltas.push(...(eventData['timeDeltas'] || []));\n        }\n        if (cpuProfile.samples && cpuProfile.timeDeltas && cpuProfile.samples.length !== cpuProfile.timeDeltas.length) {\n          Common.Console.Console.instance().error('Failed to parse CPU profile.');\n          return null;\n        }\n      }\n      if (!cpuProfile.endTime && cpuProfile.timeDeltas) {\n        const timeDeltas: number[] = cpuProfile.timeDeltas;\n        cpuProfile.endTime = timeDeltas.reduce((x, y) => x + y, cpuProfile.startTime);\n      }\n    }\n\n    try {\n      const profile = (cpuProfile as Protocol.Profiler.Profile);\n      const jsProfileModel = new SDK.CPUProfileDataModel.CPUProfileDataModel(profile, target);\n      this.cpuProfilesInternal.push(jsProfileModel);\n      return jsProfileModel;\n    } catch (e) {\n      Common.Console.Console.instance().error('Failed to parse CPU profile.');\n    }\n    return null;\n  }\n\n  private injectJSFrameEvents(tracingModel: SDK.TracingModel.TracingModel, thread: SDK.TracingModel.Thread):\n      SDK.TracingModel.Event[] {\n    const jsProfileModel = this.extractCpuProfile(tracingModel, thread);\n    let events = thread.events();\n    const jsSamples =\n        jsProfileModel ? TimelineJSProfileProcessor.generateTracingEventsFromCpuProfile(jsProfileModel, thread) : null;\n    if (jsSamples && jsSamples.length) {\n      events = Platform.ArrayUtilities.mergeOrdered(events, jsSamples, SDK.TracingModel.Event.orderedCompareStartTime);\n    }\n    if (jsSamples || events.some(e => e.name === RecordType.JSSample)) {\n      const jsFrameEvents = TimelineJSProfileProcessor.generateJSFrameEvents(events, {\n        showAllEvents: Root.Runtime.experiments.isEnabled('timelineShowAllEvents'),\n        showRuntimeCallStats: Root.Runtime.experiments.isEnabled('timelineV8RuntimeCallStats'),\n        showNativeFunctions: Common.Settings.Settings.instance().moduleSetting('showNativeFunctionsInJSProfile').get(),\n      });\n      if (jsFrameEvents && jsFrameEvents.length) {\n        events =\n            Platform.ArrayUtilities.mergeOrdered(jsFrameEvents, events, SDK.TracingModel.Event.orderedCompareStartTime);\n      }\n    }\n    return events;\n  }\n\n  private processThreadEvents(\n      tracingModel: SDK.TracingModel.TracingModel, ranges: {\n        from: number,\n        to: number,\n      }[],\n      thread: SDK.TracingModel.Thread, isMainThread: boolean, isWorker: boolean, forMainFrame: boolean,\n      url: Platform.DevToolsPath.UrlString|null): void {\n    const track = new Track();\n    track.name = thread.name() || i18nString(UIStrings.threadS, {PH1: thread.id()});\n    track.type = TrackType.Other;\n    track.thread = thread;\n    if (isMainThread) {\n      track.type = TrackType.MainThread;\n      track.url = url || Platform.DevToolsPath.EmptyUrlString;\n      track.forMainFrame = forMainFrame;\n    } else if (isWorker) {\n      track.type = TrackType.Worker;\n      track.url = url || Platform.DevToolsPath.EmptyUrlString;\n      track.name = track.url ? i18nString(UIStrings.workerS, {PH1: track.url}) : i18nString(UIStrings.dedicatedWorker);\n    } else if (thread.name().startsWith('CompositorTileWorker')) {\n      track.type = TrackType.Raster;\n    }\n    this.tracksInternal.push(track);\n\n    const events = this.injectJSFrameEvents(tracingModel, thread);\n    this.eventStack = [];\n    const eventStack = this.eventStack;\n\n    // Get the worker name from the target.\n    if (isWorker) {\n      const cpuProfileEvent = events.find(event => event.name === RecordType.Profile);\n      if (cpuProfileEvent) {\n        const target = this.targetByEvent(cpuProfileEvent);\n        if (target) {\n          track.name = i18nString(UIStrings.workerSS, {PH1: target.name(), PH2: track.url});\n        }\n      }\n    }\n\n    for (const range of ranges) {\n      let i = Platform.ArrayUtilities.lowerBound(events, range.from, (time, event) => time - event.startTime);\n      for (; i < events.length; i++) {\n        const event = events[i];\n        if (event.startTime >= range.to) {\n          break;\n        }\n\n        // There may be several TTI events, only take the first one.\n        if (this.isInteractiveTimeEvent(event) && this.totalBlockingTimeInternal === -1) {\n          this.totalBlockingTimeInternal = event.args['args']['total_blocking_time_ms'];\n        }\n\n        const isLongRunningTask = event.name === RecordType.Task && event.duration && event.duration > 50;\n        if (isMainThread && isLongRunningTask && event.duration) {\n          // We only track main thread events that are over 50ms, and the amount of time in the\n          // event (over 50ms) is what constitutes the blocking time. An event of 70ms, therefore,\n          // contributes 20ms to TBT.\n          this.estimatedTotalBlockingTime += event.duration - 50;\n        }\n\n        let last: SDK.TracingModel.Event = eventStack[eventStack.length - 1];\n        while (last && last.endTime !== undefined && last.endTime <= event.startTime) {\n          eventStack.pop();\n          last = eventStack[eventStack.length - 1];\n        }\n        if (!this.processEvent(event)) {\n          continue;\n        }\n        if (!SDK.TracingModel.TracingModel.isAsyncPhase(event.phase) && event.duration) {\n          if (eventStack.length) {\n            const parent = eventStack[eventStack.length - 1];\n            if (parent) {\n              parent.selfTime -= event.duration;\n              if (parent.selfTime < 0) {\n                this.fixNegativeDuration(parent, event);\n              }\n            }\n          }\n          event.selfTime = event.duration;\n          if (!eventStack.length) {\n            track.tasks.push(event);\n          }\n          eventStack.push(event);\n        }\n        if (this.isMarkerEvent(event)) {\n          this.timeMarkerEventsInternal.push(event);\n        }\n\n        track.events.push(event);\n        this.inspectedTargetEventsInternal.push(event);\n      }\n    }\n    this.processAsyncEvents(thread, ranges);\n  }\n\n  private fixNegativeDuration(event: SDK.TracingModel.Event, child: SDK.TracingModel.Event): void {\n    const epsilon = 1e-3;\n    if (event.selfTime < -epsilon) {\n      console.error(\n          `Children are longer than parent at ${event.startTime} ` +\n          `(${(child.startTime - this.minimumRecordTime()).toFixed(3)} by ${(-event.selfTime).toFixed(3)}`);\n    }\n    event.selfTime = 0;\n  }\n\n  private processAsyncEvents(thread: SDK.TracingModel.Thread, ranges: {\n    from: number,\n    to: number,\n  }[]): void {\n    const asyncEvents = thread.asyncEvents();\n    const groups = new Map<TrackType, SDK.TracingModel.AsyncEvent[]>();\n\n    function group(type: TrackType): SDK.TracingModel.AsyncEvent[] {\n      if (!groups.has(type)) {\n        groups.set(type, []);\n      }\n      return groups.get(type) as SDK.TracingModel.AsyncEvent[];\n    }\n\n    for (const range of ranges) {\n      let i = Platform.ArrayUtilities.lowerBound(asyncEvents, range.from, function(time, asyncEvent) {\n        return time - asyncEvent.startTime;\n      });\n\n      for (; i < asyncEvents.length; ++i) {\n        const asyncEvent = asyncEvents[i];\n        if (asyncEvent.startTime >= range.to) {\n          break;\n        }\n\n        if (asyncEvent.hasCategory(TimelineModelImpl.Category.Console)) {\n          group(TrackType.Console).push(asyncEvent);\n          continue;\n        }\n\n        if (asyncEvent.hasCategory(TimelineModelImpl.Category.UserTiming)) {\n          group(TrackType.Timings).push(asyncEvent);\n          continue;\n        }\n\n        if (asyncEvent.name === RecordType.Animation) {\n          group(TrackType.Animation).push(asyncEvent);\n          continue;\n        }\n      }\n    }\n\n    for (const [type, events] of groups) {\n      const track = this.ensureNamedTrack(type);\n      track.thread = thread;\n      track.asyncEvents =\n          Platform.ArrayUtilities.mergeOrdered(track.asyncEvents, events, SDK.TracingModel.Event.compareStartTime);\n    }\n  }\n\n  private processEvent(event: SDK.TracingModel.Event): boolean {\n    const eventStack = this.eventStack;\n\n    if (!eventStack.length) {\n      if (this.currentTaskLayoutAndRecalcEvents && this.currentTaskLayoutAndRecalcEvents.length) {\n        const totalTime = this.currentTaskLayoutAndRecalcEvents.reduce((time, event) => {\n          return event.duration === undefined ? time : time + event.duration;\n        }, 0);\n        if (totalTime > TimelineModelImpl.Thresholds.ForcedLayout) {\n          for (const e of this.currentTaskLayoutAndRecalcEvents) {\n            const timelineData = TimelineData.forEvent(e);\n            timelineData.warning = e.name === RecordType.Layout ? TimelineModelImpl.WarningType.ForcedLayout :\n                                                                  TimelineModelImpl.WarningType.ForcedStyle;\n          }\n        }\n      }\n      this.currentTaskLayoutAndRecalcEvents = [];\n    }\n\n    if (this.currentScriptEvent) {\n      if (this.currentScriptEvent.endTime !== undefined && event.startTime > this.currentScriptEvent.endTime) {\n        this.currentScriptEvent = null;\n      }\n    }\n\n    const eventData = event.args['data'] || event.args['beginData'] || {};\n    const timelineData = TimelineData.forEvent(event);\n    if (eventData['stackTrace']) {\n      timelineData.stackTrace = eventData['stackTrace'].map((callFrameOrProfileNode: Protocol.Runtime.CallFrame) => {\n        // `callFrameOrProfileNode` can also be a `SDK.ProfileTreeModel.ProfileNode` for JSSample; that class\n        // has accessors to mimic a `CallFrame`, but apparently we don't adjust stack traces in that case. Whether\n        // we should is unclear.\n        if (event.name !== RecordType.JSSample) {\n          // We need to copy the data so we can safely modify it below.\n          const frame = {...callFrameOrProfileNode};\n          // TraceEvents come with 1-based line & column numbers. The frontend code\n          // requires 0-based ones. Adjust the values.\n          --frame.lineNumber;\n          --frame.columnNumber;\n          return frame;\n        }\n        return callFrameOrProfileNode;\n      });\n    }\n    let pageFrameId = TimelineModelImpl.eventFrameId(event);\n    const last = eventStack[eventStack.length - 1];\n    if (!pageFrameId && last) {\n      pageFrameId = TimelineData.forEvent(last).frameId;\n    }\n    timelineData.frameId = pageFrameId || (this.mainFrame && this.mainFrame.frameId) || '';\n    this.asyncEventTracker.processEvent(event);\n\n    if (this.isMarkerEvent(event)) {\n      this.ensureNamedTrack(TrackType.Timings);\n    }\n\n    switch (event.name) {\n      case RecordType.ResourceSendRequest:\n      case RecordType.WebSocketCreate: {\n        timelineData.setInitiator(eventStack[eventStack.length - 1] || null);\n        timelineData.url = eventData['url'];\n        break;\n      }\n\n      case RecordType.ScheduleStyleRecalculation: {\n        this.lastScheduleStyleRecalculation[eventData['frame']] = event;\n        break;\n      }\n\n      case RecordType.UpdateLayoutTree:\n      case RecordType.RecalculateStyles: {\n        this.invalidationTracker.didRecalcStyle(event);\n        if (event.args['beginData']) {\n          timelineData.setInitiator(this.lastScheduleStyleRecalculation[event.args['beginData']['frame']]);\n        }\n        this.lastRecalculateStylesEvent = event;\n        if (this.currentScriptEvent) {\n          this.currentTaskLayoutAndRecalcEvents.push(event);\n        }\n        break;\n      }\n\n      case RecordType.ScheduleStyleInvalidationTracking:\n      case RecordType.StyleRecalcInvalidationTracking:\n      case RecordType.StyleInvalidatorInvalidationTracking:\n      case RecordType.LayoutInvalidationTracking: {\n        this.invalidationTracker.addInvalidation(new InvalidationTrackingEvent(event, timelineData));\n        break;\n      }\n\n      case RecordType.InvalidateLayout: {\n        // Consider style recalculation as a reason for layout invalidation,\n        // but only if we had no earlier layout invalidation records.\n        let layoutInitator: (SDK.TracingModel.Event|null)|SDK.TracingModel.Event = event;\n        const frameId = eventData['frame'];\n        if (!this.layoutInvalidate[frameId] && this.lastRecalculateStylesEvent &&\n            this.lastRecalculateStylesEvent.endTime !== undefined &&\n            this.lastRecalculateStylesEvent.endTime > event.startTime) {\n          layoutInitator = TimelineData.forEvent(this.lastRecalculateStylesEvent).initiator();\n        }\n        this.layoutInvalidate[frameId] = layoutInitator;\n        break;\n      }\n\n      case RecordType.Layout: {\n        this.invalidationTracker.didLayout(event);\n        const frameId = event.args['beginData']['frame'];\n        timelineData.setInitiator(this.layoutInvalidate[frameId]);\n        // In case we have no closing Layout event, endData is not available.\n        if (event.args['endData']) {\n          if (event.args['endData']['layoutRoots']) {\n            for (let i = 0; i < event.args['endData']['layoutRoots'].length; ++i) {\n              timelineData.backendNodeIds.push(event.args['endData']['layoutRoots'][i]['nodeId']);\n            }\n          } else {\n            timelineData.backendNodeIds.push(event.args['endData']['rootNode']);\n          }\n        }\n        this.layoutInvalidate[frameId] = null;\n        if (this.currentScriptEvent) {\n          this.currentTaskLayoutAndRecalcEvents.push(event);\n        }\n        break;\n      }\n\n      case RecordType.Task: {\n        if (event.duration !== undefined && event.duration > TimelineModelImpl.Thresholds.LongTask) {\n          timelineData.warning = TimelineModelImpl.WarningType.LongTask;\n        }\n        break;\n      }\n\n      case RecordType.EventDispatch: {\n        if (event.duration !== undefined && event.duration > TimelineModelImpl.Thresholds.RecurringHandler) {\n          timelineData.warning = TimelineModelImpl.WarningType.LongHandler;\n        }\n        break;\n      }\n\n      case RecordType.TimerFire:\n      case RecordType.FireAnimationFrame: {\n        if (event.duration !== undefined && event.duration > TimelineModelImpl.Thresholds.RecurringHandler) {\n          timelineData.warning = TimelineModelImpl.WarningType.LongRecurringHandler;\n        }\n        break;\n      }\n      // @ts-ignore fallthrough intended.\n      case RecordType.FunctionCall: {\n        // Compatibility with old format.\n        if (typeof eventData['scriptName'] === 'string') {\n          eventData['url'] = eventData['scriptName'];\n        }\n        if (typeof eventData['scriptLine'] === 'number') {\n          eventData['lineNumber'] = eventData['scriptLine'];\n        }\n      }\n\n      case RecordType.EvaluateScript:\n      case RecordType.CompileScript:\n      // @ts-ignore fallthrough intended.\n      case RecordType.CacheScript: {\n        if (typeof eventData['lineNumber'] === 'number') {\n          --eventData['lineNumber'];\n        }\n        if (typeof eventData['columnNumber'] === 'number') {\n          --eventData['columnNumber'];\n        }\n      }\n\n      case RecordType.RunMicrotasks: {\n        // Microtasks technically are not necessarily scripts, but for purpose of\n        // forced sync style recalc or layout detection they are.\n        if (!this.currentScriptEvent) {\n          this.currentScriptEvent = event;\n        }\n        break;\n      }\n\n      case RecordType.SetLayerTreeId: {\n        // This is to support old traces.\n        if (this.sessionId && eventData['sessionId'] && this.sessionId === eventData['sessionId']) {\n          this.mainFrameLayerTreeId = eventData['layerTreeId'];\n          break;\n        }\n\n        // We currently only show layer tree for the main frame.\n        const frameId = TimelineModelImpl.eventFrameId(event);\n        const pageFrame = frameId ? this.pageFrames.get(frameId) : null;\n        if (!pageFrame || pageFrame.parent) {\n          return false;\n        }\n        this.mainFrameLayerTreeId = eventData['layerTreeId'];\n        break;\n      }\n\n      case RecordType.Paint: {\n        this.invalidationTracker.didPaint = true;\n        // With CompositeAfterPaint enabled, paint events are no longer\n        // associated with a Node, and nodeId will not be present.\n        if ('nodeId' in eventData) {\n          timelineData.backendNodeIds.push(eventData['nodeId']);\n        }\n        // Only keep layer paint events, skip paints for subframes that get painted to the same layer as parent.\n        if (!eventData['layerId']) {\n          break;\n        }\n        const layerId = eventData['layerId'];\n        this.lastPaintForLayer[layerId] = event;\n        break;\n      }\n\n      case RecordType.DisplayItemListSnapshot:\n      case RecordType.PictureSnapshot: {\n        const layerUpdateEvent = this.findAncestorEvent(RecordType.UpdateLayer);\n        if (!layerUpdateEvent || layerUpdateEvent.args['layerTreeId'] !== this.mainFrameLayerTreeId) {\n          break;\n        }\n        const paintEvent = this.lastPaintForLayer[layerUpdateEvent.args['layerId']];\n        if (paintEvent) {\n          TimelineData.forEvent(paintEvent).picture = (event as SDK.TracingModel.ObjectSnapshot);\n        }\n        break;\n      }\n\n      case RecordType.ScrollLayer: {\n        timelineData.backendNodeIds.push(eventData['nodeId']);\n        break;\n      }\n\n      case RecordType.PaintImage: {\n        timelineData.backendNodeIds.push(eventData['nodeId']);\n        timelineData.url = eventData['url'];\n        break;\n      }\n\n      case RecordType.DecodeImage:\n      case RecordType.ResizeImage: {\n        let paintImageEvent = this.findAncestorEvent(RecordType.PaintImage);\n        if (!paintImageEvent) {\n          const decodeLazyPixelRefEvent = this.findAncestorEvent(RecordType.DecodeLazyPixelRef);\n          paintImageEvent =\n              decodeLazyPixelRefEvent && this.paintImageEventByPixelRefId[decodeLazyPixelRefEvent.args['LazyPixelRef']];\n        }\n        if (!paintImageEvent) {\n          break;\n        }\n        const paintImageData = TimelineData.forEvent(paintImageEvent);\n        timelineData.backendNodeIds.push(paintImageData.backendNodeIds[0]);\n        timelineData.url = paintImageData.url;\n        break;\n      }\n\n      case RecordType.DrawLazyPixelRef: {\n        const paintImageEvent = this.findAncestorEvent(RecordType.PaintImage);\n        if (!paintImageEvent) {\n          break;\n        }\n        this.paintImageEventByPixelRefId[event.args['LazyPixelRef']] = paintImageEvent;\n        const paintImageData = TimelineData.forEvent(paintImageEvent);\n        timelineData.backendNodeIds.push(paintImageData.backendNodeIds[0]);\n        timelineData.url = paintImageData.url;\n        break;\n      }\n\n      case RecordType.FrameStartedLoading: {\n        if (timelineData.frameId !== event.args['frame']) {\n          return false;\n        }\n        break;\n      }\n\n      case RecordType.MarkLCPCandidate: {\n        timelineData.backendNodeIds.push(eventData['nodeId']);\n        break;\n      }\n\n      case RecordType.MarkDOMContent:\n      case RecordType.MarkLoad: {\n        const frameId = TimelineModelImpl.eventFrameId(event);\n        if (!frameId || !this.pageFrames.has(frameId)) {\n          return false;\n        }\n        break;\n      }\n\n      case RecordType.CommitLoad: {\n        if (this.browserFrameTracking) {\n          break;\n        }\n        const frameId = TimelineModelImpl.eventFrameId(event);\n        const isOutermostMainFrame = Boolean(eventData['isOutermostMainFrame'] ?? eventData['isMainFrame']);\n        const pageFrame = frameId ? this.pageFrames.get(frameId) : null;\n        if (pageFrame) {\n          pageFrame.update(event.startTime, eventData);\n        } else {\n          // We should only have one main frame which has persistent id,\n          // unless it's an old trace without 'persistentIds' flag.\n          if (!this.persistentIds) {\n            if (eventData['page'] && eventData['page'] !== this.legacyCurrentPage) {\n              return false;\n            }\n          } else if (isOutermostMainFrame) {\n            return false;\n          } else if (!this.addPageFrame(event, eventData)) {\n            return false;\n          }\n        }\n        if (isOutermostMainFrame && frameId) {\n          const frame = this.pageFrames.get(frameId);\n          if (frame) {\n            this.mainFrame = frame;\n          }\n        }\n        break;\n      }\n\n      case RecordType.FireIdleCallback: {\n        if (event.duration !== undefined &&\n            event.duration > eventData['allottedMilliseconds'] + TimelineModelImpl.Thresholds.IdleCallbackAddon) {\n          timelineData.warning = TimelineModelImpl.WarningType.IdleDeadlineExceeded;\n        }\n        break;\n      }\n    }\n    return true;\n  }\n\n  private processBrowserEvent(event: SDK.TracingModel.Event): void {\n    if (event.name === RecordType.ResourceWillSendRequest) {\n      const requestId = event.args?.data?.requestId;\n      if (typeof requestId === 'string') {\n        this.requestsFromBrowser.set(requestId, event);\n      }\n      return;\n    }\n\n    if (event.hasCategory(SDK.TracingModel.DevToolsMetadataEventCategory) && event.args['data']) {\n      const data = event.args['data'];\n      if (event.name === TimelineModelImpl.DevToolsMetadataEvent.TracingStartedInBrowser) {\n        if (!data['persistentIds']) {\n          return;\n        }\n        this.browserFrameTracking = true;\n        this.mainFrameNodeId = data['frameTreeNodeId'];\n        const frames: any[] = data['frames'] || [];\n        frames.forEach(payload => {\n          const parent = payload['parent'] && this.pageFrames.get(payload['parent']);\n          if (payload['parent'] && !parent) {\n            return;\n          }\n          let frame = this.pageFrames.get(payload['frame']);\n          if (!frame) {\n            frame = new PageFrame(payload);\n            this.pageFrames.set(frame.frameId, frame);\n            if (parent) {\n              parent.addChild(frame);\n            } else {\n              this.mainFrame = frame;\n            }\n          }\n          // TODO(dgozman): this should use event.startTime, but due to races between tracing start\n          // in different processes we cannot do this yet.\n          frame.update(this.minimumRecordTimeInternal, payload);\n        });\n        return;\n      }\n      if (event.name === TimelineModelImpl.DevToolsMetadataEvent.FrameCommittedInBrowser && this.browserFrameTracking) {\n        let frame = this.pageFrames.get(data['frame']);\n        if (!frame) {\n          const parent = data['parent'] && this.pageFrames.get(data['parent']);\n          if (!parent) {\n            return;\n          }\n          frame = new PageFrame(data);\n          this.pageFrames.set(frame.frameId, frame);\n          parent.addChild(frame);\n        }\n        frame.update(event.startTime, data);\n        return;\n      }\n      if (event.name === TimelineModelImpl.DevToolsMetadataEvent.ProcessReadyInBrowser && this.browserFrameTracking) {\n        const frame = this.pageFrames.get(data['frame']);\n        if (frame) {\n          frame.processReady(data['processPseudoId'], data['processId']);\n        }\n        return;\n      }\n      if (event.name === TimelineModelImpl.DevToolsMetadataEvent.FrameDeletedInBrowser && this.browserFrameTracking) {\n        const frame = this.pageFrames.get(data['frame']);\n        if (frame) {\n          frame.deletedTime = event.startTime;\n        }\n        return;\n      }\n    }\n  }\n\n  private ensureNamedTrack(type: TrackType): Track {\n    let track = this.namedTracks.get(type);\n    if (track) {\n      return track;\n    }\n\n    track = new Track();\n    track.type = type;\n    this.tracksInternal.push(track);\n    this.namedTracks.set(type, track);\n    return track;\n  }\n\n  private findAncestorEvent(name: string): SDK.TracingModel.Event|null {\n    for (let i = this.eventStack.length - 1; i >= 0; --i) {\n      const event = this.eventStack[i];\n      if (event.name === name) {\n        return event;\n      }\n    }\n    return null;\n  }\n\n  private addPageFrame(event: SDK.TracingModel.Event, payload: any): boolean {\n    const parent = payload['parent'] && this.pageFrames.get(payload['parent']);\n    if (payload['parent'] && !parent) {\n      return false;\n    }\n    const pageFrame = new PageFrame(payload);\n    this.pageFrames.set(pageFrame.frameId, pageFrame);\n    pageFrame.update(event.startTime, payload);\n    if (parent) {\n      parent.addChild(pageFrame);\n    }\n    return true;\n  }\n\n  private reset(): void {\n    this.isGenericTraceInternal = false;\n    this.tracksInternal = [];\n    this.namedTracks = new Map();\n    this.inspectedTargetEventsInternal = [];\n    this.timeMarkerEventsInternal = [];\n    this.sessionId = null;\n    this.mainFrameNodeId = null;\n    this.cpuProfilesInternal = [];\n    this.workerIdByThread = new WeakMap();\n    this.pageFrames = new Map();\n    this.requestsFromBrowser = new Map();\n\n    this.minimumRecordTimeInternal = 0;\n    this.maximumRecordTimeInternal = 0;\n\n    this.totalBlockingTimeInternal = -1;\n    this.estimatedTotalBlockingTime = 0;\n  }\n\n  isGenericTrace(): boolean {\n    return this.isGenericTraceInternal;\n  }\n\n  tracingModel(): SDK.TracingModel.TracingModel|null {\n    return this.tracingModelInternal;\n  }\n\n  minimumRecordTime(): number {\n    return this.minimumRecordTimeInternal;\n  }\n\n  maximumRecordTime(): number {\n    return this.maximumRecordTimeInternal;\n  }\n\n  inspectedTargetEvents(): SDK.TracingModel.Event[] {\n    return this.inspectedTargetEventsInternal;\n  }\n\n  tracks(): Track[] {\n    return this.tracksInternal;\n  }\n\n  isEmpty(): boolean {\n    return this.minimumRecordTime() === 0 && this.maximumRecordTime() === 0;\n  }\n\n  timeMarkerEvents(): SDK.TracingModel.Event[] {\n    return this.timeMarkerEventsInternal;\n  }\n\n  rootFrames(): PageFrame[] {\n    return Array.from(this.pageFrames.values()).filter(frame => !frame.parent);\n  }\n\n  pageURL(): Platform.DevToolsPath.UrlString {\n    return this.mainFrame && this.mainFrame.url || Platform.DevToolsPath.EmptyUrlString;\n  }\n\n  pageFrameById(frameId: Protocol.Page.FrameId): PageFrame|null {\n    return frameId ? this.pageFrames.get(frameId) || null : null;\n  }\n\n  networkRequests(): NetworkRequest[] {\n    if (this.isGenericTrace()) {\n      return [];\n    }\n    const requests = new Map<string, NetworkRequest>();\n    const requestsList: NetworkRequest[] = [];\n    const zeroStartRequestsList: NetworkRequest[] = [];\n    const resourceTypes = new Set<string>([\n      RecordType.ResourceWillSendRequest,\n      RecordType.ResourceSendRequest,\n      RecordType.ResourceReceiveResponse,\n      RecordType.ResourceReceivedData,\n      RecordType.ResourceFinish,\n      RecordType.ResourceMarkAsCached,\n    ]);\n    const events = this.inspectedTargetEvents();\n    for (let i = 0; i < events.length; ++i) {\n      const e = events[i];\n      if (!resourceTypes.has(e.name)) {\n        continue;\n      }\n      const id = TimelineModelImpl.globalEventId(e, 'requestId');\n      const requestId = e.args?.data?.requestId;\n      if (e.name === RecordType.ResourceSendRequest && requestId && this.requestsFromBrowser.has(requestId)) {\n        const event = this.requestsFromBrowser.get(requestId);\n        if (event) {\n          addRequest(event, id);\n        }\n      }\n      addRequest(e, id);\n    }\n    function addRequest(e: SDK.TracingModel.Event, id: string): void {\n      let request = requests.get(id);\n      if (request) {\n        request.addEvent(e);\n      } else {\n        request = new NetworkRequest(e);\n        requests.set(id, request);\n        if (request.startTime) {\n          requestsList.push(request);\n        } else {\n          zeroStartRequestsList.push(request);\n        }\n      }\n    }\n    return zeroStartRequestsList.concat(requestsList);\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum RecordType {\n  Task = 'RunTask',\n  Program = 'Program',\n  EventDispatch = 'EventDispatch',\n\n  GPUTask = 'GPUTask',\n\n  Animation = 'Animation',\n  RequestMainThreadFrame = 'RequestMainThreadFrame',\n  BeginFrame = 'BeginFrame',\n  NeedsBeginFrameChanged = 'NeedsBeginFrameChanged',\n  BeginMainThreadFrame = 'BeginMainThreadFrame',\n  ActivateLayerTree = 'ActivateLayerTree',\n  DrawFrame = 'DrawFrame',\n  DroppedFrame = 'DroppedFrame',\n  HitTest = 'HitTest',\n  ScheduleStyleRecalculation = 'ScheduleStyleRecalculation',\n  RecalculateStyles = 'RecalculateStyles',\n  UpdateLayoutTree = 'UpdateLayoutTree',\n  InvalidateLayout = 'InvalidateLayout',\n  Layout = 'Layout',\n  LayoutShift = 'LayoutShift',\n  UpdateLayer = 'UpdateLayer',\n  UpdateLayerTree = 'UpdateLayerTree',\n  PaintSetup = 'PaintSetup',\n  Paint = 'Paint',\n  PaintImage = 'PaintImage',\n  PrePaint = 'PrePaint',\n  Rasterize = 'Rasterize',\n  RasterTask = 'RasterTask',\n  ScrollLayer = 'ScrollLayer',\n  CompositeLayers = 'CompositeLayers',\n  ComputeIntersections = 'IntersectionObserverController::computeIntersections',\n  InteractiveTime = 'InteractiveTime',\n\n  ScheduleStyleInvalidationTracking = 'ScheduleStyleInvalidationTracking',\n  StyleRecalcInvalidationTracking = 'StyleRecalcInvalidationTracking',\n  StyleInvalidatorInvalidationTracking = 'StyleInvalidatorInvalidationTracking',\n  LayoutInvalidationTracking = 'LayoutInvalidationTracking',\n\n  ParseHTML = 'ParseHTML',\n  ParseAuthorStyleSheet = 'ParseAuthorStyleSheet',\n\n  TimerInstall = 'TimerInstall',\n  TimerRemove = 'TimerRemove',\n  TimerFire = 'TimerFire',\n\n  XHRReadyStateChange = 'XHRReadyStateChange',\n  XHRLoad = 'XHRLoad',\n  CompileScript = 'v8.compile',\n  CompileCode = 'V8.CompileCode',\n  OptimizeCode = 'V8.OptimizeCode',\n  EvaluateScript = 'EvaluateScript',\n  CacheScript = 'v8.produceCache',\n  CompileModule = 'v8.compileModule',\n  EvaluateModule = 'v8.evaluateModule',\n  CacheModule = 'v8.produceModuleCache',\n  WasmStreamFromResponseCallback = 'v8.wasm.streamFromResponseCallback',\n  WasmCompiledModule = 'v8.wasm.compiledModule',\n  WasmCachedModule = 'v8.wasm.cachedModule',\n  WasmModuleCacheHit = 'v8.wasm.moduleCacheHit',\n  WasmModuleCacheInvalid = 'v8.wasm.moduleCacheInvalid',\n\n  FrameStartedLoading = 'FrameStartedLoading',\n  CommitLoad = 'CommitLoad',\n  MarkLoad = 'MarkLoad',\n  MarkDOMContent = 'MarkDOMContent',\n  MarkFirstPaint = 'firstPaint',\n  MarkFCP = 'firstContentfulPaint',\n  MarkLCPCandidate = 'largestContentfulPaint::Candidate',\n  MarkLCPInvalidate = 'largestContentfulPaint::Invalidate',\n  NavigationStart = 'navigationStart',\n\n  TimeStamp = 'TimeStamp',\n  ConsoleTime = 'ConsoleTime',\n  UserTiming = 'UserTiming',\n\n  ResourceWillSendRequest = 'ResourceWillSendRequest',\n  ResourceSendRequest = 'ResourceSendRequest',\n  ResourceReceiveResponse = 'ResourceReceiveResponse',\n  ResourceReceivedData = 'ResourceReceivedData',\n  ResourceFinish = 'ResourceFinish',\n  ResourceMarkAsCached = 'ResourceMarkAsCached',\n\n  RunMicrotasks = 'RunMicrotasks',\n  FunctionCall = 'FunctionCall',\n  GCEvent = 'GCEvent',\n  MajorGC = 'MajorGC',\n  MinorGC = 'MinorGC',\n  JSFrame = 'JSFrame',\n  JSSample = 'JSSample',\n  // V8Sample events are coming from tracing and contain raw stacks with function addresses.\n  // After being processed with help of JitCodeAdded and JitCodeMoved events they\n  // get translated into function infos and stored as stacks in JSSample events.\n  V8Sample = 'V8Sample',\n  JitCodeAdded = 'JitCodeAdded',\n  JitCodeMoved = 'JitCodeMoved',\n  StreamingCompileScript = 'v8.parseOnBackground',\n  StreamingCompileScriptWaiting = 'v8.parseOnBackgroundWaiting',\n  StreamingCompileScriptParsing = 'v8.parseOnBackgroundParsing',\n  V8Execute = 'V8.Execute',\n\n  UpdateCounters = 'UpdateCounters',\n\n  RequestAnimationFrame = 'RequestAnimationFrame',\n  CancelAnimationFrame = 'CancelAnimationFrame',\n  FireAnimationFrame = 'FireAnimationFrame',\n\n  RequestIdleCallback = 'RequestIdleCallback',\n  CancelIdleCallback = 'CancelIdleCallback',\n  FireIdleCallback = 'FireIdleCallback',\n\n  WebSocketCreate = 'WebSocketCreate',\n  WebSocketSendHandshakeRequest = 'WebSocketSendHandshakeRequest',\n  WebSocketReceiveHandshakeResponse = 'WebSocketReceiveHandshakeResponse',\n  WebSocketDestroy = 'WebSocketDestroy',\n\n  EmbedderCallback = 'EmbedderCallback',\n\n  SetLayerTreeId = 'SetLayerTreeId',\n  TracingStartedInPage = 'TracingStartedInPage',\n  TracingSessionIdForWorker = 'TracingSessionIdForWorker',\n\n  DecodeImage = 'Decode Image',\n  ResizeImage = 'Resize Image',\n  DrawLazyPixelRef = 'Draw LazyPixelRef',\n  DecodeLazyPixelRef = 'Decode LazyPixelRef',\n\n  LazyPixelRef = 'LazyPixelRef',\n  LayerTreeHostImplSnapshot = 'cc::LayerTreeHostImpl',\n  PictureSnapshot = 'cc::Picture',\n  DisplayItemListSnapshot = 'cc::DisplayItemList',\n  LatencyInfo = 'LatencyInfo',\n  LatencyInfoFlow = 'LatencyInfo.Flow',\n  InputLatencyMouseMove = 'InputLatency::MouseMove',\n  InputLatencyMouseWheel = 'InputLatency::MouseWheel',\n  ImplSideFling = 'InputHandlerProxy::HandleGestureFling::started',\n  GCCollectGarbage = 'BlinkGC.AtomicPhase',\n\n  CryptoDoEncrypt = 'DoEncrypt',\n  CryptoDoEncryptReply = 'DoEncryptReply',\n  CryptoDoDecrypt = 'DoDecrypt',\n  CryptoDoDecryptReply = 'DoDecryptReply',\n  CryptoDoDigest = 'DoDigest',\n  CryptoDoDigestReply = 'DoDigestReply',\n  CryptoDoSign = 'DoSign',\n  CryptoDoSignReply = 'DoSignReply',\n  CryptoDoVerify = 'DoVerify',\n  CryptoDoVerifyReply = 'DoVerifyReply',\n\n  // CpuProfile is a virtual event created on frontend to support\n  // serialization of CPU Profiles within tracing timeline data.\n  CpuProfile = 'CpuProfile',\n  Profile = 'Profile',\n\n  AsyncTask = 'AsyncTask',\n}\n\nexport namespace TimelineModelImpl {\n  export const Category = {\n    Console: 'blink.console',\n    UserTiming: 'blink.user_timing',\n    LatencyInfo: 'latencyInfo',\n    Loading: 'loading',\n  };\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line rulesdir/const_enum\n  export enum WarningType {\n    LongTask = 'LongTask',\n    ForcedStyle = 'ForcedStyle',\n    ForcedLayout = 'ForcedLayout',\n    IdleDeadlineExceeded = 'IdleDeadlineExceeded',\n    LongHandler = 'LongHandler',\n    LongRecurringHandler = 'LongRecurringHandler',\n    V8Deopt = 'V8Deopt',\n  }\n\n  export const WorkerThreadName = 'DedicatedWorker thread';\n  export const WorkerThreadNameLegacy = 'DedicatedWorker Thread';\n  export const RendererMainThreadName = 'CrRendererMain';\n  export const BrowserMainThreadName = 'CrBrowserMain';\n\n  export const DevToolsMetadataEvent = {\n    TracingStartedInBrowser: 'TracingStartedInBrowser',\n    TracingStartedInPage: 'TracingStartedInPage',\n    TracingSessionIdForWorker: 'TracingSessionIdForWorker',\n    FrameCommittedInBrowser: 'FrameCommittedInBrowser',\n    ProcessReadyInBrowser: 'ProcessReadyInBrowser',\n    FrameDeletedInBrowser: 'FrameDeletedInBrowser',\n  };\n\n  export const Thresholds = {\n    LongTask: 50,\n    Handler: 150,\n    RecurringHandler: 50,\n    ForcedLayout: 30,\n    IdleCallbackAddon: 5,\n  };\n}\n\nexport class Track {\n  name: string;\n  type: TrackType;\n  forMainFrame: boolean;\n  url: Platform.DevToolsPath.UrlString;\n  events: SDK.TracingModel.Event[];\n  asyncEvents: SDK.TracingModel.AsyncEvent[];\n  tasks: SDK.TracingModel.Event[];\n  private syncEventsInternal: SDK.TracingModel.Event[]|null;\n  thread: SDK.TracingModel.Thread|null;\n  constructor() {\n    this.name = '';\n    this.type = TrackType.Other;\n    // TODO(dgozman): replace forMainFrame with a list of frames, urls and time ranges.\n    this.forMainFrame = false;\n    this.url = Platform.DevToolsPath.EmptyUrlString;\n    // TODO(dgozman): do not distinguish between sync and async events.\n    this.events = [];\n    this.asyncEvents = [];\n    this.tasks = [];\n    this.syncEventsInternal = null;\n    this.thread = null;\n  }\n\n  syncEvents(): SDK.TracingModel.Event[] {\n    if (this.events.length) {\n      return this.events;\n    }\n\n    if (this.syncEventsInternal) {\n      return this.syncEventsInternal;\n    }\n\n    const stack: SDK.TracingModel.Event[] = [];\n\n    function peekLastEndTime(): number {\n      const last = stack[stack.length - 1];\n      if (last !== undefined) {\n        const endTime = last.endTime;\n        if (endTime !== undefined) {\n          return endTime;\n        }\n      }\n      throw new Error('End time does not exist on event.');\n    }\n\n    this.syncEventsInternal = [];\n    for (const event of this.asyncEvents) {\n      const startTime = event.startTime;\n      let endTime: number|(number | undefined) = event.endTime;\n      if (endTime === undefined) {\n        endTime = startTime;\n      }\n      while (stack.length && startTime >= peekLastEndTime()) {\n        stack.pop();\n      }\n      if (stack.length && endTime > peekLastEndTime()) {\n        this.syncEventsInternal = [];\n        break;\n      }\n      const syncEvent = new SDK.TracingModel.Event(\n          event.categoriesString, event.name, SDK.TracingModel.Phase.Complete, startTime, event.thread);\n      syncEvent.setEndTime(endTime);\n      syncEvent.addArgs(event.args);\n      this.syncEventsInternal.push(syncEvent);\n      stack.push(syncEvent);\n    }\n    return this.syncEventsInternal;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum TrackType {\n  MainThread = 'MainThread',\n  Worker = 'Worker',\n  Animation = 'Animation',\n  Timings = 'Timings',\n  Console = 'Console',\n  Raster = 'Raster',\n  GPU = 'GPU',\n  Experience = 'Experience',\n  Other = 'Other',\n}\n\nexport class PageFrame {\n  frameId: any;\n  url: any;\n  name: any;\n  children: PageFrame[];\n  parent: PageFrame|null;\n  processes: {\n    time: number,\n    processId: number,\n    processPseudoId: string|null,\n    url: Platform.DevToolsPath.UrlString,\n  }[];\n  deletedTime: number|null;\n  ownerNode: SDK.DOMModel.DeferredDOMNode|null;\n  constructor(payload: any) {\n    this.frameId = payload['frame'];\n    this.url = payload['url'] || Platform.DevToolsPath.EmptyUrlString;\n    this.name = payload['name'];\n    this.children = [];\n    this.parent = null;\n    this.processes = [];\n    this.deletedTime = null;\n    // TODO(dgozman): figure this out.\n    // this.ownerNode = target && payload['nodeId'] ? new SDK.DOMModel.DeferredDOMNode(target, payload['nodeId']) : null;\n    this.ownerNode = null;\n  }\n\n  update(time: number, payload: any): void {\n    this.url = payload['url'] || '';\n    this.name = payload['name'];\n    if (payload['processId']) {\n      this.processes.push(\n          {time: time, processId: payload['processId'], processPseudoId: '', url: payload['url'] || ''});\n    } else {\n      this.processes.push(\n          {time: time, processId: -1, processPseudoId: payload['processPseudoId'], url: payload['url'] || ''});\n    }\n  }\n\n  processReady(processPseudoId: string, processId: number): void {\n    for (const process of this.processes) {\n      if (process.processPseudoId === processPseudoId) {\n        process.processPseudoId = '';\n        process.processId = processId;\n      }\n    }\n  }\n\n  addChild(child: PageFrame): void {\n    this.children.push(child);\n    child.parent = this;\n  }\n}\n\nexport class NetworkRequest {\n  startTime: number;\n  endTime: number;\n  encodedDataLength: number;\n  decodedBodyLength: number;\n  children: SDK.TracingModel.Event[];\n  timing!: {\n    pushStart: number,\n    requestTime: number,\n    sendStart: number,\n    receiveHeadersEnd: number,\n  };\n  mimeType!: string;\n  url!: Platform.DevToolsPath.UrlString;\n  requestMethod!: string;\n  private transferSize: number;\n  private maybeDiskCached: boolean;\n  private memoryCachedInternal: boolean;\n  priority?: any;\n  finishTime?: number;\n  responseTime?: number;\n  fromServiceWorker?: boolean;\n  hasCachedResource?: boolean;\n  constructor(event: SDK.TracingModel.Event) {\n    const isInitial =\n        event.name === RecordType.ResourceSendRequest || event.name === RecordType.ResourceWillSendRequest;\n    this.startTime = isInitial ? event.startTime : 0;\n    this.endTime = Infinity;\n    this.encodedDataLength = 0;\n    this.decodedBodyLength = 0;\n    this.children = [];\n    this.transferSize = 0;\n    this.maybeDiskCached = false;\n    this.memoryCachedInternal = false;\n    this.addEvent(event);\n  }\n\n  addEvent(event: SDK.TracingModel.Event): void {\n    this.children.push(event);\n    // This Math.min is likely because of BUG(chromium:865066).\n    this.startTime = Math.min(this.startTime, event.startTime);\n    const eventData = event.args['data'];\n    if (eventData['mimeType']) {\n      this.mimeType = eventData['mimeType'];\n    }\n    if ('priority' in eventData) {\n      this.priority = eventData['priority'];\n    }\n    if (event.name === RecordType.ResourceFinish) {\n      this.endTime = event.startTime;\n    }\n    if (eventData['finishTime']) {\n      this.finishTime = eventData['finishTime'] * 1000;\n    }\n    if (!this.responseTime &&\n        (event.name === RecordType.ResourceReceiveResponse || event.name === RecordType.ResourceReceivedData)) {\n      this.responseTime = event.startTime;\n    }\n    const encodedDataLength = eventData['encodedDataLength'] || 0;\n    if (event.name === RecordType.ResourceMarkAsCached) {\n      // This is a reliable signal for memory caching.\n      this.memoryCachedInternal = true;\n    }\n    if (event.name === RecordType.ResourceReceiveResponse) {\n      if (eventData['fromCache']) {\n        // See BUG(chromium:998397): back-end over-approximates caching.\n        this.maybeDiskCached = true;\n      }\n      if (eventData['fromServiceWorker']) {\n        this.fromServiceWorker = true;\n      }\n      if (eventData['hasCachedResource']) {\n        this.hasCachedResource = true;\n      }\n      this.encodedDataLength = encodedDataLength;\n    }\n    if (event.name === RecordType.ResourceReceivedData) {\n      this.encodedDataLength += encodedDataLength;\n    }\n    if (event.name === RecordType.ResourceFinish && encodedDataLength) {\n      this.encodedDataLength = encodedDataLength;\n      // If a ResourceFinish event with an encoded data length is received,\n      // then the resource was not cached; it was fetched before it was\n      // requested, e.g. because it was pushed in this navigation.\n      this.transferSize = encodedDataLength;\n    }\n    const decodedBodyLength = eventData['decodedBodyLength'];\n    if (event.name === RecordType.ResourceFinish && decodedBodyLength) {\n      this.decodedBodyLength = decodedBodyLength;\n    }\n    if (!this.url) {\n      this.url = eventData['url'];\n    }\n    if (!this.requestMethod) {\n      this.requestMethod = eventData['requestMethod'];\n    }\n    if (!this.timing) {\n      this.timing = eventData['timing'];\n    }\n    if (eventData['fromServiceWorker']) {\n      this.fromServiceWorker = true;\n    }\n  }\n\n  /**\n   * Return whether this request was cached. This works around BUG(chromium:998397),\n   * which reports pushed resources, and resources serverd by a service worker as\n   * disk cached. Pushed resources that were not disk cached, however, have a non-zero\n   * `transferSize`.\n   */\n  cached(): boolean {\n    return Boolean(this.memoryCachedInternal) ||\n        (Boolean(this.maybeDiskCached) && !this.transferSize && !this.fromServiceWorker);\n  }\n\n  /**\n   * Return whether this request was served from a memory cache.\n   */\n  memoryCached(): boolean {\n    return this.memoryCachedInternal;\n  }\n\n  /**\n   * Get the timing information for this request. If the request was cached,\n   * the timing refers to the original (uncached) load, and should not be used.\n   */\n  getSendReceiveTiming(): {\n    sendStartTime: number,\n    headersEndTime: number,\n  } {\n    if (this.cached() || !this.timing) {\n      // If the request is served from cache, the timing refers to the original\n      // resource load, and should not be used.\n      return {sendStartTime: this.startTime, headersEndTime: this.startTime};\n    }\n    const requestTime = this.timing.requestTime * 1000;\n    const sendStartTime = requestTime + this.timing.sendStart;\n    const headersEndTime = requestTime + this.timing.receiveHeadersEnd;\n    return {sendStartTime, headersEndTime};\n  }\n\n  /**\n   * Get the start time of this request, i.e. the time when the browser or\n   * renderer queued this request. There are two cases where request time is\n   * earlier than `startTime`: (1) if the request is served from cache, because\n   * it refers to the original load of the resource. (2) if the request was\n   * initiated by the browser instead of the renderer. Only in case (2) the\n   * the request time must be used instead of the start time to work around\n   * BUG(chromium:865066).\n   */\n  getStartTime(): number {\n    return Math.min(this.startTime, !this.cached() && this.timing && this.timing.requestTime * 1000 || Infinity);\n  }\n\n  /**\n   * Returns the time where the earliest event belonging to this request starts.\n   * This differs from `getStartTime()` if a previous HTTP/2 request pushed the\n   * resource proactively: Then `beginTime()` refers to the time the push was received.\n   */\n  beginTime(): number {\n    // `pushStart` is referring to the original push if the request was cached (i.e. in\n    // general not the most recent push), and should hence only be used for requests that were not cached.\n    return Math.min(this.getStartTime(), !this.cached() && this.timing && this.timing.pushStart * 1000 || Infinity);\n  }\n}\n\nexport class InvalidationTrackingEvent {\n  type: string;\n  startTime: number;\n  readonly tracingEvent: SDK.TracingModel.Event;\n  frame: number;\n  nodeId: number|null;\n  nodeName: string|null;\n  invalidationSet: number|null;\n  invalidatedSelectorId: string|null;\n  changedId: string|null;\n  changedClass: string|null;\n  changedAttribute: string|null;\n  changedPseudo: string|null;\n  selectorPart: string|null;\n  extraData: string|null;\n  invalidationList: {\n    [x: string]: number,\n  }[]|null;\n  cause: InvalidationCause;\n  linkedRecalcStyleEvent: boolean;\n  linkedLayoutEvent: boolean;\n  constructor(event: SDK.TracingModel.Event, timelineData: TimelineData) {\n    this.type = event.name;\n    this.startTime = event.startTime;\n    this.tracingEvent = event;\n\n    const eventData = event.args['data'];\n\n    this.frame = eventData['frame'];\n    this.nodeId = eventData['nodeId'];\n    this.nodeName = eventData['nodeName'];\n    this.invalidationSet = eventData['invalidationSet'];\n    this.invalidatedSelectorId = eventData['invalidatedSelectorId'];\n    this.changedId = eventData['changedId'];\n    this.changedClass = eventData['changedClass'];\n    this.changedAttribute = eventData['changedAttribute'];\n    this.changedPseudo = eventData['changedPseudo'];\n    this.selectorPart = eventData['selectorPart'];\n    this.extraData = eventData['extraData'];\n    this.invalidationList = eventData['invalidationList'];\n    this.cause = {reason: eventData['reason'], stackTrace: timelineData.stackTrace};\n    this.linkedRecalcStyleEvent = false;\n    this.linkedLayoutEvent = false;\n\n    // FIXME: Move this to TimelineUIUtils.js.\n    if (!this.cause.reason && this.cause.stackTrace && this.type === RecordType.LayoutInvalidationTracking) {\n      this.cause.reason = 'Layout forced';\n    }\n  }\n}\n\nexport class InvalidationTracker {\n  private lastRecalcStyle: SDK.TracingModel.Event|null;\n  private lastPaintWithLayer: SDK.TracingModel.Event|null;\n  didPaint: boolean;\n  private invalidations: {\n    [x: string]: InvalidationTrackingEvent[],\n  };\n  private invalidationsByNodeId: {\n    [x: number]: InvalidationTrackingEvent[],\n  };\n  constructor() {\n    this.lastRecalcStyle = null;\n    this.lastPaintWithLayer = null;\n    this.didPaint = false;\n    this.initializePerFrameState();\n    this.invalidations = {};\n    this.invalidationsByNodeId = {};\n  }\n\n  static invalidationEventsFor(event: SDK.TracingModel.Event): InvalidationTrackingEvent[]|null {\n    return eventToInvalidation.get(event) || null;\n  }\n\n  addInvalidation(invalidation: InvalidationTrackingEvent): void {\n    this.startNewFrameIfNeeded();\n\n    if (!invalidation.nodeId) {\n      console.error('Invalidation lacks node information.');\n      console.error(invalidation);\n      return;\n    }\n\n    // Suppress StyleInvalidator StyleRecalcInvalidationTracking invalidations because they\n    // will be handled by StyleInvalidatorInvalidationTracking.\n    // FIXME: Investigate if we can remove StyleInvalidator invalidations entirely.\n    if (invalidation.type === RecordType.StyleRecalcInvalidationTracking &&\n        invalidation.cause.reason === 'StyleInvalidator') {\n      return;\n    }\n\n    // Style invalidation events can occur before and during recalc style. didRecalcStyle\n    // handles style invalidations that occur before the recalc style event but we need to\n    // handle style recalc invalidations during recalc style here.\n    const styleRecalcInvalidation =\n        (invalidation.type === RecordType.ScheduleStyleInvalidationTracking ||\n         invalidation.type === RecordType.StyleInvalidatorInvalidationTracking ||\n         invalidation.type === RecordType.StyleRecalcInvalidationTracking);\n    if (styleRecalcInvalidation) {\n      const duringRecalcStyle = invalidation.startTime && this.lastRecalcStyle &&\n          this.lastRecalcStyle.endTime !== undefined && invalidation.startTime >= this.lastRecalcStyle.startTime &&\n          invalidation.startTime <= this.lastRecalcStyle.endTime;\n      if (duringRecalcStyle) {\n        this.associateWithLastRecalcStyleEvent(invalidation);\n      }\n    }\n\n    // Record the invalidation so later events can look it up.\n    if (this.invalidations[invalidation.type]) {\n      this.invalidations[invalidation.type].push(invalidation);\n    } else {\n      this.invalidations[invalidation.type] = [invalidation];\n    }\n    if (invalidation.nodeId) {\n      if (this.invalidationsByNodeId[invalidation.nodeId]) {\n        this.invalidationsByNodeId[invalidation.nodeId].push(invalidation);\n      } else {\n        this.invalidationsByNodeId[invalidation.nodeId] = [invalidation];\n      }\n    }\n  }\n\n  didRecalcStyle(recalcStyleEvent: SDK.TracingModel.Event): void {\n    this.lastRecalcStyle = recalcStyleEvent;\n    const types = [\n      RecordType.ScheduleStyleInvalidationTracking,\n      RecordType.StyleInvalidatorInvalidationTracking,\n      RecordType.StyleRecalcInvalidationTracking,\n    ];\n    for (const invalidation of this.invalidationsOfTypes(types)) {\n      this.associateWithLastRecalcStyleEvent(invalidation);\n    }\n  }\n\n  private associateWithLastRecalcStyleEvent(invalidation: InvalidationTrackingEvent): void {\n    if (invalidation.linkedRecalcStyleEvent) {\n      return;\n    }\n\n    if (!this.lastRecalcStyle) {\n      throw new Error('Last recalculate style event not set.');\n    }\n    const recalcStyleFrameId = this.lastRecalcStyle.args['beginData']['frame'];\n    if (invalidation.type === RecordType.StyleInvalidatorInvalidationTracking) {\n      // Instead of calling addInvalidationToEvent directly, we create synthetic\n      // StyleRecalcInvalidationTracking events which will be added in addInvalidationToEvent.\n      this.addSyntheticStyleRecalcInvalidations(this.lastRecalcStyle, recalcStyleFrameId, invalidation);\n    } else if (invalidation.type === RecordType.ScheduleStyleInvalidationTracking) {\n      // ScheduleStyleInvalidationTracking events are only used for adding information to\n      // StyleInvalidatorInvalidationTracking events. See: addSyntheticStyleRecalcInvalidations.\n    } else {\n      this.addInvalidationToEvent(this.lastRecalcStyle, recalcStyleFrameId, invalidation);\n    }\n\n    invalidation.linkedRecalcStyleEvent = true;\n  }\n\n  private addSyntheticStyleRecalcInvalidations(\n      event: SDK.TracingModel.Event, frameId: number, styleInvalidatorInvalidation: InvalidationTrackingEvent): void {\n    if (!styleInvalidatorInvalidation.invalidationList) {\n      this.addSyntheticStyleRecalcInvalidation(styleInvalidatorInvalidation.tracingEvent, styleInvalidatorInvalidation);\n      return;\n    }\n    if (!styleInvalidatorInvalidation.nodeId) {\n      console.error('Invalidation lacks node information.');\n      console.error(styleInvalidatorInvalidation);\n      return;\n    }\n    for (let i = 0; i < styleInvalidatorInvalidation.invalidationList.length; i++) {\n      const setId = styleInvalidatorInvalidation.invalidationList[i]['id'];\n      let lastScheduleStyleRecalculation;\n      const nodeInvalidations = this.invalidationsByNodeId[styleInvalidatorInvalidation.nodeId] || [];\n      for (let j = 0; j < nodeInvalidations.length; j++) {\n        const invalidation = nodeInvalidations[j];\n        if (invalidation.frame !== frameId || invalidation.invalidationSet !== setId ||\n            invalidation.type !== RecordType.ScheduleStyleInvalidationTracking) {\n          continue;\n        }\n        lastScheduleStyleRecalculation = invalidation;\n      }\n      if (!lastScheduleStyleRecalculation) {\n        continue;\n      }\n      this.addSyntheticStyleRecalcInvalidation(\n          lastScheduleStyleRecalculation.tracingEvent, styleInvalidatorInvalidation);\n    }\n  }\n\n  private addSyntheticStyleRecalcInvalidation(\n      baseEvent: SDK.TracingModel.Event, styleInvalidatorInvalidation: InvalidationTrackingEvent): void {\n    const timelineData = TimelineData.forEvent(baseEvent);\n    const invalidation = new InvalidationTrackingEvent(baseEvent, timelineData);\n    invalidation.type = RecordType.StyleRecalcInvalidationTracking;\n    if (styleInvalidatorInvalidation.cause.reason) {\n      invalidation.cause.reason = styleInvalidatorInvalidation.cause.reason;\n    }\n    if (styleInvalidatorInvalidation.selectorPart) {\n      invalidation.selectorPart = styleInvalidatorInvalidation.selectorPart;\n    }\n\n    if (!invalidation.linkedRecalcStyleEvent) {\n      this.associateWithLastRecalcStyleEvent(invalidation);\n    }\n  }\n\n  didLayout(layoutEvent: SDK.TracingModel.Event): void {\n    const layoutFrameId = layoutEvent.args['beginData']['frame'];\n    for (const invalidation of this.invalidationsOfTypes([RecordType.LayoutInvalidationTracking])) {\n      if (invalidation.linkedLayoutEvent) {\n        continue;\n      }\n      this.addInvalidationToEvent(layoutEvent, layoutFrameId, invalidation);\n      invalidation.linkedLayoutEvent = true;\n    }\n  }\n\n  private addInvalidationToEvent(\n      event: SDK.TracingModel.Event, eventFrameId: number, invalidation: InvalidationTrackingEvent): void {\n    if (eventFrameId !== invalidation.frame) {\n      return;\n    }\n    const invalidations = eventToInvalidation.get(event);\n    if (!invalidations) {\n      eventToInvalidation.set(event, [invalidation]);\n    } else {\n      invalidations.push(invalidation);\n    }\n  }\n\n  private invalidationsOfTypes(types?: string[]): Generator<InvalidationTrackingEvent, any, any> {\n    const invalidations = this.invalidations;\n    if (!types) {\n      types = Object.keys(invalidations);\n    }\n    function* generator(): Generator<InvalidationTrackingEvent, void, unknown> {\n      if (!types) {\n        return;\n      }\n      for (let i = 0; i < types.length; ++i) {\n        const invalidationList = invalidations[types[i]] || [];\n        for (let j = 0; j < invalidationList.length; ++j) {\n          yield invalidationList[j];\n        }\n      }\n    }\n    return generator();\n  }\n\n  private startNewFrameIfNeeded(): void {\n    if (!this.didPaint) {\n      return;\n    }\n\n    this.initializePerFrameState();\n  }\n\n  private initializePerFrameState(): void {\n    this.invalidations = {};\n    this.invalidationsByNodeId = {};\n\n    this.lastRecalcStyle = null;\n    this.lastPaintWithLayer = null;\n    this.didPaint = false;\n  }\n}\n\nexport class TimelineAsyncEventTracker {\n  private readonly initiatorByType: Map<RecordType, Map<RecordType, SDK.TracingModel.Event>>;\n  constructor() {\n    TimelineAsyncEventTracker.initialize();\n    this.initiatorByType = new Map();\n    if (TimelineAsyncEventTracker.asyncEvents) {\n      for (const initiator of TimelineAsyncEventTracker.asyncEvents.keys()) {\n        this.initiatorByType.set(initiator, new Map());\n      }\n    }\n  }\n\n  private static initialize(): void {\n    if (TimelineAsyncEventTracker.asyncEvents) {\n      return;\n    }\n\n    const events = new Map<RecordType, {\n      causes: RecordType[],\n      joinBy: string,\n    }>();\n\n    events.set(RecordType.TimerInstall, {causes: [RecordType.TimerFire], joinBy: 'timerId'});\n    events.set(RecordType.ResourceSendRequest, {\n      causes: [\n        RecordType.ResourceMarkAsCached,\n        RecordType.ResourceReceiveResponse,\n        RecordType.ResourceReceivedData,\n        RecordType.ResourceFinish,\n      ],\n      joinBy: 'requestId',\n    });\n    events.set(RecordType.RequestAnimationFrame, {causes: [RecordType.FireAnimationFrame], joinBy: 'id'});\n    events.set(RecordType.RequestIdleCallback, {causes: [RecordType.FireIdleCallback], joinBy: 'id'});\n    events.set(RecordType.WebSocketCreate, {\n      causes: [\n        RecordType.WebSocketSendHandshakeRequest,\n        RecordType.WebSocketReceiveHandshakeResponse,\n        RecordType.WebSocketDestroy,\n      ],\n      joinBy: 'identifier',\n    });\n\n    TimelineAsyncEventTracker.asyncEvents = events;\n    TimelineAsyncEventTracker.typeToInitiator = new Map();\n    for (const entry of events) {\n      const types = entry[1].causes;\n      for (const currentType of types) {\n        TimelineAsyncEventTracker.typeToInitiator.set(currentType, entry[0]);\n      }\n    }\n  }\n\n  processEvent(event: SDK.TracingModel.Event): void {\n    if (!TimelineAsyncEventTracker.typeToInitiator || !TimelineAsyncEventTracker.asyncEvents) {\n      return;\n    }\n    let initiatorType: RecordType|undefined = TimelineAsyncEventTracker.typeToInitiator.get((event.name as RecordType));\n    const isInitiator = !initiatorType;\n    if (!initiatorType) {\n      initiatorType = (event.name as RecordType);\n    }\n    const initiatorInfo = TimelineAsyncEventTracker.asyncEvents.get(initiatorType);\n    if (!initiatorInfo) {\n      return;\n    }\n    const id = (TimelineModelImpl.globalEventId(event, initiatorInfo.joinBy) as RecordType);\n    if (!id) {\n      return;\n    }\n    const initiatorMap: Map<RecordType, SDK.TracingModel.Event>|undefined = this.initiatorByType.get(initiatorType);\n    if (initiatorMap) {\n      if (isInitiator) {\n        initiatorMap.set(id, event);\n        return;\n      }\n      const initiator = initiatorMap.get(id);\n      const timelineData = TimelineData.forEvent(event);\n      timelineData.setInitiator(initiator ? initiator : null);\n      if (!timelineData.frameId && initiator) {\n        timelineData.frameId = TimelineModelImpl.eventFrameId(initiator);\n      }\n    }\n  }\n\n  private static asyncEvents: Map<RecordType, {causes: RecordType[], joinBy: string}>|null = null;\n  private static typeToInitiator: Map<RecordType, RecordType>|null = null;\n}\n\nexport class TimelineData {\n  warning: string|null;\n  previewElement: Element|null;\n  url: Platform.DevToolsPath.UrlString|null;\n  backendNodeIds: Protocol.DOM.BackendNodeId[];\n  stackTrace: Protocol.Runtime.CallFrame[]|null;\n  picture: SDK.TracingModel.ObjectSnapshot|null;\n  private initiatorInternal: SDK.TracingModel.Event|null;\n  frameId: Protocol.Page.FrameId|null;\n  timeWaitingForMainThread?: number;\n\n  constructor() {\n    this.warning = null;\n    this.previewElement = null;\n    this.url = null;\n    this.backendNodeIds = [];\n    this.stackTrace = null;\n    this.picture = null;\n    this.initiatorInternal = null;\n    this.frameId = null;\n  }\n\n  setInitiator(initiator: SDK.TracingModel.Event|null): void {\n    this.initiatorInternal = initiator;\n    if (!initiator || this.url) {\n      return;\n    }\n    const initiatorURL = TimelineData.forEvent(initiator).url;\n    if (initiatorURL) {\n      this.url = initiatorURL;\n    }\n  }\n\n  initiator(): SDK.TracingModel.Event|null {\n    return this.initiatorInternal;\n  }\n\n  topFrame(): Protocol.Runtime.CallFrame|null {\n    const stackTrace = this.stackTraceForSelfOrInitiator();\n    return stackTrace && stackTrace[0] || null;\n  }\n\n  stackTraceForSelfOrInitiator(): Protocol.Runtime.CallFrame[]|null {\n    return this.stackTrace || (this.initiatorInternal && TimelineData.forEvent(this.initiatorInternal).stackTrace);\n  }\n\n  static forEvent(event: SDK.TracingModel.Event): TimelineData {\n    let data = eventToData.get(event);\n    if (!data) {\n      data = new TimelineData();\n      eventToData.set(event, data);\n    }\n    return data;\n  }\n}\n\nconst eventToData = new WeakMap();\nconst eventToInvalidation = new WeakMap();\nexport interface InvalidationCause {\n  reason: string;\n  stackTrace: Protocol.Runtime.CallFrame[]|null;\n}\nexport interface MetadataEvents {\n  page: SDK.TracingModel.Event[];\n  workers: SDK.TracingModel.Event[];\n}\n"],
  "mappings": "AAiCA;AACA;AACA;AACA;AACA;AAGA;AAEA,MAAM,YAAY;AAAA,EAKhB,SAAS;AAAA,EAKT,SAAS;AAAA,EAIT,iBAAiB;AAAA,EAMjB,UAAU;AAAA;AAEZ,MAAM,OAAO,KAAK,KAAK,kBAAkB,0CAA0C;AACnF,MAAM,aAAa,KAAK,KAAK,mBAAmB,KAAK,QAAW;AACzD,+BAAwB;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAGA;AAAA,EAGA;AAAA,EAGA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,cAAc;AACZ,SAAK,4BAA4B;AACjC,SAAK,4BAA4B;AACjC,SAAK,4BAA4B;AACjC,SAAK,6BAA6B;AAElC,SAAK;AACL,SAAK;AAEL,SAAK,mCAAmC;AACxC,SAAK,uBAAuB;AAAA;AAAA,SAGvB,aACH,QAAkC,cAClC,YACA,gBAA8F,WAC9F,SAAkB,QAA4D;AAChF,gBAAY,aAAa;AACzB,cAAU,WAAW;AACrB,UAAM,QAAkC;AACxC,UAAM,aAAa,kBAAkB,yBAAyB,QAAQ;AACtE,aAAS,IAAI,YAAY,IAAI,OAAO,QAAQ,EAAE,GAAG;AAC/C,YAAM,IAAI,OAAO;AACjB,UAAK,GAAE,WAAW,EAAE,aAAa,WAAW;AAC1C;AAAA;AAEF,UAAI,EAAE,aAAa,SAAS;AAC1B;AAAA;AAEF,UAAI,IAAI,aAAa,aAAa,aAAa,EAAE,UAAU,IAAI,aAAa,aAAa,YAAY,EAAE,QAAQ;AAC7G;AAAA;AAEF,UAAI,OAA+B,MAAM,MAAM,SAAS;AACxD,aAAO,QAAQ,KAAK,YAAY,UAAa,KAAK,WAAW,EAAE,WAAW;AACxE,cAAM;AACN,mBAAW;AACX,eAAO,MAAM,MAAM,SAAS;AAAA;AAE9B,UAAI,UAAU,CAAC,OAAO,IAAI;AACxB;AAAA;AAEF,UAAI,EAAE,UAAU;AACd,qBAAa;AACb,cAAM,KAAK;AAAA,aACN;AACL,0BAAkB,eAAe,GAAG,MAAM,MAAM,SAAS,MAAM;AAAA;AAAA;AAGnE,WAAO,MAAM,QAAQ;AACnB,YAAM,OAAO,MAAM;AACnB,UAAI,MAAM;AACR,mBAAW;AAAA;AAAA;AAAA;AAAA,SAKF,yBAAyB,QAAkC,MAAsB;AAC9F,QAAI,QAAQ,SAAS,eAAe,WAAW,QAAQ,MAAM,CAAC,OAAM,UAAU,QAAO,MAAM,aAAa;AACxG,WAAO,QAAQ,KAAK,CAAC,IAAI,aAAa,aAAa,gBAAgB,OAAO,SAAS;AACjF;AAAA;AAEF,WAAO,KAAK,IAAI,OAAO;AAAA;AAAA,EAGzB,cAAc,OAAwC;AACpD,YAAQ,MAAM;AAAA,WACP,WAAW;AACd,eAAO;AAAA,WACJ,WAAW;AAAA,WACX,WAAW;AACd,eAAO,QAAQ,KAAK,cAAc,MAAM,KAAK,UAAU,KAAK,UAAU,WAAW,QAAQ,MAAM,KAAK;AAAA,WACjG,WAAW;AAAA,WACX,WAAW;AAAA,WACX,WAAW;AAAA,WACX,WAAW;AACd,eAAO,QAAQ,MAAM,KAAK,QAAQ,2BAA2B,MAAM,KAAK,QAAQ;AAAA;AAEhF,eAAO;AAAA;AAAA;AAAA,EAIb,uBAAuB,OAAwC;AAC7D,WAAO,MAAM,SAAS,WAAW;AAAA;AAAA,EAGnC,mBAAmB,OAAwC;AACzD,WAAO,MAAM,SAAS,WAAW;AAAA;AAAA,EAGnC,kBAAkB,OAAwC;AACxD,WAAO,MAAM,qBAAqB,kBAAkB,SAAS;AAAA;AAAA,EAE/D,iBAAiB,OAAwC;AACvD,WAAO,MAAM,SAAS,WAAW;AAAA;AAAA,EAGnC,oBAAoB,OAAwC;AAC1D,WAAO,MAAM,SAAS,WAAW,oBAC7B,QAAQ,MAAM,KAAK,QAAQ,2BAA2B,MAAM,KAAK,QAAQ;AAAA;AAAA,EAG/E,qBAAqB,OAAwC;AAC3D,WAAO,MAAM,SAAS,WAAW,qBAC7B,QAAQ,MAAM,KAAK,QAAQ,2BAA2B,MAAM,KAAK,QAAQ;AAAA;AAAA,EAG/E,WAAW,OAAwC;AACjD,WAAO,MAAM,SAAS,WAAW,WAAW,QAAQ,KAAK,cACrD,MAAM,KAAK,aAAa,KAAK,UAAU;AAAA;AAAA,EAG7C,kBAAkB,OAAwC;AACxD,WAAO,MAAM,SAAS,WAAW,QAC7B,aAAa,SAAS,OAAO,YAAY,kBAAkB,YAAY;AAAA;AAAA,EAG7E,uBAAuB,OAAwC;AAC7D,WAAO,MAAM,SAAS,WAAW;AAAA;AAAA,EAGnC,gCAAgC,OAAwC;AACtE,WAAO,KAAK,uBAAuB,UAC9B,OAAM,KAAK,QAAQ,2BAA2B,MAAM,KAAK,QAAQ,0BAClE,MAAM,KAAK,QAAQ;AAAA;AAAA,SAGlB,cAAc,OAA+B,OAAuB;AACzE,UAAM,OAAO,MAAM,KAAK,WAAW,MAAM,KAAK;AAC9C,UAAM,KAAK,QAAQ,KAAK;AACxB,QAAI,CAAC,IAAI;AACP,aAAO;AAAA;AAET,WAAO,GAAG,MAAM,OAAO,UAAU,QAAQ;AAAA;AAAA,SAGpC,aAAa,OAA2D;AAC7E,UAAM,OAAO,MAAM,KAAK,WAAW,MAAM,KAAK;AAC9C,WAAO,QAAQ,KAAK,YAAY;AAAA;AAAA,EAGlC,cAA6D;AAC3D,WAAO,KAAK;AAAA;AAAA,EAGd,oBAGE;AACA,QAAI,KAAK,8BAA8B,IAAI;AACzC,aAAO,EAAC,MAAM,KAAK,4BAA4B,WAAW;AAAA;AAG5D,WAAO,EAAC,MAAM,KAAK,2BAA2B,WAAW;AAAA;AAAA,EAG3D,cAAc,OAAuD;AAEnE,UAAM,WAAW,KAAK,iBAAiB,IAAI,MAAM;AACjD,UAAM,aAAa,IAAI,cAAc,cAAc,WAAW;AAC9D,WAAO,WAAW,IAAI,cAAc,cAAc,WAAW,WAAW,YAAY;AAAA;AAAA,EAGtF,gBAAqD;AACnD,QAAI,CAAC,KAAK,sBAAsB;AAC9B,aAAO,oBAAI;AAAA;AAGb,WAAO,KAAK,qBAAqB;AAAA;AAAA,EAGnC,UAAU,cAAmD;AAC3D,SAAK;AACL,SAAK;AACL,SAAK,uBAAuB;AAE5B,SAAK,4BAA4B,aAAa;AAC9C,SAAK,4BAA4B,aAAa;AAI9C,UAAM,oBAAoB;AAC1B,eAAW,WAAW,aAAa,mBAAmB;AACpD,UAAI,QAAQ,WAAW,YAAY;AACjC;AAAA;AAGF,iBAAW,UAAU,QAAQ,iBAAiB;AAC5C,cAAM,SAAS,OAAO,mBAAmB,WAAW;AACpD,0BAAkB,KAAK,GAAG;AAAA;AAAA;AAI9B,SAAK,yBAAyB;AAC9B,QAAI,KAAK,sBAAsB;AAC7B,WAAK,+BAA+B;AAAA,WAC/B;AAGL,YAAM,iBAAiB,KAAK,sBAAsB;AAClD,WAAK,yBAAyB,CAAC;AAC/B,UAAI,gBAAgB;AAClB,aAAK,0BAA0B,cAAc;AAAA,aACxC;AACL,aAAK,oBAAoB;AAAA;AAAA;AAG7B,SAAK,8BAA8B,KAAK,IAAI,aAAa,MAAM;AAC/D,SAAK,0BAA0B;AAC/B,SAAK,eAAe;AACpB,SAAK,mBAAmB,cAAc;AACtC,SAAK;AAAA;AAAA,EAGC,oBAAoB,cAAmD;AAC7E,QAAI,oBAAoB,IAAI,aAAa,aAAa,kBAAkB;AACxE,QAAI,CAAC,qBAAqB,aAAa,kBAAkB,QAAQ;AAC/D,0BAAoB,aAAa,kBAAkB,GAAG,gBAAgB;AAAA;AAExE,eAAW,WAAW,aAAa,mBAAmB;AACpD,iBAAW,UAAU,QAAQ,iBAAiB;AAC5C,aAAK,oBACD,cAAc,CAAC,EAAC,MAAM,GAAG,IAAI,aAAY,QAAQ,WAAW,mBAAmB,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA,EAK9F,0BAA0B,cAA6C,gBAAsC;AACnH,QAAI,YAAY;AAChB,aAAS,IAAI,GAAG,SAAS,eAAe,KAAK,QAAQ,IAAI,QAAQ,KAAK;AACpE,YAAM,YAAY,eAAe,KAAK;AACtC,YAAM,UAAU,UAAU,OAAO;AACjC,YAAM,UAAU,IAAI,IAAI,SAAS,eAAe,KAAK,IAAI,GAAG,YAAY;AACxE,UAAI,cAAc,SAAS;AACzB;AAAA;AAEF,WAAK,oBAAoB,UAAU,KAAK,WAAW,UAAU,KAAK,QAAQ;AAC1E,iBAAW,UAAU,QAAQ,iBAAiB;AAC5C,YAAI,YAAkD;AACtD,YAAI,OAAO,WAAW,kBAAkB,oBACpC,OAAO,WAAW,kBAAkB,wBAAwB;AAC9D,gBAAM,kBAAkB,eAAe,QAAQ,KAAK,OAAK;AACvD,gBAAI,EAAE,KAAK,QAAQ,sBAAsB,OAAO,MAAM;AACpD,qBAAO;AAAA;AAGT,gBAAI,EAAE,KAAK,QAAQ,iBAAiB,KAAK,WAAW;AAClD,qBAAO;AAAA;AAET,kBAAM,UAAU,kBAAkB,aAAa;AAC/C,mBAAO,UAAU,QAAQ,KAAK,WAAW,IAAI,YAAY;AAAA;AAE3D,cAAI,CAAC,iBAAiB;AACpB;AAAA;AAEF,gBAAM,WAAW,gBAAgB,KAAK,QAAQ;AAC9C,cAAI,UAAU;AACZ,iBAAK,iBAAiB,IAAI,QAAQ;AAAA;AAEpC,sBAAY,gBAAgB,KAAK,QAAQ,UAAU,SAAS,aAAa;AAAA;AAE3E,aAAK,oBACD,cAAc,CAAC,EAAC,MAAM,WAAW,IAAI,YAAW,QAAQ,WAAW,UAAU,QAAQ,QAAQ,YAC7F,MAAM;AAAA;AAEZ,kBAAY;AAAA;AAAA;AAAA,EAIR,+BAA+B,cAAmD;AACxF,UAAM,cAAc,oBAAI;AAMxB,eAAW,SAAS,KAAK,WAAW,UAAU;AAC5C,eAAS,IAAI,GAAG,IAAI,MAAM,UAAU,QAAQ,KAAK;AAC/C,cAAM,MAAM,MAAM,UAAU,GAAG;AAC/B,YAAI,OAAO,YAAY,IAAI;AAC3B,YAAI,CAAC,MAAM;AACT,iBAAO;AACP,sBAAY,IAAI,KAAK;AAAA;AAEvB,cAAM,KAAK,MAAM,MAAM,UAAU,SAAS,IAAK,MAAM,eAAe,WAAY,MAAM,UAAU,IAAI,GAAG;AACvG,aAAK,KAAK,EAAC,MAAM,MAAM,UAAU,GAAG,MAAM,IAAQ,MAAM,CAAC,MAAM,QAAQ,KAAK,MAAM,UAAU,GAAG;AAAA;AAAA;AAGnG,UAAM,oBAAoB,aAAa;AACvC,eAAW,WAAW,aAAa,mBAAmB;AACpD,YAAM,OAAO,YAAY,IAAI,QAAQ;AACrC,UAAI,CAAC,MAAM;AACT;AAAA;AAEF,WAAK,KAAK,CAAC,GAAG,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE;AAChD,YAAM,SAAS;AACf,UAAI,UAAgD;AACpD,UAAI,cAAoD;AACxD,UAAI,UAAU;AACd,iBAAW,QAAQ,MAAM;AACvB,cAAM,OAAO,OAAO,OAAO,SAAS;AACpC,YAAI,CAAC,QAAQ,KAAK,OAAO,KAAK,IAAI;AAChC,iBAAO,KAAK,EAAC,MAAM,KAAK,MAAM,IAAI,KAAK;AAAA,eAClC;AACL,eAAK,KAAK,KAAK;AAAA;AAEjB,YAAI,KAAK,MAAM;AACb,oBAAU;AAAA;AAEZ,YAAI,KAAK,KAAK;AACZ,cAAI,KAAK,MAAM;AACb,0BAAc,KAAK;AAAA;AAErB,oBAAU,KAAK;AAAA;AAAA;AAInB,iBAAW,UAAU,QAAQ,iBAAiB;AAC5C,YAAI,OAAO,WAAW,kBAAkB,wBAAwB;AAC9D,eAAK,oBACD,cAAc,QAAQ,QAAQ,MAAyB,OAAsB,SAC7E,UAAU,cAAc;AAAA,mBAE1B,OAAO,WAAW,kBAAkB,oBACpC,OAAO,WAAW,kBAAkB,wBAAwB;AAC9D,gBAAM,kBAAkB,kBAAkB,KAAK,OAAK;AAClD,gBAAI,EAAE,SAAS,kBAAkB,sBAAsB,2BAA2B;AAChF,qBAAO;AAAA;AAET,gBAAI,EAAE,OAAO,cAAc,SAAS;AAClC,qBAAO;AAAA;AAET,gBAAI,EAAE,KAAK,QAAQ,sBAAsB,OAAO,MAAM;AACpD,qBAAO;AAAA;AAET,kBAAM,UAAU,kBAAkB,aAAa;AAC/C,mBAAO,UAAU,QAAQ,KAAK,WAAW,IAAI,YAAY;AAAA;AAE3D,cAAI,CAAC,iBAAiB;AACpB;AAAA;AAEF,eAAK,iBAAiB,IAAI,QAAQ,gBAAgB,KAAK,QAAQ,eAAe;AAC9E,eAAK,oBACD,cAAc,QAAQ,QAAQ,OAA0B,MAAqB,OAC7E,gBAAgB,KAAK,QAAQ,UAAU,SAAS,aAAa;AAAA,eAC5D;AACL,eAAK,oBACD,cAAc,QAAQ,QAAQ,OAA0B,OAAsB,OAC9E;AAAA;AAAA;AAAA;AAAA;AAAA,EAMJ,sBAAsB,cAAkE;AAC9F,UAAM,iBAAiB,aAAa;AAEpC,UAAM,6BAA6B;AACnC,UAAM,gCAAgC;AACtC,eAAW,SAAS,gBAAgB;AAClC,UAAI,MAAM,SAAS,kBAAkB,sBAAsB,sBAAsB;AAC/E,mCAA2B,KAAK;AAChC,YAAI,MAAM,KAAK,WAAW,MAAM,KAAK,QAAQ,kBAAkB;AAC7D,eAAK,gBAAgB;AAAA;AAEvB,cAAM,SAAW,MAAM,KAAK,WAAW,MAAM,KAAK,QAAQ,aAAc;AACxE,eAAO,QAAQ,CAAC,YAAuB,KAAK,aAAa,OAAO;AAChE,aAAK,YAAY,KAAK,aAAa;AAAA,iBAC1B,MAAM,SAAS,kBAAkB,sBAAsB,2BAA2B;AAC3F,sCAA8B,KAAK;AAAA,iBAC1B,MAAM,SAAS,kBAAkB,sBAAsB,yBAAyB;AACzF,gBAAQ,OAAO,CAAC,KAAK,iBAAiB;AACtC,aAAK,kBAAkB,MAAM,KAAK;AAAA;AAAA;AAGtC,QAAI,CAAC,2BAA2B,QAAQ;AACtC,aAAO;AAAA;AAGT,UAAM,YACF,2BAA2B,GAAG,KAAK,gBAAgB,2BAA2B,GAAG,KAAK,QAAQ;AAClG,SAAK,YAAY;AAEjB,UAAM,iBAAiB,oBAAI;AAC3B,4BAAwB,OAAwC;AAC9D,UAAI,OAAO,MAAM;AAEjB,UAAI,KAAK,SAAS;AAChB,eAAO,KAAK;AAAA;AAEd,YAAM,KAAK,KAAK;AAChB,UAAI,OAAO,WAAW;AACpB,eAAO;AAAA;AAET,qBAAe,IAAI;AACnB,aAAO;AAAA;AAET,UAAM,SAAS;AAAA,MACb,MAAM,2BAA2B,OAAO,gBAAgB,KAAK,IAAI,aAAa,MAAM;AAAA,MACpF,SAAS,8BAA8B,KAAK,IAAI,aAAa,MAAM;AAAA;AAErE,QAAI,eAAe,MAAM;AACvB,aAAO,QAAQ,QAAQ,WAAW,MAC9B,+FACA,KAAK,YAAY,UAAU,CAAC,GAAG,kBAAkB;AAAA;AAEvD,WAAO;AAAA;AAAA,EAGD,yBAAyB,cAAmD;AAClF,UAAM,cAAc,IAAI,aAAa,aAAa,kBAAkB;AACpE,QAAI,aAAa;AACf,kBAAY,SAAS,QAAQ,KAAK,qBAAqB;AAAA;AAAA;AAAA,EAInD,0BAA0B,cAAmD;AACnF,UAAM,cAAc,IAAI,aAAa,aAAa,kBAAkB;AACpE,QAAI,aAAa;AACf,WAAK,mBAAmB,aAAa,CAAC,EAAC,MAAM,GAAG,IAAI;AAAA;AAAA;AAAA,EAIhD,eAAe,cAAmD;AACxE,UAAM,SAAS,aAAa,gBAAgB,eAAe;AAC3D,QAAI,CAAC,QAAQ;AACX;AAAA;AAEF,UAAM,eAAe,WAAW;AAChC,UAAM,QAAQ,KAAK,iBAAiB,UAAU;AAC9C,UAAM,SAAS;AACf,UAAM,SAAS,OAAO,SAAS,OAAO,WAAS,MAAM,SAAS;AAAA;AAAA,EAGxD,mBAAmB,cAA6C,QAAwC;AAC9G,UAAM,SAAS,aAAa,gBAAgB,YAAY;AACxD,QAAI,CAAC,QAAQ;AACX;AAAA;AAEF,UAAM,qBAAqB;AAC3B,UAAM,QAAQ,KAAK,iBAAiB,UAAU;AAC9C,UAAM,SAAS;AACf,UAAM,SAAS;AAIf,eAAW,cAAc,MAAM,QAAQ;AACrC,iBAAW,mBAAmB;AAC9B,UAAI,WAAW,SAAS,WAAW,aAAa;AAC9C,cAAM,YAAY,WAAW,KAAK,WAAW,WAAW,KAAK,gBAAgB;AAC7E,cAAM,eAAe,aAAa,SAAS;AAC3C,YAAI,UAAU,mBAAmB;AAC/B,mBAAS,IAAI,GAAG,IAAI,UAAU,kBAAkB,QAAQ,EAAE,GAAG;AAC3D,yBAAa,eAAe,KAAK,UAAU,kBAAkB,GAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOlE,uBAA6B;AACnC,SAAK,oBAAoB,IAAI;AAC7B,SAAK,sBAAsB,IAAI;AAC/B,SAAK,mBAAmB;AACxB,SAAK,iCAAiC;AACtC,SAAK,8BAA8B;AACnC,SAAK,oBAAoB;AACzB,SAAK,6BAA6B;AAClC,SAAK,qBAAqB;AAC1B,SAAK,aAAa;AAClB,SAAK,uBAAuB;AAC5B,SAAK,gBAAgB;AACrB,SAAK,oBAAoB;AAAA;AAAA,EAGnB,kBAAkB,cAA6C,QAClB;AACnD,UAAM,SAAS,OAAO;AACtB,QAAI;AACJ,QAAI,SAAwC;AAG5C,QAAI,kBAA6E,OAAO,OAAO,SAAS;AACxG,QAAI,mBAAmB,gBAAgB,SAAS,WAAW,YAAY;AACrE,YAAM,YAAY,gBAAgB,KAAK;AACvC,mBAAc,aAAa,UAAU;AACrC,eAAS,KAAK,cAAc;AAAA;AAG9B,QAAI,CAAC,YAAY;AACf,wBAAkB,OAAO,KAAK,OAAK,EAAE,SAAS,WAAW;AACzD,UAAI,CAAC,iBAAiB;AACpB,eAAO;AAAA;AAET,eAAS,KAAK,cAAc;AAC5B,YAAM,eAAe,aAAa,aAAa;AAC/C,UAAI,CAAC,cAAc;AACjB,eAAO,QAAQ,QAAQ,WAAW,MAAM;AACxC,eAAO;AAAA;AAET,mBAAc;AAAA,QACZ,WAAW,gBAAgB,YAAY;AAAA,QACvC,SAAS;AAAA,QACT,OAAO;AAAA,QACP,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,OAAO;AAAA;AAET,iBAAW,gBAAgB,aAAa,UAAU;AAChD,cAAM,YAAY,aAAa,KAAK;AACpC,YAAI,eAAe,WAAW;AAM5B,qBAAW,YAAY,aAAa,YAAY;AAAA;AAElD,YAAI,aAAa,WAAW;AAS1B,qBAAW,UAAU,aAAa,YAAY;AAAA;AAEhD,cAAM,kBAAkB,UAAU,iBAAiB;AACnD,cAAM,UAAU,gBAAgB,cAAc;AAC9C,cAAM,QAAQ,UAAU,YAAY,MAAM,QAAQ,QAAQ,KAAK;AAC/D,mBAAW,MAAM,KAAK,GAAI,gBAAgB,YAAY;AACtD,mBAAW,MAAM,KAAK,GAAG;AACzB,YAAI,WAAW,SAAS;AACtB,qBAAW,QAAQ,KAAK,GAAG;AAAA;AAE7B,YAAI,WAAW,YAAY;AACzB,qBAAW,WAAW,KAAK,GAAI,UAAU,iBAAiB;AAAA;AAE5D,YAAI,WAAW,WAAW,WAAW,cAAc,WAAW,QAAQ,WAAW,WAAW,WAAW,QAAQ;AAC7G,iBAAO,QAAQ,QAAQ,WAAW,MAAM;AACxC,iBAAO;AAAA;AAAA;AAGX,UAAI,CAAC,WAAW,WAAW,WAAW,YAAY;AAChD,cAAM,aAAuB,WAAW;AACxC,mBAAW,UAAU,WAAW,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,WAAW;AAAA;AAAA;AAIvE,QAAI;AACF,YAAM,UAAW;AACjB,YAAM,iBAAiB,IAAI,IAAI,oBAAoB,oBAAoB,SAAS;AAChF,WAAK,oBAAoB,KAAK;AAC9B,aAAO;AAAA,aACA,GAAP;AACA,aAAO,QAAQ,QAAQ,WAAW,MAAM;AAAA;AAE1C,WAAO;AAAA;AAAA,EAGD,oBAAoB,cAA6C,QAC5C;AAC3B,UAAM,iBAAiB,KAAK,kBAAkB,cAAc;AAC5D,QAAI,SAAS,OAAO;AACpB,UAAM,YACF,iBAAiB,2BAA2B,oCAAoC,gBAAgB,UAAU;AAC9G,QAAI,aAAa,UAAU,QAAQ;AACjC,eAAS,SAAS,eAAe,aAAa,QAAQ,WAAW,IAAI,aAAa,MAAM;AAAA;AAE1F,QAAI,aAAa,OAAO,KAAK,OAAK,EAAE,SAAS,WAAW,WAAW;AACjE,YAAM,gBAAgB,2BAA2B,sBAAsB,QAAQ;AAAA,QAC7E,eAAe,KAAK,QAAQ,YAAY,UAAU;AAAA,QAClD,sBAAsB,KAAK,QAAQ,YAAY,UAAU;AAAA,QACzD,qBAAqB,OAAO,SAAS,SAAS,WAAW,cAAc,kCAAkC;AAAA;AAE3G,UAAI,iBAAiB,cAAc,QAAQ;AACzC,iBACI,SAAS,eAAe,aAAa,eAAe,QAAQ,IAAI,aAAa,MAAM;AAAA;AAAA;AAG3F,WAAO;AAAA;AAAA,EAGD,oBACJ,cAA6C,QAI7C,QAAiC,cAAuB,UAAmB,cAC3E,KAAiD;AACnD,UAAM,QAAQ,IAAI;AAClB,UAAM,OAAO,OAAO,UAAU,WAAW,UAAU,SAAS,EAAC,KAAK,OAAO;AACzE,UAAM,OAAO,UAAU;AACvB,UAAM,SAAS;AACf,QAAI,cAAc;AAChB,YAAM,OAAO,UAAU;AACvB,YAAM,MAAM,OAAO,SAAS,aAAa;AACzC,YAAM,eAAe;AAAA,eACZ,UAAU;AACnB,YAAM,OAAO,UAAU;AACvB,YAAM,MAAM,OAAO,SAAS,aAAa;AACzC,YAAM,OAAO,MAAM,MAAM,WAAW,UAAU,SAAS,EAAC,KAAK,MAAM,SAAQ,WAAW,UAAU;AAAA,eACvF,OAAO,OAAO,WAAW,yBAAyB;AAC3D,YAAM,OAAO,UAAU;AAAA;AAEzB,SAAK,eAAe,KAAK;AAEzB,UAAM,SAAS,KAAK,oBAAoB,cAAc;AACtD,SAAK,aAAa;AAClB,UAAM,aAAa,KAAK;AAGxB,QAAI,UAAU;AACZ,YAAM,kBAAkB,OAAO,KAAK,WAAS,MAAM,SAAS,WAAW;AACvE,UAAI,iBAAiB;AACnB,cAAM,SAAS,KAAK,cAAc;AAClC,YAAI,QAAQ;AACV,gBAAM,OAAO,WAAW,UAAU,UAAU,EAAC,KAAK,OAAO,QAAQ,KAAK,MAAM;AAAA;AAAA;AAAA;AAKlF,eAAW,SAAS,QAAQ;AAC1B,UAAI,IAAI,SAAS,eAAe,WAAW,QAAQ,MAAM,MAAM,CAAC,MAAM,UAAU,OAAO,MAAM;AAC7F,aAAO,IAAI,OAAO,QAAQ,KAAK;AAC7B,cAAM,QAAQ,OAAO;AACrB,YAAI,MAAM,aAAa,MAAM,IAAI;AAC/B;AAAA;AAIF,YAAI,KAAK,uBAAuB,UAAU,KAAK,8BAA8B,IAAI;AAC/E,eAAK,4BAA4B,MAAM,KAAK,QAAQ;AAAA;AAGtD,cAAM,oBAAoB,MAAM,SAAS,WAAW,QAAQ,MAAM,YAAY,MAAM,WAAW;AAC/F,YAAI,gBAAgB,qBAAqB,MAAM,UAAU;AAIvD,eAAK,8BAA8B,MAAM,WAAW;AAAA;AAGtD,YAAI,OAA+B,WAAW,WAAW,SAAS;AAClE,eAAO,QAAQ,KAAK,YAAY,UAAa,KAAK,WAAW,MAAM,WAAW;AAC5E,qBAAW;AACX,iBAAO,WAAW,WAAW,SAAS;AAAA;AAExC,YAAI,CAAC,KAAK,aAAa,QAAQ;AAC7B;AAAA;AAEF,YAAI,CAAC,IAAI,aAAa,aAAa,aAAa,MAAM,UAAU,MAAM,UAAU;AAC9E,cAAI,WAAW,QAAQ;AACrB,kBAAM,SAAS,WAAW,WAAW,SAAS;AAC9C,gBAAI,QAAQ;AACV,qBAAO,YAAY,MAAM;AACzB,kBAAI,OAAO,WAAW,GAAG;AACvB,qBAAK,oBAAoB,QAAQ;AAAA;AAAA;AAAA;AAIvC,gBAAM,WAAW,MAAM;AACvB,cAAI,CAAC,WAAW,QAAQ;AACtB,kBAAM,MAAM,KAAK;AAAA;AAEnB,qBAAW,KAAK;AAAA;AAElB,YAAI,KAAK,cAAc,QAAQ;AAC7B,eAAK,yBAAyB,KAAK;AAAA;AAGrC,cAAM,OAAO,KAAK;AAClB,aAAK,8BAA8B,KAAK;AAAA;AAAA;AAG5C,SAAK,mBAAmB,QAAQ;AAAA;AAAA,EAG1B,oBAAoB,OAA+B,OAAqC;AAC9F,UAAM,UAAU;AAChB,QAAI,MAAM,WAAW,CAAC,SAAS;AAC7B,cAAQ,MACJ,sCAAsC,MAAM,cACvC,OAAM,YAAY,KAAK,qBAAqB,QAAQ,SAAU,EAAC,MAAM,UAAU,QAAQ;AAAA;AAElG,UAAM,WAAW;AAAA;AAAA,EAGX,mBAAmB,QAAiC,QAGjD;AACT,UAAM,cAAc,OAAO;AAC3B,UAAM,SAAS,oBAAI;AAEnB,mBAAe,MAAgD;AAC7D,UAAI,CAAC,OAAO,IAAI,OAAO;AACrB,eAAO,IAAI,MAAM;AAAA;AAEnB,aAAO,OAAO,IAAI;AAAA;AAGpB,eAAW,SAAS,QAAQ;AAC1B,UAAI,IAAI,SAAS,eAAe,WAAW,aAAa,MAAM,MAAM,SAAS,MAAM,YAAY;AAC7F,eAAO,OAAO,WAAW;AAAA;AAG3B,aAAO,IAAI,YAAY,QAAQ,EAAE,GAAG;AAClC,cAAM,aAAa,YAAY;AAC/B,YAAI,WAAW,aAAa,MAAM,IAAI;AACpC;AAAA;AAGF,YAAI,WAAW,YAAY,kBAAkB,SAAS,UAAU;AAC9D,gBAAM,UAAU,SAAS,KAAK;AAC9B;AAAA;AAGF,YAAI,WAAW,YAAY,kBAAkB,SAAS,aAAa;AACjE,gBAAM,UAAU,SAAS,KAAK;AAC9B;AAAA;AAGF,YAAI,WAAW,SAAS,WAAW,WAAW;AAC5C,gBAAM,UAAU,WAAW,KAAK;AAChC;AAAA;AAAA;AAAA;AAKN,eAAW,CAAC,MAAM,WAAW,QAAQ;AACnC,YAAM,QAAQ,KAAK,iBAAiB;AACpC,YAAM,SAAS;AACf,YAAM,cACF,SAAS,eAAe,aAAa,MAAM,aAAa,QAAQ,IAAI,aAAa,MAAM;AAAA;AAAA;AAAA,EAIvF,aAAa,OAAwC;AAC3D,UAAM,aAAa,KAAK;AAExB,QAAI,CAAC,WAAW,QAAQ;AACtB,UAAI,KAAK,oCAAoC,KAAK,iCAAiC,QAAQ;AACzF,cAAM,YAAY,KAAK,iCAAiC,OAAO,CAAC,MAAM,WAAU;AAC9E,iBAAO,OAAM,aAAa,SAAY,OAAO,OAAO,OAAM;AAAA,WACzD;AACH,YAAI,YAAY,kBAAkB,WAAW,cAAc;AACzD,qBAAW,KAAK,KAAK,kCAAkC;AACrD,kBAAM,gBAAe,aAAa,SAAS;AAC3C,0BAAa,UAAU,EAAE,SAAS,WAAW,SAAS,kBAAkB,YAAY,eAC9B,kBAAkB,YAAY;AAAA;AAAA;AAAA;AAI1F,WAAK,mCAAmC;AAAA;AAG1C,QAAI,KAAK,oBAAoB;AAC3B,UAAI,KAAK,mBAAmB,YAAY,UAAa,MAAM,YAAY,KAAK,mBAAmB,SAAS;AACtG,aAAK,qBAAqB;AAAA;AAAA;AAI9B,UAAM,YAAY,MAAM,KAAK,WAAW,MAAM,KAAK,gBAAgB;AACnE,UAAM,eAAe,aAAa,SAAS;AAC3C,QAAI,UAAU,eAAe;AAC3B,mBAAa,aAAa,UAAU,cAAc,IAAI,CAAC,2BAAuD;AAI5G,YAAI,MAAM,SAAS,WAAW,UAAU;AAEtC,gBAAM,QAAQ,KAAI;AAGlB,YAAE,MAAM;AACR,YAAE,MAAM;AACR,iBAAO;AAAA;AAET,eAAO;AAAA;AAAA;AAGX,QAAI,cAAc,kBAAkB,aAAa;AACjD,UAAM,OAAO,WAAW,WAAW,SAAS;AAC5C,QAAI,CAAC,eAAe,MAAM;AACxB,oBAAc,aAAa,SAAS,MAAM;AAAA;AAE5C,iBAAa,UAAU,eAAgB,KAAK,aAAa,KAAK,UAAU,WAAY;AACpF,SAAK,kBAAkB,aAAa;AAEpC,QAAI,KAAK,cAAc,QAAQ;AAC7B,WAAK,iBAAiB,UAAU;AAAA;AAGlC,YAAQ,MAAM;AAAA,WACP,WAAW;AAAA,WACX,WAAW,iBAAiB;AAC/B,qBAAa,aAAa,WAAW,WAAW,SAAS,MAAM;AAC/D,qBAAa,MAAM,UAAU;AAC7B;AAAA;AAAA,WAGG,WAAW,4BAA4B;AAC1C,aAAK,+BAA+B,UAAU,YAAY;AAC1D;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW,mBAAmB;AACjC,aAAK,oBAAoB,eAAe;AACxC,YAAI,MAAM,KAAK,cAAc;AAC3B,uBAAa,aAAa,KAAK,+BAA+B,MAAM,KAAK,aAAa;AAAA;AAExF,aAAK,6BAA6B;AAClC,YAAI,KAAK,oBAAoB;AAC3B,eAAK,iCAAiC,KAAK;AAAA;AAE7C;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW;AAAA,WACX,WAAW;AAAA,WACX,WAAW,4BAA4B;AAC1C,aAAK,oBAAoB,gBAAgB,IAAI,0BAA0B,OAAO;AAC9E;AAAA;AAAA,WAGG,WAAW,kBAAkB;AAGhC,YAAI,iBAAuE;AAC3E,cAAM,UAAU,UAAU;AAC1B,YAAI,CAAC,KAAK,iBAAiB,YAAY,KAAK,8BACxC,KAAK,2BAA2B,YAAY,UAC5C,KAAK,2BAA2B,UAAU,MAAM,WAAW;AAC7D,2BAAiB,aAAa,SAAS,KAAK,4BAA4B;AAAA;AAE1E,aAAK,iBAAiB,WAAW;AACjC;AAAA;AAAA,WAGG,WAAW,QAAQ;AACtB,aAAK,oBAAoB,UAAU;AACnC,cAAM,UAAU,MAAM,KAAK,aAAa;AACxC,qBAAa,aAAa,KAAK,iBAAiB;AAEhD,YAAI,MAAM,KAAK,YAAY;AACzB,cAAI,MAAM,KAAK,WAAW,gBAAgB;AACxC,qBAAS,IAAI,GAAG,IAAI,MAAM,KAAK,WAAW,eAAe,QAAQ,EAAE,GAAG;AACpE,2BAAa,eAAe,KAAK,MAAM,KAAK,WAAW,eAAe,GAAG;AAAA;AAAA,iBAEtE;AACL,yBAAa,eAAe,KAAK,MAAM,KAAK,WAAW;AAAA;AAAA;AAG3D,aAAK,iBAAiB,WAAW;AACjC,YAAI,KAAK,oBAAoB;AAC3B,eAAK,iCAAiC,KAAK;AAAA;AAE7C;AAAA;AAAA,WAGG,WAAW,MAAM;AACpB,YAAI,MAAM,aAAa,UAAa,MAAM,WAAW,kBAAkB,WAAW,UAAU;AAC1F,uBAAa,UAAU,kBAAkB,YAAY;AAAA;AAEvD;AAAA;AAAA,WAGG,WAAW,eAAe;AAC7B,YAAI,MAAM,aAAa,UAAa,MAAM,WAAW,kBAAkB,WAAW,kBAAkB;AAClG,uBAAa,UAAU,kBAAkB,YAAY;AAAA;AAEvD;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW,oBAAoB;AAClC,YAAI,MAAM,aAAa,UAAa,MAAM,WAAW,kBAAkB,WAAW,kBAAkB;AAClG,uBAAa,UAAU,kBAAkB,YAAY;AAAA;AAEvD;AAAA;AAAA,WAGG,WAAW,cAAc;AAE5B,YAAI,OAAO,UAAU,kBAAkB,UAAU;AAC/C,oBAAU,SAAS,UAAU;AAAA;AAE/B,YAAI,OAAO,UAAU,kBAAkB,UAAU;AAC/C,oBAAU,gBAAgB,UAAU;AAAA;AAAA;AAAA,WAInC,WAAW;AAAA,WACX,WAAW;AAAA,WAEX,WAAW,aAAa;AAC3B,YAAI,OAAO,UAAU,kBAAkB,UAAU;AAC/C,YAAE,UAAU;AAAA;AAEd,YAAI,OAAO,UAAU,oBAAoB,UAAU;AACjD,YAAE,UAAU;AAAA;AAAA;AAAA,WAIX,WAAW,eAAe;AAG7B,YAAI,CAAC,KAAK,oBAAoB;AAC5B,eAAK,qBAAqB;AAAA;AAE5B;AAAA;AAAA,WAGG,WAAW,gBAAgB;AAE9B,YAAI,KAAK,aAAa,UAAU,gBAAgB,KAAK,cAAc,UAAU,cAAc;AACzF,eAAK,uBAAuB,UAAU;AACtC;AAAA;AAIF,cAAM,UAAU,kBAAkB,aAAa;AAC/C,cAAM,YAAY,UAAU,KAAK,WAAW,IAAI,WAAW;AAC3D,YAAI,CAAC,aAAa,UAAU,QAAQ;AAClC,iBAAO;AAAA;AAET,aAAK,uBAAuB,UAAU;AACtC;AAAA;AAAA,WAGG,WAAW,OAAO;AACrB,aAAK,oBAAoB,WAAW;AAGpC,YAAI,YAAY,WAAW;AACzB,uBAAa,eAAe,KAAK,UAAU;AAAA;AAG7C,YAAI,CAAC,UAAU,YAAY;AACzB;AAAA;AAEF,cAAM,UAAU,UAAU;AAC1B,aAAK,kBAAkB,WAAW;AAClC;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW,iBAAiB;AAC/B,cAAM,mBAAmB,KAAK,kBAAkB,WAAW;AAC3D,YAAI,CAAC,oBAAoB,iBAAiB,KAAK,mBAAmB,KAAK,sBAAsB;AAC3F;AAAA;AAEF,cAAM,aAAa,KAAK,kBAAkB,iBAAiB,KAAK;AAChE,YAAI,YAAY;AACd,uBAAa,SAAS,YAAY,UAAW;AAAA;AAE/C;AAAA;AAAA,WAGG,WAAW,aAAa;AAC3B,qBAAa,eAAe,KAAK,UAAU;AAC3C;AAAA;AAAA,WAGG,WAAW,YAAY;AAC1B,qBAAa,eAAe,KAAK,UAAU;AAC3C,qBAAa,MAAM,UAAU;AAC7B;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW,aAAa;AAC3B,YAAI,kBAAkB,KAAK,kBAAkB,WAAW;AACxD,YAAI,CAAC,iBAAiB;AACpB,gBAAM,0BAA0B,KAAK,kBAAkB,WAAW;AAClE,4BACI,2BAA2B,KAAK,4BAA4B,wBAAwB,KAAK;AAAA;AAE/F,YAAI,CAAC,iBAAiB;AACpB;AAAA;AAEF,cAAM,iBAAiB,aAAa,SAAS;AAC7C,qBAAa,eAAe,KAAK,eAAe,eAAe;AAC/D,qBAAa,MAAM,eAAe;AAClC;AAAA;AAAA,WAGG,WAAW,kBAAkB;AAChC,cAAM,kBAAkB,KAAK,kBAAkB,WAAW;AAC1D,YAAI,CAAC,iBAAiB;AACpB;AAAA;AAEF,aAAK,4BAA4B,MAAM,KAAK,mBAAmB;AAC/D,cAAM,iBAAiB,aAAa,SAAS;AAC7C,qBAAa,eAAe,KAAK,eAAe,eAAe;AAC/D,qBAAa,MAAM,eAAe;AAClC;AAAA;AAAA,WAGG,WAAW,qBAAqB;AACnC,YAAI,aAAa,YAAY,MAAM,KAAK,UAAU;AAChD,iBAAO;AAAA;AAET;AAAA;AAAA,WAGG,WAAW,kBAAkB;AAChC,qBAAa,eAAe,KAAK,UAAU;AAC3C;AAAA;AAAA,WAGG,WAAW;AAAA,WACX,WAAW,UAAU;AACxB,cAAM,UAAU,kBAAkB,aAAa;AAC/C,YAAI,CAAC,WAAW,CAAC,KAAK,WAAW,IAAI,UAAU;AAC7C,iBAAO;AAAA;AAET;AAAA;AAAA,WAGG,WAAW,YAAY;AAC1B,YAAI,KAAK,sBAAsB;AAC7B;AAAA;AAEF,cAAM,UAAU,kBAAkB,aAAa;AAC/C,cAAM,uBAAuB,QAAQ,UAAU,2BAA2B,UAAU;AACpF,cAAM,YAAY,UAAU,KAAK,WAAW,IAAI,WAAW;AAC3D,YAAI,WAAW;AACb,oBAAU,OAAO,MAAM,WAAW;AAAA,eAC7B;AAGL,cAAI,CAAC,KAAK,eAAe;AACvB,gBAAI,UAAU,WAAW,UAAU,YAAY,KAAK,mBAAmB;AACrE,qBAAO;AAAA;AAAA,qBAEA,sBAAsB;AAC/B,mBAAO;AAAA,qBACE,CAAC,KAAK,aAAa,OAAO,YAAY;AAC/C,mBAAO;AAAA;AAAA;AAGX,YAAI,wBAAwB,SAAS;AACnC,gBAAM,QAAQ,KAAK,WAAW,IAAI;AAClC,cAAI,OAAO;AACT,iBAAK,YAAY;AAAA;AAAA;AAGrB;AAAA;AAAA,WAGG,WAAW,kBAAkB;AAChC,YAAI,MAAM,aAAa,UACnB,MAAM,WAAW,UAAU,0BAA0B,kBAAkB,WAAW,mBAAmB;AACvG,uBAAa,UAAU,kBAAkB,YAAY;AAAA;AAEvD;AAAA;AAAA;AAGJ,WAAO;AAAA;AAAA,EAGD,oBAAoB,OAAqC;AAC/D,QAAI,MAAM,SAAS,WAAW,yBAAyB;AACrD,YAAM,YAAY,MAAM,MAAM,MAAM;AACpC,UAAI,OAAO,cAAc,UAAU;AACjC,aAAK,oBAAoB,IAAI,WAAW;AAAA;AAE1C;AAAA;AAGF,QAAI,MAAM,YAAY,IAAI,aAAa,kCAAkC,MAAM,KAAK,SAAS;AAC3F,YAAM,OAAO,MAAM,KAAK;AACxB,UAAI,MAAM,SAAS,kBAAkB,sBAAsB,yBAAyB;AAClF,YAAI,CAAC,KAAK,kBAAkB;AAC1B;AAAA;AAEF,aAAK,uBAAuB;AAC5B,aAAK,kBAAkB,KAAK;AAC5B,cAAM,SAAgB,KAAK,aAAa;AACxC,eAAO,QAAQ,aAAW;AACxB,gBAAM,SAAS,QAAQ,aAAa,KAAK,WAAW,IAAI,QAAQ;AAChE,cAAI,QAAQ,aAAa,CAAC,QAAQ;AAChC;AAAA;AAEF,cAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ;AACxC,cAAI,CAAC,OAAO;AACV,oBAAQ,IAAI,UAAU;AACtB,iBAAK,WAAW,IAAI,MAAM,SAAS;AACnC,gBAAI,QAAQ;AACV,qBAAO,SAAS;AAAA,mBACX;AACL,mBAAK,YAAY;AAAA;AAAA;AAKrB,gBAAM,OAAO,KAAK,2BAA2B;AAAA;AAE/C;AAAA;AAEF,UAAI,MAAM,SAAS,kBAAkB,sBAAsB,2BAA2B,KAAK,sBAAsB;AAC/G,YAAI,QAAQ,KAAK,WAAW,IAAI,KAAK;AACrC,YAAI,CAAC,OAAO;AACV,gBAAM,SAAS,KAAK,aAAa,KAAK,WAAW,IAAI,KAAK;AAC1D,cAAI,CAAC,QAAQ;AACX;AAAA;AAEF,kBAAQ,IAAI,UAAU;AACtB,eAAK,WAAW,IAAI,MAAM,SAAS;AACnC,iBAAO,SAAS;AAAA;AAElB,cAAM,OAAO,MAAM,WAAW;AAC9B;AAAA;AAEF,UAAI,MAAM,SAAS,kBAAkB,sBAAsB,yBAAyB,KAAK,sBAAsB;AAC7G,cAAM,QAAQ,KAAK,WAAW,IAAI,KAAK;AACvC,YAAI,OAAO;AACT,gBAAM,aAAa,KAAK,oBAAoB,KAAK;AAAA;AAEnD;AAAA;AAEF,UAAI,MAAM,SAAS,kBAAkB,sBAAsB,yBAAyB,KAAK,sBAAsB;AAC7G,cAAM,QAAQ,KAAK,WAAW,IAAI,KAAK;AACvC,YAAI,OAAO;AACT,gBAAM,cAAc,MAAM;AAAA;AAE5B;AAAA;AAAA;AAAA;AAAA,EAKE,iBAAiB,MAAwB;AAC/C,QAAI,QAAQ,KAAK,YAAY,IAAI;AACjC,QAAI,OAAO;AACT,aAAO;AAAA;AAGT,YAAQ,IAAI;AACZ,UAAM,OAAO;AACb,SAAK,eAAe,KAAK;AACzB,SAAK,YAAY,IAAI,MAAM;AAC3B,WAAO;AAAA;AAAA,EAGD,kBAAkB,MAA2C;AACnE,aAAS,IAAI,KAAK,WAAW,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AACpD,YAAM,QAAQ,KAAK,WAAW;AAC9B,UAAI,MAAM,SAAS,MAAM;AACvB,eAAO;AAAA;AAAA;AAGX,WAAO;AAAA;AAAA,EAGD,aAAa,OAA+B,SAAuB;AACzE,UAAM,SAAS,QAAQ,aAAa,KAAK,WAAW,IAAI,QAAQ;AAChE,QAAI,QAAQ,aAAa,CAAC,QAAQ;AAChC,aAAO;AAAA;AAET,UAAM,YAAY,IAAI,UAAU;AAChC,SAAK,WAAW,IAAI,UAAU,SAAS;AACvC,cAAU,OAAO,MAAM,WAAW;AAClC,QAAI,QAAQ;AACV,aAAO,SAAS;AAAA;AAElB,WAAO;AAAA;AAAA,EAGD,QAAc;AACpB,SAAK,yBAAyB;AAC9B,SAAK,iBAAiB;AACtB,SAAK,cAAc,oBAAI;AACvB,SAAK,gCAAgC;AACrC,SAAK,2BAA2B;AAChC,SAAK,YAAY;AACjB,SAAK,kBAAkB;AACvB,SAAK,sBAAsB;AAC3B,SAAK,mBAAmB,oBAAI;AAC5B,SAAK,aAAa,oBAAI;AACtB,SAAK,sBAAsB,oBAAI;AAE/B,SAAK,4BAA4B;AACjC,SAAK,4BAA4B;AAEjC,SAAK,4BAA4B;AACjC,SAAK,6BAA6B;AAAA;AAAA,EAGpC,iBAA0B;AACxB,WAAO,KAAK;AAAA;AAAA,EAGd,eAAmD;AACjD,WAAO,KAAK;AAAA;AAAA,EAGd,oBAA4B;AAC1B,WAAO,KAAK;AAAA;AAAA,EAGd,oBAA4B;AAC1B,WAAO,KAAK;AAAA;AAAA,EAGd,wBAAkD;AAChD,WAAO,KAAK;AAAA;AAAA,EAGd,SAAkB;AAChB,WAAO,KAAK;AAAA;AAAA,EAGd,UAAmB;AACjB,WAAO,KAAK,wBAAwB,KAAK,KAAK,wBAAwB;AAAA;AAAA,EAGxE,mBAA6C;AAC3C,WAAO,KAAK;AAAA;AAAA,EAGd,aAA0B;AACxB,WAAO,MAAM,KAAK,KAAK,WAAW,UAAU,OAAO,WAAS,CAAC,MAAM;AAAA;AAAA,EAGrE,UAA2C;AACzC,WAAO,KAAK,aAAa,KAAK,UAAU,OAAO,SAAS,aAAa;AAAA;AAAA,EAGvE,cAAc,SAAgD;AAC5D,WAAO,UAAU,KAAK,WAAW,IAAI,YAAY,OAAO;AAAA;AAAA,EAG1D,kBAAoC;AAClC,QAAI,KAAK,kBAAkB;AACzB,aAAO;AAAA;AAET,UAAM,WAAW,oBAAI;AACrB,UAAM,eAAiC;AACvC,UAAM,wBAA0C;AAChD,UAAM,gBAAgB,oBAAI,IAAY;AAAA,MACpC,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA,MACX,WAAW;AAAA;AAEb,UAAM,SAAS,KAAK;AACpB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,EAAE,GAAG;AACtC,YAAM,IAAI,OAAO;AACjB,UAAI,CAAC,cAAc,IAAI,EAAE,OAAO;AAC9B;AAAA;AAEF,YAAM,KAAK,kBAAkB,cAAc,GAAG;AAC9C,YAAM,YAAY,EAAE,MAAM,MAAM;AAChC,UAAI,EAAE,SAAS,WAAW,uBAAuB,aAAa,KAAK,oBAAoB,IAAI,YAAY;AACrG,cAAM,QAAQ,KAAK,oBAAoB,IAAI;AAC3C,YAAI,OAAO;AACT,qBAAW,OAAO;AAAA;AAAA;AAGtB,iBAAW,GAAG;AAAA;AAEhB,wBAAoB,GAA2B,IAAkB;AAC/D,UAAI,UAAU,SAAS,IAAI;AAC3B,UAAI,SAAS;AACX,gBAAQ,SAAS;AAAA,aACZ;AACL,kBAAU,IAAI,eAAe;AAC7B,iBAAS,IAAI,IAAI;AACjB,YAAI,QAAQ,WAAW;AACrB,uBAAa,KAAK;AAAA,eACb;AACL,gCAAsB,KAAK;AAAA;AAAA;AAAA;AAIjC,WAAO,sBAAsB,OAAO;AAAA;AAAA;AAMjC,WAAK,aAAL,kBAAK,gBAAL;AACL,wBAAO;AACP,2BAAU;AACV,iCAAgB;AAEhB,2BAAU;AAEV,6BAAY;AACZ,0CAAyB;AACzB,8BAAa;AACb,0CAAyB;AACzB,wCAAuB;AACvB,qCAAoB;AACpB,6BAAY;AACZ,gCAAe;AACf,2BAAU;AACV,8CAA6B;AAC7B,qCAAoB;AACpB,oCAAmB;AACnB,oCAAmB;AACnB,0BAAS;AACT,+BAAc;AACd,+BAAc;AACd,mCAAkB;AAClB,8BAAa;AACb,yBAAQ;AACR,8BAAa;AACb,4BAAW;AACX,6BAAY;AACZ,8BAAa;AACb,+BAAc;AACd,mCAAkB;AAClB,wCAAuB;AACvB,mCAAkB;AAElB,qDAAoC;AACpC,mDAAkC;AAClC,wDAAuC;AACvC,8CAA6B;AAE7B,6BAAY;AACZ,yCAAwB;AAExB,gCAAe;AACf,+BAAc;AACd,6BAAY;AAEZ,uCAAsB;AACtB,2BAAU;AACV,iCAAgB;AAChB,+BAAc;AACd,gCAAe;AACf,kCAAiB;AACjB,+BAAc;AACd,iCAAgB;AAChB,kCAAiB;AACjB,+BAAc;AACd,kDAAiC;AACjC,sCAAqB;AACrB,oCAAmB;AACnB,sCAAqB;AACrB,0CAAyB;AAEzB,uCAAsB;AACtB,8BAAa;AACb,4BAAW;AACX,kCAAiB;AACjB,kCAAiB;AACjB,2BAAU;AACV,oCAAmB;AACnB,qCAAoB;AACpB,mCAAkB;AAElB,6BAAY;AACZ,+BAAc;AACd,8BAAa;AAEb,2CAA0B;AAC1B,uCAAsB;AACtB,2CAA0B;AAC1B,wCAAuB;AACvB,kCAAiB;AACjB,wCAAuB;AAEvB,iCAAgB;AAChB,gCAAe;AACf,2BAAU;AACV,2BAAU;AACV,2BAAU;AACV,2BAAU;AACV,4BAAW;AAIX,4BAAW;AACX,gCAAe;AACf,gCAAe;AACf,0CAAyB;AACzB,iDAAgC;AAChC,iDAAgC;AAChC,6BAAY;AAEZ,kCAAiB;AAEjB,yCAAwB;AACxB,wCAAuB;AACvB,sCAAqB;AAErB,uCAAsB;AACtB,sCAAqB;AACrB,oCAAmB;AAEnB,mCAAkB;AAClB,iDAAgC;AAChC,qDAAoC;AACpC,oCAAmB;AAEnB,oCAAmB;AAEnB,kCAAiB;AACjB,wCAAuB;AACvB,6CAA4B;AAE5B,+BAAc;AACd,+BAAc;AACd,oCAAmB;AACnB,sCAAqB;AAErB,gCAAe;AACf,6CAA4B;AAC5B,mCAAkB;AAClB,2CAA0B;AAC1B,+BAAc;AACd,mCAAkB;AAClB,yCAAwB;AACxB,0CAAyB;AACzB,iCAAgB;AAChB,oCAAmB;AAEnB,mCAAkB;AAClB,wCAAuB;AACvB,mCAAkB;AAClB,wCAAuB;AACvB,kCAAiB;AACjB,uCAAsB;AACtB,gCAAe;AACf,qCAAoB;AACpB,kCAAiB;AACjB,uCAAsB;AAItB,8BAAa;AACb,2BAAU;AAEV,6BAAY;AA3JF;AAAA;AA8JL,EAAU,uBAAV;AACE,EAAM,8BAAW;AAAA,IACtB,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,aAAa;AAAA,IACb,SAAS;AAAA;AAKJ,MAAK;AAAL,IAAK,iBAAL;AACL,+BAAW;AACX,kCAAc;AACd,mCAAe;AACf,2CAAuB;AACvB,kCAAc;AACd,2CAAuB;AACvB,8BAAU;AAAA,KAPA;AAUL,EAAM,sCAAmB;AACzB,EAAM,4CAAyB;AAC/B,EAAM,4CAAyB;AAC/B,EAAM,2CAAwB;AAE9B,EAAM,2CAAwB;AAAA,IACnC,yBAAyB;AAAA,IACzB,sBAAsB;AAAA,IACtB,2BAA2B;AAAA,IAC3B,yBAAyB;AAAA,IACzB,uBAAuB;AAAA,IACvB,uBAAuB;AAAA;AAGlB,EAAM,gCAAa;AAAA,IACxB,UAAU;AAAA,IACV,SAAS;AAAA,IACT,kBAAkB;AAAA,IAClB,cAAc;AAAA,IACd,mBAAmB;AAAA;AAAA,GAvCN;AA2CV,mBAAY;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACQ;AAAA,EACR;AAAA,EACA,cAAc;AACZ,SAAK,OAAO;AACZ,SAAK,OAAO,UAAU;AAEtB,SAAK,eAAe;AACpB,SAAK,MAAM,SAAS,aAAa;AAEjC,SAAK,SAAS;AACd,SAAK,cAAc;AACnB,SAAK,QAAQ;AACb,SAAK,qBAAqB;AAC1B,SAAK,SAAS;AAAA;AAAA,EAGhB,aAAuC;AACrC,QAAI,KAAK,OAAO,QAAQ;AACtB,aAAO,KAAK;AAAA;AAGd,QAAI,KAAK,oBAAoB;AAC3B,aAAO,KAAK;AAAA;AAGd,UAAM,QAAkC;AAExC,+BAAmC;AACjC,YAAM,OAAO,MAAM,MAAM,SAAS;AAClC,UAAI,SAAS,QAAW;AACtB,cAAM,UAAU,KAAK;AACrB,YAAI,YAAY,QAAW;AACzB,iBAAO;AAAA;AAAA;AAGX,YAAM,IAAI,MAAM;AAAA;AAGlB,SAAK,qBAAqB;AAC1B,eAAW,SAAS,KAAK,aAAa;AACpC,YAAM,YAAY,MAAM;AACxB,UAAI,UAAuC,MAAM;AACjD,UAAI,YAAY,QAAW;AACzB,kBAAU;AAAA;AAEZ,aAAO,MAAM,UAAU,aAAa,mBAAmB;AACrD,cAAM;AAAA;AAER,UAAI,MAAM,UAAU,UAAU,mBAAmB;AAC/C,aAAK,qBAAqB;AAC1B;AAAA;AAEF,YAAM,YAAY,IAAI,IAAI,aAAa,MACnC,MAAM,kBAAkB,MAAM,MAAM,IAAI,aAAa,MAAM,UAAU,WAAW,MAAM;AAC1F,gBAAU,WAAW;AACrB,gBAAU,QAAQ,MAAM;AACxB,WAAK,mBAAmB,KAAK;AAC7B,YAAM,KAAK;AAAA;AAEb,WAAO,KAAK;AAAA;AAAA;AAMT,WAAK,YAAL,kBAAK,eAAL;AACL,6BAAa;AACb,yBAAS;AACT,4BAAY;AACZ,0BAAU;AACV,0BAAU;AACV,yBAAS;AACT,sBAAM;AACN,6BAAa;AACb,wBAAQ;AATE;AAAA;AAYL,uBAAgB;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAMA;AAAA,EACA;AAAA,EACA,YAAY,SAAc;AACxB,SAAK,UAAU,QAAQ;AACvB,SAAK,MAAM,QAAQ,UAAU,SAAS,aAAa;AACnD,SAAK,OAAO,QAAQ;AACpB,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,cAAc;AAGnB,SAAK,YAAY;AAAA;AAAA,EAGnB,OAAO,MAAc,SAAoB;AACvC,SAAK,MAAM,QAAQ,UAAU;AAC7B,SAAK,OAAO,QAAQ;AACpB,QAAI,QAAQ,cAAc;AACxB,WAAK,UAAU,KACX,EAAC,MAAY,WAAW,QAAQ,cAAc,iBAAiB,IAAI,KAAK,QAAQ,UAAU;AAAA,WACzF;AACL,WAAK,UAAU,KACX,EAAC,MAAY,WAAW,IAAI,iBAAiB,QAAQ,oBAAoB,KAAK,QAAQ,UAAU;AAAA;AAAA;AAAA,EAIxG,aAAa,iBAAyB,WAAyB;AAC7D,eAAW,WAAW,KAAK,WAAW;AACpC,UAAI,QAAQ,oBAAoB,iBAAiB;AAC/C,gBAAQ,kBAAkB;AAC1B,gBAAQ,YAAY;AAAA;AAAA;AAAA;AAAA,EAK1B,SAAS,OAAwB;AAC/B,SAAK,SAAS,KAAK;AACnB,UAAM,SAAS;AAAA;AAAA;AAIZ,4BAAqB;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAMA;AAAA,EACA;AAAA,EACA;AAAA,EACQ;AAAA,EACA;AAAA,EACA;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,OAA+B;AACzC,UAAM,YACF,MAAM,SAAS,mDAAkC,MAAM,SAAS;AACpE,SAAK,YAAY,YAAY,MAAM,YAAY;AAC/C,SAAK,UAAU;AACf,SAAK,oBAAoB;AACzB,SAAK,oBAAoB;AACzB,SAAK,WAAW;AAChB,SAAK,eAAe;AACpB,SAAK,kBAAkB;AACvB,SAAK,uBAAuB;AAC5B,SAAK,SAAS;AAAA;AAAA,EAGhB,SAAS,OAAqC;AAC5C,SAAK,SAAS,KAAK;AAEnB,SAAK,YAAY,KAAK,IAAI,KAAK,WAAW,MAAM;AAChD,UAAM,YAAY,MAAM,KAAK;AAC7B,QAAI,UAAU,aAAa;AACzB,WAAK,WAAW,UAAU;AAAA;AAE5B,QAAI,cAAc,WAAW;AAC3B,WAAK,WAAW,UAAU;AAAA;AAE5B,QAAI,MAAM,SAAS,uCAA2B;AAC5C,WAAK,UAAU,MAAM;AAAA;AAEvB,QAAI,UAAU,eAAe;AAC3B,WAAK,aAAa,UAAU,gBAAgB;AAAA;AAE9C,QAAI,CAAC,KAAK,gBACL,OAAM,SAAS,2DAAsC,MAAM,SAAS,oDAAkC;AACzG,WAAK,eAAe,MAAM;AAAA;AAE5B,UAAM,oBAAoB,UAAU,wBAAwB;AAC5D,QAAI,MAAM,SAAS,mDAAiC;AAElD,WAAK,uBAAuB;AAAA;AAE9B,QAAI,MAAM,SAAS,yDAAoC;AACrD,UAAI,UAAU,cAAc;AAE1B,aAAK,kBAAkB;AAAA;AAEzB,UAAI,UAAU,sBAAsB;AAClC,aAAK,oBAAoB;AAAA;AAE3B,UAAI,UAAU,sBAAsB;AAClC,aAAK,oBAAoB;AAAA;AAE3B,WAAK,oBAAoB;AAAA;AAE3B,QAAI,MAAM,SAAS,mDAAiC;AAClD,WAAK,qBAAqB;AAAA;AAE5B,QAAI,MAAM,SAAS,yCAA6B,mBAAmB;AACjE,WAAK,oBAAoB;AAIzB,WAAK,eAAe;AAAA;AAEtB,UAAM,oBAAoB,UAAU;AACpC,QAAI,MAAM,SAAS,yCAA6B,mBAAmB;AACjE,WAAK,oBAAoB;AAAA;AAE3B,QAAI,CAAC,KAAK,KAAK;AACb,WAAK,MAAM,UAAU;AAAA;AAEvB,QAAI,CAAC,KAAK,eAAe;AACvB,WAAK,gBAAgB,UAAU;AAAA;AAEjC,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,SAAS,UAAU;AAAA;AAE1B,QAAI,UAAU,sBAAsB;AAClC,WAAK,oBAAoB;AAAA;AAAA;AAAA,EAU7B,SAAkB;AAChB,WAAO,QAAQ,KAAK,yBACf,QAAQ,KAAK,oBAAoB,CAAC,KAAK,gBAAgB,CAAC,KAAK;AAAA;AAAA,EAMpE,eAAwB;AACtB,WAAO,KAAK;AAAA;AAAA,EAOd,uBAGE;AACA,QAAI,KAAK,YAAY,CAAC,KAAK,QAAQ;AAGjC,aAAO,EAAC,eAAe,KAAK,WAAW,gBAAgB,KAAK;AAAA;AAE9D,UAAM,cAAc,KAAK,OAAO,cAAc;AAC9C,UAAM,gBAAgB,cAAc,KAAK,OAAO;AAChD,UAAM,iBAAiB,cAAc,KAAK,OAAO;AACjD,WAAO,EAAC,eAAe;AAAA;AAAA,EAYzB,eAAuB;AACrB,WAAO,KAAK,IAAI,KAAK,WAAW,CAAC,KAAK,YAAY,KAAK,UAAU,KAAK,OAAO,cAAc,OAAQ;AAAA;AAAA,EAQrG,YAAoB;AAGlB,WAAO,KAAK,IAAI,KAAK,gBAAgB,CAAC,KAAK,YAAY,KAAK,UAAU,KAAK,OAAO,YAAY,OAAQ;AAAA;AAAA;AAInG,uCAAgC;AAAA,EACrC;AAAA,EACA;AAAA,EACS;AAAA,EACT;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAGA;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,OAA+B,cAA4B;AACrE,SAAK,OAAO,MAAM;AAClB,SAAK,YAAY,MAAM;AACvB,SAAK,eAAe;AAEpB,UAAM,YAAY,MAAM,KAAK;AAE7B,SAAK,QAAQ,UAAU;AACvB,SAAK,SAAS,UAAU;AACxB,SAAK,WAAW,UAAU;AAC1B,SAAK,kBAAkB,UAAU;AACjC,SAAK,wBAAwB,UAAU;AACvC,SAAK,YAAY,UAAU;AAC3B,SAAK,eAAe,UAAU;AAC9B,SAAK,mBAAmB,UAAU;AAClC,SAAK,gBAAgB,UAAU;AAC/B,SAAK,eAAe,UAAU;AAC9B,SAAK,YAAY,UAAU;AAC3B,SAAK,mBAAmB,UAAU;AAClC,SAAK,QAAQ,EAAC,QAAQ,UAAU,WAAW,YAAY,aAAa;AACpE,SAAK,yBAAyB;AAC9B,SAAK,oBAAoB;AAGzB,QAAI,CAAC,KAAK,MAAM,UAAU,KAAK,MAAM,cAAc,KAAK,SAAS,+DAAuC;AACtG,WAAK,MAAM,SAAS;AAAA;AAAA;AAAA;AAKnB,iCAA0B;AAAA,EACvB;AAAA,EACA;AAAA,EACR;AAAA,EACQ;AAAA,EAGA;AAAA,EAGR,cAAc;AACZ,SAAK,kBAAkB;AACvB,SAAK,qBAAqB;AAC1B,SAAK,WAAW;AAChB,SAAK;AACL,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAAA;AAAA,SAGxB,sBAAsB,OAAiE;AAC5F,WAAO,oBAAoB,IAAI,UAAU;AAAA;AAAA,EAG3C,gBAAgB,cAA+C;AAC7D,SAAK;AAEL,QAAI,CAAC,aAAa,QAAQ;AACxB,cAAQ,MAAM;AACd,cAAQ,MAAM;AACd;AAAA;AAMF,QAAI,aAAa,SAAS,2EACtB,aAAa,MAAM,WAAW,oBAAoB;AACpD;AAAA;AAMF,UAAM,0BACD,aAAa,SAAS,+EACtB,aAAa,SAAS,qFACtB,aAAa,SAAS;AAC3B,QAAI,yBAAyB;AAC3B,YAAM,oBAAoB,aAAa,aAAa,KAAK,mBACrD,KAAK,gBAAgB,YAAY,UAAa,aAAa,aAAa,KAAK,gBAAgB,aAC7F,aAAa,aAAa,KAAK,gBAAgB;AACnD,UAAI,mBAAmB;AACrB,aAAK,kCAAkC;AAAA;AAAA;AAK3C,QAAI,KAAK,cAAc,aAAa,OAAO;AACzC,WAAK,cAAc,aAAa,MAAM,KAAK;AAAA,WACtC;AACL,WAAK,cAAc,aAAa,QAAQ,CAAC;AAAA;AAE3C,QAAI,aAAa,QAAQ;AACvB,UAAI,KAAK,sBAAsB,aAAa,SAAS;AACnD,aAAK,sBAAsB,aAAa,QAAQ,KAAK;AAAA,aAChD;AACL,aAAK,sBAAsB,aAAa,UAAU,CAAC;AAAA;AAAA;AAAA;AAAA,EAKzD,eAAe,kBAAgD;AAC7D,SAAK,kBAAkB;AACvB,UAAM,QAAQ;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA;AAEF,eAAW,gBAAgB,KAAK,qBAAqB,QAAQ;AAC3D,WAAK,kCAAkC;AAAA;AAAA;AAAA,EAInC,kCAAkC,cAA+C;AACvF,QAAI,aAAa,wBAAwB;AACvC;AAAA;AAGF,QAAI,CAAC,KAAK,iBAAiB;AACzB,YAAM,IAAI,MAAM;AAAA;AAElB,UAAM,qBAAqB,KAAK,gBAAgB,KAAK,aAAa;AAClE,QAAI,aAAa,SAAS,mFAAiD;AAGzE,WAAK,qCAAqC,KAAK,iBAAiB,oBAAoB;AAAA,eAC3E,aAAa,SAAS,6EAA8C;AAAA,WAGxE;AACL,WAAK,uBAAuB,KAAK,iBAAiB,oBAAoB;AAAA;AAGxE,iBAAa,yBAAyB;AAAA;AAAA,EAGhC,qCACJ,OAA+B,SAAiB,8BAA+D;AACjH,QAAI,CAAC,6BAA6B,kBAAkB;AAClD,WAAK,oCAAoC,6BAA6B,cAAc;AACpF;AAAA;AAEF,QAAI,CAAC,6BAA6B,QAAQ;AACxC,cAAQ,MAAM;AACd,cAAQ,MAAM;AACd;AAAA;AAEF,aAAS,IAAI,GAAG,IAAI,6BAA6B,iBAAiB,QAAQ,KAAK;AAC7E,YAAM,QAAQ,6BAA6B,iBAAiB,GAAG;AAC/D,UAAI;AACJ,YAAM,oBAAoB,KAAK,sBAAsB,6BAA6B,WAAW;AAC7F,eAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,KAAK;AACjD,cAAM,eAAe,kBAAkB;AACvC,YAAI,aAAa,UAAU,WAAW,aAAa,oBAAoB,SACnE,aAAa,SAAS,6EAA8C;AACtE;AAAA;AAEF,yCAAiC;AAAA;AAEnC,UAAI,CAAC,gCAAgC;AACnC;AAAA;AAEF,WAAK,oCACD,+BAA+B,cAAc;AAAA;AAAA;AAAA,EAI7C,oCACJ,WAAmC,8BAA+D;AACpG,UAAM,eAAe,aAAa,SAAS;AAC3C,UAAM,eAAe,IAAI,0BAA0B,WAAW;AAC9D,iBAAa,OAAO;AACpB,QAAI,6BAA6B,MAAM,QAAQ;AAC7C,mBAAa,MAAM,SAAS,6BAA6B,MAAM;AAAA;AAEjE,QAAI,6BAA6B,cAAc;AAC7C,mBAAa,eAAe,6BAA6B;AAAA;AAG3D,QAAI,CAAC,aAAa,wBAAwB;AACxC,WAAK,kCAAkC;AAAA;AAAA;AAAA,EAI3C,UAAU,aAA2C;AACnD,UAAM,gBAAgB,YAAY,KAAK,aAAa;AACpD,eAAW,gBAAgB,KAAK,qBAAqB,CAAC,iEAAyC;AAC7F,UAAI,aAAa,mBAAmB;AAClC;AAAA;AAEF,WAAK,uBAAuB,aAAa,eAAe;AACxD,mBAAa,oBAAoB;AAAA;AAAA;AAAA,EAI7B,uBACJ,OAA+B,cAAsB,cAA+C;AACtG,QAAI,iBAAiB,aAAa,OAAO;AACvC;AAAA;AAEF,UAAM,gBAAgB,oBAAoB,IAAI;AAC9C,QAAI,CAAC,eAAe;AAClB,0BAAoB,IAAI,OAAO,CAAC;AAAA,WAC3B;AACL,oBAAc,KAAK;AAAA;AAAA;AAAA,EAIf,qBAAqB,OAAkE;AAC7F,UAAM,gBAAgB,KAAK;AAC3B,QAAI,CAAC,OAAO;AACV,cAAQ,OAAO,KAAK;AAAA;AAEtB,0BAA2E;AACzE,UAAI,CAAC,OAAO;AACV;AAAA;AAEF,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,GAAG;AACrC,cAAM,mBAAmB,cAAc,MAAM,OAAO;AACpD,iBAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,EAAE,GAAG;AAChD,gBAAM,iBAAiB;AAAA;AAAA;AAAA;AAI7B,WAAO;AAAA;AAAA,EAGD,wBAA8B;AACpC,QAAI,CAAC,KAAK,UAAU;AAClB;AAAA;AAGF,SAAK;AAAA;AAAA,EAGC,0BAAgC;AACtC,SAAK,gBAAgB;AACrB,SAAK,wBAAwB;AAE7B,SAAK,kBAAkB;AACvB,SAAK,qBAAqB;AAC1B,SAAK,WAAW;AAAA;AAAA;AAIb,uCAAgC;AAAA,EACpB;AAAA,EACjB,cAAc;AACZ,8BAA0B;AAC1B,SAAK,kBAAkB,oBAAI;AAC3B,QAAI,0BAA0B,aAAa;AACzC,iBAAW,aAAa,0BAA0B,YAAY,QAAQ;AACpE,aAAK,gBAAgB,IAAI,WAAW,oBAAI;AAAA;AAAA;AAAA;AAAA,SAK/B,aAAmB;AAChC,QAAI,0BAA0B,aAAa;AACzC;AAAA;AAGF,UAAM,SAAS,oBAAI;AAKnB,WAAO,IAAI,mCAAyB,EAAC,QAAQ,CAAC,8BAAuB,QAAQ;AAC7E,WAAO,IAAI,iDAAgC;AAAA,MACzC,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAEF,QAAQ;AAAA;AAEV,WAAO,IAAI,qDAAkC,EAAC,QAAQ,CAAC,gDAAgC,QAAQ;AAC/F,WAAO,IAAI,iDAAgC,EAAC,QAAQ,CAAC,4CAA8B,QAAQ;AAC3F,WAAO,IAAI,yCAA4B;AAAA,MACrC,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAEF,QAAQ;AAAA;AAGV,8BAA0B,cAAc;AACxC,8BAA0B,kBAAkB,oBAAI;AAChD,eAAW,SAAS,QAAQ;AAC1B,YAAM,QAAQ,MAAM,GAAG;AACvB,iBAAW,eAAe,OAAO;AAC/B,kCAA0B,gBAAgB,IAAI,aAAa,MAAM;AAAA;AAAA;AAAA;AAAA,EAKvE,aAAa,OAAqC;AAChD,QAAI,CAAC,0BAA0B,mBAAmB,CAAC,0BAA0B,aAAa;AACxF;AAAA;AAEF,QAAI,gBAAsC,0BAA0B,gBAAgB,IAAK,MAAM;AAC/F,UAAM,cAAc,CAAC;AACrB,QAAI,CAAC,eAAe;AAClB,sBAAiB,MAAM;AAAA;AAEzB,UAAM,gBAAgB,0BAA0B,YAAY,IAAI;AAChE,QAAI,CAAC,eAAe;AAClB;AAAA;AAEF,UAAM,KAAM,kBAAkB,cAAc,OAAO,cAAc;AACjE,QAAI,CAAC,IAAI;AACP;AAAA;AAEF,UAAM,eAAkE,KAAK,gBAAgB,IAAI;AACjG,QAAI,cAAc;AAChB,UAAI,aAAa;AACf,qBAAa,IAAI,IAAI;AACrB;AAAA;AAEF,YAAM,YAAY,aAAa,IAAI;AACnC,YAAM,eAAe,aAAa,SAAS;AAC3C,mBAAa,aAAa,YAAY,YAAY;AAClD,UAAI,CAAC,aAAa,WAAW,WAAW;AACtC,qBAAa,UAAU,kBAAkB,aAAa;AAAA;AAAA;AAAA;AAAA,SAK7C,cAA4E;AAAA,SAC5E,kBAAoD;AAAA;AAG9D,0BAAmB;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACQ;AAAA,EACR;AAAA,EACA;AAAA,EAEA,cAAc;AACZ,SAAK,UAAU;AACf,SAAK,iBAAiB;AACtB,SAAK,MAAM;AACX,SAAK,iBAAiB;AACtB,SAAK,aAAa;AAClB,SAAK,UAAU;AACf,SAAK,oBAAoB;AACzB,SAAK,UAAU;AAAA;AAAA,EAGjB,aAAa,WAA8C;AACzD,SAAK,oBAAoB;AACzB,QAAI,CAAC,aAAa,KAAK,KAAK;AAC1B;AAAA;AAEF,UAAM,eAAe,aAAa,SAAS,WAAW;AACtD,QAAI,cAAc;AAChB,WAAK,MAAM;AAAA;AAAA;AAAA,EAIf,YAAyC;AACvC,WAAO,KAAK;AAAA;AAAA,EAGd,WAA4C;AAC1C,UAAM,aAAa,KAAK;AACxB,WAAO,cAAc,WAAW,MAAM;AAAA;AAAA,EAGxC,+BAAkE;AAChE,WAAO,KAAK,cAAe,KAAK,qBAAqB,aAAa,SAAS,KAAK,mBAAmB;AAAA;AAAA,SAG9F,SAAS,OAA6C;AAC3D,QAAI,OAAO,YAAY,IAAI;AAC3B,QAAI,CAAC,MAAM;AACT,aAAO,IAAI;AACX,kBAAY,IAAI,OAAO;AAAA;AAEzB,WAAO;AAAA;AAAA;AAIX,MAAM,cAAc,oBAAI;AACxB,MAAM,sBAAsB,oBAAI;",
  "names": []
}
