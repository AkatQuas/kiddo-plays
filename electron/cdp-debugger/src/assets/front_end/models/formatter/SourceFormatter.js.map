{
  "version": 3,
  "sources": ["../../../../../../front_end/models/formatter/SourceFormatter.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../bindings/bindings.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nimport type {FormatterSourceMapping} from './ScriptFormatter.js';\nimport {format} from './ScriptFormatter.js';\n\nconst objectToFormattingResult = new WeakMap<Object, SourceFormatData>();\n\nexport class SourceFormatData {\n  originalSourceCode: Workspace.UISourceCode.UISourceCode;\n  formattedSourceCode: Workspace.UISourceCode.UISourceCode;\n  mapping: FormatterSourceMapping;\n\n  constructor(\n      originalSourceCode: Workspace.UISourceCode.UISourceCode, formattedSourceCode: Workspace.UISourceCode.UISourceCode,\n      mapping: FormatterSourceMapping) {\n    this.originalSourceCode = originalSourceCode;\n    this.formattedSourceCode = formattedSourceCode;\n    this.mapping = mapping;\n  }\n\n  originalPath(): string {\n    return this.originalSourceCode.project().id() + ':' + this.originalSourceCode.url();\n  }\n\n  static for(object: Object): SourceFormatData|null {\n    return objectToFormattingResult.get(object) || null;\n  }\n}\n\nlet sourceFormatterInstance: SourceFormatter|null = null;\n\nexport class SourceFormatter {\n  private readonly projectId: string;\n  private readonly project: Bindings.ContentProviderBasedProject.ContentProviderBasedProject;\n  private readonly formattedSourceCodes: Map<Workspace.UISourceCode.UISourceCode, {\n    promise: Promise<SourceFormatData>,\n    formatData: SourceFormatData|null,\n  }>;\n  private readonly scriptMapping: ScriptMapping;\n  private readonly styleMapping: StyleMapping;\n\n  constructor() {\n    this.projectId = 'formatter:';\n    this.project = new Bindings.ContentProviderBasedProject.ContentProviderBasedProject(\n        Workspace.Workspace.WorkspaceImpl.instance(), this.projectId, Workspace.Workspace.projectTypes.Formatter,\n        'formatter', true /* isServiceProject */);\n\n    this.formattedSourceCodes = new Map();\n    this.scriptMapping = new ScriptMapping();\n    this.styleMapping = new StyleMapping();\n    Workspace.Workspace.WorkspaceImpl.instance().addEventListener(\n        Workspace.Workspace.Events.UISourceCodeRemoved, event => {\n          void this.onUISourceCodeRemoved(event);\n        }, this);\n  }\n\n  static instance({forceNew = false}: {forceNew?: boolean} = {}): SourceFormatter {\n    if (!sourceFormatterInstance || forceNew) {\n      sourceFormatterInstance = new SourceFormatter();\n    }\n    return sourceFormatterInstance;\n  }\n\n  private async onUISourceCodeRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>):\n      Promise<void> {\n    const uiSourceCode = event.data;\n    const cacheEntry = this.formattedSourceCodes.get(uiSourceCode);\n    if (cacheEntry && cacheEntry.formatData) {\n      await this.discardFormatData(cacheEntry.formatData);\n    }\n    this.formattedSourceCodes.delete(uiSourceCode);\n  }\n\n  async discardFormattedUISourceCode(formattedUISourceCode: Workspace.UISourceCode.UISourceCode):\n      Promise<Workspace.UISourceCode.UISourceCode|null> {\n    const formatData = SourceFormatData.for(formattedUISourceCode);\n    if (!formatData) {\n      return null;\n    }\n    await this.discardFormatData(formatData);\n    this.formattedSourceCodes.delete(formatData.originalSourceCode);\n    return formatData.originalSourceCode;\n  }\n\n  private async discardFormatData(formatData: SourceFormatData): Promise<void> {\n    objectToFormattingResult.delete(formatData.formattedSourceCode);\n    await this.scriptMapping.setSourceMappingEnabled(formatData, false);\n    void this.styleMapping.setSourceMappingEnabled(formatData, false);\n    this.project.removeFile(formatData.formattedSourceCode.url());\n  }\n\n  hasFormatted(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean {\n    return this.formattedSourceCodes.has(uiSourceCode);\n  }\n\n  getOriginalUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): Workspace.UISourceCode.UISourceCode {\n    const formatData = objectToFormattingResult.get(uiSourceCode);\n    if (!formatData) {\n      return uiSourceCode;\n    }\n    return formatData.originalSourceCode;\n  }\n\n  async format(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<SourceFormatData> {\n    const cacheEntry = this.formattedSourceCodes.get(uiSourceCode);\n    if (cacheEntry) {\n      return cacheEntry.promise;\n    }\n\n    const resultPromise = new Promise<SourceFormatData>(async (resolve, reject) => {\n      const {content} = await uiSourceCode.requestContent();\n\n      try {\n        const {formattedContent, formattedMapping} =\n            await format(uiSourceCode.contentType(), uiSourceCode.mimeType(), content || '');\n        const cacheEntry = this.formattedSourceCodes.get(uiSourceCode);\n        if (!cacheEntry || cacheEntry.promise !== resultPromise) {\n          return;\n        }\n        let formattedURL;\n        let count = 0;\n        let suffix = '';\n        do {\n          formattedURL = Common.ParsedURL.ParsedURL.concatenate(uiSourceCode.url(), ':formatted', suffix);\n          suffix = `:${count++}`;\n        } while (this.project.uiSourceCodeForURL(formattedURL));\n        const contentProvider = TextUtils.StaticContentProvider.StaticContentProvider.fromString(\n            formattedURL, uiSourceCode.contentType(), formattedContent);\n        const formattedUISourceCode = this.project.createUISourceCode(formattedURL, contentProvider.contentType());\n        const formatData = new SourceFormatData(uiSourceCode, formattedUISourceCode, formattedMapping);\n        objectToFormattingResult.set(formattedUISourceCode, formatData);\n        this.project.addUISourceCodeWithProvider(\n            formattedUISourceCode, contentProvider, /* metadata */ null, uiSourceCode.mimeType());\n        await this.scriptMapping.setSourceMappingEnabled(formatData, true);\n        await this.styleMapping.setSourceMappingEnabled(formatData, true);\n        cacheEntry.formatData = formatData;\n        resolve(formatData);\n      } catch (e) {\n        reject(e);\n      }\n    });\n\n    this.formattedSourceCodes.set(uiSourceCode, {promise: resultPromise, formatData: null});\n\n    return resultPromise;\n  }\n}\n\nclass ScriptMapping implements Bindings.DebuggerWorkspaceBinding.DebuggerSourceMapping {\n  constructor() {\n    Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().addSourceMapping(this);\n  }\n\n  rawLocationToUILocation(rawLocation: SDK.DebuggerModel.Location): Workspace.UISourceCode.UILocation|null {\n    const script = rawLocation.script();\n    const formatData = script && SourceFormatData.for(script);\n    if (!formatData || !script) {\n      return null;\n    }\n    const [lineNumber, columnNumber] =\n        formatData.mapping.originalToFormatted(rawLocation.lineNumber, rawLocation.columnNumber || 0);\n    return formatData.formattedSourceCode.uiLocation(lineNumber, columnNumber);\n  }\n\n  uiLocationToRawLocations(uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number):\n      SDK.DebuggerModel.Location[] {\n    const formatData = SourceFormatData.for(uiSourceCode);\n    if (!formatData) {\n      return [];\n    }\n    const [originalLine, originalColumn] = formatData.mapping.formattedToOriginal(lineNumber, columnNumber);\n    if (formatData.originalSourceCode.contentType().isScript()) {\n      // Here we have a script that is displayed on its own (i.e. it has a dedicated uiSourceCode). This means it is\n      // either a stand-alone script or an inline script with a #sourceURL= and in both cases we can just forward the\n      // question to the original (unformatted) source code.\n      const rawLocations = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance()\n                               .uiLocationToRawLocationsForUnformattedJavaScript(\n                                   formatData.originalSourceCode, originalLine, originalColumn);\n      console.assert(rawLocations.every(l => l && Boolean(l.script())));\n      return rawLocations;\n    }\n    if (formatData.originalSourceCode.contentType() === Common.ResourceType.resourceTypes.Document) {\n      const target = Bindings.NetworkProject.NetworkProject.targetForUISourceCode(formatData.originalSourceCode);\n      const debuggerModel = target && target.model(SDK.DebuggerModel.DebuggerModel);\n      if (debuggerModel) {\n        const scripts = debuggerModel.scriptsForSourceURL(formatData.originalSourceCode.url())\n                            .filter(script => script.isInlineScript() && !script.hasSourceURL);\n        // Here we have an inline script, which was formatted together with the containing document, so we must not\n        // translate locations as they are relative to the start of the document.\n        const locations =\n            (scripts.map(script => script.rawLocation(originalLine, originalColumn)).filter(l => Boolean(l)) as\n             SDK.DebuggerModel.Location[]);\n        console.assert(locations.every(l => l && Boolean(l.script())));\n        return locations;\n      }\n    }\n    return [];\n  }\n\n  async setSourceMappingEnabled(formatData: SourceFormatData, enabled: boolean): Promise<void> {\n    const scripts = this.scriptsForUISourceCode(formatData.originalSourceCode);\n    if (!scripts.length) {\n      return;\n    }\n    if (enabled) {\n      for (const script of scripts) {\n        objectToFormattingResult.set(script, formatData);\n      }\n    } else {\n      for (const script of scripts) {\n        objectToFormattingResult.delete(script);\n      }\n    }\n    const updatePromises = scripts.map(\n        script => Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().updateLocations(script));\n    await Promise.all(updatePromises);\n  }\n\n  private scriptsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): SDK.Script.Script[] {\n    if (uiSourceCode.contentType() === Common.ResourceType.resourceTypes.Document) {\n      const target = Bindings.NetworkProject.NetworkProject.targetForUISourceCode(uiSourceCode);\n      const debuggerModel = target && target.model(SDK.DebuggerModel.DebuggerModel);\n      if (debuggerModel) {\n        const scripts = debuggerModel.scriptsForSourceURL(uiSourceCode.url())\n                            .filter(script => script.isInlineScript() && !script.hasSourceURL);\n        return scripts;\n      }\n    }\n    if (uiSourceCode.contentType().isScript()) {\n      console.assert(!objectToFormattingResult.has(uiSourceCode));\n      const rawLocations = Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance()\n                               .uiLocationToRawLocationsForUnformattedJavaScript(uiSourceCode, 0, 0);\n      return rawLocations.map(location => location.script()).filter(script => Boolean(script)) as SDK.Script.Script[];\n    }\n    return [];\n  }\n}\n\nconst sourceCodeToHeaders =\n    new WeakMap<Workspace.UISourceCode.UISourceCode, SDK.CSSStyleSheetHeader.CSSStyleSheetHeader[]>();\n\nclass StyleMapping implements Bindings.CSSWorkspaceBinding.SourceMapping {\n  private readonly headersSymbol: symbol;\n  constructor() {\n    Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance().addSourceMapping(this);\n    this.headersSymbol = Symbol('Formatter.SourceFormatter.StyleMapping._headersSymbol');\n  }\n\n  rawLocationToUILocation(rawLocation: SDK.CSSModel.CSSLocation): Workspace.UISourceCode.UILocation|null {\n    const styleHeader = rawLocation.header();\n    const formatData = styleHeader && SourceFormatData.for(styleHeader);\n    if (!formatData) {\n      return null;\n    }\n    const formattedLocation =\n        formatData.mapping.originalToFormatted(rawLocation.lineNumber, rawLocation.columnNumber || 0);\n    return formatData.formattedSourceCode.uiLocation(formattedLocation[0], formattedLocation[1]);\n  }\n\n  uiLocationToRawLocations(uiLocation: Workspace.UISourceCode.UILocation): SDK.CSSModel.CSSLocation[] {\n    const formatData = SourceFormatData.for(uiLocation.uiSourceCode);\n    if (!formatData) {\n      return [];\n    }\n    const [originalLine, originalColumn] =\n        formatData.mapping.formattedToOriginal(uiLocation.lineNumber, uiLocation.columnNumber);\n    const allHeaders = sourceCodeToHeaders.get(formatData.originalSourceCode);\n\n    if (!allHeaders) {\n      return [];\n    }\n\n    const headers = allHeaders.filter(header => header.containsLocation(originalLine, originalColumn));\n    return headers.map(header => new SDK.CSSModel.CSSLocation(header, originalLine, originalColumn));\n  }\n\n  async setSourceMappingEnabled(formatData: SourceFormatData, enable: boolean): Promise<void> {\n    const original = formatData.originalSourceCode;\n    const headers = this.headersForUISourceCode(original);\n    if (enable) {\n      sourceCodeToHeaders.set(original, headers);\n      headers.forEach(header => {\n        objectToFormattingResult.set(header, formatData);\n      });\n    } else {\n      sourceCodeToHeaders.delete(original);\n      headers.forEach(header => {\n        objectToFormattingResult.delete(header);\n      });\n    }\n    const updatePromises =\n        headers.map(header => Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance().updateLocations(header));\n    await Promise.all(updatePromises);\n  }\n\n  private headersForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode):\n      SDK.CSSStyleSheetHeader.CSSStyleSheetHeader[] {\n    if (uiSourceCode.contentType() === Common.ResourceType.resourceTypes.Document) {\n      const target = Bindings.NetworkProject.NetworkProject.targetForUISourceCode(uiSourceCode);\n      const cssModel = target && target.model(SDK.CSSModel.CSSModel);\n      if (cssModel) {\n        return cssModel.headersForSourceURL(uiSourceCode.url())\n            .filter(header => header.isInline && !header.hasSourceURL);\n      }\n    } else if (uiSourceCode.contentType().isStyleSheet()) {\n      const rawLocations = Bindings.CSSWorkspaceBinding.CSSWorkspaceBinding.instance().uiLocationToRawLocations(\n          uiSourceCode.uiLocation(0, 0));\n      return rawLocations.map(rawLocation => rawLocation.header()).filter(header => Boolean(header)) as\n          SDK.CSSStyleSheetHeader.CSSStyleSheetHeader[];\n    }\n    return [];\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
