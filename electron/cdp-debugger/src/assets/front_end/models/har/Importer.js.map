{
  "version": 3,
  "sources": ["../../../../../../front_end/models/har/Importer.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nimport type {HAREntry, HARLog, HARPage, HARTimings} from './HARFormat.js';\n\nexport class Importer {\n  static requestsFromHARLog(log: HARLog): SDK.NetworkRequest.NetworkRequest[] {\n    const pages = new Map<string, HARPage>();\n    for (const page of log.pages) {\n      pages.set(page.id, page);\n    }\n\n    log.entries.sort((a, b) => a.startedDateTime.valueOf() - b.startedDateTime.valueOf());\n\n    const pageLoads = new Map<string, SDK.PageLoad.PageLoad>();\n    const requests: SDK.NetworkRequest.NetworkRequest[] = [];\n    for (const entry of log.entries) {\n      const pageref = entry.pageref;\n      let pageLoad: SDK.PageLoad.PageLoad|(SDK.PageLoad.PageLoad | undefined) =\n          pageref ? pageLoads.get(pageref) : undefined;\n      const documentURL = pageLoad ? pageLoad.mainRequest.url() : entry.request.url;\n\n      let initiator: {\n        type: Protocol.Network.InitiatorType,\n        url: string|undefined,\n        lineNumber: number|undefined,\n      }|null = null;\n      const initiatorEntry = entry.customInitiator();\n      if (initiatorEntry) {\n        initiator = {\n          type: (initiatorEntry.type as Protocol.Network.InitiatorType),\n          url: initiatorEntry.url,\n          lineNumber: initiatorEntry.lineNumber,\n        };\n      }\n      const request = SDK.NetworkRequest.NetworkRequest.createWithoutBackendRequest(\n          'har-' + requests.length, entry.request.url, documentURL, initiator);\n      const page = pageref ? pages.get(pageref) : undefined;\n      if (!pageLoad && pageref && page) {\n        pageLoad = Importer.buildPageLoad(page, request);\n        pageLoads.set(pageref, pageLoad);\n      }\n      Importer.fillRequestFromHAREntry(request, entry, pageLoad);\n      if (pageLoad) {\n        pageLoad.bindRequest(request);\n      }\n      requests.push(request);\n    }\n    return requests;\n  }\n\n  static buildPageLoad(page: HARPage, mainRequest: SDK.NetworkRequest.NetworkRequest): SDK.PageLoad.PageLoad {\n    const pageLoad = new SDK.PageLoad.PageLoad(mainRequest);\n    pageLoad.startTime = page.startedDateTime.valueOf();\n    pageLoad.contentLoadTime = Number(page.pageTimings.onContentLoad) * 1000;\n    pageLoad.loadTime = Number(page.pageTimings.onLoad) * 1000;\n    return pageLoad;\n  }\n\n  static fillRequestFromHAREntry(\n      request: SDK.NetworkRequest.NetworkRequest, entry: HAREntry, pageLoad: SDK.PageLoad.PageLoad|undefined): void {\n    // Request data.\n    if (entry.request.postData) {\n      request.setRequestFormData(true, entry.request.postData.text);\n    } else {\n      request.setRequestFormData(false, null);\n    }\n    request.connectionId = entry.connection || '';\n    request.requestMethod = entry.request.method;\n    request.setRequestHeaders(entry.request.headers);\n\n    // Response data.\n    if (entry.response.content.mimeType && entry.response.content.mimeType !== 'x-unknown') {\n      request.mimeType = (entry.response.content.mimeType as SDK.NetworkRequest.MIME_TYPE);\n    }\n    request.responseHeaders = entry.response.headers;\n    request.statusCode = entry.response.status;\n    request.statusText = entry.response.statusText;\n    let protocol = entry.response.httpVersion.toLowerCase();\n    if (protocol === 'http/2.0') {\n      protocol = 'h2';\n    }\n    request.protocol = protocol.replace(/^http\\/2\\.0?\\+quic/, 'http/2+quic');\n\n    // Timing data.\n    const issueTime = entry.startedDateTime.getTime() / 1000;\n    request.setIssueTime(issueTime, issueTime);\n\n    // Content data.\n    const contentSize = entry.response.content.size > 0 ? entry.response.content.size : 0;\n    const headersSize = entry.response.headersSize > 0 ? entry.response.headersSize : 0;\n    const bodySize = entry.response.bodySize > 0 ? entry.response.bodySize : 0;\n    request.resourceSize = contentSize || (headersSize + bodySize);\n    let transferSize = entry.response.customAsNumber('transferSize');\n    if (transferSize === undefined) {\n      transferSize = entry.response.headersSize + entry.response.bodySize;\n    }\n    request.setTransferSize(transferSize >= 0 ? transferSize : 0);\n\n    const fromCache = entry.customAsString('fromCache');\n    if (fromCache === 'memory') {\n      request.setFromMemoryCache();\n    } else if (fromCache === 'disk') {\n      request.setFromDiskCache();\n    }\n\n    const contentText = entry.response.content.text;\n    const contentData = {\n      error: null,\n      content: contentText ? contentText : null,\n      encoded: entry.response.content.encoding === 'base64',\n    };\n    request.setContentDataProvider(async () => contentData);\n\n    // Timing data.\n    Importer.setupTiming(request, issueTime, entry.time, entry.timings);\n\n    // Meta data.\n    request.setRemoteAddress(entry.serverIPAddress || '', 80);  // Har does not support port numbers.\n    request.setResourceType(Importer.getResourceType(request, entry, pageLoad));\n\n    const priority = entry.customAsString('priority');\n    if (priority && Protocol.Network.ResourcePriority.hasOwnProperty(priority)) {\n      request.setPriority((priority as Protocol.Network.ResourcePriority));\n    }\n\n    const messages = entry.customAsArray('webSocketMessages');\n    if (messages) {\n      for (const message of messages) {\n        if (message.time === undefined) {\n          continue;\n        }\n        if (!Object.values(SDK.NetworkRequest.WebSocketFrameType).includes(message.type)) {\n          continue;\n        }\n        if (message.opcode === undefined) {\n          continue;\n        }\n        if (message.data === undefined) {\n          continue;\n        }\n\n        const mask = message.type === SDK.NetworkRequest.WebSocketFrameType.Send;\n        request.addFrame(\n            {time: message.time, text: message.data, opCode: message.opcode, mask: mask, type: message.type});\n      }\n    }\n\n    request.finished = true;\n  }\n\n  static getResourceType(\n      request: SDK.NetworkRequest.NetworkRequest, entry: HAREntry,\n      pageLoad: SDK.PageLoad.PageLoad|undefined): Common.ResourceType.ResourceType {\n    const customResourceTypeName = entry.customAsString('resourceType');\n    if (customResourceTypeName) {\n      const customResourceType = Common.ResourceType.ResourceType.fromName(customResourceTypeName);\n      if (customResourceType) {\n        return customResourceType;\n      }\n    }\n\n    if (pageLoad && pageLoad.mainRequest === request) {\n      return Common.ResourceType.resourceTypes.Document;\n    }\n\n    const resourceTypeFromMime = Common.ResourceType.ResourceType.fromMimeType(entry.response.content.mimeType);\n    if (resourceTypeFromMime !== Common.ResourceType.resourceTypes.Other) {\n      return resourceTypeFromMime;\n    }\n\n    const resourceTypeFromUrl = Common.ResourceType.ResourceType.fromURL(entry.request.url);\n    if (resourceTypeFromUrl) {\n      return resourceTypeFromUrl;\n    }\n\n    return Common.ResourceType.resourceTypes.Other;\n  }\n\n  static setupTiming(\n      request: SDK.NetworkRequest.NetworkRequest, issueTime: number, entryTotalDuration: number,\n      timings: HARTimings): void {\n    function accumulateTime(timing: number|undefined): number {\n      if (timing === undefined || timing < 0) {\n        return -1;\n      }\n      lastEntry += timing;\n      return lastEntry;\n    }\n    let lastEntry = timings.blocked && (timings.blocked >= 0) ? timings.blocked : 0;\n\n    const proxy = timings.customAsNumber('blocked_proxy') || -1;\n    const queueing = timings.customAsNumber('blocked_queueing') || -1;\n\n    // SSL is part of connect for both HAR and Chrome's format so subtract it here.\n    const ssl = timings.ssl && (timings.ssl >= 0) ? timings.ssl : 0;\n    if (timings.connect && (timings.connect > 0)) {\n      timings.connect -= ssl;\n    }\n    const timing = {\n      proxyStart: proxy > 0 ? lastEntry - proxy : -1,\n      proxyEnd: proxy > 0 ? lastEntry : -1,\n      requestTime: issueTime + (queueing > 0 ? queueing : 0) / 1000,\n      dnsStart: timings.dns && (timings.dns >= 0) ? lastEntry : -1,\n      dnsEnd: accumulateTime(timings.dns),\n\n      // Add ssl to end time without modifying lastEntry (see comment above).\n      connectStart: timings.connect && (timings.connect >= 0) ? lastEntry : -1,\n      connectEnd: accumulateTime(timings.connect) + ssl,\n\n      // Now update lastEntry to add ssl timing back in (see comment above).\n      sslStart: timings.ssl && (timings.ssl >= 0) ? lastEntry : -1,\n      sslEnd: accumulateTime(timings.ssl),\n\n      workerStart: -1,\n      workerReady: -1,\n      workerFetchStart: -1,\n      workerRespondWithSettled: -1,\n      sendStart: timings.send >= 0 ? lastEntry : -1,\n      sendEnd: accumulateTime(timings.send),\n      pushStart: 0,\n      pushEnd: 0,\n      receiveHeadersEnd: accumulateTime(timings.wait),\n    };\n    accumulateTime(timings.receive);\n\n    request.timing = timing;\n    request.endTime = issueTime + Math.max(entryTotalDuration, lastEntry) / 1000;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
