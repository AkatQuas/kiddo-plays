{
  "version": 3,
  "sources": ["../../../../../../front_end/models/bindings/PresentationConsoleMessageHelper.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport type * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nimport {DebuggerWorkspaceBinding} from './DebuggerWorkspaceBinding.js';\nimport type {LiveLocation} from './LiveLocation.js';\nimport {LiveLocationPool} from './LiveLocation.js';\n\nconst debuggerModelToMessageHelperMap =\n    new WeakMap<SDK.DebuggerModel.DebuggerModel, PresentationConsoleMessageHelper>();\n\nexport class PresentationConsoleMessageManager implements\n    SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  constructor() {\n    SDK.TargetManager.TargetManager.instance().observeModels(SDK.DebuggerModel.DebuggerModel, this);\n\n    SDK.ConsoleModel.ConsoleModel.instance().addEventListener(\n        SDK.ConsoleModel.Events.ConsoleCleared, this.consoleCleared, this);\n    SDK.ConsoleModel.ConsoleModel.instance().addEventListener(\n        SDK.ConsoleModel.Events.MessageAdded, event => this.consoleMessageAdded(event.data));\n    SDK.ConsoleModel.ConsoleModel.instance().messages().forEach(this.consoleMessageAdded, this);\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModelToMessageHelperMap.set(debuggerModel, new PresentationConsoleMessageHelper(debuggerModel));\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const helper = debuggerModelToMessageHelperMap.get(debuggerModel);\n    if (helper) {\n      helper.consoleCleared();\n    }\n  }\n\n  private consoleMessageAdded(message: SDK.ConsoleModel.ConsoleMessage): void {\n    const runtimeModel = message.runtimeModel();\n    if (!message.isErrorOrWarning() || !message.runtimeModel() ||\n        message.source === Protocol.Log.LogEntrySource.Violation || !runtimeModel) {\n      return;\n    }\n    const helper = debuggerModelToMessageHelperMap.get(runtimeModel.debuggerModel());\n    if (helper) {\n      helper.consoleMessageAdded(message);\n    }\n  }\n\n  private consoleCleared(): void {\n    for (const debuggerModel of SDK.TargetManager.TargetManager.instance().models(SDK.DebuggerModel.DebuggerModel)) {\n      const helper = debuggerModelToMessageHelperMap.get(debuggerModel);\n      if (helper) {\n        helper.consoleCleared();\n      }\n    }\n  }\n}\n\nexport class PresentationConsoleMessageHelper {\n  readonly #debuggerModel: SDK.DebuggerModel.DebuggerModel;\n  #pendingConsoleMessages: Map<string, SDK.ConsoleModel.ConsoleMessage[]>;\n  #presentationConsoleMessages: PresentationConsoleMessage[];\n  readonly #locationPool: LiveLocationPool;\n\n  constructor(debuggerModel: SDK.DebuggerModel.DebuggerModel) {\n    this.#debuggerModel = debuggerModel;\n\n    this.#pendingConsoleMessages = new Map();\n\n    this.#presentationConsoleMessages = [];\n\n    // TODO(dgozman): queueMicrotask because we race with DebuggerWorkspaceBinding on ParsedScriptSource event delivery.\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.ParsedScriptSource, event => {\n      queueMicrotask(() => {\n        this.parsedScriptSource(event);\n      });\n    });\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.GlobalObjectCleared, this.debuggerReset, this);\n\n    this.#locationPool = new LiveLocationPool();\n  }\n\n  consoleMessageAdded(message: SDK.ConsoleModel.ConsoleMessage): void {\n    const rawLocation = this.rawLocation(message);\n    if (rawLocation) {\n      this.addConsoleMessageToScript(message, rawLocation);\n    } else {\n      this.addPendingConsoleMessage(message);\n    }\n  }\n\n  private rawLocation(message: SDK.ConsoleModel.ConsoleMessage): SDK.DebuggerModel.Location|null {\n    if (message.scriptId) {\n      return this.#debuggerModel.createRawLocationByScriptId(message.scriptId, message.line, message.column);\n    }\n    const callFrame = message.stackTrace && message.stackTrace.callFrames ? message.stackTrace.callFrames[0] : null;\n    if (callFrame) {\n      return this.#debuggerModel.createRawLocationByScriptId(\n          callFrame.scriptId, callFrame.lineNumber, callFrame.columnNumber);\n    }\n    if (message.url) {\n      return this.#debuggerModel.createRawLocationByURL(message.url, message.line, message.column);\n    }\n    return null;\n  }\n\n  private addConsoleMessageToScript(message: SDK.ConsoleModel.ConsoleMessage, rawLocation: SDK.DebuggerModel.Location):\n      void {\n    this.#presentationConsoleMessages.push(new PresentationConsoleMessage(message, rawLocation, this.#locationPool));\n  }\n\n  private addPendingConsoleMessage(message: SDK.ConsoleModel.ConsoleMessage): void {\n    if (!message.url) {\n      return;\n    }\n    const pendingMessages = this.#pendingConsoleMessages.get(message.url);\n    if (!pendingMessages) {\n      this.#pendingConsoleMessages.set(message.url, [message]);\n    } else {\n      pendingMessages.push(message);\n    }\n  }\n\n  private parsedScriptSource(event: Common.EventTarget.EventTargetEvent<SDK.Script.Script>): void {\n    const script = event.data;\n\n    const messages = this.#pendingConsoleMessages.get(script.sourceURL);\n    if (!messages) {\n      return;\n    }\n\n    const pendingMessages = [];\n    for (const message of messages) {\n      const rawLocation = this.rawLocation(message);\n      if (rawLocation && script.scriptId === rawLocation.scriptId) {\n        this.addConsoleMessageToScript(message, rawLocation);\n      } else {\n        pendingMessages.push(message);\n      }\n    }\n\n    if (pendingMessages.length) {\n      this.#pendingConsoleMessages.set(script.sourceURL, pendingMessages);\n    } else {\n      this.#pendingConsoleMessages.delete(script.sourceURL);\n    }\n  }\n\n  consoleCleared(): void {\n    this.#pendingConsoleMessages = new Map();\n    this.debuggerReset();\n  }\n\n  private debuggerReset(): void {\n    for (const message of this.#presentationConsoleMessages) {\n      message.dispose();\n    }\n    this.#presentationConsoleMessages = [];\n    this.#locationPool.disposeAll();\n  }\n}\n\nexport class PresentationConsoleMessage extends Workspace.UISourceCode.Message {\n  #uiSourceCode?: Workspace.UISourceCode.UISourceCode;\n\n  constructor(\n      message: SDK.ConsoleModel.ConsoleMessage, rawLocation: SDK.DebuggerModel.Location,\n      locationPool: LiveLocationPool) {\n    const level = message.level === Protocol.Log.LogEntryLevel.Error ? Workspace.UISourceCode.Message.Level.Error :\n                                                                       Workspace.UISourceCode.Message.Level.Warning;\n    super(level, message.messageText);\n    void DebuggerWorkspaceBinding.instance().createLiveLocation(\n        rawLocation, this.updateLocation.bind(this), locationPool);\n  }\n\n  private async updateLocation(liveLocation: LiveLocation): Promise<void> {\n    if (this.#uiSourceCode) {\n      this.#uiSourceCode.removeMessage(this);\n    }\n    const uiLocation = await liveLocation.uiLocation();\n    if (!uiLocation) {\n      return;\n    }\n    this.range = TextUtils.TextRange.TextRange.createFromLocation(uiLocation.lineNumber, uiLocation.columnNumber || 0);\n    this.#uiSourceCode = uiLocation.uiSourceCode;\n    this.#uiSourceCode.addMessage(this);\n  }\n\n  dispose(): void {\n    if (this.#uiSourceCode) {\n      this.#uiSourceCode.removeMessage(this);\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
