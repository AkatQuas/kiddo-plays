{
  "version": 3,
  "sources": ["../../../../../../front_end/models/bindings/BreakpointManager.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport type * as TextUtils from '../text_utils/text_utils.js';\nimport * as Workspace from '../workspace/workspace.js';\n\nimport {DebuggerWorkspaceBinding} from './DebuggerWorkspaceBinding.js';\nimport type {LiveLocation} from './LiveLocation.js';\nimport {LiveLocationPool} from './LiveLocation.js';\nimport {DefaultScriptMapping} from './DefaultScriptMapping.js';\n\nlet breakpointManagerInstance: BreakpointManager;\n\nexport class BreakpointManager extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly storage: Storage;\n  readonly #workspace: Workspace.Workspace.WorkspaceImpl;\n  readonly targetManager: SDK.TargetManager.TargetManager;\n  readonly debuggerWorkspaceBinding: DebuggerWorkspaceBinding;\n  readonly #breakpointsForUISourceCode: Map<Workspace.UISourceCode.UISourceCode, Map<string, BreakpointLocation>>;\n  readonly #breakpointByStorageId: Map<string, Breakpoint>;\n  #updateBindingsCallbacks: ((uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>)[];\n\n  private constructor(\n      targetManager: SDK.TargetManager.TargetManager, workspace: Workspace.Workspace.WorkspaceImpl,\n      debuggerWorkspaceBinding: DebuggerWorkspaceBinding) {\n    super();\n    this.storage = new Storage();\n    this.#workspace = workspace;\n    this.targetManager = targetManager;\n    this.debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.#breakpointsForUISourceCode = new Map();\n    this.#breakpointByStorageId = new Map();\n\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeAdded, this.uiSourceCodeAdded, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.UISourceCodeRemoved, this.uiSourceCodeRemoved, this);\n    this.#workspace.addEventListener(Workspace.Workspace.Events.ProjectRemoved, this.projectRemoved, this);\n\n    this.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n    this.#updateBindingsCallbacks = [];\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n    targetManager: SDK.TargetManager.TargetManager|null,\n    workspace: Workspace.Workspace.WorkspaceImpl|null,\n    debuggerWorkspaceBinding: DebuggerWorkspaceBinding|null,\n  } = {forceNew: null, targetManager: null, workspace: null, debuggerWorkspaceBinding: null}): BreakpointManager {\n    const {forceNew, targetManager, workspace, debuggerWorkspaceBinding} = opts;\n    if (!breakpointManagerInstance || forceNew) {\n      if (!targetManager || !workspace || !debuggerWorkspaceBinding) {\n        throw new Error(\n            `Unable to create settings: targetManager, workspace, and debuggerWorkspaceBinding must be provided: ${\n                new Error().stack}`);\n      }\n\n      breakpointManagerInstance = new BreakpointManager(targetManager, workspace, debuggerWorkspaceBinding);\n    }\n\n    return breakpointManagerInstance;\n  }\n\n  static breakpointStorageId(url: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber?: number): string {\n    if (!url) {\n      return '';\n    }\n    return `${url}:${lineNumber}` + (typeof columnNumber === 'number' ? `:${columnNumber}` : '');\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    if (Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      debuggerModel.setSynchronizeBreakpointsCallback(this.restoreBreakpointsForScript.bind(this));\n    }\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.setSynchronizeBreakpointsCallback(null);\n  }\n\n  addUpdateBindingsCallback(callback: ((uiSourceCode: Workspace.UISourceCode.UISourceCode) => Promise<void>)): void {\n    this.#updateBindingsCallbacks.push(callback);\n  }\n\n  async copyBreakpoints(fromURL: Platform.DevToolsPath.UrlString, toSourceCode: Workspace.UISourceCode.UISourceCode):\n      Promise<void> {\n    const breakpointItems = this.storage.breakpointItems(fromURL);\n    for (const item of breakpointItems) {\n      await this.setBreakpoint(toSourceCode, item.lineNumber, item.columnNumber, item.condition, item.enabled);\n    }\n  }\n\n  // This method explicitly awaits the source map (if necessary) and the uiSourceCodes\n  // required to set all breakpoints that are related to this script.\n  async restoreBreakpointsForScript(script: SDK.Script.Script): Promise<void> {\n    if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n      return;\n    }\n    if (!script.sourceURL) {\n      return;\n    }\n\n    const debuggerModel = script.debuggerModel;\n    const uiSourceCode = await this.getUISourceCodeWithUpdatedBreakpointInfo(script);\n    if (this.#hasBreakpointsForUrl(script.sourceURL)) {\n      await this.#restoreBreakpointsForUrl(uiSourceCode);\n    }\n\n    // Handle source maps and the original sources.\n    const sourceMap = await debuggerModel.sourceMapManager().sourceMapForClientPromise(script);\n    if (sourceMap) {\n      for (const sourceURL of sourceMap.sourceURLs()) {\n        if (this.#hasBreakpointsForUrl(sourceURL)) {\n          const uiSourceCode = await Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURLPromise(sourceURL);\n          await this.#restoreBreakpointsForUrl(uiSourceCode);\n        }\n      }\n    }\n\n    // Handle language plugins\n    const {pluginManager} = this.debuggerWorkspaceBinding;\n    if (pluginManager) {\n      const sourceUrls = await pluginManager.getSourcesForScript(script);\n      if (Array.isArray(sourceUrls)) {\n        for (const sourceURL of sourceUrls) {\n          if (this.#hasBreakpointsForUrl(sourceURL)) {\n            const uiSourceCode =\n                await Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURLPromise(sourceURL);\n            await this.#restoreBreakpointsForUrl(uiSourceCode);\n          }\n        }\n      }\n    }\n  }\n\n  async getUISourceCodeWithUpdatedBreakpointInfo(script: SDK.Script.Script):\n      Promise<Workspace.UISourceCode.UISourceCode> {\n    const isSnippet = script.sourceURL.startsWith('snippet://');\n    const projectType = isSnippet ? Workspace.Workspace.projectTypes.Network : undefined;\n\n    // Handle inline scripts without sourceURL comment separately:\n    // The UISourceCode of inline scripts without sourceURLs will not be availabe\n    // until a later point. Use the v8 script for setting the breakpoint.\n    const isInlineScriptWithoutSourceURL = script.isInlineScript() && !script.hasSourceURL;\n    const sourceURL =\n        isInlineScriptWithoutSourceURL ? DefaultScriptMapping.createV8ScriptURL(script) : script.sourceURL;\n    const uiSourceCode =\n        await Workspace.Workspace.WorkspaceImpl.instance().uiSourceCodeForURLPromise(sourceURL, projectType);\n\n    if (this.#updateBindingsCallbacks.length > 0) {\n      // It's possible to set breakpoints on files on the file system, and to have them\n      // hit whenever we navigate to a page that serves that file.\n      // To make sure that we have all breakpoint information moved from the file system\n      // to the served file, we need to update the bindings and await it. This will\n      // move the breakpoints from the FileSystem UISourceCode to the Network UiSourceCode.\n      const promises = [];\n      for (const callback of this.#updateBindingsCallbacks) {\n        promises.push(callback(uiSourceCode));\n      }\n      await Promise.all(promises);\n    }\n    return uiSourceCode;\n  }\n\n  async #restoreBreakpointsForUrl(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<void> {\n    this.restoreBreakpoints(uiSourceCode);\n    const breakpoints = this.#breakpointByStorageId.values();\n    const affectedBreakpoints = Array.from(breakpoints).filter(x => x.uiSourceCodes.has(uiSourceCode));\n    // Make sure to properly await their updates\n    await Promise.all(affectedBreakpoints.map(bp => bp.updateBreakpoint()));\n  }\n\n  #hasBreakpointsForUrl(url: Platform.DevToolsPath.UrlString): boolean {\n    const breakpointItems = this.storage.breakpointItems(url);\n    return breakpointItems.length > 0;\n  }\n\n  private restoreBreakpoints(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const url = uiSourceCode.url();\n    if (!url) {\n      return;\n    }\n\n    this.storage.mute();\n    const breakpointItems = this.storage.breakpointItems(url);\n    for (const item of breakpointItems) {\n      this.innerSetBreakpoint(uiSourceCode, item.lineNumber, item.columnNumber, item.condition, item.enabled);\n    }\n    this.storage.unmute();\n  }\n\n  private uiSourceCodeAdded(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.restoreBreakpoints(uiSourceCode);\n  }\n\n  private uiSourceCodeRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.UISourceCode.UISourceCode>): void {\n    const uiSourceCode = event.data;\n    this.removeUISourceCode(uiSourceCode);\n  }\n\n  private projectRemoved(event: Common.EventTarget.EventTargetEvent<Workspace.Workspace.Project>): void {\n    const project = event.data;\n    for (const uiSourceCode of project.uiSourceCodes()) {\n      this.removeUISourceCode(uiSourceCode);\n    }\n  }\n\n  private removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    const breakpoints = this.breakpointLocationsForUISourceCode(uiSourceCode);\n    breakpoints.forEach(bp => bp.breakpoint.removeUISourceCode(uiSourceCode));\n  }\n\n  async setBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: string, enabled: boolean): Promise<Breakpoint> {\n    let uiLocation: Workspace.UISourceCode.UILocation =\n        new Workspace.UISourceCode.UILocation(uiSourceCode, lineNumber, columnNumber);\n    const normalizedLocation = await this.debuggerWorkspaceBinding.normalizeUILocation(uiLocation);\n    if (normalizedLocation.id() !== uiLocation.id()) {\n      void Common.Revealer.reveal(normalizedLocation);\n      uiLocation = normalizedLocation;\n    }\n    return this.innerSetBreakpoint(\n        uiLocation.uiSourceCode, uiLocation.lineNumber, uiLocation.columnNumber, condition, enabled);\n  }\n\n  private innerSetBreakpoint(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number, columnNumber: number|undefined,\n      condition: string, enabled: boolean): Breakpoint {\n    const itemId = BreakpointManager.breakpointStorageId(uiSourceCode.url(), lineNumber, columnNumber);\n    let breakpoint = this.#breakpointByStorageId.get(itemId);\n    if (breakpoint) {\n      breakpoint.updateState(condition, enabled);\n      breakpoint.addUISourceCode(uiSourceCode);\n      void breakpoint.updateBreakpoint();\n      return breakpoint;\n    }\n    breakpoint = new Breakpoint(this, uiSourceCode, uiSourceCode.url(), lineNumber, columnNumber, condition, enabled);\n    this.#breakpointByStorageId.set(itemId, breakpoint);\n    return breakpoint;\n  }\n\n  findBreakpoint(uiLocation: Workspace.UISourceCode.UILocation): BreakpointLocation|null {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    return breakpoints ? (breakpoints.get(uiLocation.id())) || null : null;\n  }\n\n  async possibleBreakpoints(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode,\n      textRange: TextUtils.TextRange.TextRange): Promise<Workspace.UISourceCode.UILocation[]> {\n    const {pluginManager} = this.debuggerWorkspaceBinding;\n    if (pluginManager) {\n      // TODO(bmeurer): Refactor this logic, as for DWARF and sourcemaps, it doesn't make sense\n      //                to even ask V8 for possible break locations, since these are determined\n      //                from the debugging information.\n      const rawLocations = await pluginManager.uiLocationToRawLocations(uiSourceCode, textRange.startLine);\n      if (rawLocations) {\n        const uiLocations = [];\n        for (const rawLocation of rawLocations) {\n          const uiLocation = await this.debuggerWorkspaceBinding.rawLocationToUILocation(rawLocation);\n          if (uiLocation) {\n            uiLocations.push(uiLocation);\n          }\n        }\n        return uiLocations;\n      }\n    }\n    const startLocationsPromise = DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(\n        uiSourceCode, textRange.startLine, textRange.startColumn);\n    const endLocationsPromise = DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(\n        uiSourceCode, textRange.endLine, textRange.endColumn);\n    const [startLocations, endLocations] = await Promise.all([startLocationsPromise, endLocationsPromise]);\n    const endLocationByModel = new Map<SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Location>();\n    for (const location of endLocations) {\n      endLocationByModel.set(location.debuggerModel, location);\n    }\n    let startLocation: SDK.DebuggerModel.Location|null = null;\n    let endLocation: SDK.DebuggerModel.Location|null = null;\n    for (const location of startLocations) {\n      const endLocationCandidate = endLocationByModel.get(location.debuggerModel);\n      if (endLocationCandidate) {\n        startLocation = location;\n        endLocation = endLocationCandidate;\n        break;\n      }\n    }\n    if (!startLocation || !endLocation) {\n      return [];\n    }\n\n    return startLocation.debuggerModel\n        .getPossibleBreakpoints(startLocation, endLocation, /* restrictToFunction */ false)\n        .then(toUILocations.bind(this));\n\n    async function toUILocations(this: BreakpointManager, locations: SDK.DebuggerModel.BreakLocation[]):\n        Promise<Workspace.UISourceCode.UILocation[]> {\n      const sortedLocationsPromises =\n          locations.map(location => this.debuggerWorkspaceBinding.rawLocationToUILocation(location));\n      const nullableLocations = await Promise.all(sortedLocationsPromises);\n      const sortedLocations =\n          (nullableLocations.filter(location => location && location.uiSourceCode === uiSourceCode) as\n           Workspace.UISourceCode.UILocation[]);\n      if (!sortedLocations.length) {\n        return [];\n      }\n      sortedLocations.sort(Workspace.UISourceCode.UILocation.comparator);\n      let lastLocation: Workspace.UISourceCode.UILocation = sortedLocations[0];\n      const result = [lastLocation];\n      for (const location of sortedLocations) {\n        if (location.id() !== lastLocation.id()) {\n          result.push(location);\n          lastLocation = location;\n        }\n      }\n      return result;\n    }\n  }\n\n  breakpointLocationsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): BreakpointLocation[] {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiSourceCode);\n    return breakpoints ? Array.from(breakpoints.values()) : [];\n  }\n\n  allBreakpointLocations(): BreakpointLocation[] {\n    const result = [];\n    for (const breakpoints of this.#breakpointsForUISourceCode.values()) {\n      result.push(...breakpoints.values());\n    }\n    return result;\n  }\n\n  removeBreakpoint(breakpoint: Breakpoint, removeFromStorage: boolean): void {\n    if (removeFromStorage) {\n      this.storage.removeBreakpoint(breakpoint);\n    }\n    this.#breakpointByStorageId.delete(breakpoint.breakpointStorageId());\n  }\n\n  uiLocationAdded(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation): void {\n    let breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      breakpoints = new Map();\n      this.#breakpointsForUISourceCode.set(uiLocation.uiSourceCode, breakpoints);\n    }\n    const breakpointLocation = {breakpoint: breakpoint, uiLocation: uiLocation};\n    breakpoints.set(uiLocation.id(), breakpointLocation);\n    this.dispatchEventToListeners(Events.BreakpointAdded, breakpointLocation);\n  }\n\n  uiLocationRemoved(breakpoint: Breakpoint, uiLocation: Workspace.UISourceCode.UILocation): void {\n    const breakpoints = this.#breakpointsForUISourceCode.get(uiLocation.uiSourceCode);\n    if (!breakpoints) {\n      return;\n    }\n    const breakpointLocation = breakpoints.get(uiLocation.id()) || null;\n    if (!breakpointLocation) {\n      return;\n    }\n    breakpoints.delete(uiLocation.id());\n    if (breakpoints.size === 0) {\n      this.#breakpointsForUISourceCode.delete(uiLocation.uiSourceCode);\n    }\n    this.dispatchEventToListeners(Events.BreakpointRemoved, {breakpoint: breakpoint, uiLocation: uiLocation});\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  BreakpointAdded = 'breakpoint-added',\n  BreakpointRemoved = 'breakpoint-removed',\n}\n\nexport type EventTypes = {\n  [Events.BreakpointAdded]: BreakpointLocation,\n  [Events.BreakpointRemoved]: BreakpointLocation,\n};\n\nconst enum DebuggerUpdateResult {\n  OK = 'OK',\n  ERROR = 'ERROR',\n  // PENDING implies that the current update requires another re-run.\n  PENDING = 'PENDING',\n}\n\nconst enum ResolveLocationResult {\n  OK = 'OK',\n  ERROR = 'ERROR',\n}\n\nexport class Breakpoint implements SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly breakpointManager: BreakpointManager;\n  urlInternal: Platform.DevToolsPath.UrlString;\n  readonly #lineNumberInternal: number;\n  readonly #columnNumberInternal: number|undefined;\n  readonly #uiLocations: Set<Workspace.UISourceCode.UILocation>;\n  uiSourceCodes: Set<Workspace.UISourceCode.UISourceCode>;\n  #conditionInternal!: string;\n  #enabledInternal!: boolean;\n  isRemoved!: boolean;\n  currentState: Breakpoint.State|null;\n  readonly #modelBreakpoints: Map<SDK.DebuggerModel.DebuggerModel, ModelBreakpoint>;\n\n  constructor(\n      breakpointManager: BreakpointManager, primaryUISourceCode: Workspace.UISourceCode.UISourceCode,\n      url: Platform.DevToolsPath.UrlString, lineNumber: number, columnNumber: number|undefined, condition: string,\n      enabled: boolean) {\n    this.breakpointManager = breakpointManager;\n    this.urlInternal = url;\n    this.#lineNumberInternal = lineNumber;\n    this.#columnNumberInternal = columnNumber;\n\n    this.#uiLocations = new Set();   // Bound locations\n    this.uiSourceCodes = new Set();  // All known UISourceCodes with this url\n\n    this.currentState = null;\n\n    this.#modelBreakpoints = new Map();\n    this.updateState(condition, enabled);\n    this.addUISourceCode(primaryUISourceCode);\n    this.breakpointManager.targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n  }\n\n  async refreshInDebugger(): Promise<void> {\n    if (!this.isRemoved) {\n      const modelBreakpoints = Array.from(this.#modelBreakpoints.values());\n      await Promise.all(modelBreakpoints.map(async modelBreakpoint => {\n        await modelBreakpoint.resetBreakpoint();\n        return this.#updateModel(modelBreakpoint);\n      }));\n    }\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const debuggerWorkspaceBinding = this.breakpointManager.debuggerWorkspaceBinding;\n    const modelBreakpoint = new ModelBreakpoint(debuggerModel, this, debuggerWorkspaceBinding);\n    this.#modelBreakpoints.set(debuggerModel, modelBreakpoint);\n    void this.#updateModel(modelBreakpoint);\n\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    const modelBreakpoint = this.#modelBreakpoints.get(debuggerModel);\n    modelBreakpoint?.cleanUpAfterDebuggerIsGone();\n    this.#modelBreakpoints.delete(debuggerModel);\n\n    this.#removeDebuggerModelListeners(debuggerModel);\n  }\n\n  #removeDebuggerModelListeners(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasEnabled, this.#onDebuggerEnabled, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.DebuggerWasDisabled, this.#onDebuggerDisabled, this);\n  }\n\n  #onDebuggerEnabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    if (model) {\n      void this.#updateModel(model);\n    }\n  }\n\n  #onDebuggerDisabled(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    const model = this.#modelBreakpoints.get(debuggerModel);\n    model?.cleanUpAfterDebuggerIsGone();\n  }\n\n  modelBreakpoint(debuggerModel: SDK.DebuggerModel.DebuggerModel): ModelBreakpoint|undefined {\n    return this.#modelBreakpoints.get(debuggerModel);\n  }\n\n  addUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (!this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.add(uiSourceCode);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n      }\n    }\n  }\n\n  clearUISourceCodes(): void {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n    }\n    this.uiSourceCodes.clear();\n  }\n\n  removeUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): void {\n    if (this.uiSourceCodes.has(uiSourceCode)) {\n      this.uiSourceCodes.delete(uiSourceCode);\n      if (!this.bound()) {\n        this.breakpointManager.uiLocationRemoved(this, this.defaultUILocation(uiSourceCode));\n      }\n    }\n\n    // Do we need to do this? Not sure if bound locations will leak...\n    if (this.bound()) {\n      for (const uiLocation of this.#uiLocations) {\n        if (uiLocation.uiSourceCode === uiSourceCode) {\n          this.#uiLocations.delete(uiLocation);\n          this.breakpointManager.uiLocationRemoved(this, uiLocation);\n        }\n      }\n\n      if (!this.bound() && !this.isRemoved) {\n        // Switch to unbound locations\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.urlInternal;\n  }\n\n  lineNumber(): number {\n    return this.#lineNumberInternal;\n  }\n\n  columnNumber(): number|undefined {\n    return this.#columnNumberInternal;\n  }\n\n  uiLocationAdded(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.isRemoved) {\n      return;\n    }\n    if (!this.bound()) {\n      // This is our first bound location; remove all unbound locations\n      this.removeAllUnboundLocations();\n    }\n    this.#uiLocations.add(uiLocation);\n    this.breakpointManager.uiLocationAdded(this, uiLocation);\n  }\n\n  uiLocationRemoved(uiLocation: Workspace.UISourceCode.UILocation): void {\n    if (this.#uiLocations.has(uiLocation)) {\n      this.#uiLocations.delete(uiLocation);\n      this.breakpointManager.uiLocationRemoved(this, uiLocation);\n      if (!this.bound() && !this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n  }\n\n  enabled(): boolean {\n    return this.#enabledInternal;\n  }\n\n  bound(): boolean {\n    return this.#uiLocations.size !== 0;\n  }\n\n  hasBoundScript(): boolean {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      if (uiSourceCode.project().type() === Workspace.Workspace.projectTypes.Network) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.updateState(this.#conditionInternal, enabled);\n  }\n\n  condition(): string {\n    return this.#conditionInternal;\n  }\n\n  setCondition(condition: string): void {\n    this.updateState(condition, this.#enabledInternal);\n  }\n\n  updateState(condition: string, enabled: boolean): void {\n    if (this.#enabledInternal === enabled && this.#conditionInternal === condition) {\n      return;\n    }\n    this.#enabledInternal = enabled;\n    this.#conditionInternal = condition;\n    this.breakpointManager.storage.updateBreakpoint(this);\n    void this.updateBreakpoint();\n  }\n\n  async updateBreakpoint(): Promise<void> {\n    if (!this.bound()) {\n      this.removeAllUnboundLocations();\n      if (!this.isRemoved) {\n        this.addAllUnboundLocations();\n      }\n    }\n    return this.#updateModels();\n  }\n\n  async remove(keepInStorage: boolean): Promise<void> {\n    this.isRemoved = true;\n    const removeFromStorage = !keepInStorage;\n\n    for (const debuggerModel of this.#modelBreakpoints.keys()) {\n      this.#removeDebuggerModelListeners(debuggerModel);\n    }\n    await this.#updateModels();\n\n    this.breakpointManager.removeBreakpoint(this, removeFromStorage);\n    this.breakpointManager.targetManager.unobserveModels(SDK.DebuggerModel.DebuggerModel, this);\n    this.clearUISourceCodes();\n  }\n\n  breakpointStorageId(): string {\n    return BreakpointManager.breakpointStorageId(\n        this.urlInternal, this.#lineNumberInternal, this.#columnNumberInternal);\n  }\n\n  private defaultUILocation(uiSourceCode: Workspace.UISourceCode.UISourceCode): Workspace.UISourceCode.UILocation {\n    return uiSourceCode.uiLocation(this.#lineNumberInternal, this.#columnNumberInternal);\n  }\n\n  private removeAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationRemoved(this, this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  private addAllUnboundLocations(): void {\n    for (const uiSourceCode of this.uiSourceCodes) {\n      this.breakpointManager.uiLocationAdded(this, this.defaultUILocation(uiSourceCode));\n    }\n  }\n\n  getUiSourceCodes(): Set<Workspace.UISourceCode.UISourceCode> {\n    return this.uiSourceCodes;\n  }\n\n  getIsRemoved(): boolean {\n    return this.isRemoved;\n  }\n\n  async #updateModels(): Promise<void> {\n    await Promise.all(Array.from(this.#modelBreakpoints.values()).map(model => this.#updateModel(model)));\n  }\n\n  async #updateModel(model: ModelBreakpoint): Promise<void> {\n    const success = await model.scheduleUpdateInDebugger();\n    if (!success) {\n      await this.remove(false);\n    }\n  }\n}\n\nexport class ModelBreakpoint {\n  #debuggerModel: SDK.DebuggerModel.DebuggerModel;\n  #breakpoint: Breakpoint;\n  readonly #debuggerWorkspaceBinding: DebuggerWorkspaceBinding;\n  readonly #liveLocations: LiveLocationPool;\n  readonly #uiLocations: Map<LiveLocation, Workspace.UISourceCode.UILocation>;\n  #updateMutex = new Common.Mutex.Mutex();\n  #cancelCallback: boolean;\n  #currentState: Breakpoint.State|null;\n  #breakpointIds: Protocol.Debugger.BreakpointId[];\n\n  constructor(\n      debuggerModel: SDK.DebuggerModel.DebuggerModel, breakpoint: Breakpoint,\n      debuggerWorkspaceBinding: DebuggerWorkspaceBinding) {\n    this.#debuggerModel = debuggerModel;\n    this.#breakpoint = breakpoint;\n    this.#debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.#liveLocations = new LiveLocationPool();\n\n    this.#uiLocations = new Map();\n    this.#cancelCallback = false;\n    this.#currentState = null;\n    this.#breakpointIds = [];\n  }\n\n  get currentState(): Breakpoint.State|null {\n    return this.#currentState;\n  }\n\n  resetLocations(): void {\n    for (const uiLocation of this.#uiLocations.values()) {\n      this.#breakpoint.uiLocationRemoved(uiLocation);\n    }\n\n    this.#uiLocations.clear();\n    this.#liveLocations.disposeAll();\n  }\n\n  // Returns true, if scheduling ran as expected.\n  // Returns false, if an error occurred.\n  async scheduleUpdateInDebugger(): Promise<boolean> {\n    if (!this.#debuggerModel.debuggerEnabled()) {\n      return true;\n    }\n\n    const release = await this.#updateMutex.acquire();\n    let result = DebuggerUpdateResult.PENDING;\n    while (result === DebuggerUpdateResult.PENDING) {\n      result = await this.#updateInDebugger();\n    }\n    release();\n    return result === DebuggerUpdateResult.OK;\n  }\n\n  private scriptDiverged(): boolean {\n    for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n      const scriptFile = this.#debuggerWorkspaceBinding.scriptFile(uiSourceCode, this.#debuggerModel);\n      if (scriptFile && scriptFile.hasDivergedFromVM()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  async #updateInDebugger(): Promise<DebuggerUpdateResult> {\n    if (this.#debuggerModel.target().isDisposed()) {\n      this.cleanUpAfterDebuggerIsGone();\n      return DebuggerUpdateResult.OK;\n    }\n    const lineNumber = this.#breakpoint.lineNumber();\n    const columnNumber = this.#breakpoint.columnNumber();\n    const condition = this.#breakpoint.condition();\n\n    // Calculate the new state.\n    let newState: Breakpoint.State|null = null;\n    if (!this.#breakpoint.getIsRemoved() && this.#breakpoint.enabled() && !this.scriptDiverged()) {\n      let debuggerLocations: SDK.DebuggerModel.Location[] = [];\n      for (const uiSourceCode of this.#breakpoint.getUiSourceCodes()) {\n        const locations =\n            await DebuggerWorkspaceBinding.instance().uiLocationToRawLocations(uiSourceCode, lineNumber, columnNumber);\n        debuggerLocations = locations.filter(location => location.debuggerModel === this.#debuggerModel);\n        if (debuggerLocations.length) {\n          break;\n        }\n      }\n      if (debuggerLocations.length && debuggerLocations.every(loc => loc.script())) {\n        const positions = debuggerLocations.map(loc => {\n          const script = loc.script() as SDK.Script.Script;\n          return {\n            url: script.sourceURL,\n            scriptId: script.scriptId,\n            scriptHash: script.hash,\n            lineNumber: loc.lineNumber,\n            columnNumber: loc.columnNumber,\n          };\n        });\n        newState = new Breakpoint.State(positions, condition);\n      } else if (!Root.Runtime.experiments.isEnabled(Root.Runtime.ExperimentName.INSTRUMENTATION_BREAKPOINTS)) {\n        // Use this fallback if we do not have instrumentation breakpoints enabled yet. This currently makes\n        // sure that v8 knows about the breakpoint and is able to restore it whenever the script is parsed.\n        if (this.#breakpoint.currentState) {\n          newState = new Breakpoint.State(this.#breakpoint.currentState.positions, condition);\n        } else {\n          // TODO(bmeurer): This fallback doesn't make a whole lot of sense, we should\n          // at least signal a warning to the developer that this #breakpoint wasn't\n          // really resolved.\n          const position = {\n            url: this.#breakpoint.url(),\n            scriptId: '' as Protocol.Runtime.ScriptId,\n            scriptHash: '',\n            lineNumber,\n            columnNumber,\n          };\n          newState = new Breakpoint.State([position], condition);\n        }\n      }\n    }\n    const hasBackendState = this.#breakpointIds.length;\n\n    // Case 1: State hasn't changed, and back-end is up to date and has information\n    // on some breakpoints.\n    if (hasBackendState && Breakpoint.State.equals(newState, this.#currentState)) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    this.#breakpoint.currentState = newState;\n\n    // Case 2: State has changed, and the back-end has outdated information on old\n    // breakpoints.\n    if (hasBackendState) {\n      // Reset the current state.\n      await this.resetBreakpoint();\n      // Schedule another run of updates, to finally update to the new state.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    // Case 3: State is null (no breakpoints to set), and back-end is up to date\n    // (no info on breakpoints).\n    if (!newState) {\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Case 4: State is not null, so we have breakpoints to set and the back-end\n    // has no information on breakpoints yet. Set the breakpoints.\n    const {breakpointIds, locations, serverError} = await this.#setBreakpointOnBackend(newState);\n\n    const maybeRescheduleUpdate =\n        serverError && this.#debuggerModel.debuggerEnabled() && !this.#debuggerModel.isReadyToPause();\n    if (!breakpointIds.length && maybeRescheduleUpdate) {\n      // TODO(crbug.com/1229541): This is a quickfix to prevent #breakpoints from\n      // disappearing if the Debugger is actually not enabled\n      // yet. This quickfix should be removed as soon as we have a solution\n      // to correctly synchronize the front-end with the inspector back-end.\n      return DebuggerUpdateResult.PENDING;\n    }\n\n    this.#currentState = newState;\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return DebuggerUpdateResult.OK;\n    }\n\n    // Something went wrong: we expect to have a non-null state, but have not received any\n    // breakpointIds from the back-end.\n    if (!breakpointIds.length) {\n      return DebuggerUpdateResult.ERROR;\n    }\n\n    this.#breakpointIds = breakpointIds;\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.addBreakpointListener(breakpointId, this.breakpointResolved, this));\n    const resolvedResults = await Promise.all(locations.map(location => this.addResolvedLocation(location)));\n\n    // Breakpoint clash: the resolved location resolves to a different breakpoint, report an error.\n    if (resolvedResults.includes(ResolveLocationResult.ERROR)) {\n      return DebuggerUpdateResult.ERROR;\n    }\n    return DebuggerUpdateResult.OK;\n  }\n\n  async #setBreakpointOnBackend(newState: Breakpoint.State): Promise<{\n    breakpointIds: Protocol.Debugger.BreakpointId[],\n    locations: SDK.DebuggerModel.Location[],\n    serverError: boolean,\n  }> {\n    const condition = this.#breakpoint.condition();\n    const results = await Promise.all(newState.positions.map(pos => {\n      if (pos.url) {\n        return this.#debuggerModel.setBreakpointByURL(pos.url, pos.lineNumber, pos.columnNumber, condition);\n      }\n      return this.#debuggerModel.setBreakpointInAnonymousScript(\n          pos.scriptId, pos.scriptHash as string, pos.lineNumber, pos.columnNumber, condition);\n    }));\n    const breakpointIds: Protocol.Debugger.BreakpointId[] = [];\n    let locations: SDK.DebuggerModel.Location[] = [];\n    let serverError = false;\n    for (const result of results) {\n      if (result.breakpointId) {\n        breakpointIds.push(result.breakpointId);\n        locations = locations.concat(result.locations);\n      } else {\n        serverError = true;\n      }\n    }\n    return {breakpointIds, locations, serverError};\n  }\n\n  async resetBreakpoint(): Promise<void> {\n    if (!this.#breakpointIds.length) {\n      return;\n    }\n    this.resetLocations();\n    await Promise.all(this.#breakpointIds.map(id => this.#debuggerModel.removeBreakpoint(id)));\n    this.didRemoveFromDebugger();\n    this.#currentState = null;\n  }\n\n  private didRemoveFromDebugger(): void {\n    if (this.#cancelCallback) {\n      this.#cancelCallback = false;\n      return;\n    }\n\n    this.resetLocations();\n    this.#breakpointIds.forEach(\n        breakpointId => this.#debuggerModel.removeBreakpointListener(breakpointId, this.breakpointResolved, this));\n    this.#breakpointIds = [];\n  }\n\n  private async breakpointResolved({data: location}: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.Location>):\n      Promise<void> {\n    const result = await this.addResolvedLocation(location);\n    if (result === ResolveLocationResult.ERROR) {\n      await this.#breakpoint.remove(false);\n    }\n  }\n\n  private async locationUpdated(liveLocation: LiveLocation): Promise<void> {\n    const oldUILocation = this.#uiLocations.get(liveLocation);\n    const uiLocation = await liveLocation.uiLocation();\n\n    if (oldUILocation) {\n      this.#breakpoint.uiLocationRemoved(oldUILocation);\n    }\n\n    if (uiLocation) {\n      this.#uiLocations.set(liveLocation, uiLocation);\n      this.#breakpoint.uiLocationAdded(uiLocation);\n    } else {\n      this.#uiLocations.delete(liveLocation);\n    }\n  }\n\n  private async addResolvedLocation(location: SDK.DebuggerModel.Location): Promise<ResolveLocationResult> {\n    const uiLocation = await this.#debuggerWorkspaceBinding.rawLocationToUILocation(location);\n    if (!uiLocation) {\n      return ResolveLocationResult.OK;\n    }\n    const breakpointLocation = this.#breakpoint.breakpointManager.findBreakpoint(uiLocation);\n    if (breakpointLocation && breakpointLocation.breakpoint !== this.#breakpoint) {\n      // location clash\n      return ResolveLocationResult.ERROR;\n    }\n    await this.#debuggerWorkspaceBinding.createLiveLocation(\n        location, this.locationUpdated.bind(this), this.#liveLocations);\n    return ResolveLocationResult.OK;\n  }\n\n  cleanUpAfterDebuggerIsGone(): void {\n    this.#cancelCallback = true;\n    this.resetLocations();\n    this.#currentState = null;\n    if (this.#breakpointIds.length) {\n      this.didRemoveFromDebugger();\n    }\n  }\n}\n\ninterface Position {\n  url: Platform.DevToolsPath.UrlString;\n  scriptId: Protocol.Runtime.ScriptId;\n  scriptHash: string;\n  lineNumber: number;\n  columnNumber?: number;\n}\n\nexport namespace Breakpoint {\n  export class State {\n    positions: Position[];\n    condition: string;\n\n    constructor(positions: Position[], condition: string) {\n      this.positions = positions;\n      this.condition = condition;\n    }\n\n    static equals(stateA?: State|null, stateB?: State|null): boolean {\n      if (!stateA || !stateB) {\n        return false;\n      }\n      if (stateA.condition !== stateB.condition) {\n        return false;\n      }\n      if (stateA.positions.length !== stateB.positions.length) {\n        return false;\n      }\n      for (let i = 0; i < stateA.positions.length; i++) {\n        const positionA = stateA.positions[i];\n        const positionB = stateB.positions[i];\n        if (positionA.url !== positionB.url) {\n          return false;\n        }\n        if (positionA.scriptId !== positionB.scriptId) {\n          return false;\n        }\n        if (positionA.scriptHash !== positionB.scriptHash) {\n          return false;\n        }\n        if (positionA.lineNumber !== positionB.lineNumber) {\n          return false;\n        }\n        if (positionA.columnNumber !== positionB.columnNumber) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n}\n\nclass Storage {\n  readonly #setting: Common.Settings.Setting<Storage.Item[]>;\n  readonly #breakpoints: Map<string, Storage.Item>;\n  #muted!: boolean|undefined;\n\n  constructor() {\n    this.#setting = Common.Settings.Settings.instance().createLocalSetting('breakpoints', []);\n    this.#breakpoints = new Map();\n    const items = (this.#setting.get() as Storage.Item[]);\n    for (const item of items) {\n      this.#breakpoints.set(BreakpointManager.breakpointStorageId(item.url, item.lineNumber, item.columnNumber), item);\n    }\n  }\n\n  get setting(): Common.Settings.Setting<Storage.Item[]> {\n    return this.#setting;\n  }\n\n  mute(): void {\n    this.#muted = true;\n  }\n\n  unmute(): void {\n    this.#muted = undefined;\n  }\n\n  breakpointItems(url: Platform.DevToolsPath.UrlString): Storage.Item[] {\n    return Array.from(this.#breakpoints.values()).filter(item => item.url === url);\n  }\n\n  updateBreakpoint(breakpoint: Breakpoint): void {\n    if (this.#muted || !breakpoint.breakpointStorageId()) {\n      return;\n    }\n    this.#breakpoints.set(breakpoint.breakpointStorageId(), new Storage.Item(breakpoint));\n    this.save();\n  }\n\n  removeBreakpoint(breakpoint: Breakpoint): void {\n    if (!this.#muted) {\n      this.#breakpoints.delete(breakpoint.breakpointStorageId());\n      this.save();\n    }\n  }\n\n  private save(): void {\n    this.#setting.set(Array.from(this.#breakpoints.values()));\n  }\n}\n\nnamespace Storage {\n  export class Item {\n    url: Platform.DevToolsPath.UrlString;\n    lineNumber: number;\n    columnNumber?: number;\n    condition: string;\n    enabled: boolean;\n\n    constructor(breakpoint: Breakpoint) {\n      this.url = breakpoint.url();\n      this.lineNumber = breakpoint.lineNumber();\n      this.columnNumber = breakpoint.columnNumber();\n      this.condition = breakpoint.condition();\n      this.enabled = breakpoint.enabled();\n    }\n  }\n}\n\nexport interface BreakpointLocation {\n  breakpoint: Breakpoint;\n  uiLocation: Workspace.UISourceCode.UILocation;\n}\n"],
  "mappings": "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",
  "names": []
}
