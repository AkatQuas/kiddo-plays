{
  "version": 3,
  "sources": ["../../../../../../front_end/models/bindings/LiveLocation.ts"],
  "sourcesContent": ["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Workspace from '../workspace/workspace.js';\n\nexport interface LiveLocation {\n  update(): Promise<void>;\n  uiLocation(): Promise<Workspace.UISourceCode.UILocation|null>;\n  dispose(): void;\n  isDisposed(): boolean;\n  isIgnoreListed(): Promise<boolean>;\n}\n\nexport class LiveLocationWithPool implements LiveLocation {\n  #updateDelegate: ((arg0: LiveLocation) => Promise<void>)|null;\n  readonly #locationPool: LiveLocationPool;\n  #updatePromise: Promise<void>|null;\n\n  constructor(updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    this.#updateDelegate = updateDelegate;\n    this.#locationPool = locationPool;\n    this.#locationPool.add(this);\n\n    this.#updatePromise = null;\n  }\n\n  async update(): Promise<void> {\n    if (!this.#updateDelegate) {\n      return;\n    }\n    // The following is a basic scheduling algorithm, guaranteeing that\n    // {#updateDelegate} is always run atomically. That is, we always\n    // wait for an update to finish before we trigger the next run.\n    if (this.#updatePromise) {\n      await this.#updatePromise.then(() => this.update());\n    } else {\n      this.#updatePromise = this.#updateDelegate(this);\n      await this.#updatePromise;\n      this.#updatePromise = null;\n    }\n  }\n\n  async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    throw 'Not implemented';\n  }\n\n  dispose(): void {\n    this.#locationPool.delete(this);\n    this.#updateDelegate = null;\n  }\n\n  isDisposed(): boolean {\n    return !this.#locationPool.has(this);\n  }\n\n  async isIgnoreListed(): Promise<boolean> {\n    throw 'Not implemented';\n  }\n}\n\nexport class LiveLocationPool {\n  readonly #locations: Set<LiveLocation>;\n\n  constructor() {\n    this.#locations = new Set();\n  }\n\n  add(location: LiveLocation): void {\n    this.#locations.add(location);\n  }\n\n  delete(location: LiveLocation): void {\n    this.#locations.delete(location);\n  }\n\n  has(location: LiveLocation): boolean {\n    return this.#locations.has(location);\n  }\n\n  disposeAll(): void {\n    for (const location of this.#locations) {\n      location.dispose();\n    }\n  }\n}\n"],
  "mappings": "AAcO,kCAAmD;AAAA;AAAA;AAAA;AAAA,EAKxD,YAAY,gBAAuD,cAAgC;AACjG,2BAAuB;AACvB,yBAAqB;AACrB,uBAAmB,IAAI;AAEvB,0BAAsB;AAAA;AAAA,QAGlB,SAAwB;AAC5B,QAAI,CAAC,sBAAsB;AACzB;AAAA;AAKF,QAAI,qBAAqB;AACvB,YAAM,oBAAoB,KAAK,MAAM,KAAK;AAAA,WACrC;AACL,4BAAsB,qBAAqB;AAC3C,YAAM;AACN,4BAAsB;AAAA;AAAA;AAAA,QAIpB,aAA8D;AAClE,UAAM;AAAA;AAAA,EAGR,UAAgB;AACd,uBAAmB,OAAO;AAC1B,2BAAuB;AAAA;AAAA,EAGzB,aAAsB;AACpB,WAAO,CAAC,mBAAmB,IAAI;AAAA;AAAA,QAG3B,iBAAmC;AACvC,UAAM;AAAA;AAAA;AAIH,8BAAuB;AAAA;AAAA,EAG5B,cAAc;AACZ,sBAAkB,oBAAI;AAAA;AAAA,EAGxB,IAAI,UAA8B;AAChC,oBAAgB,IAAI;AAAA;AAAA,EAGtB,OAAO,UAA8B;AACnC,oBAAgB,OAAO;AAAA;AAAA,EAGzB,IAAI,UAAiC;AACnC,WAAO,gBAAgB,IAAI;AAAA;AAAA,EAG7B,aAAmB;AACjB,eAAW,YAAY,iBAAiB;AACtC,eAAS;AAAA;AAAA;AAAA;",
  "names": []
}
