{
  "version": 3,
  "sources": ["../../../../../../front_end/models/bindings/DebuggerLanguagePlugins.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Protocol from '../../generated/protocol.js';\nimport * as Workspace from '../workspace/workspace.js';\nimport type {Chrome} from '../../../extension-api/ExtensionAPI.js'; // eslint-disable-line rulesdir/es_modules_import\n\nimport {ContentProviderBasedProject} from './ContentProviderBasedProject.js';\n\nimport type {DebuggerWorkspaceBinding} from './DebuggerWorkspaceBinding.js';\nimport {NetworkProject} from './NetworkProject.js';\n\nconst UIStrings = {\n  /**\n  *@description Error message that is displayed in the Console when language #plugins report errors\n  *@example {File not found} PH1\n  */\n  errorInDebuggerLanguagePlugin: 'Error in debugger language plugin: {PH1}',\n  /**\n  *@description Status message that is shown in the Console when debugging information is being\n  *loaded. The 2nd and 3rd placeholders are URLs.\n  *@example {C/C++ DevTools Support (DWARF)} PH1\n  *@example {http://web.dev/file.wasm} PH2\n  *@example {http://web.dev/file.wasm.debug.wasm} PH3\n  */\n  loadingDebugSymbolsForVia: '[{PH1}] Loading debug symbols for {PH2} (via {PH3})...',\n  /**\n  *@description Status message that is shown in the Console when debugging information is being loaded\n  *@example {C/C++ DevTools Support (DWARF)} PH1\n  *@example {http://web.dev/file.wasm} PH2\n  */\n  loadingDebugSymbolsFor: '[{PH1}] Loading debug symbols for {PH2}...',\n  /**\n  *@description Warning message that is displayed in the Console when debugging information was loaded, but no source files were found\n  *@example {C/C++ DevTools Support (DWARF)} PH1\n  *@example {http://web.dev/file.wasm} PH2\n  */\n  loadedDebugSymbolsForButDidnt: '[{PH1}] Loaded debug symbols for {PH2}, but didn\\'t find any source files',\n  /**\n  *@description Status message that is shown in the Console when debugging information is successfully loaded\n  *@example {C/C++ DevTools Support (DWARF)} PH1\n  *@example {http://web.dev/file.wasm} PH2\n  *@example {42} PH3\n  */\n  loadedDebugSymbolsForFound: '[{PH1}] Loaded debug symbols for {PH2}, found {PH3} source file(s)',\n  /**\n  *@description Error message that is displayed in the Console when debugging information cannot be loaded\n  *@example {C/C++ DevTools Support (DWARF)} PH1\n  *@example {http://web.dev/file.wasm} PH2\n  *@example {File not found} PH3\n  */\n  failedToLoadDebugSymbolsFor: '[{PH1}] Failed to load debug symbols for {PH2} ({PH3})',\n  /**\n  *@description Error message that is displayed in UI debugging information cannot be found for a call frame\n  *@example {main} PH1\n  */\n  failedToLoadDebugSymbolsForFunction: 'No debug information for function \"{PH1}\"',\n  /**\n  *@description Error message that is displayed in UI when a file needed for debugging information for a call frame is missing\n  *@example {mainp.debug.wasm.dwp} PH1\n  */\n  debugSymbolsIncomplete: 'The debug information for function {PH1} is incomplete',\n};\nconst str_ = i18n.i18n.registerUIStrings('models/bindings/DebuggerLanguagePlugins.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nclass SourceType {\n  typeInfo: Chrome.DevTools.TypeInfo;\n  members: SourceType[];\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeMap: Map<any, SourceType>;\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(typeInfo: Chrome.DevTools.TypeInfo, members: SourceType[], typeMap: Map<any, SourceType>) {\n    this.typeInfo = typeInfo;\n    this.members = members;\n    this.typeMap = typeMap;\n  }\n\n  /**\n   * Create a type graph\n   */\n  static create(typeInfos: Chrome.DevTools.TypeInfo[]): SourceType|null {\n    if (typeInfos.length === 0) {\n      return null;\n    }\n\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const typeMap = new Map<any, SourceType>();\n    for (const typeInfo of typeInfos) {\n      typeMap.set(typeInfo.typeId, new SourceType(typeInfo, [], typeMap));\n    }\n\n    for (const sourceType of typeMap.values()) {\n      sourceType.members = sourceType.typeInfo.members.map(({typeId}) => {\n        const memberType = typeMap.get(typeId);\n        if (!memberType) {\n          throw new Error(`Incomplete type information for type ${typeInfos[0].typeNames[0] || '<anonymous>'}`);\n        }\n        return memberType;\n      });\n    }\n\n    return typeMap.get(typeInfos[0].typeId) || null;\n  }\n}\n\n/**\n * Generates the raw module ID for a script, which is used\n * to uniquely identify the debugging data for a script on\n * the responsible language #plugin.\n *\n * @param script the unique raw module ID for the script.\n */\nfunction rawModuleIdForScript(script: SDK.Script.Script): string {\n  return `${script.sourceURL}@${script.hash}`;\n}\n\nfunction getRawLocation(callFrame: SDK.DebuggerModel.CallFrame): Chrome.DevTools.RawLocation {\n  const {script} = callFrame;\n  return {\n    rawModuleId: rawModuleIdForScript(script),\n    codeOffset: callFrame.location().columnNumber - (script.codeOffset() || 0),\n    inlineFrameIndex: callFrame.inlineFrameIndex,\n  };\n}\n\nasync function resolveRemoteObject(\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callFrame: SDK.DebuggerModel.CallFrame, object: SDK.RemoteObject.RemoteObject): Promise<any> {\n  if (typeof object.value !== 'undefined') {\n    return object.value;\n  }\n\n  const response = await callFrame.debuggerModel.target().runtimeAgent().invoke_callFunctionOn(\n      {functionDeclaration: 'function() { return this; }', objectId: object.objectId, returnByValue: true});\n  const {result} = response;\n  if (!result) {\n    return undefined;\n  }\n  return result.value;\n}\n\nexport class ValueNode extends SDK.RemoteObject.RemoteObjectImpl {\n  inspectableAddress?: number;\n  callFrame: SDK.DebuggerModel.CallFrame;\n\n  constructor(\n      callFrame: SDK.DebuggerModel.CallFrame, objectId: Protocol.Runtime.RemoteObjectId|undefined, type: string,\n      subtype: string|undefined,\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      value: any, inspectableAddress?: number, unserializableValue?: string, description?: string,\n      preview?: Protocol.Runtime.ObjectPreview, customPreview?: Protocol.Runtime.CustomPreview, className?: string) {\n    super(\n        callFrame.debuggerModel.runtimeModel(), objectId, type, subtype, value, unserializableValue, description,\n        preview, customPreview, className);\n\n    this.inspectableAddress = inspectableAddress;\n    this.callFrame = callFrame;\n  }\n}\n\n// Debugger language #plugins present source-language values as trees with mixed dynamic and static structural\n// information. The static structure is defined by the variable's static type in the source language. Formatters are\n// able to present source-language values in an arbitrary user-friendly way, which contributes the dynamic structural\n// information. The classes StaticallyTypedValue and FormatedValueNode respectively implement the static and dynamic\n// parts in the RemoteObject tree that defines the presentation of the source-language value in the debugger UI.\n//\n// struct S {\n//   int i;\n//   struct A {\n//     int j;\n//   } a[3];\n// } s\n//\n// The RemoteObject tree representing the C struct above could look like the graph below with a formatter for the type\n// struct A[3], interleaving static and dynamic representations:\n//\n// StaticallyTypedValueNode   -->  s: struct S\n//                                 \\\n//                                 |\\\n// StaticallyTypedValueNode   -->  | i: int\n//                                 \\\n//                                  \\\n// StaticallyTypedValueNode   -->    a: struct A[3]\n//                                   \\\n//                                   |\\\n// FormattedValueNode         -->    | 0: struct A\n//                                   | \\\n//                                   |  \\\n// StaticallyTypedValueNode   -->    |   j: int\n//                                   .\n//                                   .\n//                                   .\n\n/** Create a new value tree from an expression.\n */\nasync function getValueTreeForExpression(\n    callFrame: SDK.DebuggerModel.CallFrame, plugin: DebuggerLanguagePlugin, expression: string,\n    evalOptions: SDK.RuntimeModel.EvaluationOptions): Promise<SDK.RemoteObject.RemoteObject> {\n  const location = getRawLocation(callFrame);\n\n  let typeInfo;\n  try {\n    typeInfo = await plugin.getTypeInfo(expression, location);\n  } catch (e) {\n    FormattingError.throwLocal(callFrame, e.message);\n  }\n  // If there's no type information we cannot represent this expression.\n  if (!typeInfo) {\n    return new SDK.RemoteObject.LocalJSONObject(undefined);\n  }\n  const {base, typeInfos} = typeInfo;\n  const sourceType = SourceType.create(typeInfos);\n  if (!sourceType) {\n    return new SDK.RemoteObject.LocalJSONObject(undefined);\n  }\n  if (sourceType.typeInfo.hasValue && !sourceType.typeInfo.canExpand && base) {\n    // Need to run the formatter for the expression result.\n    return formatSourceValue(callFrame, plugin, sourceType, base, [], evalOptions);\n  }\n\n  // Create a new value tree with static information for the root.\n  const address = await StaticallyTypedValueNode.getInspectableAddress(callFrame, plugin, base, [], evalOptions);\n  return new StaticallyTypedValueNode(callFrame, plugin, sourceType, base, [], evalOptions, address);\n}\n\n/** Run the formatter for the value defined by the pair of #base and #fieldChain.\n */\nasync function formatSourceValue(\n    callFrame: SDK.DebuggerModel.CallFrame, plugin: DebuggerLanguagePlugin, sourceType: SourceType,\n    base: Chrome.DevTools.EvalBase, field: Chrome.DevTools.FieldInfo[],\n    evalOptions: SDK.RuntimeModel.EvaluationOptions): Promise<FormattedValueNode> {\n  const location = getRawLocation(callFrame);\n\n  let evalCode: {\n    js: string,\n  }|({\n    js: string,\n  } | null) = await plugin.getFormatter({base, field}, location);\n  if (!evalCode) {\n    evalCode = {js: ''};\n  }\n  const response = await callFrame.debuggerModel.target().debuggerAgent().invoke_evaluateOnCallFrame({\n    callFrameId: callFrame.id,\n    expression: evalCode.js,\n    objectGroup: evalOptions.objectGroup,\n    includeCommandLineAPI: evalOptions.includeCommandLineAPI,\n    silent: evalOptions.silent,\n    returnByValue: evalOptions.returnByValue,\n    generatePreview: evalOptions.generatePreview,\n    throwOnSideEffect: evalOptions.throwOnSideEffect,\n    timeout: evalOptions.timeout,\n  });\n  const error = response.getError();\n  if (error) {\n    throw new Error(error);\n  }\n\n  const {result, exceptionDetails} = response;\n  if (exceptionDetails) {\n    throw new FormattingError(callFrame.debuggerModel.runtimeModel().createRemoteObject(result), exceptionDetails);\n  }\n  // Wrap the formatted result into a FormattedValueNode.\n  const object = new FormattedValueNode(callFrame, sourceType, plugin, result, null, evalOptions, undefined);\n  // Check whether the formatter returned a plain object or and object alongisde a formatter tag.\n  const unpackedResultObject = await unpackResultObject(object);\n  const node = unpackedResultObject || object;\n\n  if (typeof node.value === 'undefined' && node.type !== 'undefined') {\n    node.description = sourceType.typeInfo.typeNames[0];\n  }\n\n  return node;\n\n  async function unpackResultObject(object: FormattedValueNode): Promise<FormattedValueNode|null> {\n    const {tag, value, inspectableAddress, description} =\n        await object.findProperties('tag', 'value', 'inspectableAddress', 'description');\n    if (!tag || !value) {\n      return null;\n    }\n    const {className, symbol} = await tag.findProperties('className', 'symbol');\n    if (!className || !symbol) {\n      return null;\n    }\n    const resolvedClassName = className.value;\n    if (typeof resolvedClassName !== 'string' || typeof symbol.objectId === 'undefined') {\n      return null;\n    }\n\n    const descriptionText = description?.value;\n    if (typeof descriptionText === 'string') {\n      value.description = descriptionText;\n    }\n\n    value.formatterTag = {symbol: symbol.objectId, className: resolvedClassName};\n    value.inspectableAddress = inspectableAddress ? inspectableAddress.value : undefined;\n    return value;\n  }\n}\n\n// Formatters produce proper JavaScript objects, which are mirrored as RemoteObjects. To implement interleaving of\n// formatted and statically typed values, formatters may insert markers in the JavaScript objects. The markers contain\n// the static type information (`EvalBase`)to create a new StaticallyTypedValueNode tree root. Markers are identified by\n// their className and the presence of a special Symbol property. Both the class name and the symbol are defined by the\n// `formatterTag` property.\n//\n// A FormattedValueNode is a RemoteObject whose properties can be either FormattedValueNodes or\n// StaticallyTypedValueNodes. The class hooks into the creation of RemoteObjects for properties to check whether a\n// property is a marker.\nclass FormattedValueNode extends ValueNode {\n  readonly #plugin: DebuggerLanguagePlugin;\n  readonly #sourceType: SourceType;\n  formatterTag: {\n    className: string,\n    symbol: string,\n  }|null;\n  readonly #evalOptions: SDK.RuntimeModel.EvaluationOptions;\n  constructor(\n      callFrame: SDK.DebuggerModel.CallFrame, sourceType: SourceType, plugin: DebuggerLanguagePlugin,\n      object: Protocol.Runtime.RemoteObject, formatterTag: {\n        className: string,\n        symbol: string,\n      }|null,\n      evalOptions: SDK.RuntimeModel.EvaluationOptions, inspectableAddress: number|undefined) {\n    super(\n        callFrame, object.objectId, object.type, object.subtype, object.value, inspectableAddress,\n        object.unserializableValue, object.description, object.preview, object.customPreview, object.className);\n\n    this.#plugin = plugin;\n    this.#sourceType = sourceType;\n\n    // The tag describes how to identify a marker by its className and its identifier symbol's object id.\n    this.formatterTag = formatterTag;\n\n    this.#evalOptions = evalOptions;\n  }\n\n  async findProperties(...properties: string[]): Promise<{\n    [x: string]: FormattedValueNode | undefined,\n  }> {\n    const result: {\n      [x: string]: FormattedValueNode|undefined,\n    } = {};\n    for (const prop of (await this.getOwnProperties(false)).properties || []) {\n      if (properties.indexOf(prop.name) >= 0) {\n        if (prop.value) {\n          result[prop.name] = (prop.value as FormattedValueNode | undefined);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Hook into RemoteObject creation for properties to check whether a property is a marker.\n   */\n  async createRemoteObject(newObject: Protocol.Runtime.RemoteObject):\n      Promise<FormattedValueNode|StaticallyTypedValueNode> {\n    // Check if the property RemoteObject is a marker\n    const base = await this.getEvalBaseFromObject(newObject);\n    if (!base) {\n      return new FormattedValueNode(\n          this.callFrame, this.#sourceType, this.#plugin, newObject, this.formatterTag, this.#evalOptions, undefined);\n    }\n\n    // Property is a marker, check if it's just static type information or if we need to run formatters for the value.\n    const newSourceType = this.#sourceType.typeMap.get(base.rootType.typeId);\n    if (!newSourceType) {\n      throw new Error('Unknown typeId in eval base');\n    }\n    // The marker refers to a value that needs to be formatted, so run the formatter.\n    if (base.rootType.hasValue && !base.rootType.canExpand && base) {\n      return formatSourceValue(this.callFrame, this.#plugin, newSourceType, base, [], this.#evalOptions);\n    }\n\n    // The marker is just static information, so start a new subtree with a static type info root.\n    const address =\n        await StaticallyTypedValueNode.getInspectableAddress(this.callFrame, this.#plugin, base, [], this.#evalOptions);\n    return new StaticallyTypedValueNode(\n        this.callFrame, this.#plugin, newSourceType, base, [], this.#evalOptions, address);\n  }\n\n  /**\n   * Check whether an object is a marker and if so return the EvalBase it contains.\n   */\n  private async getEvalBaseFromObject(object: Protocol.Runtime.RemoteObject): Promise<Chrome.DevTools.EvalBase|null> {\n    const {objectId} = object;\n    if (!object || !this.formatterTag) {\n      return null;\n    }\n\n    // A marker is definitively identified by the symbol property. To avoid checking the properties of all objects,\n    // check the className first for an early exit.\n    const {className, symbol} = this.formatterTag;\n    if (className !== object.className) {\n      return null;\n    }\n\n    const response = await this.debuggerModel().target().runtimeAgent().invoke_callFunctionOn({\n      functionDeclaration: 'function(sym) { return this[sym]; }',\n      objectId,\n      arguments: [{objectId: symbol as Protocol.Runtime.RemoteObjectId}],\n    });\n    const {result} = response;\n    if (!result || result.type === 'undefined') {\n      return null;\n    }\n\n    // The object is a marker, so pull the static type information from its symbol property. The symbol property is not\n    // a formatted value per se, but we wrap it as one to be able to call `findProperties`.\n    const baseObject = new FormattedValueNode(\n        this.callFrame, this.#sourceType, this.#plugin, result, null, this.#evalOptions, undefined);\n    const {payload, rootType} = await baseObject.findProperties('payload', 'rootType');\n    if (typeof payload === 'undefined' || typeof rootType === 'undefined') {\n      return null;\n    }\n    const value = await resolveRemoteObject(this.callFrame, payload);\n    const {typeId} = await rootType.findProperties('typeId');\n    if (typeof value === 'undefined' || typeof typeId === 'undefined') {\n      return null;\n    }\n\n    const newSourceType = this.#sourceType.typeMap.get(typeId.value);\n    if (!newSourceType) {\n      return null;\n    }\n\n    return {payload: value, rootType: newSourceType.typeInfo};\n  }\n}\n\nclass FormattingError extends Error {\n  exception: SDK.RemoteObject.RemoteObject;\n  exceptionDetails: Protocol.Runtime.ExceptionDetails;\n  constructor(exception: SDK.RemoteObject.RemoteObject, exceptionDetails: Protocol.Runtime.ExceptionDetails) {\n    const {description} = exceptionDetails.exception || {};\n    super(description || exceptionDetails.text);\n    this.exception = exception;\n    this.exceptionDetails = exceptionDetails;\n  }\n\n  static throwLocal(callFrame: SDK.DebuggerModel.CallFrame, message: string): void {\n    const exception: Protocol.Runtime.RemoteObject = {\n      type: Protocol.Runtime.RemoteObjectType.Object,\n      subtype: Protocol.Runtime.RemoteObjectSubtype.Error,\n      description: message,\n    };\n    const exceptionDetails: Protocol.Runtime\n        .ExceptionDetails = {text: 'Uncaught', exceptionId: -1, columnNumber: 0, lineNumber: 0, exception};\n    const errorObject = callFrame.debuggerModel.runtimeModel().createRemoteObject(exception);\n    throw new FormattingError(errorObject, exceptionDetails);\n  }\n}\n\n// This class implements a `RemoteObject` for source language value whose immediate properties are defined purely by\n// static type information. Static type information is expressed by an `EvalBase` together with a `#fieldChain`. The\n// latter is necessary to express navigating through type members. We don't know how to make sense of an `EvalBase`'s\n// payload here, which is why member navigation is relayed to the formatter via the `#fieldChain`.\nclass StaticallyTypedValueNode extends ValueNode {\n  readonly #variableType: string;\n  readonly #plugin: DebuggerLanguagePlugin;\n  readonly #sourceType: SourceType;\n  readonly #base: Chrome.DevTools.EvalBase|null;\n  readonly #fieldChain: Chrome.DevTools.FieldInfo[];\n  readonly #evalOptions: SDK.RuntimeModel.EvaluationOptions;\n\n  constructor(\n      callFrame: SDK.DebuggerModel.CallFrame, plugin: DebuggerLanguagePlugin, sourceType: SourceType,\n      base: Chrome.DevTools.EvalBase|null, fieldChain: Chrome.DevTools.FieldInfo[],\n      evalOptions: SDK.RuntimeModel.EvaluationOptions, inspectableAddress: number|undefined) {\n    const typeName = sourceType.typeInfo.typeNames[0] || '<anonymous>';\n    const variableType = 'object';\n    super(\n        callFrame,\n        /* objectId=*/ undefined,\n        /* type=*/ variableType,\n        /* subtype=*/ undefined, /* value=*/ null, inspectableAddress, /* unserializableValue=*/ undefined,\n        /* description=*/ typeName, /* preview=*/ undefined, /* customPreview=*/ undefined, /* className=*/ typeName);\n    this.#variableType = variableType;\n    this.#plugin = plugin;\n    this.#sourceType = sourceType;\n    this.#base = base;\n    this.#fieldChain = fieldChain;\n    this.hasChildrenInternal = true;\n    this.#evalOptions = evalOptions;\n  }\n\n  get type(): string {\n    return this.#variableType;\n  }\n\n  private async expandMember(sourceType: SourceType, fieldInfo: Chrome.DevTools.FieldInfo):\n      Promise<SDK.RemoteObject.RemoteObject> {\n    const fieldChain = this.#fieldChain.concat(fieldInfo);\n    if (sourceType.typeInfo.hasValue && !sourceType.typeInfo.canExpand && this.#base) {\n      return formatSourceValue(this.callFrame, this.#plugin, sourceType, this.#base, fieldChain, this.#evalOptions);\n    }\n\n    const address = this.inspectableAddress !== undefined ? this.inspectableAddress + fieldInfo.offset : undefined;\n    return new StaticallyTypedValueNode(\n        this.callFrame, this.#plugin, sourceType, this.#base, fieldChain, this.#evalOptions, address);\n  }\n\n  static async getInspectableAddress(\n      callFrame: SDK.DebuggerModel.CallFrame, plugin: DebuggerLanguagePlugin, base: Chrome.DevTools.EvalBase|null,\n      field: Chrome.DevTools.FieldInfo[], evalOptions: SDK.RuntimeModel.EvaluationOptions): Promise<number|undefined> {\n    if (!base) {\n      return undefined;\n    }\n\n    const addressCode = await plugin.getInspectableAddress({base, field});\n    if (!addressCode.js) {\n      return undefined;\n    }\n    const response = await callFrame.debuggerModel.target().debuggerAgent().invoke_evaluateOnCallFrame({\n      callFrameId: callFrame.id,\n      expression: addressCode.js,\n      objectGroup: evalOptions.objectGroup,\n      includeCommandLineAPI: evalOptions.includeCommandLineAPI,\n      silent: evalOptions.silent,\n      returnByValue: true,\n      generatePreview: evalOptions.generatePreview,\n      throwOnSideEffect: evalOptions.throwOnSideEffect,\n      timeout: evalOptions.timeout,\n    });\n\n    const error = response.getError();\n    if (error) {\n      throw new Error(error);\n    }\n\n    const {result, exceptionDetails} = response;\n    if (exceptionDetails) {\n      throw new FormattingError(callFrame.debuggerModel.runtimeModel().createRemoteObject(result), exceptionDetails);\n    }\n\n    const address = result.value;\n    if (!Number.isSafeInteger(address) || address < 0) {\n      console.error(`Inspectable address is not a positive, safe integer: ${address}`);\n      return undefined;\n    }\n\n    return address;\n  }\n\n  async doGetProperties(_ownProperties: boolean, accessorPropertiesOnly: boolean, _generatePreview: boolean):\n      Promise<SDK.RemoteObject.GetPropertiesResult> {\n    const {typeInfo} = this.#sourceType;\n    if (accessorPropertiesOnly || !typeInfo.canExpand) {\n      return {properties: [], internalProperties: []} as SDK.RemoteObject.GetPropertiesResult;\n    }\n\n    if (typeInfo.members.length > 0) {\n      // This value doesn't have a formatter, but we can eagerly expand arrays in the frontend if the size is known.\n      if (typeInfo.arraySize > 0) {\n        const {typeId} = this.#sourceType.typeInfo.members[0];\n        const properties: SDK.RemoteObject.RemoteObjectProperty[] = [];\n        const elementTypeInfo = this.#sourceType.members[0];\n        for (let i = 0; i < typeInfo.arraySize; ++i) {\n          const name = `${i}`;\n          const elementField = {name, typeId, offset: elementTypeInfo.typeInfo.size * i};\n          properties.push(new SDK.RemoteObject.RemoteObjectProperty(\n              name, await this.expandMember(elementTypeInfo, elementField), /* enumerable=*/ false,\n              /* writable=*/ false,\n              /* isOwn=*/ true,\n              /* wasThrown=*/ false));\n        }\n        return {properties, internalProperties: []} as SDK.RemoteObject.GetPropertiesResult;\n      }\n\n      // The node is expanded, just make remote objects for its members\n      const members = Promise.all(this.#sourceType.members.map(async (memberTypeInfo, idx) => {\n        const fieldInfo = this.#sourceType.typeInfo.members[idx];\n        const propertyObject = await this.expandMember(memberTypeInfo, fieldInfo);\n        const name = fieldInfo.name || '';\n        return new SDK.RemoteObject.RemoteObjectProperty(\n            name, propertyObject, /* enumerable=*/ false, /* writable=*/ false, /* isOwn=*/ true,\n            /* wasThrown=*/ false);\n      }));\n      return {properties: await members, internalProperties: []} as SDK.RemoteObject.GetPropertiesResult;\n    }\n\n    return {properties: [], internalProperties: []} as SDK.RemoteObject.GetPropertiesResult;\n  }\n}\n\nclass NamespaceObject extends SDK.RemoteObject.LocalJSONObject {\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(value: any) {\n    super(value);\n  }\n\n  get description(): string {\n    return this.type;\n  }\n\n  get type(): string {\n    return 'namespace';\n  }\n}\n\nclass SourceScopeRemoteObject extends SDK.RemoteObject.RemoteObjectImpl {\n  variables: Chrome.DevTools.Variable[];\n  #callFrame: SDK.DebuggerModel.CallFrame;\n  #plugin: DebuggerLanguagePlugin;\n\n  constructor(callFrame: SDK.DebuggerModel.CallFrame, plugin: DebuggerLanguagePlugin) {\n    super(callFrame.debuggerModel.runtimeModel(), undefined, 'object', undefined, null);\n    this.variables = [];\n    this.#callFrame = callFrame;\n    this.#plugin = plugin;\n  }\n\n  async doGetProperties(ownProperties: boolean, accessorPropertiesOnly: boolean, _generatePreview: boolean):\n      Promise<SDK.RemoteObject.GetPropertiesResult> {\n    if (accessorPropertiesOnly) {\n      return {properties: [], internalProperties: []} as SDK.RemoteObject.GetPropertiesResult;\n    }\n\n    const properties = [];\n    const namespaces: {\n      [x: string]: SDK.RemoteObject.RemoteObject,\n    } = {};\n\n    function makeProperty(name: string, obj: SDK.RemoteObject.RemoteObject): SDK.RemoteObject.RemoteObjectProperty {\n      return new SDK.RemoteObject.RemoteObjectProperty(\n          name, obj,\n          /* enumerable=*/ false, /* writable=*/ false, /* isOwn=*/ true, /* wasThrown=*/ false);\n    }\n\n    for (const variable of this.variables) {\n      let sourceVar;\n      try {\n        sourceVar = await getValueTreeForExpression(this.#callFrame, this.#plugin, variable.name, ({\n                                                      generatePreview: false,\n                                                      includeCommandLineAPI: true,\n                                                      objectGroup: 'backtrace',\n                                                      returnByValue: false,\n                                                      silent: false,\n                                                    } as SDK.RuntimeModel.EvaluationOptions));\n      } catch (e) {\n        console.warn(e);\n        sourceVar = new SDK.RemoteObject.LocalJSONObject(undefined);\n      }\n      if (variable.nestedName && variable.nestedName.length > 1) {\n        let parent: {\n          [x: string]: SDK.RemoteObject.RemoteObject,\n        } = namespaces;\n        for (let index = 0; index < variable.nestedName.length - 1; index++) {\n          const nestedName = variable.nestedName[index];\n          let child: NamespaceObject|SDK.RemoteObject.RemoteObject = parent[nestedName];\n          if (!child) {\n            child = new NamespaceObject({});\n            parent[nestedName] = child;\n          }\n          parent = child.value;\n        }\n        const name = variable.nestedName[variable.nestedName.length - 1];\n        parent[name] = sourceVar;\n      } else {\n        properties.push(makeProperty(variable.name, sourceVar));\n      }\n    }\n\n    for (const namespace in namespaces) {\n      properties.push(makeProperty(namespace, (namespaces[namespace] as SDK.RemoteObject.RemoteObject)));\n    }\n\n    return {properties: properties, internalProperties: []};\n  }\n}\n\nexport class SourceScope implements SDK.DebuggerModel.ScopeChainEntry {\n  readonly #callFrameInternal: SDK.DebuggerModel.CallFrame;\n  readonly #typeInternal: string;\n  readonly #typeNameInternal: string;\n  readonly #iconInternal: string|undefined;\n  readonly #objectInternal: SourceScopeRemoteObject;\n  readonly #startLocationInternal: SDK.DebuggerModel.Location|null;\n  readonly #endLocationInternal: SDK.DebuggerModel.Location|null;\n  constructor(\n      callFrame: SDK.DebuggerModel.CallFrame, type: string, typeName: string, icon: string|undefined,\n      plugin: DebuggerLanguagePlugin) {\n    this.#callFrameInternal = callFrame;\n    this.#typeInternal = type;\n    this.#typeNameInternal = typeName;\n    this.#iconInternal = icon;\n    this.#objectInternal = new SourceScopeRemoteObject(callFrame, plugin);\n    this.#startLocationInternal = null;\n    this.#endLocationInternal = null;\n  }\n\n  async getVariableValue(name: string): Promise<SDK.RemoteObject.RemoteObject|null> {\n    for (let v = 0; v < this.#objectInternal.variables.length; ++v) {\n      if (this.#objectInternal.variables[v].name !== name) {\n        continue;\n      }\n      const properties = await this.#objectInternal.getAllProperties(false, false);\n      if (!properties.properties) {\n        continue;\n      }\n      const {value} = properties.properties[v];\n      if (value) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  callFrame(): SDK.DebuggerModel.CallFrame {\n    return this.#callFrameInternal;\n  }\n\n  type(): string {\n    return this.#typeInternal;\n  }\n\n  typeName(): string {\n    return this.#typeNameInternal;\n  }\n\n  name(): string|undefined {\n    return undefined;\n  }\n\n  startLocation(): SDK.DebuggerModel.Location|null {\n    return this.#startLocationInternal;\n  }\n\n  endLocation(): SDK.DebuggerModel.Location|null {\n    return this.#endLocationInternal;\n  }\n\n  object(): SourceScopeRemoteObject {\n    return this.#objectInternal;\n  }\n\n  description(): string {\n    return '';\n  }\n\n  icon(): string|undefined {\n    return this.#iconInternal;\n  }\n}\n\nexport class DebuggerLanguagePluginManager implements\n    SDK.TargetManager.SDKModelObserver<SDK.DebuggerModel.DebuggerModel> {\n  readonly #workspace: Workspace.Workspace.WorkspaceImpl;\n  readonly #debuggerWorkspaceBinding: DebuggerWorkspaceBinding;\n  #plugins: DebuggerLanguagePlugin[];\n  readonly #debuggerModelToData: Map<SDK.DebuggerModel.DebuggerModel, ModelData>;\n  readonly #rawModuleHandles: Map<string, {\n    rawModuleId: string,\n    plugin: DebuggerLanguagePlugin,\n    scripts: Array<SDK.Script.Script>,\n    addRawModulePromise: Promise<Array<Platform.DevToolsPath.UrlString>|{missingSymbolFiles: string[]}>,\n  }>;\n\n  constructor(\n      targetManager: SDK.TargetManager.TargetManager, workspace: Workspace.Workspace.WorkspaceImpl,\n      debuggerWorkspaceBinding: DebuggerWorkspaceBinding) {\n    this.#workspace = workspace;\n    this.#debuggerWorkspaceBinding = debuggerWorkspaceBinding;\n\n    this.#plugins = [];\n\n    this.#debuggerModelToData = new Map();\n    targetManager.observeModels(SDK.DebuggerModel.DebuggerModel, this);\n\n    this.#rawModuleHandles = new Map();\n  }\n\n  private async evaluateOnCallFrame(\n      callFrame: SDK.DebuggerModel.CallFrame, options: SDK.RuntimeModel.EvaluationOptions): Promise<{\n    object: SDK.RemoteObject.RemoteObject,\n    exceptionDetails: Protocol.Runtime.ExceptionDetails|undefined,\n  }|{\n    error: string,\n  }|null> {\n    const {script} = callFrame;\n    const {expression} = options;\n    const {plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return null;\n    }\n    const location = getRawLocation(callFrame);\n    const sourceLocations = await plugin.rawLocationToSourceLocation(location);\n    if (sourceLocations.length === 0) {\n      return null;\n    }\n\n    try {\n      const object = await getValueTreeForExpression(callFrame, plugin, expression, options);\n      return {object, exceptionDetails: undefined};\n    } catch (error) {\n      if (error instanceof FormattingError) {\n        const {exception: object, exceptionDetails} = error;\n        return {object, exceptionDetails};\n      }\n      return {error: error.message};\n    }\n  }\n\n  private expandCallFrames(callFrames: SDK.DebuggerModel.CallFrame[]): Promise<SDK.DebuggerModel.CallFrame[]> {\n    return Promise\n        .all(callFrames.map(async callFrame => {\n          const functionInfo = await this.getFunctionInfo(callFrame.script, callFrame.location());\n          if (functionInfo) {\n            if ('frames' in functionInfo && functionInfo.frames.length) {\n              return functionInfo.frames.map(({name}, index) => callFrame.createVirtualCallFrame(index, name));\n            }\n            if ('missingSymbolFiles' in functionInfo && functionInfo.missingSymbolFiles.length) {\n              const resources = functionInfo.missingSymbolFiles;\n              const details = i18nString(UIStrings.debugSymbolsIncomplete, {PH1: callFrame.functionName});\n              callFrame.setMissingDebugInfoDetails({details, resources});\n            } else {\n              callFrame.setMissingDebugInfoDetails({\n                resources: [],\n                details: i18nString(UIStrings.failedToLoadDebugSymbolsForFunction, {PH1: callFrame.functionName}),\n              });\n            }\n          }\n          return callFrame;\n        }))\n        .then(callFrames => callFrames.flat());\n  }\n\n  modelAdded(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    this.#debuggerModelToData.set(debuggerModel, new ModelData(debuggerModel, this.#workspace));\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.GlobalObjectCleared, this.globalObjectCleared, this);\n    debuggerModel.addEventListener(SDK.DebuggerModel.Events.ParsedScriptSource, this.parsedScriptSource, this);\n    debuggerModel.setEvaluateOnCallFrameCallback(this.evaluateOnCallFrame.bind(this));\n    debuggerModel.setExpandCallFramesCallback(this.expandCallFrames.bind(this));\n  }\n\n  modelRemoved(debuggerModel: SDK.DebuggerModel.DebuggerModel): void {\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.GlobalObjectCleared, this.globalObjectCleared, this);\n    debuggerModel.removeEventListener(SDK.DebuggerModel.Events.ParsedScriptSource, this.parsedScriptSource, this);\n    debuggerModel.setEvaluateOnCallFrameCallback(null);\n    debuggerModel.setExpandCallFramesCallback(null);\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (modelData) {\n      modelData.dispose();\n      this.#debuggerModelToData.delete(debuggerModel);\n    }\n    this.#rawModuleHandles.forEach((rawModuleHandle, rawModuleId) => {\n      const scripts = rawModuleHandle.scripts.filter(script => script.debuggerModel !== debuggerModel);\n      if (scripts.length === 0) {\n        rawModuleHandle.plugin.removeRawModule(rawModuleId).catch(error => {\n          Common.Console.Console.instance().error(\n              i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n        });\n        this.#rawModuleHandles.delete(rawModuleId);\n      } else {\n        rawModuleHandle.scripts = scripts;\n      }\n    });\n  }\n\n  private globalObjectCleared(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    this.modelRemoved(debuggerModel);\n    this.modelAdded(debuggerModel);\n  }\n\n  addPlugin(plugin: DebuggerLanguagePlugin): void {\n    this.#plugins.push(plugin);\n    for (const debuggerModel of this.#debuggerModelToData.keys()) {\n      for (const script of debuggerModel.scripts()) {\n        if (this.hasPluginForScript(script)) {\n          continue;\n        }\n        this.parsedScriptSource({data: script});\n      }\n    }\n  }\n\n  removePlugin(plugin: DebuggerLanguagePlugin): void {\n    this.#plugins = this.#plugins.filter(p => p !== plugin);\n    const scripts = new Set<SDK.Script.Script>();\n    this.#rawModuleHandles.forEach((rawModuleHandle, rawModuleId) => {\n      if (rawModuleHandle.plugin !== plugin) {\n        return;\n      }\n      rawModuleHandle.scripts.forEach(script => scripts.add(script));\n      this.#rawModuleHandles.delete(rawModuleId);\n    });\n    for (const script of scripts) {\n      const modelData = (this.#debuggerModelToData.get(script.debuggerModel) as ModelData);\n      modelData.removeScript(script);\n\n      // Let's see if we have another #plugin that's happy to\n      // take this orphaned script now. This is important to\n      // get right, since the same #plugin might race during\n      // unregister/register and we might already have the\n      // new instance of the #plugin added before we remove\n      // the previous instance.\n      this.parsedScriptSource({data: script});\n    }\n  }\n\n  hasPluginForScript(script: SDK.Script.Script): boolean {\n    const rawModuleId = rawModuleIdForScript(script);\n    const rawModuleHandle = this.#rawModuleHandles.get(rawModuleId);\n    return rawModuleHandle !== undefined && rawModuleHandle.scripts.includes(script);\n  }\n\n  /**\n   * Returns the responsible language #plugin and the raw module ID for a script.\n   *\n   * This ensures that the `addRawModule` call finishes first such that the\n   * caller can immediately issue calls to the returned #plugin without the\n   * risk of racing with the `addRawModule` call. The returned #plugin will be\n   * set to undefined to indicate that there's no #plugin for the script.\n   */\n  private async rawModuleIdAndPluginForScript(script: SDK.Script.Script): Promise<{\n    rawModuleId: string,\n    plugin: DebuggerLanguagePlugin|null,\n  }> {\n    const rawModuleId = rawModuleIdForScript(script);\n    const rawModuleHandle = this.#rawModuleHandles.get(rawModuleId);\n    if (rawModuleHandle) {\n      await rawModuleHandle.addRawModulePromise;\n      if (rawModuleHandle === this.#rawModuleHandles.get(rawModuleId)) {\n        return {rawModuleId, plugin: rawModuleHandle.plugin};\n      }\n    }\n    return {rawModuleId, plugin: null};\n  }\n\n  uiSourceCodeForURL(debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString):\n      Workspace.UISourceCode.UISourceCode|null {\n    const modelData = this.#debuggerModelToData.get(debuggerModel);\n    if (modelData) {\n      return modelData.getProject().uiSourceCodeForURL(url);\n    }\n    return null;\n  }\n\n  async rawLocationToUILocation(rawLocation: SDK.DebuggerModel.Location):\n      Promise<Workspace.UISourceCode.UILocation|null> {\n    const script = rawLocation.script();\n    if (!script) {\n      return null;\n    }\n    const {rawModuleId, plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return null;\n    }\n\n    const pluginLocation = {\n      rawModuleId,\n      // RawLocation.#columnNumber is the byte offset in the full raw wasm module. Plugins expect the offset in the code\n      // section, so subtract the offset of the code section in the module here.\n      codeOffset: rawLocation.columnNumber - (script.codeOffset() || 0),\n      inlineFrameIndex: rawLocation.inlineFrameIndex,\n    };\n\n    try {\n      const sourceLocations = await plugin.rawLocationToSourceLocation(pluginLocation);\n      for (const sourceLocation of sourceLocations) {\n        const uiSourceCode = this.uiSourceCodeForURL(\n            script.debuggerModel, sourceLocation.sourceFileURL as Platform.DevToolsPath.UrlString);\n        if (!uiSourceCode) {\n          continue;\n        }\n        // Absence of column information is indicated by the value `-1` in talking to language #plugins.\n        return uiSourceCode.uiLocation(\n            sourceLocation.lineNumber, sourceLocation.columnNumber >= 0 ? sourceLocation.columnNumber : undefined);\n      }\n    } catch (error) {\n      Common.Console.Console.instance().error(\n          i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n    }\n    return null;\n  }\n\n  uiLocationToRawLocationRanges(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber: number|undefined = -1): Promise<{\n    start: SDK.DebuggerModel.Location,\n    end: SDK.DebuggerModel.Location,\n  }[]|null> {\n    const locationPromises: Promise<{\n      start: SDK.DebuggerModel.Location,\n      end: SDK.DebuggerModel.Location,\n    }[]>[] = [];\n    this.scriptsForUISourceCode(uiSourceCode).forEach(script => {\n      const rawModuleId = rawModuleIdForScript(script);\n      const rawModuleHandle = this.#rawModuleHandles.get(rawModuleId);\n      if (!rawModuleHandle) {\n        return;\n      }\n      const {plugin} = rawModuleHandle;\n      locationPromises.push(getLocations(rawModuleId, plugin, script));\n    });\n    if (locationPromises.length === 0) {\n      return Promise.resolve(null);\n    }\n\n    return Promise.all(locationPromises).then(locations => locations.flat()).catch(error => {\n      Common.Console.Console.instance().error(\n          i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n      return null;\n    });\n\n    async function getLocations(\n        rawModuleId: string, plugin: DebuggerLanguagePlugin, script: SDK.Script.Script): Promise<{\n      start: SDK.DebuggerModel.Location,\n      end: SDK.DebuggerModel.Location,\n    }[]> {\n      const pluginLocation = {rawModuleId, sourceFileURL: uiSourceCode.url(), lineNumber, columnNumber};\n\n      const rawLocations = await plugin.sourceLocationToRawLocation(pluginLocation);\n      if (!rawLocations) {\n        return [];\n      }\n      return rawLocations.map(\n          m => ({\n            start: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.startOffset) + (script.codeOffset() || 0)),\n            end: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.endOffset) + (script.codeOffset() || 0)),\n          }));\n    }\n  }\n\n  async uiLocationToRawLocations(\n      uiSourceCode: Workspace.UISourceCode.UISourceCode, lineNumber: number,\n      columnNumber?: number): Promise<SDK.DebuggerModel.Location[]|null> {\n    const locationRanges = await this.uiLocationToRawLocationRanges(uiSourceCode, lineNumber, columnNumber);\n    if (!locationRanges) {\n      return null;\n    }\n    return locationRanges.map(({start}) => start);\n  }\n\n  scriptsForUISourceCode(uiSourceCode: Workspace.UISourceCode.UISourceCode): SDK.Script.Script[] {\n    for (const modelData of this.#debuggerModelToData.values()) {\n      const scripts = modelData.uiSourceCodeToScripts.get(uiSourceCode);\n      if (scripts) {\n        return scripts;\n      }\n    }\n    return [];\n  }\n\n  private parsedScriptSource(event: Common.EventTarget.EventTargetEvent<SDK.Script.Script>): void {\n    const script = event.data;\n    if (!script.sourceURL) {\n      return;\n    }\n\n    for (const plugin of this.#plugins) {\n      if (!plugin.handleScript(script)) {\n        return;\n      }\n      const rawModuleId = rawModuleIdForScript(script);\n      let rawModuleHandle = this.#rawModuleHandles.get(rawModuleId);\n      if (!rawModuleHandle) {\n        const sourceFileURLsPromise =\n            (async(): Promise<Platform.DevToolsPath.UrlString[]|{missingSymbolFiles: string[]}> => {\n              const console = Common.Console.Console.instance();\n              const url = script.sourceURL;\n              const symbolsUrl = (script.debugSymbols && script.debugSymbols.externalURL) || '';\n              if (symbolsUrl) {\n                console.log(\n                    i18nString(UIStrings.loadingDebugSymbolsForVia, {PH1: plugin.name, PH2: url, PH3: symbolsUrl}));\n              } else {\n                console.log(i18nString(UIStrings.loadingDebugSymbolsFor, {PH1: plugin.name, PH2: url}));\n              }\n              try {\n                const code = (!symbolsUrl && url.startsWith('wasm://')) ? await script.getWasmBytecode() : undefined;\n                const addModuleResult = await plugin.addRawModule(rawModuleId, symbolsUrl, {url, code});\n                // Check that the handle isn't stale by now. This works because the code that assigns to\n                // `rawModuleHandle` below will run before this code because of the `await` in the preceding\n                // line. This is primarily to avoid logging the message below, which would give the developer\n                // the misleading information that we're done, while in reality it was a stale call that finished.\n                if (rawModuleHandle !== this.#rawModuleHandles.get(rawModuleId)) {\n                  return [];\n                }\n                if ('missingSymbolFiles' in addModuleResult) {\n                  return {missingSymbolFiles: addModuleResult.missingSymbolFiles};\n                }\n                const sourceFileURLs = addModuleResult as Platform.DevToolsPath.UrlString[];\n                if (sourceFileURLs.length === 0) {\n                  console.warn(i18nString(UIStrings.loadedDebugSymbolsForButDidnt, {PH1: plugin.name, PH2: url}));\n                } else {\n                  console.log(i18nString(\n                      UIStrings.loadedDebugSymbolsForFound, {PH1: plugin.name, PH2: url, PH3: sourceFileURLs.length}));\n                }\n                return sourceFileURLs;\n              } catch (error) {\n                console.error(i18nString(\n                    UIStrings.failedToLoadDebugSymbolsFor, {PH1: plugin.name, PH2: url, PH3: error.message}));\n                this.#rawModuleHandles.delete(rawModuleId);\n                return [];\n              }\n            })();\n        rawModuleHandle = {rawModuleId, plugin, scripts: [script], addRawModulePromise: sourceFileURLsPromise};\n        this.#rawModuleHandles.set(rawModuleId, rawModuleHandle);\n      } else {\n        rawModuleHandle.scripts.push(script);\n      }\n\n      // Wait for the addRawModule call to finish and\n      // update the #project. It's important to check\n      // for the DebuggerModel again, which may disappear\n      // in the meantime...\n      void rawModuleHandle.addRawModulePromise.then(sourceFileURLs => {\n        if (!('missingSymbolFiles' in sourceFileURLs)) {\n          // The script might have disappeared meanwhile...\n          if (script.debuggerModel.scriptForId(script.scriptId) === script) {\n            const modelData = this.#debuggerModelToData.get(script.debuggerModel);\n            if (modelData) {  // The DebuggerModel could have disappeared meanwhile...\n              modelData.addSourceFiles(script, sourceFileURLs);\n              void this.#debuggerWorkspaceBinding.updateLocations(script);\n            }\n          }\n        }\n      });\n      return;\n    }\n  }\n\n  getSourcesForScript(script: SDK.Script.Script):\n      Promise<Array<Platform.DevToolsPath.UrlString>|{missingSymbolFiles: string[]}|undefined> {\n    const rawModuleId = rawModuleIdForScript(script);\n    const rawModuleHandle = this.#rawModuleHandles.get(rawModuleId);\n    if (rawModuleHandle) {\n      return rawModuleHandle.addRawModulePromise;\n    }\n    return Promise.resolve(undefined);\n  }\n\n  async resolveScopeChain(callFrame: SDK.DebuggerModel.CallFrame): Promise<SourceScope[]|null> {\n    const script = callFrame.script;\n    const {rawModuleId, plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return null;\n    }\n\n    const location = {\n      rawModuleId,\n      codeOffset: callFrame.location().columnNumber - (script.codeOffset() || 0),\n      inlineFrameIndex: callFrame.inlineFrameIndex,\n    };\n\n    try {\n      const sourceMapping = await plugin.rawLocationToSourceLocation(location);\n      if (sourceMapping.length === 0) {\n        return null;\n      }\n      const scopes = new Map<string, SourceScope>();\n      const variables = await plugin.listVariablesInScope(location);\n      for (const variable of variables || []) {\n        let scope = scopes.get(variable.scope);\n        if (!scope) {\n          const {type, typeName, icon} = await plugin.getScopeInfo(variable.scope);\n          scope = new SourceScope(callFrame, type, typeName, icon, plugin);\n          scopes.set(variable.scope, scope);\n        }\n        scope.object().variables.push(variable);\n      }\n      return Array.from(scopes.values());\n    } catch (error) {\n      Common.Console.Console.instance().error(\n          i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n      return null;\n    }\n  }\n\n  async getFunctionInfo(script: SDK.Script.Script, location: SDK.DebuggerModel.Location):\n      Promise<{frames: Array<Chrome.DevTools.FunctionInfo>}|{missingSymbolFiles: string[]}|null> {\n    const {rawModuleId, plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return null;\n    }\n\n    const rawLocation: Chrome.DevTools.RawLocation = {\n      rawModuleId,\n      codeOffset: location.columnNumber - (script.codeOffset() || 0),\n      inlineFrameIndex: 0,\n    };\n\n    try {\n      const functionInfo = await plugin.getFunctionInfo(rawLocation);\n      return functionInfo;\n    } catch (error) {\n      Common.Console.Console.instance().warn(i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n      return {frames: []};\n    }\n  }\n\n  async getInlinedFunctionRanges(rawLocation: SDK.DebuggerModel.Location): Promise<{\n    start: SDK.DebuggerModel.Location,\n    end: SDK.DebuggerModel.Location,\n  }[]> {\n    const script = rawLocation.script();\n    if (!script) {\n      return [];\n    }\n    const {rawModuleId, plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return [];\n    }\n\n    const pluginLocation = {\n      rawModuleId,\n      // RawLocation.#columnNumber is the byte offset in the full raw wasm module. Plugins expect the offset in the code\n      // section, so subtract the offset of the code section in the module here.\n      codeOffset: rawLocation.columnNumber - (script.codeOffset() || 0),\n    };\n\n    try {\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // @ts-ignore\n      const locations = await plugin.getInlinedFunctionRanges(pluginLocation);\n      return locations.map(\n          m => ({\n            start: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.startOffset) + (script.codeOffset() || 0)),\n            end: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.endOffset) + (script.codeOffset() || 0)),\n          }));\n    } catch (error) {\n      Common.Console.Console.instance().warn(i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n      return [];\n    }\n  }\n\n  async getInlinedCalleesRanges(rawLocation: SDK.DebuggerModel.Location): Promise<{\n    start: SDK.DebuggerModel.Location,\n    end: SDK.DebuggerModel.Location,\n  }[]> {\n    const script = rawLocation.script();\n    if (!script) {\n      return [];\n    }\n    const {rawModuleId, plugin} = await this.rawModuleIdAndPluginForScript(script);\n    if (!plugin) {\n      return [];\n    }\n\n    const pluginLocation = {\n      rawModuleId,\n      // RawLocation.#columnNumber is the byte offset in the full raw wasm module. Plugins expect the offset in the code\n      // section, so subtract the offset of the code section in the module here.\n      codeOffset: rawLocation.columnNumber - (script.codeOffset() || 0),\n    };\n\n    try {\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // @ts-ignore\n      const locations = await plugin.getInlinedCalleesRanges(pluginLocation);\n      return locations.map(\n          m => ({\n            start: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.startOffset) + (script.codeOffset() || 0)),\n            end: new SDK.DebuggerModel.Location(\n                script.debuggerModel, script.scriptId, 0, Number(m.endOffset) + (script.codeOffset() || 0)),\n          }));\n    } catch (error) {\n      Common.Console.Console.instance().warn(i18nString(UIStrings.errorInDebuggerLanguagePlugin, {PH1: error.message}));\n      return [];\n    }\n  }\n\n  async getMappedLines(uiSourceCode: Workspace.UISourceCode.UISourceCode): Promise<Set<number>|undefined> {\n    const rawModuleIds =\n        await Promise.all(this.scriptsForUISourceCode(uiSourceCode).map(s => this.rawModuleIdAndPluginForScript(s)));\n\n    let mappedLines: Set<number>|undefined;\n    for (const {rawModuleId, plugin} of rawModuleIds) {\n      if (!plugin) {\n        continue;\n      }\n      const lines = await plugin.getMappedLines(rawModuleId, uiSourceCode.url());\n\n      if (lines === undefined) {\n        continue;\n      }\n      if (mappedLines === undefined) {\n        mappedLines = new Set(lines);\n      } else {\n        /**\n         * @param {number} l\n         */\n        lines.forEach(l => (mappedLines as Set<number>).add(l));\n      }\n    }\n    return mappedLines;\n  }\n}\n\nclass ModelData {\n  project: ContentProviderBasedProject;\n  readonly uiSourceCodeToScripts: Map<Workspace.UISourceCode.UISourceCode, SDK.Script.Script[]>;\n  constructor(debuggerModel: SDK.DebuggerModel.DebuggerModel, workspace: Workspace.Workspace.WorkspaceImpl) {\n    this.project = new ContentProviderBasedProject(\n        workspace, 'language_plugins::' + debuggerModel.target().id(), Workspace.Workspace.projectTypes.Network, '',\n        false /* isServiceProject */);\n    NetworkProject.setTargetForProject(this.project, debuggerModel.target());\n\n    this.uiSourceCodeToScripts = new Map();\n  }\n\n  addSourceFiles(script: SDK.Script.Script, urls: Platform.DevToolsPath.UrlString[]): void {\n    const initiator = script.createPageResourceLoadInitiator();\n    for (const url of urls) {\n      let uiSourceCode = this.project.uiSourceCodeForURL(url);\n      if (!uiSourceCode) {\n        uiSourceCode = this.project.createUISourceCode(url, Common.ResourceType.resourceTypes.SourceMapScript);\n        NetworkProject.setInitialFrameAttribution(uiSourceCode, script.frameId);\n\n        // Bind the uiSourceCode to the script first before we add the\n        // uiSourceCode to the #project and thereby notify the rest of\n        // the system about the new source file.\n        // https://crbug.com/1150295 is an example where the breakpoint\n        // resolution logic kicks in right after adding the uiSourceCode\n        // and at that point we already need to have the mapping in place\n        // otherwise we will not get the breakpoint right.\n        this.uiSourceCodeToScripts.set(uiSourceCode, [script]);\n\n        const contentProvider = new SDK.CompilerSourceMappingContentProvider.CompilerSourceMappingContentProvider(\n            url, Common.ResourceType.resourceTypes.SourceMapScript, initiator);\n        const mimeType = Common.ResourceType.ResourceType.mimeFromURL(url) || 'text/javascript';\n        this.project.addUISourceCodeWithProvider(uiSourceCode, contentProvider, null, mimeType);\n      } else {\n        // The same uiSourceCode can be provided by different scripts,\n        // but we don't expect that to happen frequently.\n        const scripts = (this.uiSourceCodeToScripts.get(uiSourceCode) as SDK.Script.Script[]);\n        if (!scripts.includes(script)) {\n          scripts.push(script);\n        }\n      }\n    }\n  }\n\n  removeScript(script: SDK.Script.Script): void {\n    this.uiSourceCodeToScripts.forEach((scripts, uiSourceCode) => {\n      scripts = scripts.filter(s => s !== script);\n      if (scripts.length === 0) {\n        this.uiSourceCodeToScripts.delete(uiSourceCode);\n        this.project.removeUISourceCode(uiSourceCode.url());\n      } else {\n        this.uiSourceCodeToScripts.set(uiSourceCode, scripts);\n      }\n    });\n  }\n\n  dispose(): void {\n    this.project.dispose();\n  }\n\n  getProject(): ContentProviderBasedProject {\n    return this.project;\n  }\n}\n\nexport class DebuggerLanguagePlugin implements Chrome.DevTools.LanguageExtensionPlugin {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  handleScript(_script: SDK.Script.Script): boolean {\n    throw new Error('Not implemented yet');\n  }\n\n  dispose(): void {\n  }\n\n  /** Notify the #plugin about a new script\n    */\n  async addRawModule(_rawModuleId: string, _symbolsURL: string, _rawModule: Chrome.DevTools.RawModule):\n      Promise<string[]|{missingSymbolFiles: string[]}> {\n    throw new Error('Not implemented yet');\n  }\n\n  /** Find #locations in raw modules from a #location in a source file\n    */\n  async sourceLocationToRawLocation(_sourceLocation: Chrome.DevTools.SourceLocation):\n      Promise<Chrome.DevTools.RawLocationRange[]> {\n    throw new Error('Not implemented yet');\n  }\n\n  /** Find #locations in source files from a #location in a raw module\n    */\n  async rawLocationToSourceLocation(_rawLocation: Chrome.DevTools.RawLocation):\n      Promise<Chrome.DevTools.SourceLocation[]> {\n    throw new Error('Not implemented yet');\n  }\n\n  /** Return detailed information about a scope\n     */\n  async getScopeInfo(_type: string): Promise<Chrome.DevTools.ScopeInfo> {\n    throw new Error('Not implemented yet');\n  }\n\n  /** List all variables in lexical scope at a given #location in a raw module\n    */\n  async listVariablesInScope(_rawLocation: Chrome.DevTools.RawLocation): Promise<Chrome.DevTools.Variable[]> {\n    throw new Error('Not implemented yet');\n  }\n\n  /**\n   * Notifies the #plugin that a script is removed.\n   */\n  removeRawModule(_rawModuleId: string): Promise<void> {\n    throw new Error('Not implemented yet');\n  }\n\n  getTypeInfo(_expression: string, _context: Chrome.DevTools.RawLocation): Promise<{\n    typeInfos: Array<Chrome.DevTools.TypeInfo>,\n    base: Chrome.DevTools.EvalBase,\n  }|null> {\n    throw new Error('Not implemented yet');\n  }\n\n  getFormatter(\n      _expressionOrField: string|{\n        base: Chrome.DevTools.EvalBase,\n        field: Array<Chrome.DevTools.FieldInfo>,\n      },\n      _context: Chrome.DevTools.RawLocation): Promise<{\n    js: string,\n  }|null> {\n    throw new Error('Not implemented yet');\n  }\n\n  getInspectableAddress(_field: {\n    base: Chrome.DevTools.EvalBase,\n    field: Array<Chrome.DevTools.FieldInfo>,\n  }): Promise<{\n    js: string,\n  }> {\n    throw new Error('Not implemented yet');\n  }\n\n  /**\n   * Find #locations in source files from a #location in a raw module\n   */\n  async getFunctionInfo(_rawLocation: Chrome.DevTools.RawLocation):\n      Promise<{frames: Array<Chrome.DevTools.FunctionInfo>}|{missingSymbolFiles: string[]}> {\n    throw new Error('Not implemented yet');\n  }\n\n  /**\n   * Find #locations in raw modules corresponding to the inline function\n   * that rawLocation is in. Used for stepping out of an inline function.\n   */\n  async getInlinedFunctionRanges(_rawLocation: Chrome.DevTools.RawLocation):\n      Promise<Chrome.DevTools.RawLocationRange[]> {\n    throw new Error('Not implemented yet');\n  }\n\n  /**\n   * Find #locations in raw modules corresponding to inline functions\n   * called by the function or inline frame that rawLocation is in.\n   * Used for stepping over inline functions.\n   */\n  async getInlinedCalleesRanges(_rawLocation: Chrome.DevTools.RawLocation):\n      Promise<Chrome.DevTools.RawLocationRange[]> {\n    throw new Error('Not implemented yet');\n  }\n\n  async getMappedLines(_rawModuleId: string, _sourceFileURL: string): Promise<number[]|undefined> {\n    throw new Error('Not implemented yet');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
