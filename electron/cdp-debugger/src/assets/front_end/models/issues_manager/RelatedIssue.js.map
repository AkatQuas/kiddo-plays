{
  "version": 3,
  "sources": ["../../../../../../front_end/models/issues_manager/RelatedIssue.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type {Issue, IssueCategory} from './Issue.js';\nimport {IssuesManager} from './IssuesManager.js';\n\nexport type IssuesAssociatable = SDK.NetworkRequest.NetworkRequest|SDK.Cookie.Cookie|string;\n\nfunction issuesAssociatedWithNetworkRequest(issues: Issue[], request: SDK.NetworkRequest.NetworkRequest): Issue[] {\n  return issues.filter(issue => {\n    for (const affectedRequest of issue.requests()) {\n      if (affectedRequest.requestId === request.requestId()) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nfunction issuesAssociatedWithCookie(issues: Issue[], domain: string, name: string, path: string): Issue[] {\n  return issues.filter(issue => {\n    for (const cookie of issue.cookies()) {\n      if (cookie.domain === domain && cookie.name === name && cookie.path === path) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\n/**\n * @throws In case obj has an unsupported type (i.e. not part of the IssuesAssociatble union).\n */\nexport function issuesAssociatedWith(issues: Issue[], obj: IssuesAssociatable): Issue[] {\n  if (obj instanceof SDK.NetworkRequest.NetworkRequest) {\n    return issuesAssociatedWithNetworkRequest(issues, obj);\n  }\n  if (obj instanceof SDK.Cookie.Cookie) {\n    return issuesAssociatedWithCookie(issues, obj.domain(), obj.name(), obj.path());\n  }\n  throw new Error(`issues can not be associated with ${JSON.stringify(obj)}`);\n}\n\nexport function hasIssues(obj: IssuesAssociatable): boolean {\n  const issues = Array.from(IssuesManager.instance().issues());\n  return issuesAssociatedWith(issues, obj).length > 0;\n}\n\nexport function hasIssueOfCategory(obj: IssuesAssociatable, category: IssueCategory): boolean {\n  const issues = Array.from(IssuesManager.instance().issues());\n  return issuesAssociatedWith(issues, obj).some(issue => issue.getCategory() === category);\n}\n\nexport async function reveal(obj: IssuesAssociatable, category?: IssueCategory): Promise<void|undefined> {\n  if (typeof obj === 'string') {\n    const issue = IssuesManager.instance().getIssueById(obj);\n    if (issue) {\n      return Common.Revealer.reveal(issue);\n    }\n  }\n  const issues = Array.from(IssuesManager.instance().issues());\n  const candidates = issuesAssociatedWith(issues, obj).filter(issue => !category || issue.getCategory() === category);\n  if (candidates.length > 0) {\n    return Common.Revealer.reveal(candidates[0]);\n  }\n}\n"],
  "mappings": "AAIA;AACA;AAEA;AAIA,4CAA4C,QAAiB,SAAqD;AAChH,SAAO,OAAO,OAAO,WAAS;AAC5B,eAAW,mBAAmB,MAAM,YAAY;AAC9C,UAAI,gBAAgB,cAAc,QAAQ,aAAa;AACrD,eAAO;AAAA;AAAA;AAGX,WAAO;AAAA;AAAA;AAIX,oCAAoC,QAAiB,QAAgB,MAAc,MAAuB;AACxG,SAAO,OAAO,OAAO,WAAS;AAC5B,eAAW,UAAU,MAAM,WAAW;AACpC,UAAI,OAAO,WAAW,UAAU,OAAO,SAAS,QAAQ,OAAO,SAAS,MAAM;AAC5E,eAAO;AAAA;AAAA;AAGX,WAAO;AAAA;AAAA;AAOJ,qCAA8B,QAAiB,KAAkC;AACtF,MAAI,eAAe,IAAI,eAAe,gBAAgB;AACpD,WAAO,mCAAmC,QAAQ;AAAA;AAEpD,MAAI,eAAe,IAAI,OAAO,QAAQ;AACpC,WAAO,2BAA2B,QAAQ,IAAI,UAAU,IAAI,QAAQ,IAAI;AAAA;AAE1E,QAAM,IAAI,MAAM,qCAAqC,KAAK,UAAU;AAAA;AAG/D,0BAAmB,KAAkC;AAC1D,QAAM,SAAS,MAAM,KAAK,cAAc,WAAW;AACnD,SAAO,qBAAqB,QAAQ,KAAK,SAAS;AAAA;AAG7C,mCAA4B,KAAyB,UAAkC;AAC5F,QAAM,SAAS,MAAM,KAAK,cAAc,WAAW;AACnD,SAAO,qBAAqB,QAAQ,KAAK,KAAK,WAAS,MAAM,kBAAkB;AAAA;AAGjF,6BAA6B,KAAyB,UAAmD;AACvG,MAAI,OAAO,QAAQ,UAAU;AAC3B,UAAM,QAAQ,cAAc,WAAW,aAAa;AACpD,QAAI,OAAO;AACT,aAAO,OAAO,SAAS,OAAO;AAAA;AAAA;AAGlC,QAAM,SAAS,MAAM,KAAK,cAAc,WAAW;AACnD,QAAM,aAAa,qBAAqB,QAAQ,KAAK,OAAO,WAAS,CAAC,YAAY,MAAM,kBAAkB;AAC1G,MAAI,WAAW,SAAS,GAAG;AACzB,WAAO,OAAO,SAAS,OAAO,WAAW;AAAA;AAAA;",
  "names": []
}
