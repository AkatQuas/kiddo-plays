{
  "version": 3,
  "sources": ["../../../../../../front_end/models/issues_manager/MarkdownIssueDescription.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Marked from '../../third_party/marked/marked.js';\n\n/**\n * The description that subclasses of `Issue` use define the issue appearance:\n * `file` specifies the markdown file, substitutions can be used to replace\n * placeholders with, e.g. URLs. The `links` property is used to specify the\n * links at the bottom of the issue.\n */\nexport interface MarkdownIssueDescription {\n  file: string;\n  substitutions?: Map<string, string>;\n  links: {link: string, linkTitle: string}[];\n}\n\nexport interface LazyMarkdownIssueDescription {\n  file: string;\n  substitutions?: Map<string, () => string>;\n  links: {link: string, linkTitle: () => string}[];\n}\n\n/**\n * A lazy version of the description. Allows to specify a description as a\n * constant and at the same time delays resolution of the substitutions\n * and/or link titles to allow localization.\n */\nexport function resolveLazyDescription(lazyDescription: LazyMarkdownIssueDescription): MarkdownIssueDescription {\n  function linksMap(currentLink: {link: string, linkTitle: () => string}): {link: string, linkTitle: string} {\n    return {link: currentLink.link, linkTitle: currentLink.linkTitle()};\n  }\n\n  const substitutionMap = new Map();\n  lazyDescription.substitutions?.forEach((value, key) => {\n    substitutionMap.set(key, value());\n  });\n\n  const description = {\n    file: lazyDescription.file,\n    links: lazyDescription.links.map(linksMap),\n    substitutions: substitutionMap,\n  };\n  return description;\n}\n\n/**\n * A loaded and parsed issue description. This is usually obtained by loading\n * a `MarkdownIssueDescription` via `createIssueDescriptionFromMarkdown`.\n */\nexport interface IssueDescription {\n  title: string;\n  markdown: Marked.Marked.Token[];\n  links: {link: string, linkTitle: string}[];\n}\n\nexport async function getFileContent(url: URL): Promise<string> {\n  try {\n    const response = await fetch(url.toString());\n    return response.text();\n  } catch (error) {\n    throw new Error(\n        `Markdown file ${url.toString()} not found. Make sure it is correctly listed in the relevant BUILD.gn files.`);\n  }\n}\n\nexport async function getMarkdownFileContent(filename: string): Promise<string> {\n  return getFileContent(new URL(`descriptions/${filename}`, import.meta.url));\n}\n\nexport async function createIssueDescriptionFromMarkdown(description: MarkdownIssueDescription):\n    Promise<IssueDescription> {\n  const rawMarkdown = await getMarkdownFileContent(description.file);\n  const rawMarkdownWithPlaceholdersReplaced = substitutePlaceholders(rawMarkdown, description.substitutions);\n  return createIssueDescriptionFromRawMarkdown(rawMarkdownWithPlaceholdersReplaced, description);\n}\n\n/**\n * This function is exported separately for unit testing.\n */\nexport function createIssueDescriptionFromRawMarkdown(\n    markdown: string, description: MarkdownIssueDescription): IssueDescription {\n  const markdownAst = Marked.Marked.lexer(markdown);\n  const title = findTitleFromMarkdownAst(markdownAst);\n  if (!title) {\n    throw new Error('Markdown issue descriptions must start with a heading');\n  }\n\n  return {\n    title,\n    markdown: markdownAst.slice(1),\n    links: description.links,\n  };\n}\n\nconst validPlaceholderMatchPattern = /\\{(PLACEHOLDER_[a-zA-Z][a-zA-Z0-9]*)\\}/g;\nconst validPlaceholderNamePattern = /PLACEHOLDER_[a-zA-Z][a-zA-Z0-9]*/;\n\n/**\n * Replaces placeholders in markdown text with a string provided by the\n * `substitutions` map. To keep mental overhead to a minimum, the same\n * syntax is used as for l10n placeholders. Please note that the\n * placeholders require a mandatory 'PLACEHOLDER_' prefix.\n *\n * Example:\n *   const str = \"This is markdown with `code` and two placeholders, namely {PLACEHOLDER_PH1} and {PLACEHOLDER_PH2}\".\n *   const result = substitePlaceholders(str, new Map([['PLACEHOLDER_PH1', 'foo'], ['PLACEHOLDER_PH2', 'bar']]));\n *\n * Exported only for unit testing.\n */\nexport function substitutePlaceholders(markdown: string, substitutions?: Map<string, string>): string {\n  const unusedPlaceholders = new Set(substitutions ? substitutions.keys() : []);\n  validatePlaceholders(unusedPlaceholders);\n\n  const result = markdown.replace(validPlaceholderMatchPattern, (_, placeholder) => {\n    const replacement = substitutions ? substitutions.get(placeholder) : undefined;\n    if (!replacement) {\n      throw new Error(`No replacment provided for placeholder '${placeholder}'.`);\n    }\n    unusedPlaceholders.delete(placeholder);\n    return replacement;\n  });\n\n  if (unusedPlaceholders.size > 0) {\n    throw new Error(`Unused replacements provided: ${[...unusedPlaceholders]}`);\n  }\n\n  return result;\n}\n\n// Ensure that all provided placeholders match the naming pattern.\nfunction validatePlaceholders(placeholders: Set<string>): void {\n  const invalidPlaceholders = [...placeholders].filter(placeholder => !validPlaceholderNamePattern.test(placeholder));\n  if (invalidPlaceholders.length > 0) {\n    throw new Error(`Invalid placeholders provided in the substitutions map: ${invalidPlaceholders}`);\n  }\n}\n\nexport function findTitleFromMarkdownAst(markdownAst: Marked.Marked.Token[]): string|null {\n  if (markdownAst.length === 0 || markdownAst[0].type !== 'heading' || markdownAst[0].depth !== 1) {\n    return null;\n  }\n  return markdownAst[0].text;\n}\n\nexport async function getIssueTitleFromMarkdownDescription(description: MarkdownIssueDescription):\n    Promise<string|null> {\n  const rawMarkdown = await getMarkdownFileContent(description.file);\n  const markdownAst = Marked.Marked.lexer(rawMarkdown);\n  return findTitleFromMarkdownAst(markdownAst);\n}\n"],
  "mappings": "AAIA;AAyBO,uCAAgC,iBAAyE;AAC9G,oBAAkB,aAAyF;AACzG,WAAO,EAAC,MAAM,YAAY,MAAM,WAAW,YAAY;AAAA;AAGzD,QAAM,kBAAkB,oBAAI;AAC5B,kBAAgB,eAAe,QAAQ,CAAC,OAAO,QAAQ;AACrD,oBAAgB,IAAI,KAAK;AAAA;AAG3B,QAAM,cAAc;AAAA,IAClB,MAAM,gBAAgB;AAAA,IACtB,OAAO,gBAAgB,MAAM,IAAI;AAAA,IACjC,eAAe;AAAA;AAEjB,SAAO;AAAA;AAaT,qCAAqC,KAA2B;AAC9D,MAAI;AACF,UAAM,WAAW,MAAM,MAAM,IAAI;AACjC,WAAO,SAAS;AAAA,WACT,OAAP;AACA,UAAM,IAAI,MACN,iBAAiB,IAAI;AAAA;AAAA;AAI7B,6CAA6C,UAAmC;AAC9E,SAAO,eAAe,IAAI,IAAI,gBAAgB,YAAY,YAAY;AAAA;AAGxE,yDAAyD,aAC3B;AAC5B,QAAM,cAAc,MAAM,uBAAuB,YAAY;AAC7D,QAAM,sCAAsC,uBAAuB,aAAa,YAAY;AAC5F,SAAO,sCAAsC,qCAAqC;AAAA;AAM7E,sDACH,UAAkB,aAAyD;AAC7E,QAAM,cAAc,OAAO,OAAO,MAAM;AACxC,QAAM,QAAQ,yBAAyB;AACvC,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM;AAAA;AAGlB,SAAO;AAAA,IACL;AAAA,IACA,UAAU,YAAY,MAAM;AAAA,IAC5B,OAAO,YAAY;AAAA;AAAA;AAIvB,MAAM,+BAA+B;AACrC,MAAM,8BAA8B;AAc7B,uCAAgC,UAAkB,eAA6C;AACpG,QAAM,qBAAqB,IAAI,IAAI,gBAAgB,cAAc,SAAS;AAC1E,uBAAqB;AAErB,QAAM,SAAS,SAAS,QAAQ,8BAA8B,CAAC,GAAG,gBAAgB;AAChF,UAAM,cAAc,gBAAgB,cAAc,IAAI,eAAe;AACrE,QAAI,CAAC,aAAa;AAChB,YAAM,IAAI,MAAM,2CAA2C;AAAA;AAE7D,uBAAmB,OAAO;AAC1B,WAAO;AAAA;AAGT,MAAI,mBAAmB,OAAO,GAAG;AAC/B,UAAM,IAAI,MAAM,iCAAiC,CAAC,GAAG;AAAA;AAGvD,SAAO;AAAA;AAIT,8BAA8B,cAAiC;AAC7D,QAAM,sBAAsB,CAAC,GAAG,cAAc,OAAO,iBAAe,CAAC,4BAA4B,KAAK;AACtG,MAAI,oBAAoB,SAAS,GAAG;AAClC,UAAM,IAAI,MAAM,2DAA2D;AAAA;AAAA;AAIxE,yCAAkC,aAAiD;AACxF,MAAI,YAAY,WAAW,KAAK,YAAY,GAAG,SAAS,aAAa,YAAY,GAAG,UAAU,GAAG;AAC/F,WAAO;AAAA;AAET,SAAO,YAAY,GAAG;AAAA;AAGxB,2DAA2D,aAClC;AACvB,QAAM,cAAc,MAAM,uBAAuB,YAAY;AAC7D,QAAM,cAAc,OAAO,OAAO,MAAM;AACxC,SAAO,yBAAyB;AAAA;",
  "names": []
}
