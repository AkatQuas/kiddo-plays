{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/media/TickingFlameChart.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as ThemeSupport from '../../ui/legacy/theme_support/theme_support.js';\n\nimport {Bounds, formatMillisecondsToSeconds} from './TickingFlameChartHelpers.js';\n\nconst defaultFont = '11px ' + Host.Platform.fontFamily();\nconst defaultColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n\nconst DefaultStyle = {\n  height: 20,\n  padding: 2,\n  collapsible: false,\n  font: defaultFont,\n  color: defaultColor,\n  backgroundColor: 'rgba(100 0 0 / 10%)',\n  nestingLevel: 0,\n  itemsHeight: 20,\n  shareHeaderLine: false,\n  useFirstLineForOverview: false,\n  useDecoratorsForOverview: false,\n};\n\nexport const HotColorScheme = ['#ffba08', '#faa307', '#f48c06', '#e85d04', '#dc2f02', '#d00000', '#9d0208'];\nexport const ColdColorScheme = ['#7400b8', '#6930c3', '#5e60ce', '#5390d9', '#4ea8de', '#48bfe3', '#56cfe1', '#64dfdf'];\n\nfunction calculateFontColor(backgroundColor: string): string {\n  const parsedColor = Common.Color.Color.parse(backgroundColor);\n  // Dark background needs a light font.\n  if (parsedColor && parsedColor.hsla()[2] < 0.5) {\n    return '#eee';\n  }\n  return '#444';\n}\n\ninterface EventHandlers {\n  setLive: (arg0: number) => number;\n  setComplete: (arg0: number) => void;\n  updateMaxTime: (arg0: number) => void;\n}\n\nexport interface EventProperties {\n  level: number;\n  startTime: number;\n  duration?: number;\n  name: string;\n  color?: string;\n  hoverData?: Object|null;\n}\n\n/**\n * Wrapper class for each event displayed on the timeline.\n */\nexport class Event {\n  private timelineData: PerfUI.FlameChart.TimelineData;\n  private setLive: (arg0: number) => number;\n  private readonly setComplete: (arg0: number) => void;\n  private readonly updateMaxTime: (arg0: number) => void;\n  private selfIndex: number;\n  private liveInternal: boolean;\n  title: string;\n  private colorInternal: string;\n  private fontColorInternal: string;\n  private readonly hoverData: Object;\n\n  constructor(\n      timelineData: PerfUI.FlameChart.TimelineData, eventHandlers: EventHandlers,\n      eventProperties: EventProperties|\n      undefined = {color: undefined, duration: undefined, hoverData: {}, level: 0, name: '', startTime: 0}) {\n    // These allow the event to privately change it's own data in the timeline.\n    this.timelineData = timelineData;\n    this.setLive = eventHandlers.setLive;\n    this.setComplete = eventHandlers.setComplete;\n    this.updateMaxTime = eventHandlers.updateMaxTime;\n\n    // This is the index in the timelineData arrays we should be writing to.\n    this.selfIndex = this.timelineData.entryLevels.length;\n    this.liveInternal = false;\n\n    // Can't use the dict||or||default syntax, since NaN is a valid expected duration.\n    const duration = eventProperties['duration'] === undefined ? 0 : eventProperties['duration'];\n\n    (this.timelineData.entryLevels as number[]).push(eventProperties['level'] || 0);\n    (this.timelineData.entryStartTimes as number[]).push(eventProperties['startTime'] || 0);\n    (this.timelineData.entryTotalTimes as number[]).push(duration);  // May initially push -1\n\n    // If -1 was pushed, we need to update it. The set end time method helps with this.\n    if (duration === -1) {\n      this.endTime = -1;\n    }\n\n    this.title = eventProperties['name'] || '';\n    this.colorInternal = eventProperties['color'] || HotColorScheme[0];\n    this.fontColorInternal = calculateFontColor(this.colorInternal);\n    this.hoverData = eventProperties['hoverData'] || {};\n  }\n\n  /**\n   * Render hovertext into the |htmlElement|\n   */\n  decorate(htmlElement: HTMLElement): void {\n    htmlElement.createChild('span').textContent = `Name: ${this.title}`;\n    htmlElement.createChild('br');\n\n    const startTimeReadable = formatMillisecondsToSeconds(this.startTime, 2);\n    if (this.liveInternal) {\n      htmlElement.createChild('span').textContent = `Duration: ${startTimeReadable} - LIVE!`;\n    } else if (!isNaN(this.duration)) {\n      const durationReadable = formatMillisecondsToSeconds(this.duration + this.startTime, 2);\n      htmlElement.createChild('span').textContent = `Duration: ${startTimeReadable} - ${durationReadable}`;\n    } else {\n      htmlElement.createChild('span').textContent = `Time: ${startTimeReadable}`;\n    }\n  }\n\n  /**\n   * set an event to be \"live\" where it's ended time is always the chart maximum\n   * or to be a fixed time.\n   * @param {number} time\n   */\n  set endTime(time: number) {\n    // Setting end time to -1 signals that an event becomes live\n    if (time === -1) {\n      this.timelineData.entryTotalTimes[this.selfIndex] = this.setLive(this.selfIndex);\n      this.liveInternal = true;\n    } else {\n      this.liveInternal = false;\n      const duration = time - this.timelineData.entryStartTimes[this.selfIndex];\n      this.timelineData.entryTotalTimes[this.selfIndex] = duration;\n      this.setComplete(this.selfIndex);\n      this.updateMaxTime(time);\n    }\n  }\n\n  get id(): number {\n    return this.selfIndex;\n  }\n\n  set level(level: number) {\n    this.timelineData.entryLevels[this.selfIndex] = level;\n  }\n\n  set color(color: string) {\n    this.colorInternal = color;\n    this.fontColorInternal = calculateFontColor(this.colorInternal);\n  }\n\n  get color(): string {\n    return this.colorInternal;\n  }\n\n  get fontColor(): string {\n    return this.fontColorInternal;\n  }\n\n  get startTime(): number {\n    // Round it\n    return this.timelineData.entryStartTimes[this.selfIndex];\n  }\n\n  get duration(): number {\n    return this.timelineData.entryTotalTimes[this.selfIndex];\n  }\n\n  get live(): boolean {\n    return this.liveInternal;\n  }\n}\n\nexport class TickingFlameChart extends UI.Widget.VBox {\n  private intervalTimer: number;\n  private lastTimestamp: number;\n  private canTickInternal: boolean;\n  private ticking: boolean;\n  private isShown: boolean;\n  private readonly bounds: Bounds;\n  private readonly dataProvider: TickingFlameChartDataProvider;\n  private readonly delegate: TickingFlameChartDelegate;\n  private readonly chartGroupExpansionSetting: Common.Settings.Setting<Object>;\n  private readonly chart: PerfUI.FlameChart.FlameChart;\n  private stoppedPermanently?: boolean;\n\n  constructor() {\n    super();\n\n    // set to update once per second _while the tab is active_\n    this.intervalTimer = 0;\n    this.lastTimestamp = 0;\n    this.canTickInternal = true;\n    this.ticking = false;\n    this.isShown = false;\n\n    // The max bounds for scroll-out.\n    this.bounds = new Bounds(0, 1000, 30000, 1000);\n\n    // Create the data provider with the initial max bounds,\n    // as well as a function to attempt bounds updating everywhere.\n    this.dataProvider = new TickingFlameChartDataProvider(this.bounds, this.updateMaxTime.bind(this));\n\n    // Delegate doesn't do much for now.\n    this.delegate = new TickingFlameChartDelegate();\n\n    // Chart settings.\n    this.chartGroupExpansionSetting =\n        Common.Settings.Settings.instance().createSetting('mediaFlameChartGroupExpansion', {});\n\n    // Create the chart.\n    this.chart =\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n        // @ts-expect-error\n        new PerfUI.FlameChart.FlameChart(this.dataProvider, this.delegate, this.chartGroupExpansionSetting);\n\n    // TODO: needs to have support in the delegate for supporting this.\n    this.chart.disableRangeSelection();\n\n    // Scrolling should change the current bounds, and repaint the chart.\n    this.chart.bindCanvasEvent('wheel', e => {\n      this.onScroll(e as WheelEvent);\n    });\n\n    // Add the chart.\n    this.chart.show(this.contentElement);\n  }\n\n  /**\n   * Add a marker with |properties| at |time|.\n   */\n  addMarker(properties: EventProperties): void {\n    properties['duration'] = NaN;\n    this.startEvent(properties);\n  }\n\n  /**\n   * Create an event which will be set to live by default.\n   */\n  startEvent(properties: EventProperties): Event {\n    // Make sure that an unspecified event gets live duration.\n    // Have to check for undefined, since NaN is allowed but evaluates to false.\n    if (properties['duration'] === undefined) {\n      properties['duration'] = -1;\n    }\n    const time = properties['startTime'] || 0;\n\n    // Event has to be created before the updateMaxTime call.\n    const event = this.dataProvider.startEvent(properties);\n\n    this.updateMaxTime(time);\n    return event;\n  }\n\n  /**\n   * Add a group with |name| that can contain |depth| different tracks.\n   */\n  addGroup(name: Common.UIString.LocalizedString, depth: number): void {\n    this.dataProvider.addGroup(name, depth);\n  }\n\n  private updateMaxTime(time: number): void {\n    if (this.bounds.pushMaxAtLeastTo(time)) {\n      this.updateRender();\n    }\n  }\n\n  private onScroll(e: WheelEvent): void {\n    // TODO: is this a good divisor? does it account for high presicision scroll wheels?\n    // low precisision scroll wheels?\n    const scrollTickCount = Math.round(e.deltaY / 50);\n    const scrollPositionRatio = e.offsetX / (e.srcElement as HTMLElement).clientWidth;\n    if (scrollTickCount > 0) {\n      this.bounds.zoomOut(scrollTickCount, scrollPositionRatio);\n    } else {\n      this.bounds.zoomIn(-scrollTickCount, scrollPositionRatio);\n    }\n    this.updateRender();\n  }\n\n  willHide(): void {\n    this.isShown = false;\n    if (this.ticking) {\n      this.stop();\n    }\n  }\n\n  wasShown(): void {\n    this.isShown = true;\n    if (this.canTickInternal && !this.ticking) {\n      this.start();\n    }\n  }\n\n  set canTick(allowed: boolean) {\n    this.canTickInternal = allowed;\n    if (this.ticking && !allowed) {\n      this.stop();\n    }\n    if (!this.ticking && this.isShown && allowed) {\n      this.start();\n    }\n  }\n\n  private start(): void {\n    if (this.lastTimestamp === 0) {\n      this.lastTimestamp = Date.now();\n    }\n    if (this.intervalTimer !== 0 || this.stoppedPermanently) {\n      return;\n    }\n    // 16 ms is roughly 60 fps.\n    this.intervalTimer = window.setInterval(this.updateRender.bind(this), 16);\n    this.ticking = true;\n  }\n\n  private stop(permanently: boolean = false): void {\n    window.clearInterval(this.intervalTimer);\n    this.intervalTimer = 0;\n    if (permanently) {\n      this.stoppedPermanently = true;\n    }\n    this.ticking = false;\n  }\n\n  private updateRender(): void {\n    if (this.ticking) {\n      const currentTimestamp = Date.now();\n      const duration = currentTimestamp - this.lastTimestamp;\n      this.lastTimestamp = currentTimestamp;\n      this.bounds.addMax(duration);\n    }\n    this.dataProvider.updateMaxTime(this.bounds);\n    this.chart.setWindowTimes(this.bounds.low, this.bounds.high, true);\n    this.chart.scheduleUpdate();\n  }\n}\n\n/**\n * Doesn't do much right now, but can be used in the future for selecting events.\n */\nclass TickingFlameChartDelegate implements PerfUI.FlameChart.FlameChartDelegate {\n  constructor() {\n  }\n\n  windowChanged(_windowStartTime: number, _windowEndTime: number, _animate: boolean): void {\n  }\n\n  updateRangeSelection(_startTime: number, _endTime: number): void {\n  }\n\n  updateSelectedGroup(_flameChart: PerfUI.FlameChart.FlameChart, _group: PerfUI.FlameChart.Group|null): void {\n  }\n}\n\nclass TickingFlameChartDataProvider implements PerfUI.FlameChart.FlameChartDataProvider {\n  private readonly updateMaxTimeHandle: (arg0: number) => void;\n  private bounds: Bounds;\n  private readonly liveEvents: Set<number>;\n  private eventMap: Map<number, Event>;\n  private readonly timelineDataInternal: PerfUI.FlameChart.TimelineData;\n  private maxLevel: number;\n\n  constructor(initialBounds: Bounds, updateMaxTime: (arg0: number) => void) {\n    // do _not_ call this method from within this class - only for passing to events.\n    this.updateMaxTimeHandle = updateMaxTime;\n\n    this.bounds = initialBounds;\n\n    // All the events which should have their time updated when the chart ticks.\n    this.liveEvents = new Set();\n\n    // All events.\n    // Map<Event>\n    this.eventMap = new Map();\n\n    // Contains the numerical indicies. This is passed as a reference to the events\n    // so that they can update it when they change.\n    this.timelineDataInternal = new PerfUI.FlameChart.TimelineData([], [], [], []);\n\n    // The current sum of all group heights.\n    this.maxLevel = 0;\n  }\n\n  /**\n   * Add a group with |name| that can contain |depth| different tracks.\n   */\n  addGroup(name: Common.UIString.LocalizedString, depth: number): void {\n    if (this.timelineDataInternal.groups) {\n      this.timelineDataInternal.groups.push({\n        name: name,\n        startLevel: this.maxLevel,\n        expanded: true,\n        selectable: false,\n        style: DefaultStyle,\n        track: null,\n      });\n    }\n    this.maxLevel += depth;\n  }\n\n  /**\n   * Create an event which will be set to live by default.\n   */\n  startEvent(properties: EventProperties): Event {\n    properties['level'] = properties['level'] || 0;\n    if (properties['level'] > this.maxLevel) {\n      throw `level ${properties['level']} is above the maximum allowed of ${this.maxLevel}`;\n    }\n\n    const event = new Event(\n        this.timelineDataInternal, {\n          setLive: this.setLive.bind(this),\n          setComplete: this.setComplete.bind(this),\n          updateMaxTime: this.updateMaxTimeHandle,\n        },\n        properties);\n\n    this.eventMap.set(event.id, event);\n    return event;\n  }\n\n  private setLive(index: number): number {\n    this.liveEvents.add(index);\n    return this.bounds.max;\n  }\n\n  private setComplete(index: number): void {\n    this.liveEvents.delete(index);\n  }\n\n  updateMaxTime(bounds: Bounds): void {\n    this.bounds = bounds;\n    for (const eventID of this.liveEvents.entries()) {\n      // force recalculation of all live events.\n      (this.eventMap.get(eventID[0]) as Event).endTime = -1;\n    }\n  }\n\n  maxStackDepth(): number {\n    return this.maxLevel + 1;\n  }\n\n  timelineData(): PerfUI.FlameChart.TimelineData {\n    return this.timelineDataInternal;\n  }\n\n  /** time in milliseconds\n     */\n  minimumBoundary(): number {\n    return this.bounds.low;\n  }\n\n  totalTime(): number {\n    return this.bounds.high;\n  }\n\n  entryColor(index: number): string {\n    return (this.eventMap.get(index) as Event).color;\n  }\n\n  textColor(index: number): string {\n    return (this.eventMap.get(index) as Event).fontColor;\n  }\n\n  entryTitle(index: number): string|null {\n    return (this.eventMap.get(index) as Event).title;\n  }\n\n  entryFont(_index: number): string|null {\n    return defaultFont;\n  }\n\n  decorateEntry(\n      _index: number, _context: CanvasRenderingContext2D, _text: string|null, _barX: number, _barY: number,\n      _barWidth: number, _barHeight: number, _unclippedBarX: number, _timeToPixelRatio: number): boolean {\n    return false;\n  }\n\n  forceDecoration(_index: number): boolean {\n    return false;\n  }\n\n  prepareHighlightedEntryInfo(index: number): Element|null {\n    const element = document.createElement('div');\n    (this.eventMap.get(index) as Event).decorate(element);\n    return element;\n  }\n\n  formatValue(value: number, _precision?: number): string {\n    // value is always [0, X] so we need to add lower bound\n    value += Math.round(this.bounds.low);\n\n    // Magic numbers of pre-calculated logorithms.\n\n    // we want to show additional decimals at the time when two adjacent labels\n    // would otherwise show the same number. At 3840 pixels wide, that cutoff\n    // happens to be about 30 seconds for one decimal and 2.8 for two decimals.\n    if (this.bounds.range < 2800) {\n      return formatMillisecondsToSeconds(value, 2);\n    }\n    if (this.bounds.range < 30000) {\n      return formatMillisecondsToSeconds(value, 1);\n    }\n    return formatMillisecondsToSeconds(value, 0);\n  }\n\n  canJumpToEntry(_entryIndex: number): boolean {\n    return false;\n  }\n\n  navStartTimes(): Map<string, SDK.TracingModel.Event> {\n    return new Map();\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
