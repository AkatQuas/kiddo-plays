{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/media/EventTimelineView.ts"],
  "sourcesContent": ["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\n\nimport type {PlayerEvent} from './MediaModel.js';\nimport type {Event, EventProperties} from './TickingFlameChart.js';\nimport {ColdColorScheme, HotColorScheme, TickingFlameChart} from './TickingFlameChart.js';\n\n// Has to be a double, see https://v8.dev/blog/react-cliff\nconst NO_NORMALIZED_TIMESTAMP = -1.5;\n\nconst UIStrings = {\n  /**\n  *@description Title of the 'Playback Status' button\n  */\n  playbackStatus: 'Playback Status',\n  /**\n  *@description Title of the 'Buffering Status' button\n  */\n  bufferingStatus: 'Buffering Status',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/media/EventTimelineView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\ntype State = {\n  [key: string]: string,\n};\n\nexport class PlayerEventsTimeline extends TickingFlameChart {\n  private normalizedTimestamp: number;\n  private playbackStatusLastEvent: Event|null;\n  private audioBufferingStateEvent: Event|null;\n  private videoBufferingStateEvent: Event|null;\n\n  constructor() {\n    super();\n\n    this.normalizedTimestamp = NO_NORMALIZED_TIMESTAMP;\n\n    this.addGroup(i18nString(UIStrings.playbackStatus), 2);\n    this.addGroup(i18nString(UIStrings.bufferingStatus), 2);  // video on top, audio on bottom\n\n    this.playbackStatusLastEvent = null;\n    this.audioBufferingStateEvent = null;\n    this.videoBufferingStateEvent = null;\n  }\n\n  private ensureNoPreviousPlaybackEvent(normalizedTime: number): void {\n    if (this.playbackStatusLastEvent !== null) {\n      this.playbackStatusLastEvent.endTime = normalizedTime;\n      this.playbackStatusLastEvent = null;\n    }\n  }\n\n  /**\n   * Playback events are {kPlay, kPause, kSuspended, kEnded, and kWebMediaPlayerDestroyed}\n   * once destroyed, a player cannot recieve more events of any kind.\n   */\n  private onPlaybackEvent(event: PlayerEvent, normalizedTime: number): void {\n    switch (event.event) {\n      case 'kPlay':\n        this.canTick = true;\n        this.ensureNoPreviousPlaybackEvent(normalizedTime);\n\n        // Disabled until Closure is gone.\n        // clang-format off\n        this.playbackStatusLastEvent = this.startEvent({\n          level: 0,\n          startTime: normalizedTime,\n          name: 'Play',\n        } as EventProperties);\n        // clang-format on\n        break;\n\n      case 'kPause':\n        // Don't change ticking state - the player is still active even during\n        // video pause. It may recieve buffering events, seeks, etc.\n        this.ensureNoPreviousPlaybackEvent(normalizedTime);\n\n        // Disabled until Closure is gone.\n        // clang-format off\n        this.playbackStatusLastEvent = this.startEvent({\n          level: 0,\n          startTime: normalizedTime,\n          name: 'Pause',\n          color: HotColorScheme[1],\n        } as EventProperties);\n        // clang-format on\n        break;\n\n      case 'kWebMediaPlayerDestroyed':\n        this.canTick = false;\n        this.ensureNoPreviousPlaybackEvent(normalizedTime);\n        this.addMarker({\n          level: 1,\n          startTime: normalizedTime,\n          name: 'Destroyed',\n          color: HotColorScheme[4],\n        } as EventProperties);\n        // clang-format on\n        break;\n\n      case 'kSuspended':\n        // Other event's can't happen during suspension or while the player is\n        // destroyed, so stop the ticking.\n        this.canTick = false;\n        this.ensureNoPreviousPlaybackEvent(normalizedTime);\n\n        // Disabled until Closure is gone.\n        // clang-format off\n        this.playbackStatusLastEvent = this.startEvent({\n          level: 1,\n          startTime: normalizedTime,\n          name: 'Suspended',\n          color: HotColorScheme[3],\n        } as EventProperties);\n        // clang-format on\n        break;\n\n      case 'kEnded':\n        // Player ending can still have seeks & other events.\n        this.ensureNoPreviousPlaybackEvent(normalizedTime);\n\n        // Disabled until Closure is gone.\n        // clang-format off\n        this.playbackStatusLastEvent = this.startEvent({\n          level: 1,\n          startTime: normalizedTime,\n          name: 'Ended',\n          color: HotColorScheme[2],\n        } as EventProperties);\n        // clang-format on\n        break;\n\n      default:\n        throw `_onPlaybackEvent cant handle ${event.event}`;\n    }\n  }\n\n  private bufferedEnough(state: State): boolean {\n    return state['state'] === 'BUFFERING_HAVE_ENOUGH';\n  }\n\n  private onBufferingStatus(event: PlayerEvent, normalizedTime: number): void {\n    // No declarations inside the case labels.\n    let audioState: State|null = null;\n    let videoState: State|null = null;\n\n    switch (event.event) {\n      case 'kBufferingStateChanged':\n        // There are three allowed entries, audio, video, and pipeline.\n        // We only want the buffering for audio and video to be displayed.\n        // One event may have changes for a single type, or for both audio/video\n        // simultaneously.\n        // @ts-ignore\n        audioState = event.value['audio_buffering_state'];\n        // @ts-ignore\n        videoState = event.value['video_buffering_state'];\n\n        if (audioState) {\n          if (this.audioBufferingStateEvent !== null) {\n            this.audioBufferingStateEvent.endTime = normalizedTime;\n            this.audioBufferingStateEvent = null;\n          }\n          if (!this.bufferedEnough(audioState)) {\n            this.audioBufferingStateEvent = this.startEvent({\n              level: 3,\n              startTime: normalizedTime,\n              name: 'Audio Buffering',\n              color: ColdColorScheme[1],\n            } as EventProperties);\n          }\n        }\n\n        if (videoState) {\n          if (this.videoBufferingStateEvent !== null) {\n            this.videoBufferingStateEvent.endTime = normalizedTime;\n            this.videoBufferingStateEvent = null;\n          }\n          if (!this.bufferedEnough(videoState)) {\n            this.videoBufferingStateEvent = this.startEvent({\n              level: 2,\n              startTime: normalizedTime,\n              name: 'Video Buffering',\n              color: ColdColorScheme[0],\n            } as EventProperties);\n          }\n        }\n        break;\n\n      default:\n        throw `_onPlaybackEvent cant handle ${event.event}`;\n    }\n  }\n\n  onEvent(event: PlayerEvent): void {\n    if (this.normalizedTimestamp === NO_NORMALIZED_TIMESTAMP) {\n      this.normalizedTimestamp = Number(event.timestamp);\n    }\n    const inMilliseconds = (Number(event.timestamp) - this.normalizedTimestamp) * 1000;\n\n    switch (event.event) {\n      case 'kPlay':\n      case 'kPause':\n      case 'kWebMediaPlayerDestroyed':\n      case 'kSuspended':\n      case 'kEnded':\n        return this.onPlaybackEvent(event, inMilliseconds);\n\n      case 'kBufferingStateChanged':\n        return this.onBufferingStatus(event, inMilliseconds);\n\n      default:\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
