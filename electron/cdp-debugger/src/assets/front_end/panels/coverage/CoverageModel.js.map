{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/coverage/CoverageModel.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Bindings from '../../models/bindings/bindings.js';\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport const enum CoverageType {\n  CSS = (1 << 0),\n  JavaScript = (1 << 1),\n  JavaScriptPerFunction = (1 << 2),\n}\n\nexport const enum SuspensionState {\n  Active = 'Active',\n  Suspending = 'Suspending',\n  Suspended = 'Suspended',\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  CoverageUpdated = 'CoverageUpdated',\n  CoverageReset = 'CoverageReset',\n}\n\nexport type EventTypes = {\n  [Events.CoverageUpdated]: CoverageInfo[],\n  [Events.CoverageReset]: void,\n};\n\nconst COVERAGE_POLLING_PERIOD_MS: number = 200;\n\ninterface BacklogItem<T> {\n  rawCoverageData: Array<T>;\n  stamp: number;\n}\n\nexport class CoverageModel extends SDK.SDKModel.SDKModel<EventTypes> {\n  private cpuProfilerModel: SDK.CPUProfilerModel.CPUProfilerModel|null;\n  private cssModel: SDK.CSSModel.CSSModel|null;\n  private debuggerModel: SDK.DebuggerModel.DebuggerModel|null;\n  private coverageByURL: Map<Platform.DevToolsPath.UrlString, URLCoverageInfo>;\n  private coverageByContentProvider: Map<TextUtils.ContentProvider.ContentProvider, CoverageInfo>;\n  private coverageUpdateTimes: Set<number>;\n  private suspensionState: SuspensionState;\n  private pollTimer: number|null;\n  private currentPollPromise: Promise<void>|null;\n  private shouldResumePollingOnResume: boolean|null;\n  private jsBacklog: BacklogItem<Protocol.Profiler.ScriptCoverage>[];\n  private cssBacklog: BacklogItem<Protocol.CSS.RuleUsage>[];\n  private performanceTraceRecording: boolean|null;\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.cpuProfilerModel = target.model(SDK.CPUProfilerModel.CPUProfilerModel);\n    this.cssModel = target.model(SDK.CSSModel.CSSModel);\n    this.debuggerModel = target.model(SDK.DebuggerModel.DebuggerModel);\n\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n\n    // We keep track of the update times, because the other data-structures don't change if an\n    // update doesn't change the coverage. Some visualizations want to convey to the user that\n    // an update was received at a certain time, but did not result in a coverage change.\n    this.coverageUpdateTimes = new Set();\n\n    this.suspensionState = SuspensionState.Active;\n    this.pollTimer = null;\n    this.currentPollPromise = null;\n    this.shouldResumePollingOnResume = false;\n    this.jsBacklog = [];\n    this.cssBacklog = [];\n    this.performanceTraceRecording = false;\n  }\n\n  async start(jsCoveragePerBlock: boolean): Promise<boolean> {\n    if (this.suspensionState !== SuspensionState.Active) {\n      throw Error('Cannot start CoverageModel while it is not active.');\n    }\n    const promises = [];\n    if (this.cssModel) {\n      // Note there's no JS coverage since JS won't ever return\n      // coverage twice, even after it's restarted.\n      this.clearCSS();\n\n      this.cssModel.addEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n      promises.push(this.cssModel.startCoverage());\n    }\n    if (this.cpuProfilerModel) {\n      promises.push(\n          this.cpuProfilerModel.startPreciseCoverage(jsCoveragePerBlock, this.preciseCoverageDeltaUpdate.bind(this)));\n    }\n\n    await Promise.all(promises);\n    return Boolean(this.cssModel || this.cpuProfilerModel);\n  }\n\n  preciseCoverageDeltaUpdate(timestamp: number, occasion: string, coverageData: Protocol.Profiler.ScriptCoverage[]):\n      void {\n    this.coverageUpdateTimes.add(timestamp);\n    void this.backlogOrProcessJSCoverage(coverageData, timestamp);\n  }\n\n  async stop(): Promise<void> {\n    await this.stopPolling();\n    const promises = [];\n    if (this.cpuProfilerModel) {\n      promises.push(this.cpuProfilerModel.stopPreciseCoverage());\n    }\n    if (this.cssModel) {\n      promises.push(this.cssModel.stopCoverage());\n      this.cssModel.removeEventListener(SDK.CSSModel.Events.StyleSheetAdded, this.handleStyleSheetAdded, this);\n    }\n    await Promise.all(promises);\n  }\n\n  reset(): void {\n    this.coverageByURL = new Map();\n    this.coverageByContentProvider = new Map();\n    this.coverageUpdateTimes = new Set();\n    this.dispatchEventToListeners(Events.CoverageReset);\n  }\n\n  async startPolling(): Promise<void> {\n    if (this.currentPollPromise || this.suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    await this.pollLoop();\n  }\n\n  private async pollLoop(): Promise<void> {\n    this.clearTimer();\n    this.currentPollPromise = this.pollAndCallback();\n    await this.currentPollPromise;\n    if (this.suspensionState === SuspensionState.Active || this.performanceTraceRecording) {\n      this.pollTimer = window.setTimeout(() => this.pollLoop(), COVERAGE_POLLING_PERIOD_MS);\n    }\n  }\n\n  async stopPolling(): Promise<void> {\n    this.clearTimer();\n    await this.currentPollPromise;\n    this.currentPollPromise = null;\n    // Do one last poll to get the final data.\n    await this.pollAndCallback();\n  }\n\n  private async pollAndCallback(): Promise<void> {\n    if (this.suspensionState === SuspensionState.Suspended && !this.performanceTraceRecording) {\n      return;\n    }\n    const updates = await this.takeAllCoverage();\n    // This conditional should never trigger, as all intended ways to stop\n    // polling are awaiting the `_currentPollPromise` before suspending.\n    console.assert(\n        this.suspensionState !== SuspensionState.Suspended || Boolean(this.performanceTraceRecording),\n        'CoverageModel was suspended while polling.');\n    if (updates.length) {\n      this.dispatchEventToListeners(Events.CoverageUpdated, updates);\n    }\n  }\n\n  private clearTimer(): void {\n    if (this.pollTimer) {\n      clearTimeout(this.pollTimer);\n      this.pollTimer = null;\n    }\n  }\n\n  /**\n   * Stops polling as preparation for suspension. This function is idempotent\n   * due because it changes the state to suspending.\n   */\n  async preSuspendModel(reason?: string): Promise<void> {\n    if (this.suspensionState !== SuspensionState.Active) {\n      return;\n    }\n    this.suspensionState = SuspensionState.Suspending;\n    if (reason === 'performance-timeline') {\n      this.performanceTraceRecording = true;\n      // Keep polling to the backlog if a performance trace is recorded.\n      return;\n    }\n    if (this.currentPollPromise) {\n      await this.stopPolling();\n      this.shouldResumePollingOnResume = true;\n    }\n  }\n\n  async suspendModel(_reason?: string): Promise<void> {\n    this.suspensionState = SuspensionState.Suspended;\n  }\n\n  async resumeModel(): Promise<void> {\n  }\n\n  /**\n   * Restarts polling after suspension. Note that the function is idempotent\n   * because starting polling is idempotent.\n   */\n  async postResumeModel(): Promise<void> {\n    this.suspensionState = SuspensionState.Active;\n    this.performanceTraceRecording = false;\n    if (this.shouldResumePollingOnResume) {\n      this.shouldResumePollingOnResume = false;\n      await this.startPolling();\n    }\n  }\n\n  entries(): URLCoverageInfo[] {\n    return Array.from(this.coverageByURL.values());\n  }\n\n  getCoverageForUrl(url: Platform.DevToolsPath.UrlString): URLCoverageInfo|null {\n    return this.coverageByURL.get(url) || null;\n  }\n\n  usageForRange(contentProvider: TextUtils.ContentProvider.ContentProvider, startOffset: number, endOffset: number):\n      boolean|undefined {\n    const coverageInfo = this.coverageByContentProvider.get(contentProvider);\n    return coverageInfo && coverageInfo.usageForRange(startOffset, endOffset);\n  }\n\n  private clearCSS(): void {\n    for (const entry of this.coverageByContentProvider.values()) {\n      if (entry.type() !== CoverageType.CSS) {\n        continue;\n      }\n      const contentProvider = entry.getContentProvider() as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      this.coverageByContentProvider.delete(contentProvider);\n      const urlEntry = this.coverageByURL.get(entry.url());\n      if (!urlEntry) {\n        continue;\n      }\n      const key = `${contentProvider.startLine}:${contentProvider.startColumn}`;\n      urlEntry.removeCoverageEntry(key, entry);\n      if (urlEntry.numberOfEntries() === 0) {\n        this.coverageByURL.delete(entry.url());\n      }\n    }\n\n    if (this.cssModel) {\n      for (const styleSheetHeader of this.cssModel.getAllStyleSheetHeaders()) {\n        this.addStyleSheetToCSSCoverage(styleSheetHeader);\n      }\n    }\n  }\n\n  private async takeAllCoverage(): Promise<CoverageInfo[]> {\n    const [updatesCSS, updatesJS] = await Promise.all([this.takeCSSCoverage(), this.takeJSCoverage()]);\n    return [...updatesCSS, ...updatesJS];\n  }\n\n  private async takeJSCoverage(): Promise<CoverageInfo[]> {\n    if (!this.cpuProfilerModel) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cpuProfilerModel.takePreciseCoverage();\n    this.coverageUpdateTimes.add(timestamp);\n    return this.backlogOrProcessJSCoverage(coverage, timestamp);\n  }\n\n  getCoverageUpdateTimes(): Set<number> {\n    return this.coverageUpdateTimes;\n  }\n\n  private async backlogOrProcessJSCoverage(\n      freshRawCoverageData: Protocol.Profiler.ScriptCoverage[], freshTimestamp: number): Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.jsBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.jsBacklog.sort(ascendingByTimestamp)) {\n      results.push(this.processJSCoverage(rawCoverageData, stamp));\n    }\n    this.jsBacklog = [];\n    return results.flat();\n  }\n\n  async processJSBacklog(): Promise<void> {\n    void this.backlogOrProcessJSCoverage([], 0);\n  }\n\n  private processJSCoverage(scriptsCoverage: Protocol.Profiler.ScriptCoverage[], stamp: number): CoverageInfo[] {\n    if (!this.debuggerModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    for (const entry of scriptsCoverage) {\n      const script = this.debuggerModel.scriptForId(entry.scriptId);\n      if (!script) {\n        continue;\n      }\n\n      const ranges = [];\n      let type = CoverageType.JavaScript;\n      for (const func of entry.functions) {\n        // Do not coerce undefined to false, i.e. only consider blockLevel to be false\n        // if back-end explicitly provides blockLevel field, otherwise presume blockLevel\n        // coverage is not available. Also, ignore non-block level functions that weren't\n        // ever called.\n        if (func.isBlockCoverage === false && !(func.ranges.length === 1 && !func.ranges[0].count)) {\n          type |= CoverageType.JavaScriptPerFunction;\n        }\n        for (const range of func.ranges) {\n          ranges.push(range);\n        }\n      }\n      const subentry = this.addCoverage(\n          script, script.contentLength, script.lineOffset, script.columnOffset, ranges, type as CoverageType, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private handleStyleSheetAdded(\n      event: Common.EventTarget.EventTargetEvent<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader>): void {\n    this.addStyleSheetToCSSCoverage(event.data);\n  }\n\n  private async takeCSSCoverage(): Promise<CoverageInfo[]> {\n    // Don't poll if we have no model, or are suspended.\n    if (!this.cssModel || this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const {coverage, timestamp} = await this.cssModel.takeCoverageDelta();\n    this.coverageUpdateTimes.add(timestamp);\n    return this.backlogOrProcessCSSCoverage(coverage, timestamp);\n  }\n\n  private async backlogOrProcessCSSCoverage(freshRawCoverageData: Protocol.CSS.RuleUsage[], freshTimestamp: number):\n      Promise<CoverageInfo[]> {\n    if (freshRawCoverageData.length > 0) {\n      this.cssBacklog.push({rawCoverageData: freshRawCoverageData, stamp: freshTimestamp});\n    }\n    if (this.suspensionState !== SuspensionState.Active) {\n      return [];\n    }\n    const ascendingByTimestamp = (x: {stamp: number}, y: {stamp: number}): number => x.stamp - y.stamp;\n    const results = [];\n    for (const {rawCoverageData, stamp} of this.cssBacklog.sort(ascendingByTimestamp)) {\n      results.push(this.processCSSCoverage(rawCoverageData, stamp));\n    }\n    this.cssBacklog = [];\n    return results.flat();\n  }\n\n  private processCSSCoverage(ruleUsageList: Protocol.CSS.RuleUsage[], stamp: number): CoverageInfo[] {\n    if (!this.cssModel) {\n      return [];\n    }\n    const updatedEntries = [];\n    const rulesByStyleSheet = new Map<SDK.CSSStyleSheetHeader.CSSStyleSheetHeader, RangeUseCount[]>();\n    for (const rule of ruleUsageList) {\n      const styleSheetHeader = this.cssModel.styleSheetHeaderForId(rule.styleSheetId);\n      if (!styleSheetHeader) {\n        continue;\n      }\n      let ranges = rulesByStyleSheet.get(styleSheetHeader);\n      if (!ranges) {\n        ranges = [];\n        rulesByStyleSheet.set(styleSheetHeader, ranges);\n      }\n      ranges.push({startOffset: rule.startOffset, endOffset: rule.endOffset, count: Number(rule.used)});\n    }\n    for (const entry of rulesByStyleSheet) {\n      const styleSheetHeader = entry[0] as SDK.CSSStyleSheetHeader.CSSStyleSheetHeader;\n      const ranges = entry[1] as RangeUseCount[];\n      const subentry = this.addCoverage(\n          styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn,\n          ranges, CoverageType.CSS, stamp);\n      if (subentry) {\n        updatedEntries.push(subentry);\n      }\n    }\n    return updatedEntries;\n  }\n\n  private static convertToDisjointSegments(ranges: RangeUseCount[], stamp: number): CoverageSegment[] {\n    ranges.sort((a, b) => a.startOffset - b.startOffset);\n\n    const result: CoverageSegment[] = [];\n    const stack = [];\n    for (const entry of ranges) {\n      let top: RangeUseCount = stack[stack.length - 1];\n      while (top && top.endOffset <= entry.startOffset) {\n        append(top.endOffset, top.count);\n        stack.pop();\n        top = stack[stack.length - 1];\n      }\n      append(entry.startOffset, top ? top.count : 0);\n      stack.push(entry);\n    }\n\n    for (let top = stack.pop(); top; top = stack.pop()) {\n      append(top.endOffset, top.count);\n    }\n\n    function append(end: number, count: number): void {\n      const last = result[result.length - 1];\n      if (last) {\n        if (last.end === end) {\n          return;\n        }\n        if (last.count === count) {\n          last.end = end;\n          return;\n        }\n      }\n      result.push({end: end, count: count, stamp: stamp});\n    }\n\n    return result;\n  }\n\n  private addStyleSheetToCSSCoverage(styleSheetHeader: SDK.CSSStyleSheetHeader.CSSStyleSheetHeader): void {\n    this.addCoverage(\n        styleSheetHeader, styleSheetHeader.contentLength, styleSheetHeader.startLine, styleSheetHeader.startColumn, [],\n        CoverageType.CSS, Date.now());\n  }\n\n  private addCoverage(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, startLine: number,\n      startColumn: number, ranges: RangeUseCount[], type: CoverageType, stamp: number): CoverageInfo|null {\n    const url = contentProvider.contentURL();\n    if (!url) {\n      return null;\n    }\n    let urlCoverage = this.coverageByURL.get(url);\n    let isNewUrlCoverage = false;\n    if (!urlCoverage) {\n      isNewUrlCoverage = true;\n      urlCoverage = new URLCoverageInfo(url);\n      this.coverageByURL.set(url, urlCoverage);\n    }\n\n    const coverageInfo = urlCoverage.ensureEntry(contentProvider, contentLength, startLine, startColumn, type);\n    this.coverageByContentProvider.set(contentProvider, coverageInfo);\n    const segments = CoverageModel.convertToDisjointSegments(ranges, stamp);\n    const last = segments[segments.length - 1];\n    if (last && last.end < contentLength) {\n      segments.push({end: contentLength, stamp: stamp, count: 0});\n    }\n    const usedSizeDelta = coverageInfo.mergeCoverage(segments);\n    if (!isNewUrlCoverage && usedSizeDelta === 0) {\n      return null;\n    }\n    urlCoverage.addToSizes(usedSizeDelta, 0);\n    return coverageInfo;\n  }\n\n  async exportReport(fos: Bindings.FileUtils.FileOutputStream): Promise<void> {\n    const result: {url: string, ranges: {start: number, end: number}[], text: string|null}[] = [];\n    const coverageByUrlKeys = Array.from(this.coverageByURL.keys()).sort();\n    for (const urlInfoKey of coverageByUrlKeys) {\n      const urlInfo = this.coverageByURL.get(urlInfoKey);\n      if (!urlInfo) {\n        continue;\n      }\n      const url = urlInfo.url();\n      if (url.startsWith('extensions::') || url.startsWith('chrome-extension://')) {\n        continue;\n      }\n      result.push(...await urlInfo.entriesForExport());\n    }\n    await fos.write(JSON.stringify(result, undefined, 2));\n    void fos.close();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(CoverageModel, {capabilities: SDK.Target.Capability.None, autostart: false});\n\nexport interface EntryForExport {\n  url: Platform.DevToolsPath.UrlString;\n  ranges: {start: number, end: number}[];\n  text: string|null;\n}\n\nfunction locationCompare(a: string, b: string): number {\n  const [aLine, aPos] = a.split(':');\n  const [bLine, bPos] = b.split(':');\n  return Number.parseInt(aLine, 10) - Number.parseInt(bLine, 10) ||\n      Number.parseInt(aPos, 10) - Number.parseInt(bPos, 10);\n}\n\nexport class URLCoverageInfo extends Common.ObjectWrapper.ObjectWrapper<URLCoverageInfo.EventTypes> {\n  private readonly urlInternal: Platform.DevToolsPath.UrlString;\n  private coverageInfoByLocation: Map<string, CoverageInfo>;\n  private sizeInternal: number;\n  private usedSizeInternal: number;\n  private typeInternal!: CoverageType;\n  private isContentScriptInternal: boolean;\n\n  constructor(url: Platform.DevToolsPath.UrlString) {\n    super();\n\n    this.urlInternal = url;\n    this.coverageInfoByLocation = new Map();\n    this.sizeInternal = 0;\n    this.usedSizeInternal = 0;\n    this.isContentScriptInternal = false;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.urlInternal;\n  }\n\n  type(): CoverageType {\n    return this.typeInternal;\n  }\n\n  size(): number {\n    return this.sizeInternal;\n  }\n\n  usedSize(): number {\n    return this.usedSizeInternal;\n  }\n\n  unusedSize(): number {\n    return this.sizeInternal - this.usedSizeInternal;\n  }\n\n  usedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.sizeInternal === 0) {\n      return 0;\n    }\n    return this.usedSize() / this.size();\n  }\n\n  unusedPercentage(): number {\n    // Per convention, empty files are reported as 100 % uncovered\n    if (this.sizeInternal === 0) {\n      return 100;\n    }\n    return this.unusedSize() / this.size();\n  }\n\n  isContentScript(): boolean {\n    return this.isContentScriptInternal;\n  }\n\n  entries(): IterableIterator<CoverageInfo> {\n    return this.coverageInfoByLocation.values();\n  }\n\n  numberOfEntries(): number {\n    return this.coverageInfoByLocation.size;\n  }\n\n  removeCoverageEntry(key: string, entry: CoverageInfo): void {\n    if (!this.coverageInfoByLocation.delete(key)) {\n      return;\n    }\n    this.addToSizes(-entry.getUsedSize(), -entry.getSize());\n  }\n\n  addToSizes(usedSize: number, size: number): void {\n    this.usedSizeInternal += usedSize;\n    this.sizeInternal += size;\n\n    if (usedSize !== 0 || size !== 0) {\n      this.dispatchEventToListeners(URLCoverageInfo.Events.SizesChanged);\n    }\n  }\n\n  ensureEntry(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, contentLength: number, lineOffset: number,\n      columnOffset: number, type: CoverageType): CoverageInfo {\n    const key = `${lineOffset}:${columnOffset}`;\n    let entry = this.coverageInfoByLocation.get(key);\n\n    if ((type & CoverageType.JavaScript) && !this.coverageInfoByLocation.size) {\n      this.isContentScriptInternal = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n    this.typeInternal |= type;\n\n    if (entry) {\n      entry.addCoverageType(type);\n      return entry;\n    }\n\n    if ((type & CoverageType.JavaScript) && !this.coverageInfoByLocation.size) {\n      this.isContentScriptInternal = (contentProvider as SDK.Script.Script).isContentScript();\n    }\n\n    entry = new CoverageInfo(contentProvider, contentLength, lineOffset, columnOffset, type);\n    this.coverageInfoByLocation.set(key, entry);\n    this.addToSizes(0, contentLength);\n\n    return entry;\n  }\n\n  async getFullText(): Promise<TextUtils.Text.Text|null> {\n    // For .html resources, multiple scripts share URL, but have different offsets.\n    let useFullText = false;\n    const url = this.url();\n    for (const info of this.coverageInfoByLocation.values()) {\n      const {lineOffset, columnOffset} = info.getOffsets();\n      if (lineOffset || columnOffset) {\n        useFullText = Boolean(url);\n        break;\n      }\n    }\n\n    if (!useFullText) {\n      return null;\n    }\n    const resource = SDK.ResourceTreeModel.ResourceTreeModel.resourceForURL(url);\n    if (!resource) {\n      return null;\n    }\n    const content = (await resource.requestContent()).content;\n    return new TextUtils.Text.Text(content || '');\n  }\n\n  entriesForExportBasedOnFullText(fullText: TextUtils.Text.Text): EntryForExport {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const entry: EntryForExport = {url: this.url(), ranges: [], text: fullText.value()};\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const {lineOffset, columnOffset} = info.getOffsets();\n      const offset = fullText ? fullText.offsetFromPosition(lineOffset, columnOffset) : 0;\n      entry.ranges.push(...info.rangesForExport(offset));\n    }\n    return entry;\n  }\n\n  async entriesForExportBasedOnContent(): Promise<EntryForExport[]> {\n    const coverageByLocationKeys = Array.from(this.coverageInfoByLocation.keys()).sort(locationCompare);\n    const result = [];\n    for (const infoKey of coverageByLocationKeys) {\n      const info = this.coverageInfoByLocation.get(infoKey);\n      if (!info) {\n        continue;\n      }\n      const entry: EntryForExport = {\n        url: this.url(),\n        ranges: info.rangesForExport(),\n        text: (await info.getContentProvider().requestContent()).content,\n      };\n      result.push(entry);\n    }\n    return result;\n  }\n\n  async entriesForExport(): Promise<EntryForExport[]> {\n    const fullText = await this.getFullText();\n\n    // We have full text for this resource, resolve the offsets using the text line endings.\n    if (fullText) {\n      return [await this.entriesForExportBasedOnFullText(fullText)];\n    }\n\n    // Fall back to the per-script operation.\n    return this.entriesForExportBasedOnContent();\n  }\n}\n\nexport namespace URLCoverageInfo {\n  // TODO(crbug.com/1167717): Make this a const enum again\n  // eslint-disable-next-line rulesdir/const_enum\n  export enum Events {\n    SizesChanged = 'SizesChanged',\n  }\n\n  export type EventTypes = {\n    [Events.SizesChanged]: void,\n  };\n}\n\nexport const mergeSegments = (segmentsA: CoverageSegment[], segmentsB: CoverageSegment[]): CoverageSegment[] => {\n  const result: CoverageSegment[] = [];\n\n  let indexA = 0;\n  let indexB = 0;\n  while (indexA < segmentsA.length && indexB < segmentsB.length) {\n    const a = segmentsA[indexA];\n    const b = segmentsB[indexB];\n    const count = (a.count || 0) + (b.count || 0);\n    const end = Math.min(a.end, b.end);\n    const last = result[result.length - 1];\n    const stamp = Math.min(a.stamp, b.stamp);\n    if (!last || last.count !== count || last.stamp !== stamp) {\n      result.push({end: end, count: count, stamp: stamp});\n    } else {\n      last.end = end;\n    }\n    if (a.end <= b.end) {\n      indexA++;\n    }\n    if (a.end >= b.end) {\n      indexB++;\n    }\n  }\n\n  for (; indexA < segmentsA.length; indexA++) {\n    result.push(segmentsA[indexA]);\n  }\n  for (; indexB < segmentsB.length; indexB++) {\n    result.push(segmentsB[indexB]);\n  }\n  return result;\n};\n\nexport class CoverageInfo {\n  private contentProvider: TextUtils.ContentProvider.ContentProvider;\n  private size: number;\n  private usedSize: number;\n  private statsByTimestamp: Map<number, number>;\n  private lineOffset: number;\n  private columnOffset: number;\n  private coverageType: CoverageType;\n  private segments: CoverageSegment[];\n\n  constructor(\n      contentProvider: TextUtils.ContentProvider.ContentProvider, size: number, lineOffset: number,\n      columnOffset: number, type: CoverageType) {\n    this.contentProvider = contentProvider;\n    this.size = size;\n    this.usedSize = 0;\n    this.statsByTimestamp = new Map();\n    this.lineOffset = lineOffset;\n    this.columnOffset = columnOffset;\n    this.coverageType = type;\n\n    this.segments = [];\n  }\n\n  getContentProvider(): TextUtils.ContentProvider.ContentProvider {\n    return this.contentProvider;\n  }\n\n  url(): Platform.DevToolsPath.UrlString {\n    return this.contentProvider.contentURL();\n  }\n\n  type(): CoverageType {\n    return this.coverageType;\n  }\n\n  addCoverageType(type: CoverageType): void {\n    this.coverageType |= type;\n  }\n\n  getOffsets(): {lineOffset: number, columnOffset: number} {\n    return {lineOffset: this.lineOffset, columnOffset: this.columnOffset};\n  }\n\n  /**\n   * Returns the delta by which usedSize increased.\n   */\n  mergeCoverage(segments: CoverageSegment[]): number {\n    const oldUsedSize = this.usedSize;\n    this.segments = mergeSegments(this.segments, segments);\n    this.updateStats();\n    return this.usedSize - oldUsedSize;\n  }\n\n  usedByTimestamp(): Map<number, number> {\n    return this.statsByTimestamp;\n  }\n\n  getSize(): number {\n    return this.size;\n  }\n\n  getUsedSize(): number {\n    return this.usedSize;\n  }\n\n  usageForRange(start: number, end: number): boolean {\n    let index = Platform.ArrayUtilities.upperBound(this.segments, start, (position, segment) => position - segment.end);\n    for (; index < this.segments.length && this.segments[index].end < end; ++index) {\n      if (this.segments[index].count) {\n        return true;\n      }\n    }\n    return index < this.segments.length && Boolean(this.segments[index].count);\n  }\n\n  private updateStats(): void {\n    this.statsByTimestamp = new Map();\n    this.usedSize = 0;\n\n    let last = 0;\n    for (const segment of this.segments) {\n      let previousCount = this.statsByTimestamp.get(segment.stamp);\n      if (previousCount === undefined) {\n        previousCount = 0;\n      }\n\n      if (segment.count) {\n        const used = segment.end - last;\n        this.usedSize += used;\n        this.statsByTimestamp.set(segment.stamp, previousCount + used);\n      }\n      last = segment.end;\n    }\n  }\n\n  rangesForExport(offset: number = 0): {start: number, end: number}[] {\n    const ranges = [];\n    let start = 0;\n    for (const segment of this.segments) {\n      if (segment.count) {\n        const last = ranges.length > 0 ? ranges[ranges.length - 1] : null;\n        if (last && last.end === start + offset) {\n          // We can extend the last segment.\n          last.end = segment.end + offset;\n        } else {\n          // There was a gap, add a new segment.\n          ranges.push({start: start + offset, end: segment.end + offset});\n        }\n      }\n      start = segment.end;\n    }\n    return ranges;\n  }\n}\nexport interface RangeUseCount {\n  startOffset: number;\n  endOffset: number;\n  count: number;\n}\nexport interface CoverageSegment {\n  end: number;\n  count: number;\n  stamp: number;\n}\n"],
  "mappings": "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",
  "names": []
}
