{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/layer_viewer/Layers3DView.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2014 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\n\nimport layers3DViewStyles from './layers3DView.css.js';\n\nimport type * as Protocol from '../../generated/protocol.js';\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport type {LayerView, LayerViewHost} from './LayerViewHost.js';\nimport {LayerSelection, Selection, SnapshotSelection, Type, ScrollRectSelection} from './LayerViewHost.js';\nimport {Events as TransformControllerEvents, TransformController} from './TransformController.js';\n\nconst UIStrings = {\n  /**\n  *@description Text of a DOM element in DView of the Layers panel\n  */\n  layerInformationIsNotYet: 'Layer information is not yet available.',\n  /**\n  *@description Accessibility label for canvas view in Layers tool\n  */\n  dLayersView: '3D Layers View',\n  /**\n  *@description Text in DView of the Layers panel\n  */\n  cantDisplayLayers: 'Can\\'t display layers,',\n  /**\n  *@description Text in DView of the Layers panel\n  */\n  webglSupportIsDisabledInYour: 'WebGL support is disabled in your browser.',\n  /**\n  *@description Text in DView of the Layers panel\n  *@example {about:gpu} PH1\n  */\n  checkSForPossibleReasons: 'Check {PH1} for possible reasons.',\n  /**\n  *@description Text for a checkbox in the toolbar of the Layers panel to show the area of slow scroll rect\n  */\n  slowScrollRects: 'Slow scroll rects',\n  /**\n  * @description Text for a checkbox in the toolbar of the Layers panel. This is a noun, for a\n  * setting meaning 'display paints in the layers viewer'. 'Paints' here means 'paint events' i.e.\n  * when the browser draws pixels to the screen.\n  */\n  paints: 'Paints',\n  /**\n  *@description A context menu item in the DView of the Layers panel\n  */\n  resetView: 'Reset View',\n  /**\n  *@description A context menu item in the DView of the Layers panel\n  */\n  showPaintProfiler: 'Show Paint Profiler',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/layer_viewer/Layers3DView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nconst vertexPositionAttributes = new Map<WebGLProgram, number>();\n\nconst vertexColorAttributes = new Map<WebGLProgram, number>();\n\nconst textureCoordAttributes = new Map<WebGLProgram, number>();\n\nconst uniformMatrixLocations = new Map<WebGLProgram, WebGLUniformLocation|null>();\n\nconst uniformSamplerLocations = new Map<WebGLProgram, WebGLUniformLocation|null>();\n\nconst imageForTexture = new Map<WebGLTexture, HTMLImageElement>();\n\nexport class Layers3DView extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.VBox>(UI.Widget.VBox)\n    implements LayerView {\n  private readonly failBanner: UI.Widget.VBox;\n  private readonly layerViewHost: LayerViewHost;\n  private transformController: TransformController;\n  private canvasElement: HTMLCanvasElement;\n  private lastSelection: {[x: string]: Selection|null};\n  private layerTree: SDK.LayerTreeBase.LayerTreeBase|null;\n  private readonly textureManager: LayerTextureManager;\n  private chromeTextures: (WebGLTexture|undefined)[];\n  private rects: Rectangle[];\n  private snapshotLayers: Map<SDK.LayerTreeBase.Layer, SnapshotSelection>;\n  private shaderProgram!: WebGLProgram|null;\n  private oldTextureScale!: number|undefined;\n  private depthByLayerId!: Map<string, number>;\n  private visibleLayers!: Set<SDK.LayerTreeBase.Layer>;\n  private maxDepth!: number;\n  private scale!: number;\n  private layerTexture?: {layer: SDK.LayerTreeBase.Layer, texture: WebGLTexture}|null;\n  private projectionMatrix?: DOMMatrix;\n  private whiteTexture?: WebGLTexture|null;\n  private gl?: WebGLRenderingContext|null;\n  private dimensionsForAutoscale?: {width: number, height: number};\n  private needsUpdate?: boolean;\n  private panelToolbar?: UI.Toolbar.Toolbar;\n  private showSlowScrollRectsSetting?: Common.Settings.Setting<boolean>;\n  private showPaintsSetting?: Common.Settings.Setting<boolean>;\n  private mouseDownX?: number;\n  private mouseDownY?: number;\n\n  constructor(layerViewHost: LayerViewHost) {\n    super(true);\n\n    this.contentElement.classList.add('layers-3d-view');\n    this.failBanner = new UI.Widget.VBox();\n    this.failBanner.element.classList.add('full-widget-dimmed-banner');\n    UI.UIUtils.createTextChild(this.failBanner.element, i18nString(UIStrings.layerInformationIsNotYet));\n\n    this.layerViewHost = layerViewHost;\n    this.layerViewHost.registerView(this);\n    this.transformController = new TransformController(this.contentElement as HTMLElement);\n    this.transformController.addEventListener(TransformControllerEvents.TransformChanged, this.update, this);\n    this.initToolbar();\n    this.canvasElement = this.contentElement.createChild('canvas') as HTMLCanvasElement;\n    this.canvasElement.tabIndex = 0;\n    this.canvasElement.addEventListener('dblclick', this.onDoubleClick.bind(this), false);\n    this.canvasElement.addEventListener('mousedown', this.onMouseDown.bind(this), false);\n    this.canvasElement.addEventListener('mouseup', this.onMouseUp.bind(this), false);\n    this.canvasElement.addEventListener('mouseleave', this.onMouseMove.bind(this), false);\n    this.canvasElement.addEventListener('mousemove', this.onMouseMove.bind(this), false);\n    this.canvasElement.addEventListener('contextmenu', this.onContextMenu.bind(this), false);\n    UI.ARIAUtils.setAccessibleName(this.canvasElement, i18nString(UIStrings.dLayersView));\n\n    this.lastSelection = {};\n    this.layerTree = null;\n\n    this.textureManager = new LayerTextureManager(this.update.bind(this));\n\n    this.chromeTextures = [];\n\n    this.rects = [];\n\n    this.snapshotLayers = new Map();\n    this.layerViewHost.setLayerSnapshotMap(this.snapshotLayers);\n\n    this.layerViewHost.showInternalLayersSetting().addChangeListener(this.update, this);\n  }\n\n  setLayerTree(layerTree: SDK.LayerTreeBase.LayerTreeBase|null): void {\n    this.layerTree = layerTree;\n    this.layerTexture = null;\n    delete this.oldTextureScale;\n    if (this.showPaints()) {\n      this.textureManager.setLayerTree(layerTree);\n    }\n    this.update();\n  }\n\n  showImageForLayer(layer: SDK.LayerTreeBase.Layer, imageURL?: string): void {\n    if (!imageURL) {\n      this.layerTexture = null;\n      this.update();\n      return;\n    }\n    void UI.UIUtils.loadImage(imageURL).then(image => {\n      const texture = image && LayerTextureManager.createTextureForImage(this.gl || null, image);\n      this.layerTexture = texture ? {layer: layer, texture: texture} : null;\n      this.update();\n    });\n  }\n\n  onResize(): void {\n    this.resizeCanvas();\n    this.update();\n  }\n\n  willHide(): void {\n    this.textureManager.suspend();\n  }\n\n  wasShown(): void {\n    this.textureManager.resume();\n    this.registerCSSFiles([layers3DViewStyles]);\n    if (!this.needsUpdate) {\n      return;\n    }\n    this.resizeCanvas();\n    this.update();\n  }\n\n  updateLayerSnapshot(layer: SDK.LayerTreeBase.Layer): void {\n    this.textureManager.layerNeedsUpdate(layer);\n  }\n\n  private setOutline(type: OutlineType, selection: Selection|null): void {\n    this.lastSelection[type] = selection;\n    this.update();\n  }\n\n  hoverObject(selection: Selection|null): void {\n    this.setOutline(OutlineType.Hovered, selection);\n  }\n\n  selectObject(selection: Selection|null): void {\n    this.setOutline(OutlineType.Hovered, null);\n    this.setOutline(OutlineType.Selected, selection);\n  }\n\n  snapshotForSelection(selection: Selection): Promise<SDK.PaintProfiler.SnapshotWithRect|null> {\n    if (selection.type() === Type.Snapshot) {\n      const snapshotWithRect = (selection as SnapshotSelection).snapshot();\n      snapshotWithRect.snapshot.addReference();\n      return Promise.resolve(snapshotWithRect);\n    }\n    if (selection.layer()) {\n      const promise = selection.layer().snapshots()[0];\n      if (promise !== undefined) {\n        return promise;\n      }\n    }\n    return Promise.resolve(null);\n  }\n\n  private initGL(canvas: HTMLCanvasElement): WebGLRenderingContext|null {\n    const gl = canvas.getContext('webgl');\n    if (!gl) {\n      return null;\n    }\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.enable(gl.DEPTH_TEST);\n    return gl;\n  }\n\n  private createShader(type: number, script: string): void {\n    if (!this.gl) {\n      return;\n    }\n\n    const shader = this.gl.createShader(type);\n    if (shader && this.shaderProgram) {\n      this.gl.shaderSource(shader, script);\n      this.gl.compileShader(shader);\n      this.gl.attachShader(this.shaderProgram, shader);\n    }\n  }\n\n  private initShaders(): void {\n    if (!this.gl) {\n      return;\n    }\n\n    this.shaderProgram = this.gl.createProgram();\n    if (!this.shaderProgram) {\n      return;\n    }\n    this.createShader(this.gl.FRAGMENT_SHADER, FragmentShader);\n    this.createShader(this.gl.VERTEX_SHADER, VertexShader);\n    this.gl.linkProgram(this.shaderProgram);\n    this.gl.useProgram(this.shaderProgram);\n\n    const aVertexPositionAttribute = this.gl.getAttribLocation(this.shaderProgram, 'aVertexPosition');\n    this.gl.enableVertexAttribArray(aVertexPositionAttribute);\n    vertexPositionAttributes.set(this.shaderProgram, aVertexPositionAttribute);\n\n    const aVertexColorAttribute = this.gl.getAttribLocation(this.shaderProgram, 'aVertexColor');\n    this.gl.enableVertexAttribArray(aVertexColorAttribute);\n    vertexColorAttributes.set(this.shaderProgram, aVertexColorAttribute);\n\n    const aTextureCoordAttribute = this.gl.getAttribLocation(this.shaderProgram, 'aTextureCoord');\n    this.gl.enableVertexAttribArray(aTextureCoordAttribute);\n    textureCoordAttributes.set(this.shaderProgram, aTextureCoordAttribute);\n\n    const uMatrixLocation = this.gl.getUniformLocation(this.shaderProgram, 'uPMatrix');\n    uniformMatrixLocations.set(this.shaderProgram, uMatrixLocation);\n\n    const uSamplerLocation = this.gl.getUniformLocation(this.shaderProgram, 'uSampler');\n    uniformSamplerLocations.set(this.shaderProgram, uSamplerLocation);\n  }\n\n  private resizeCanvas(): void {\n    this.canvasElement.width = this.canvasElement.offsetWidth * window.devicePixelRatio;\n    this.canvasElement.height = this.canvasElement.offsetHeight * window.devicePixelRatio;\n  }\n\n  private updateTransformAndConstraints(): void {\n    const paddingFraction = 0.1;\n    const dimensionsForAutoscale = this.dimensionsForAutoscale || {width: 0, height: 0};\n    const viewport = this.layerTree ? this.layerTree.viewportSize() : null;\n    const baseWidth = viewport ? viewport.width : dimensionsForAutoscale.width;\n    const baseHeight = viewport ? viewport.height : dimensionsForAutoscale.height;\n    const canvasWidth = this.canvasElement.width;\n    const canvasHeight = this.canvasElement.height;\n    const paddingX = canvasWidth * paddingFraction;\n    const paddingY = canvasHeight * paddingFraction;\n    const scaleX = (canvasWidth - 2 * paddingX) / baseWidth;\n    const scaleY = (canvasHeight - 2 * paddingY) / baseHeight;\n    const viewScale = Math.min(scaleX, scaleY);\n    const minScaleConstraint =\n        Math.min(baseWidth / dimensionsForAutoscale.width, baseHeight / dimensionsForAutoscale.width) / 2;\n    this.transformController.setScaleConstraints(\n        minScaleConstraint,\n        10 / viewScale);  // 1/viewScale is 1:1 in terms of pixels, so allow zooming to 10x of native size\n    const scale = this.transformController.scale();\n    const rotateX = this.transformController.rotateX();\n    const rotateY = this.transformController.rotateY();\n\n    this.scale = scale * viewScale;\n    const textureScale = Platform.NumberUtilities.clamp(this.scale, 0.1, 1);\n    if (textureScale !== this.oldTextureScale) {\n      this.oldTextureScale = textureScale;\n      this.textureManager.setScale(textureScale);\n      this.dispatchEventToListeners(Events.ScaleChanged, textureScale);\n    }\n    const scaleAndRotationMatrix = new WebKitCSSMatrix()\n                                       .scale(scale, scale, scale)\n                                       .translate(canvasWidth / 2, canvasHeight / 2, 0)\n                                       .rotate(rotateX, rotateY, 0)\n                                       .scale(viewScale, viewScale, viewScale)\n                                       .translate(-baseWidth / 2, -baseHeight / 2, 0);\n\n    let bounds;\n    for (let i = 0; i < this.rects.length; ++i) {\n      bounds = UI.Geometry.boundsForTransformedPoints(scaleAndRotationMatrix, this.rects[i].vertices, bounds);\n    }\n\n    if (bounds) {\n      this.transformController.clampOffsets(\n          (paddingX - bounds.maxX) / window.devicePixelRatio,\n          (canvasWidth - paddingX - bounds.minX) / window.devicePixelRatio,\n          (paddingY - bounds.maxY) / window.devicePixelRatio,\n          (canvasHeight - paddingY - bounds.minY) / window.devicePixelRatio);\n    }\n    const offsetX = this.transformController.offsetX() * window.devicePixelRatio;\n    const offsetY = this.transformController.offsetY() * window.devicePixelRatio;\n    // Multiply to translation matrix on the right rather than translate (which would implicitly multiply on the left).\n    this.projectionMatrix = new WebKitCSSMatrix().translate(offsetX, offsetY, 0).multiply(scaleAndRotationMatrix);\n\n    const glProjectionMatrix = new WebKitCSSMatrix()\n                                   .scale(1, -1, -1)\n                                   .translate(-1, -1, 0)\n                                   .scale(2 / this.canvasElement.width, 2 / this.canvasElement.height, 1 / 1000000)\n                                   .multiply(this.projectionMatrix);\n\n    if (this.shaderProgram) {\n      const pMatrixUniform = uniformMatrixLocations.get(this.shaderProgram);\n      if (this.gl && pMatrixUniform) {\n        this.gl.uniformMatrix4fv(pMatrixUniform, false, this.arrayFromMatrix(glProjectionMatrix));\n      }\n    }\n  }\n\n  private arrayFromMatrix(m: DOMMatrix): Float32Array {\n    return new Float32Array([\n      m.m11,\n      m.m12,\n      m.m13,\n      m.m14,\n      m.m21,\n      m.m22,\n      m.m23,\n      m.m24,\n      m.m31,\n      m.m32,\n      m.m33,\n      m.m34,\n      m.m41,\n      m.m42,\n      m.m43,\n      m.m44,\n    ]);\n  }\n\n  private initWhiteTexture(): void {\n    if (!this.gl) {\n      return;\n    }\n\n    this.whiteTexture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this.whiteTexture);\n    const whitePixel = new Uint8Array([255, 255, 255, 255]);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, whitePixel);\n  }\n\n  private initChromeTextures(): void {\n    function loadChromeTexture(this: Layers3DView, index: ChromeTexture, url: string): void {\n      void UI.UIUtils.loadImage(url).then(image => {\n        this.chromeTextures[index] =\n            image && LayerTextureManager.createTextureForImage(this.gl || null, image) || undefined;\n      });\n    }\n    loadChromeTexture.call(this, ChromeTexture.Left, 'Images/chromeLeft.avif');\n    loadChromeTexture.call(this, ChromeTexture.Middle, 'Images/chromeMiddle.avif');\n    loadChromeTexture.call(this, ChromeTexture.Right, 'Images/chromeRight.avif');\n  }\n\n  private initGLIfNecessary(): WebGLRenderingContext|null {\n    if (this.gl) {\n      return this.gl;\n    }\n    this.gl = this.initGL(this.canvasElement);\n    if (!this.gl) {\n      return null;\n    }\n    this.initShaders();\n    this.initWhiteTexture();\n    this.initChromeTextures();\n    this.textureManager.setContext(this.gl);\n    return this.gl;\n  }\n\n  private calculateDepthsAndVisibility(): void {\n    this.depthByLayerId = new Map();\n    let depth = 0;\n    const showInternalLayers = this.layerViewHost.showInternalLayersSetting().get();\n    if (!this.layerTree) {\n      return;\n    }\n\n    const root = showInternalLayers ? this.layerTree.root() : (this.layerTree.contentRoot() || this.layerTree.root());\n    if (!root) {\n      return;\n    }\n\n    const queue = [root];\n    this.depthByLayerId.set(root.id(), 0);\n    this.visibleLayers = new Set();\n    while (queue.length > 0) {\n      const layer = queue.shift();\n      if (!layer) {\n        break;\n      }\n\n      if (showInternalLayers || layer.drawsContent()) {\n        this.visibleLayers.add(layer);\n      }\n      const children = layer.children();\n      for (let i = 0; i < children.length; ++i) {\n        this.depthByLayerId.set(children[i].id(), ++depth);\n        queue.push(children[i]);\n      }\n    }\n    this.maxDepth = depth;\n  }\n\n  private depthForLayer(layer: SDK.LayerTreeBase.Layer): number {\n    return (this.depthByLayerId.get(layer.id()) || 0) * LayerSpacing;\n  }\n\n  private calculateScrollRectDepth(layer: SDK.LayerTreeBase.Layer, index: number): number {\n    return this.depthForLayer(layer) + index * ScrollRectSpacing + 1;\n  }\n\n  private updateDimensionsForAutoscale(layer: SDK.LayerTreeBase.Layer): void {\n    // We don't want to be precise, but rather pick something least affected by\n    // animationtransforms, so that we don't change scale too often. So let's\n    // disregard transforms, scrolling and relative layer positioning and choose\n    // the largest dimensions of all layers.\n    if (!this.dimensionsForAutoscale) {\n      this.dimensionsForAutoscale = {width: 0, height: 0};\n    }\n\n    this.dimensionsForAutoscale.width = Math.max(layer.width(), this.dimensionsForAutoscale.width);\n    this.dimensionsForAutoscale.height = Math.max(layer.height(), this.dimensionsForAutoscale.height);\n  }\n\n  private calculateLayerRect(layer: SDK.LayerTreeBase.Layer): void {\n    if (!this.visibleLayers.has(layer)) {\n      return;\n    }\n    const selection = new LayerSelection(layer);\n    const rect = new Rectangle(selection);\n    rect.setVertices(layer.quad(), this.depthForLayer(layer));\n    this.appendRect(rect);\n    this.updateDimensionsForAutoscale(layer);\n  }\n\n  private appendRect(rect: Rectangle): void {\n    const selection = rect.relatedObject;\n    const isSelected = Selection.isEqual(this.lastSelection[OutlineType.Selected], selection);\n    const isHovered = Selection.isEqual(this.lastSelection[OutlineType.Hovered], selection);\n    if (isSelected) {\n      rect.borderColor = SelectedBorderColor;\n    } else if (isHovered) {\n      rect.borderColor = HoveredBorderColor;\n      const fillColor = rect.fillColor || [255, 255, 255, 1];\n      const maskColor = HoveredImageMaskColor;\n      rect.fillColor = [\n        fillColor[0] * maskColor[0] / 255,\n        fillColor[1] * maskColor[1] / 255,\n        fillColor[2] * maskColor[2] / 255,\n        fillColor[3] * maskColor[3],\n      ];\n    } else {\n      rect.borderColor = BorderColor;\n    }\n    rect.lineWidth = isSelected ? SelectedBorderWidth : BorderWidth;\n    this.rects.push(rect);\n  }\n\n  private calculateLayerScrollRects(layer: SDK.LayerTreeBase.Layer): void {\n    const scrollRects = layer.scrollRects();\n    for (let i = 0; i < scrollRects.length; ++i) {\n      const selection = new ScrollRectSelection(layer, i);\n      const rect = new Rectangle(selection);\n      rect.calculateVerticesFromRect(layer, scrollRects[i].rect, this.calculateScrollRectDepth(layer, i));\n      rect.fillColor = ScrollRectBackgroundColor;\n      this.appendRect(rect);\n    }\n  }\n\n  private calculateLayerTileRects(layer: SDK.LayerTreeBase.Layer): void {\n    const tiles = this.textureManager.tilesForLayer(layer);\n    for (let i = 0; i < tiles.length; ++i) {\n      const tile = tiles[i];\n      if (!tile.texture) {\n        continue;\n      }\n      const selection = new SnapshotSelection(layer, {rect: tile.rect, snapshot: tile.snapshot});\n      const rect = new Rectangle(selection);\n      if (!this.snapshotLayers.has(layer)) {\n        this.snapshotLayers.set(layer, selection);\n      }\n\n      rect.calculateVerticesFromRect(layer, tile.rect, this.depthForLayer(layer) + 1);\n      rect.texture = tile.texture;\n      this.appendRect(rect);\n    }\n  }\n\n  private calculateRects(): void {\n    this.rects = [];\n    this.snapshotLayers.clear();\n    this.dimensionsForAutoscale = {width: 0, height: 0};\n    if (this.layerTree) {\n      this.layerTree.forEachLayer(this.calculateLayerRect.bind(this));\n    }\n\n    if (this.showSlowScrollRectsSetting && this.showSlowScrollRectsSetting.get() && this.layerTree) {\n      this.layerTree.forEachLayer(this.calculateLayerScrollRects.bind(this));\n    }\n\n    if (this.layerTexture && this.visibleLayers.has(this.layerTexture.layer)) {\n      const layer = this.layerTexture.layer;\n      const selection = new LayerSelection(layer);\n      const rect = new Rectangle(selection);\n      rect.setVertices(layer.quad(), this.depthForLayer(layer));\n      rect.texture = this.layerTexture.texture;\n      this.appendRect(rect);\n    } else if (this.showPaints() && this.layerTree) {\n      this.layerTree.forEachLayer(this.calculateLayerTileRects.bind(this));\n    }\n  }\n\n  private makeColorsArray(color: number[]): number[] {\n    let colors: number[] = [];\n    const normalizedColor = [color[0] / 255, color[1] / 255, color[2] / 255, color[3]];\n    for (let i = 0; i < 4; i++) {\n      colors = colors.concat(normalizedColor);\n    }\n    return colors;\n  }\n\n  private setVertexAttribute(attribute: number, array: number[], length: number): void {\n    const gl = this.gl;\n    if (!gl) {\n      return;\n    }\n\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(array), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(attribute, length, gl.FLOAT, false, 0, 0);\n  }\n\n  private drawRectangle(vertices: number[], mode: number, color?: number[], texture?: Object): void {\n    const gl = this.gl;\n    const white = [255, 255, 255, 1];\n    color = color || white;\n    if (!this.shaderProgram) {\n      return;\n    }\n\n    const vertexPositionAttribute = vertexPositionAttributes.get(this.shaderProgram);\n    const textureCoordAttribute = textureCoordAttributes.get(this.shaderProgram);\n    const vertexColorAttribute = vertexColorAttributes.get(this.shaderProgram);\n    if (typeof vertexPositionAttribute !== 'undefined') {\n      this.setVertexAttribute(vertexPositionAttribute, vertices, 3);\n    }\n    if (typeof textureCoordAttribute !== 'undefined') {\n      this.setVertexAttribute(textureCoordAttribute, [0, 1, 1, 1, 1, 0, 0, 0], 2);\n    }\n    if (typeof vertexColorAttribute !== 'undefined') {\n      this.setVertexAttribute(vertexColorAttribute, this.makeColorsArray(color), color.length);\n    }\n\n    if (!gl) {\n      return;\n    }\n\n    const samplerUniform = uniformSamplerLocations.get(this.shaderProgram);\n    if (texture) {\n      if (samplerUniform) {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.uniform1i(samplerUniform, 0);\n      }\n    } else if (this.whiteTexture) {\n      gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);\n    }\n\n    const numberOfVertices = vertices.length / 3;\n    gl.drawArrays(mode, 0, numberOfVertices);\n  }\n\n  private drawTexture(vertices: number[], texture: WebGLTexture, color?: number[]): void {\n    if (!this.gl) {\n      return;\n    }\n\n    this.drawRectangle(vertices, this.gl.TRIANGLE_FAN, color, texture);\n  }\n\n  private drawViewportAndChrome(): void {\n    if (!this.layerTree) {\n      return;\n    }\n\n    const viewport = this.layerTree.viewportSize();\n    if (!viewport) {\n      return;\n    }\n\n    const drawChrome = !Common.Settings.Settings.instance().moduleSetting('frameViewerHideChromeWindow').get() &&\n        this.chromeTextures.length >= 3 && this.chromeTextures.indexOf(undefined) < 0;\n    const z = (this.maxDepth + 1) * LayerSpacing;\n    const borderWidth = Math.ceil(ViewportBorderWidth * this.scale);\n    let vertices: number[] = [viewport.width, 0, z, viewport.width, viewport.height, z, 0, viewport.height, z, 0, 0, z];\n    if (!this.gl) {\n      return;\n    }\n\n    this.gl.lineWidth(borderWidth);\n    this.drawRectangle(vertices, drawChrome ? this.gl.LINE_STRIP : this.gl.LINE_LOOP, ViewportBorderColor);\n\n    if (!drawChrome) {\n      return;\n    }\n\n    const viewportSize = this.layerTree.viewportSize();\n    if (!viewportSize) {\n      return;\n    }\n\n    const borderAdjustment = ViewportBorderWidth / 2;\n    const viewportWidth = viewportSize.width + 2 * borderAdjustment;\n    if (this.chromeTextures[0] && this.chromeTextures[2]) {\n      const chromeTextureImage =\n          imageForTexture.get(this.chromeTextures[0] as WebGLTexture) || {naturalHeight: 0, naturalWidth: 0};\n      const chromeHeight = chromeTextureImage.naturalHeight;\n\n      const middleTextureImage =\n          imageForTexture.get(this.chromeTextures[2] as WebGLTexture) || {naturalHeight: 0, naturalWidth: 0};\n      const middleFragmentWidth = viewportWidth - chromeTextureImage.naturalWidth - middleTextureImage.naturalWidth;\n      let x = -borderAdjustment;\n      const y = -chromeHeight;\n      for (let i = 0; i < this.chromeTextures.length; ++i) {\n        const texture = this.chromeTextures[i];\n        if (!texture) {\n          continue;\n        }\n\n        const image = imageForTexture.get(texture);\n        if (!image) {\n          continue;\n        }\n        const width = i === ChromeTexture.Middle ? middleFragmentWidth : image.naturalWidth;\n        if (width < 0 || x + width > viewportWidth) {\n          break;\n        }\n        vertices = [x, y, z, x + width, y, z, x + width, y + chromeHeight, z, x, y + chromeHeight, z];\n        this.drawTexture(vertices, this.chromeTextures[i] as WebGLTexture);\n        x += width;\n      }\n    }\n  }\n\n  private drawViewRect(rect: Rectangle): void {\n    if (!this.gl) {\n      return;\n    }\n\n    const vertices = rect.vertices;\n    if (rect.texture) {\n      this.drawTexture(vertices, rect.texture, rect.fillColor || undefined);\n    } else if (rect.fillColor) {\n      this.drawRectangle(vertices, this.gl.TRIANGLE_FAN, rect.fillColor);\n    }\n    this.gl.lineWidth(rect.lineWidth);\n    if (rect.borderColor) {\n      this.drawRectangle(vertices, this.gl.LINE_LOOP, rect.borderColor);\n    }\n  }\n\n  private update(): void {\n    if (!this.isShowing()) {\n      this.needsUpdate = true;\n      return;\n    }\n    if (!this.layerTree || !this.layerTree.root()) {\n      this.failBanner.show(this.contentElement);\n      return;\n    }\n    const gl = this.initGLIfNecessary();\n    if (!gl) {\n      this.failBanner.element.removeChildren();\n      this.failBanner.element.appendChild(this.webglDisabledBanner());\n      this.failBanner.show(this.contentElement);\n      return;\n    }\n    this.failBanner.detach();\n    const viewportWidth = this.canvasElement.width;\n    const viewportHeight = this.canvasElement.height;\n\n    this.calculateDepthsAndVisibility();\n    this.calculateRects();\n    this.updateTransformAndConstraints();\n\n    gl.viewport(0, 0, viewportWidth, viewportHeight);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n    this.rects.forEach(this.drawViewRect.bind(this));\n    this.drawViewportAndChrome();\n  }\n\n  private webglDisabledBanner(): Node {\n    const fragment = this.contentElement.ownerDocument.createDocumentFragment();\n    fragment.createChild('div').textContent = i18nString(UIStrings.cantDisplayLayers);\n    fragment.createChild('div').textContent = i18nString(UIStrings.webglSupportIsDisabledInYour);\n    fragment.appendChild(i18n.i18n.getFormatLocalizedString(\n        str_, UIStrings.checkSForPossibleReasons, {PH1: UI.XLink.XLink.create('about:gpu')}));\n    return fragment;\n  }\n\n  private selectionFromEventPoint(event: Event): Selection|null {\n    const mouseEvent = event as MouseEvent;\n    if (!this.layerTree) {\n      return null;\n    }\n    let closestIntersectionPoint: number = Infinity;\n    let closestObject: Selection|null = null;\n    const projectionMatrix =\n        new WebKitCSSMatrix().scale(1, -1, -1).translate(-1, -1, 0).multiply(this.projectionMatrix);\n    const x0 = (mouseEvent.clientX - this.canvasElement.totalOffsetLeft()) * window.devicePixelRatio;\n    const y0 = -(mouseEvent.clientY - this.canvasElement.totalOffsetTop()) * window.devicePixelRatio;\n\n    function checkIntersection(rect: Rectangle): void {\n      if (!rect.relatedObject) {\n        return;\n      }\n      const t = rect.intersectWithLine(projectionMatrix, x0, y0);\n      if (t && t < closestIntersectionPoint) {\n        closestIntersectionPoint = t;\n        closestObject = rect.relatedObject;\n      }\n    }\n\n    this.rects.forEach(checkIntersection);\n    return closestObject;\n  }\n\n  private createVisibilitySetting(caption: string, name: string, value: boolean, toolbar: UI.Toolbar.Toolbar):\n      Common.Settings.Setting<boolean> {\n    const setting = Common.Settings.Settings.instance().createSetting(name, value);\n    setting.setTitle(caption);\n    setting.addChangeListener(this.update, this);\n    toolbar.appendToolbarItem(new UI.Toolbar.ToolbarSettingCheckbox(setting));\n    return setting;\n  }\n\n  private initToolbar(): void {\n    this.panelToolbar = this.transformController.toolbar();\n    this.contentElement.appendChild(this.panelToolbar.element);\n    this.showSlowScrollRectsSetting = this.createVisibilitySetting(\n        i18nString(UIStrings.slowScrollRects), 'frameViewerShowSlowScrollRects', true, this.panelToolbar);\n    this.showPaintsSetting =\n        this.createVisibilitySetting(i18nString(UIStrings.paints), 'frameViewerShowPaints', true, this.panelToolbar);\n    this.showPaintsSetting.addChangeListener(this.updatePaints, this);\n    Common.Settings.Settings.instance()\n        .moduleSetting('frameViewerHideChromeWindow')\n        .addChangeListener(this.update, this);\n  }\n\n  private onContextMenu(event: Event): void {\n    const contextMenu = new UI.ContextMenu.ContextMenu(event);\n    contextMenu.defaultSection().appendItem(\n        i18nString(UIStrings.resetView), () => this.transformController.resetAndNotify(), false);\n    const selection = this.selectionFromEventPoint(event);\n    if (selection && selection.type() === Type.Snapshot) {\n      contextMenu.defaultSection().appendItem(\n          i18nString(UIStrings.showPaintProfiler),\n          () => this.dispatchEventToListeners(Events.PaintProfilerRequested, selection), false);\n    }\n    this.layerViewHost.showContextMenu(contextMenu, selection);\n  }\n\n  private onMouseMove(event: Event): void {\n    const mouseEvent = event as MouseEvent;\n    if (mouseEvent.which) {\n      return;\n    }\n    this.layerViewHost.hoverObject(this.selectionFromEventPoint(event));\n  }\n\n  private onMouseDown(event: Event): void {\n    const mouseEvent = event as MouseEvent;\n    this.mouseDownX = mouseEvent.clientX;\n    this.mouseDownY = mouseEvent.clientY;\n  }\n\n  private onMouseUp(event: Event): void {\n    const mouseEvent = event as MouseEvent;\n    const maxDistanceInPixels = 6;\n    if (this.mouseDownX && Math.abs(mouseEvent.clientX - this.mouseDownX) < maxDistanceInPixels &&\n        Math.abs(mouseEvent.clientY - (this.mouseDownY || 0)) < maxDistanceInPixels) {\n      this.canvasElement.focus();\n      this.layerViewHost.selectObject(this.selectionFromEventPoint(event));\n    }\n    delete this.mouseDownX;\n    delete this.mouseDownY;\n  }\n\n  private onDoubleClick(event: Event): void {\n    const selection = this.selectionFromEventPoint(event);\n    if (selection && (selection.type() === Type.Snapshot || selection.layer())) {\n      this.dispatchEventToListeners(Events.PaintProfilerRequested, selection);\n    }\n    event.stopPropagation();\n  }\n\n  private updatePaints(): void {\n    if (this.showPaints()) {\n      this.textureManager.setLayerTree(this.layerTree);\n      this.textureManager.forceUpdate();\n    } else {\n      this.textureManager.reset();\n    }\n    this.update();\n  }\n\n  private showPaints(): boolean {\n    return this.showPaintsSetting ? this.showPaintsSetting.get() : false;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum OutlineType {\n  Hovered = 'hovered',\n  Selected = 'selected',\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  PaintProfilerRequested = 'PaintProfilerRequested',\n  ScaleChanged = 'ScaleChanged',\n}\n\nexport type EventTypes = {\n  [Events.PaintProfilerRequested]: Selection,\n  [Events.ScaleChanged]: number,\n};\n\nexport const enum ChromeTexture {\n  Left = 0,\n  Middle = 1,\n  Right = 2,\n}\n\nexport const FragmentShader = '' +\n    'precision mediump float;\\n' +\n    'varying vec4 vColor;\\n' +\n    'varying vec2 vTextureCoord;\\n' +\n    'uniform sampler2D uSampler;\\n' +\n    'void main(void)\\n' +\n    '{\\n' +\n    '    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * vColor;\\n' +\n    '}';\n\nexport const VertexShader = '' +\n    'attribute vec3 aVertexPosition;\\n' +\n    'attribute vec2 aTextureCoord;\\n' +\n    'attribute vec4 aVertexColor;\\n' +\n    'uniform mat4 uPMatrix;\\n' +\n    'varying vec2 vTextureCoord;\\n' +\n    'varying vec4 vColor;\\n' +\n    'void main(void)\\n' +\n    '{\\n' +\n    'gl_Position = uPMatrix * vec4(aVertexPosition, 1.0);\\n' +\n    'vColor = aVertexColor;\\n' +\n    'vTextureCoord = aTextureCoord;\\n' +\n    '}';\n\nexport const HoveredBorderColor = [0, 0, 255, 1];\nexport const SelectedBorderColor = [0, 255, 0, 1];\nexport const BorderColor = [0, 0, 0, 1];\nexport const ViewportBorderColor = [160, 160, 160, 1];\nexport const ScrollRectBackgroundColor = [178, 100, 100, 0.6];\nexport const HoveredImageMaskColor = [200, 200, 255, 1];\nexport const BorderWidth = 1;\nexport const SelectedBorderWidth = 2;\nexport const ViewportBorderWidth = 3;\n\nexport const LayerSpacing = 20;\nexport const ScrollRectSpacing = 4;\n\nexport class LayerTextureManager {\n  private readonly textureUpdatedCallback: () => void;\n  private readonly throttler: Common.Throttler.Throttler;\n  private scale: number;\n  private active: boolean;\n  private queue!: SDK.LayerTreeBase.Layer[];\n  private tilesByLayer!: Map<SDK.LayerTreeBase.Layer, Tile[]>;\n  private gl?: WebGLRenderingContext;\n  constructor(textureUpdatedCallback: () => void) {\n    this.textureUpdatedCallback = textureUpdatedCallback;\n    this.throttler = new Common.Throttler.Throttler(0);\n    this.scale = 0;\n    this.active = false;\n    this.reset();\n  }\n\n  static createTextureForImage(gl: WebGLRenderingContext|null, image: HTMLImageElement): WebGLTexture {\n    if (!gl) {\n      throw new Error('WebGLRenderingContext not provided');\n    }\n    const texture = gl.createTexture();\n    if (!texture) {\n      throw new Error('Unable to create texture');\n    }\n\n    imageForTexture.set(texture, image);\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    return texture;\n  }\n\n  reset(): void {\n    if (this.tilesByLayer) {\n      this.setLayerTree(null);\n    }\n\n    this.tilesByLayer = new Map();\n    this.queue = [];\n  }\n\n  setContext(glContext: WebGLRenderingContext): void {\n    this.gl = glContext;\n    if (this.scale) {\n      this.updateTextures();\n    }\n  }\n\n  suspend(): void {\n    this.active = false;\n  }\n\n  resume(): void {\n    this.active = true;\n    if (this.queue.length) {\n      void this.update();\n    }\n  }\n\n  setLayerTree(layerTree: SDK.LayerTreeBase.LayerTreeBase|null): void {\n    const newLayers = new Set<SDK.LayerTreeBase.Layer>();\n    const oldLayers = Array.from(this.tilesByLayer.keys());\n    if (layerTree) {\n      layerTree.forEachLayer(layer => {\n        if (!layer.drawsContent()) {\n          return;\n        }\n        newLayers.add(layer);\n        if (!this.tilesByLayer.has(layer)) {\n          this.tilesByLayer.set(layer, []);\n          this.layerNeedsUpdate(layer);\n        }\n      });\n    }\n    if (!oldLayers.length) {\n      this.forceUpdate();\n    }\n    for (const layer of oldLayers) {\n      if (newLayers.has(layer)) {\n        continue;\n      }\n      const tiles = this.tilesByLayer.get(layer);\n      if (tiles) {\n        tiles.forEach(tile => tile.dispose());\n      }\n      this.tilesByLayer.delete(layer);\n    }\n  }\n\n  private setSnapshotsForLayer(layer: SDK.LayerTreeBase.Layer, snapshots: SDK.PaintProfiler.SnapshotWithRect[]):\n      Promise<void> {\n    const oldSnapshotsToTiles = new Map((this.tilesByLayer.get(layer) || []).map(tile => [tile.snapshot, tile]));\n    const newTiles = [];\n    const reusedTiles = [];\n    for (const snapshot of snapshots) {\n      const oldTile = oldSnapshotsToTiles.get(snapshot.snapshot);\n      if (oldTile) {\n        reusedTiles.push(oldTile);\n        oldSnapshotsToTiles.delete(snapshot.snapshot);\n      } else {\n        newTiles.push(new Tile(snapshot));\n      }\n    }\n    this.tilesByLayer.set(layer, reusedTiles.concat(newTiles));\n    for (const tile of oldSnapshotsToTiles.values()) {\n      tile.dispose();\n    }\n    const gl = this.gl;\n    if (!gl || !this.scale) {\n      return Promise.resolve();\n    }\n    return Promise.all(newTiles.map(tile => tile.update(gl, this.scale))).then(this.textureUpdatedCallback);\n  }\n\n  setScale(scale: number): void {\n    if (this.scale && this.scale >= scale) {\n      return;\n    }\n    this.scale = scale;\n    this.updateTextures();\n  }\n\n  tilesForLayer(layer: SDK.LayerTreeBase.Layer): Tile[] {\n    return this.tilesByLayer.get(layer) || [];\n  }\n\n  layerNeedsUpdate(layer: SDK.LayerTreeBase.Layer): void {\n    if (this.queue.indexOf(layer) < 0) {\n      this.queue.push(layer);\n    }\n    if (this.active) {\n      void this.throttler.schedule(this.update.bind(this));\n    }\n  }\n\n  forceUpdate(): void {\n    this.queue.forEach(layer => this.updateLayer(layer));\n    this.queue = [];\n    void this.update();\n  }\n\n  private update(): Promise<void> {\n    const layer = this.queue.shift();\n    if (!layer) {\n      return Promise.resolve();\n    }\n    if (this.queue.length) {\n      void this.throttler.schedule(this.update.bind(this));\n    }\n    return this.updateLayer(layer);\n  }\n\n  private updateLayer(layer: SDK.LayerTreeBase.Layer): Promise<void> {\n    return Promise.all(layer.snapshots())\n        .then(\n            snapshots => this.setSnapshotsForLayer(\n                layer, snapshots.filter(snapshot => snapshot !== null) as SDK.PaintProfiler.SnapshotWithRect[]));\n  }\n\n  private updateTextures(): void {\n    if (!this.gl) {\n      return;\n    }\n    if (!this.scale) {\n      return;\n    }\n\n    for (const tiles of this.tilesByLayer.values()) {\n      for (const tile of tiles) {\n        const promise = tile.updateScale(this.gl, this.scale);\n        if (promise) {\n          void promise.then(this.textureUpdatedCallback);\n        }\n      }\n    }\n  }\n}\n\nexport class Rectangle {\n  relatedObject: Selection|null;\n  lineWidth: number;\n  borderColor: number[]|null;\n  fillColor: number[]|null;\n  texture: WebGLTexture|null;\n  vertices!: number[];\n  constructor(relatedObject: Selection|null) {\n    this.relatedObject = relatedObject;\n    this.lineWidth = 1;\n    this.borderColor = null;\n    this.fillColor = null;\n    this.texture = null;\n  }\n\n  setVertices(quad: number[], z: number): void {\n    this.vertices = [quad[0], quad[1], z, quad[2], quad[3], z, quad[4], quad[5], z, quad[6], quad[7], z];\n  }\n\n  /**\n   * Finds coordinates of point on layer quad, having offsets (ratioX * width) and (ratioY * height)\n   * from the left corner of the initial layer rect, where width and heigth are layer bounds.\n   */\n  private calculatePointOnQuad(quad: number[], ratioX: number, ratioY: number): number[] {\n    const x0 = quad[0];\n    const y0 = quad[1];\n    const x1 = quad[2];\n    const y1 = quad[3];\n    const x2 = quad[4];\n    const y2 = quad[5];\n    const x3 = quad[6];\n    const y3 = quad[7];\n    // Point on the first quad side clockwise\n    const firstSidePointX = x0 + ratioX * (x1 - x0);\n    const firstSidePointY = y0 + ratioX * (y1 - y0);\n    // Point on the third quad side clockwise\n    const thirdSidePointX = x3 + ratioX * (x2 - x3);\n    const thirdSidePointY = y3 + ratioX * (y2 - y3);\n    const x = firstSidePointX + ratioY * (thirdSidePointX - firstSidePointX);\n    const y = firstSidePointY + ratioY * (thirdSidePointY - firstSidePointY);\n    return [x, y];\n  }\n\n  calculateVerticesFromRect(layer: SDK.LayerTreeBase.Layer, rect: Protocol.DOM.Rect, z: number): void {\n    const quad = layer.quad();\n    const rx1 = rect.x / layer.width();\n    const rx2 = (rect.x + rect.width) / layer.width();\n    const ry1 = rect.y / layer.height();\n    const ry2 = (rect.y + rect.height) / layer.height();\n    const rectQuad = this.calculatePointOnQuad(quad, rx1, ry1)\n                         .concat(this.calculatePointOnQuad(quad, rx2, ry1))\n                         .concat(this.calculatePointOnQuad(quad, rx2, ry2))\n                         .concat(this.calculatePointOnQuad(quad, rx1, ry2));\n    this.setVertices(rectQuad, z);\n  }\n\n  /**\n   * Intersects quad with given transform matrix and line l(t) = (x0, y0, t)\n   */\n  intersectWithLine(matrix: DOMMatrix, x0: number, y0: number): number|undefined {\n    let i;\n    // Vertices of the quad with transform matrix applied\n    const points = [];\n    for (i = 0; i < 4; ++i) {\n      points[i] = UI.Geometry.multiplyVectorByMatrixAndNormalize(\n          new UI.Geometry.Vector(this.vertices[i * 3], this.vertices[i * 3 + 1], this.vertices[i * 3 + 2]), matrix);\n    }\n    // Calculating quad plane normal\n    const normal = UI.Geometry.crossProduct(\n        UI.Geometry.subtract(points[1], points[0]), UI.Geometry.subtract(points[2], points[1]));\n    // General form of the equation of the quad plane: A * x + B * y + C * z + D = 0\n    const A = normal.x;\n    const B = normal.y;\n    const C = normal.z;\n    const D = -(A * points[0].x + B * points[0].y + C * points[0].z);\n    // Finding t from the equation\n    const t = -(D + A * x0 + B * y0) / C;\n    // Point of the intersection\n    const pt = new UI.Geometry.Vector(x0, y0, t);\n    // Vectors from the intersection point to vertices of the quad\n    const tVects = points.map(UI.Geometry.subtract.bind(null, pt));\n    // Intersection point lies inside of the polygon if scalar products of normal of the plane and\n    // cross products of successive tVects are all nonstrictly above or all nonstrictly below zero\n    for (i = 0; i < tVects.length; ++i) {\n      const product =\n          UI.Geometry.scalarProduct(normal, UI.Geometry.crossProduct(tVects[i], tVects[(i + 1) % tVects.length]));\n      if (product < 0) {\n        return undefined;\n      }\n    }\n    return t;\n  }\n}\n\nexport class Tile {\n  snapshot: SDK.PaintProfiler.PaintProfilerSnapshot;\n  rect: Protocol.DOM.Rect;\n  scale: number;\n  texture: WebGLTexture|null;\n  private gl!: WebGLRenderingContext;\n  constructor(snapshotWithRect: SDK.PaintProfiler.SnapshotWithRect) {\n    this.snapshot = snapshotWithRect.snapshot;\n    this.rect = snapshotWithRect.rect;\n    this.scale = 0;\n    this.texture = null;\n  }\n\n  dispose(): void {\n    this.snapshot.release();\n    if (this.texture) {\n      this.gl.deleteTexture(this.texture);\n      this.texture = null;\n    }\n  }\n\n  updateScale(glContext: WebGLRenderingContext, scale: number): Promise<void>|null {\n    if (this.texture && this.scale >= scale) {\n      return null;\n    }\n    return this.update(glContext, scale);\n  }\n\n  async update(glContext: WebGLRenderingContext, scale: number): Promise<void> {\n    this.gl = glContext;\n    this.scale = scale;\n    const imageURL = await this.snapshot.replay(scale);\n    const image = imageURL ? await UI.UIUtils.loadImage(imageURL) : null;\n    this.texture = image ? LayerTextureManager.createTextureForImage(glContext, image) : null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
