{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/css_overview/CSSOverviewModel.ts"],
  "sourcesContent": ["// Copyright 2019 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as ColorPicker from '../../ui/legacy/components/color_picker/color_picker.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nimport type {ContrastIssue} from './CSSOverviewCompletedView.js';\nimport type {UnusedDeclaration} from './CSSOverviewUnusedDeclarations.js';\nimport {CSSOverviewUnusedDeclarations} from './CSSOverviewUnusedDeclarations.js';\n\ninterface NodeStyleStats {\n  elementCount: number;\n  backgroundColors: Map<string, Set<Protocol.DOM.BackendNodeId>>;\n  textColors: Map<string, Set<Protocol.DOM.BackendNodeId>>;\n  textColorContrastIssues: Map<string, ContrastIssue[]>;\n  fillColors: Map<string, Set<Protocol.DOM.BackendNodeId>>;\n  borderColors: Map<string, Set<Protocol.DOM.BackendNodeId>>;\n  fontInfo: Map<string, Map<string, Map<string, Protocol.DOM.BackendNodeId[]>>>;\n  unusedDeclarations: Map<string, UnusedDeclaration[]>;\n}\n\nexport interface GlobalStyleStats {\n  styleRules: number;\n  inlineStyles: number;\n  externalSheets: number;\n  stats: {\n    // Simple.\n    type: number,\n    class: number,\n    id: number,\n    universal: number,\n    attribute: number,\n\n    // Non-simple.\n    nonSimple: number,\n  };\n}\n\nexport class CSSOverviewModel extends SDK.SDKModel.SDKModel<void> {\n  readonly #runtimeAgent: ProtocolProxyApi.RuntimeApi;\n  readonly #cssAgent: ProtocolProxyApi.CSSApi;\n  readonly #domSnapshotAgent: ProtocolProxyApi.DOMSnapshotApi;\n  readonly #overlayAgent: ProtocolProxyApi.OverlayApi;\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n\n    this.#runtimeAgent = target.runtimeAgent();\n    this.#cssAgent = target.cssAgent();\n    this.#domSnapshotAgent = target.domsnapshotAgent();\n    this.#overlayAgent = target.overlayAgent();\n  }\n\n  highlightNode(node: Protocol.DOM.BackendNodeId): void {\n    const highlightConfig = {\n      contentColor: Common.Color.PageHighlight.Content.toProtocolRGBA(),\n      showInfo: true,\n      contrastAlgorithm: Root.Runtime.experiments.isEnabled('APCA') ? Protocol.Overlay.ContrastAlgorithm.Apca :\n                                                                      Protocol.Overlay.ContrastAlgorithm.Aa,\n    };\n\n    void this.#overlayAgent.invoke_hideHighlight();\n    void this.#overlayAgent.invoke_highlightNode({backendNodeId: node, highlightConfig});\n  }\n\n  async getNodeStyleStats(): Promise<NodeStyleStats> {\n    const backgroundColors = new Map();\n    const textColors = new Map();\n    const textColorContrastIssues = new Map();\n    const fillColors = new Map();\n    const borderColors = new Map();\n    const fontInfo = new Map();\n    const unusedDeclarations = new Map();\n    const snapshotConfig = {\n      computedStyles: [\n        'background-color',\n        'color',\n        'fill',\n        'border-top-width',\n        'border-top-color',\n        'border-bottom-width',\n        'border-bottom-color',\n        'border-left-width',\n        'border-left-color',\n        'border-right-width',\n        'border-right-color',\n        'font-family',\n        'font-size',\n        'font-weight',\n        'line-height',\n        'position',\n        'top',\n        'right',\n        'bottom',\n        'left',\n        'display',\n        'width',\n        'height',\n        'vertical-align',\n      ],\n      includeTextColorOpacities: true,\n      includeBlendedBackgroundColors: true,\n    };\n\n    const formatColor = (color: Common.Color.Color): string|null => {\n      return color.hasAlpha() ? color.asString(Common.Color.Format.HEXA) : color.asString(Common.Color.Format.HEX);\n    };\n\n    const storeColor = (id: number, nodeId: number, target: Map<string, Set<number>>): Common.Color.Color|undefined => {\n      if (id === -1) {\n        return;\n      }\n\n      // Parse the color, discard transparent ones.\n      const colorText = strings[id];\n      if (!colorText) {\n        return;\n      }\n\n      const color = Common.Color.Color.parse(colorText);\n      if (!color || color.rgba()[3] === 0) {\n        return;\n      }\n\n      // Format the color and use as the key.\n      const colorFormatted = formatColor(color);\n      if (!colorFormatted) {\n        return;\n      }\n\n      // Get the existing set of nodes with the color, or create a new set.\n      const colorValues = target.get(colorFormatted) || new Set();\n      colorValues.add(nodeId);\n\n      // Store.\n      target.set(colorFormatted, colorValues);\n\n      return color;\n    };\n\n    const isSVGNode = (nodeName: string): boolean => {\n      const validNodes = new Set([\n        'altglyph',\n        'circle',\n        'ellipse',\n        'path',\n        'polygon',\n        'polyline',\n        'rect',\n        'svg',\n        'text',\n        'textpath',\n        'tref',\n        'tspan',\n      ]);\n      return validNodes.has(nodeName.toLowerCase());\n    };\n\n    const isReplacedContent = (nodeName: string): boolean => {\n      const validNodes = new Set(['iframe', 'video', 'embed', 'img']);\n      return validNodes.has(nodeName.toLowerCase());\n    };\n\n    const isTableElementWithDefaultStyles = (nodeName: string, display: string): boolean => {\n      const validNodes = new Set(['tr', 'td', 'thead', 'tbody']);\n      return validNodes.has(nodeName.toLowerCase()) && display.startsWith('table');\n    };\n\n    let elementCount = 0;\n\n    const {documents, strings} = await this.#domSnapshotAgent.invoke_captureSnapshot(snapshotConfig);\n    for (const {nodes, layout} of documents) {\n      // Track the number of elements in the documents.\n      elementCount += layout.nodeIndex.length;\n\n      for (let idx = 0; idx < layout.styles.length; idx++) {\n        const styles = layout.styles[idx];\n        const nodeIdx = layout.nodeIndex[idx];\n        if (!nodes.backendNodeId || !nodes.nodeName) {\n          continue;\n        }\n        const nodeId = nodes.backendNodeId[nodeIdx];\n        const nodeName = nodes.nodeName[nodeIdx];\n\n        const [backgroundColorIdx, textColorIdx, fillIdx, borderTopWidthIdx, borderTopColorIdx, borderBottomWidthIdx, borderBottomColorIdx, borderLeftWidthIdx, borderLeftColorIdx, borderRightWidthIdx, borderRightColorIdx, fontFamilyIdx, fontSizeIdx, fontWeightIdx, lineHeightIdx, positionIdx, topIdx, rightIdx, bottomIdx, leftIdx, displayIdx, widthIdx, heightIdx, verticalAlignIdx] =\n            styles;\n\n        storeColor(backgroundColorIdx, nodeId, backgroundColors);\n        const textColor = storeColor(textColorIdx, nodeId, textColors);\n\n        if (isSVGNode(strings[nodeName])) {\n          storeColor(fillIdx, nodeId, fillColors);\n        }\n\n        if (strings[borderTopWidthIdx] !== '0px') {\n          storeColor(borderTopColorIdx, nodeId, borderColors);\n        }\n\n        if (strings[borderBottomWidthIdx] !== '0px') {\n          storeColor(borderBottomColorIdx, nodeId, borderColors);\n        }\n\n        if (strings[borderLeftWidthIdx] !== '0px') {\n          storeColor(borderLeftColorIdx, nodeId, borderColors);\n        }\n\n        if (strings[borderRightWidthIdx] !== '0px') {\n          storeColor(borderRightColorIdx, nodeId, borderColors);\n        }\n\n        /**\n         * Create a structure like this for font info:\n         *\n         *                 / size (Map) -- nodes (Array)\n         *                /\n         * Font family (Map) ----- weight (Map) -- nodes (Array)\n         *                \\\n         *                 \\ line-height (Map) -- nodes (Array)\n         */\n        if (fontFamilyIdx && fontFamilyIdx !== -1) {\n          const fontFamily = strings[fontFamilyIdx];\n          const fontFamilyInfo = fontInfo.get(fontFamily) || new Map();\n\n          const sizeLabel = 'font-size';\n          const weightLabel = 'font-weight';\n          const lineHeightLabel = 'line-height';\n\n          const size = fontFamilyInfo.get(sizeLabel) || new Map();\n          const weight = fontFamilyInfo.get(weightLabel) || new Map();\n          const lineHeight = fontFamilyInfo.get(lineHeightLabel) || new Map();\n\n          if (fontSizeIdx !== -1) {\n            const fontSizeValue = strings[fontSizeIdx];\n            const nodes = size.get(fontSizeValue) || [];\n            nodes.push(nodeId);\n            size.set(fontSizeValue, nodes);\n          }\n\n          if (fontWeightIdx !== -1) {\n            const fontWeightValue = strings[fontWeightIdx];\n            const nodes = weight.get(fontWeightValue) || [];\n            nodes.push(nodeId);\n            weight.set(fontWeightValue, nodes);\n          }\n\n          if (lineHeightIdx !== -1) {\n            const lineHeightValue = strings[lineHeightIdx];\n            const nodes = lineHeight.get(lineHeightValue) || [];\n            nodes.push(nodeId);\n            lineHeight.set(lineHeightValue, nodes);\n          }\n\n          // Set the data back.\n          fontFamilyInfo.set(sizeLabel, size);\n          fontFamilyInfo.set(weightLabel, weight);\n          fontFamilyInfo.set(lineHeightLabel, lineHeight);\n          fontInfo.set(fontFamily, fontFamilyInfo);\n        }\n\n        const blendedBackgroundColor =\n            textColor && layout.blendedBackgroundColors && layout.blendedBackgroundColors[idx] !== -1 ?\n            Common.Color.Color.parse(strings[layout.blendedBackgroundColors[idx]]) :\n            null;\n        if (textColor && blendedBackgroundColor) {\n          const contrastInfo = new ColorPicker.ContrastInfo.ContrastInfo({\n            backgroundColors: [blendedBackgroundColor.asString(Common.Color.Format.HEXA) as string],\n            computedFontSize: fontSizeIdx !== -1 ? strings[fontSizeIdx] : '',\n            computedFontWeight: fontWeightIdx !== -1 ? strings[fontWeightIdx] : '',\n          });\n          const blendedTextColor =\n              textColor.blendWithAlpha(layout.textColorOpacities ? layout.textColorOpacities[idx] : 1);\n          contrastInfo.setColor(blendedTextColor);\n          const formattedTextColor = formatColor(blendedTextColor);\n          const formattedBackgroundColor = formatColor(blendedBackgroundColor);\n          const key = `${formattedTextColor}_${formattedBackgroundColor}`;\n          if (Root.Runtime.experiments.isEnabled('APCA')) {\n            const contrastRatio = contrastInfo.contrastRatioAPCA();\n            const threshold = contrastInfo.contrastRatioAPCAThreshold();\n            const passes = contrastRatio && threshold ? Math.abs(contrastRatio) >= threshold : false;\n            if (!passes) {\n              const issue = {\n                nodeId,\n                contrastRatio,\n                textColor: blendedTextColor,\n                backgroundColor: blendedBackgroundColor,\n                thresholdsViolated: {\n                  aa: false,\n                  aaa: false,\n                  apca: true,\n                },\n              };\n              if (textColorContrastIssues.has(key)) {\n                textColorContrastIssues.get(key).push(issue);\n              } else {\n                textColorContrastIssues.set(key, [issue]);\n              }\n            }\n          } else {\n            const aaThreshold = contrastInfo.contrastRatioThreshold('aa') || 0;\n            const aaaThreshold = contrastInfo.contrastRatioThreshold('aaa') || 0;\n            const contrastRatio = contrastInfo.contrastRatio() || 0;\n            if (aaThreshold > contrastRatio || aaaThreshold > contrastRatio) {\n              const issue = {\n                nodeId,\n                contrastRatio,\n                textColor: blendedTextColor,\n                backgroundColor: blendedBackgroundColor,\n                thresholdsViolated: {\n                  aa: aaThreshold > contrastRatio,\n                  aaa: aaaThreshold > contrastRatio,\n                  apca: false,\n                },\n              };\n              if (textColorContrastIssues.has(key)) {\n                textColorContrastIssues.get(key).push(issue);\n              } else {\n                textColorContrastIssues.set(key, [issue]);\n              }\n            }\n          }\n        }\n\n        CSSOverviewUnusedDeclarations.checkForUnusedPositionValues(\n            unusedDeclarations, nodeId, strings, positionIdx, topIdx, leftIdx, rightIdx, bottomIdx);\n\n        // Ignore SVG elements as, despite being inline by default, they can have width & height specified.\n        // Also ignore replaced content, for similar reasons.\n        if (!isSVGNode(strings[nodeName]) && !isReplacedContent(strings[nodeName])) {\n          CSSOverviewUnusedDeclarations.checkForUnusedWidthAndHeightValues(\n              unusedDeclarations, nodeId, strings, displayIdx, widthIdx, heightIdx);\n        }\n\n        if (verticalAlignIdx !== -1 && !isTableElementWithDefaultStyles(strings[nodeName], strings[displayIdx])) {\n          CSSOverviewUnusedDeclarations.checkForInvalidVerticalAlignment(\n              unusedDeclarations, nodeId, strings, displayIdx, verticalAlignIdx);\n        }\n      }\n    }\n\n    return {\n      backgroundColors,\n      textColors,\n      textColorContrastIssues,\n      fillColors,\n      borderColors,\n      fontInfo,\n      unusedDeclarations,\n      elementCount,\n    };\n  }\n\n  getComputedStyleForNode(nodeId: Protocol.DOM.NodeId): Promise<Protocol.CSS.GetComputedStyleForNodeResponse> {\n    return this.#cssAgent.invoke_getComputedStyleForNode({nodeId});\n  }\n\n  async getMediaQueries(): Promise<Map<string, Protocol.CSS.CSSMedia[]>> {\n    const queries = await this.#cssAgent.invoke_getMediaQueries();\n    const queryMap = new Map<string, Protocol.CSS.CSSMedia[]>();\n\n    if (!queries) {\n      return queryMap;\n    }\n\n    for (const query of queries.medias) {\n      // Ignore media queries applied to stylesheets; instead only use declared media rules.\n      if (query.source === 'linkedSheet') {\n        continue;\n      }\n\n      const entries = queryMap.get(query.text) || ([] as Protocol.CSS.CSSMedia[]);\n      entries.push(query);\n      queryMap.set(query.text, entries);\n    }\n\n    return queryMap;\n  }\n\n  async getGlobalStylesheetStats(): Promise<GlobalStyleStats|void> {\n    // There are no ways to pull CSSOM values directly today, due to its unserializable format,\n    // so instead we execute some JS within the page that extracts the relevant data and send that instead.\n    const expression = `(function() {\n      let styleRules = 0;\n      let inlineStyles = 0;\n      let externalSheets = 0;\n      const stats = {\n        // Simple.\n        type: new Set(),\n        class: new Set(),\n        id: new Set(),\n        universal: new Set(),\n        attribute: new Set(),\n\n        // Non-simple.\n        nonSimple: new Set()\n      };\n\n      for (const styleSheet of document.styleSheets) {\n        if (styleSheet.href) {\n          externalSheets++;\n        } else {\n          inlineStyles++;\n        }\n\n        // Attempting to grab rules can trigger a DOMException.\n        // Try it and if it fails skip to the next stylesheet.\n        let rules;\n        try {\n          rules = styleSheet.rules;\n        } catch (err) {\n          continue;\n        }\n\n        for (const rule of rules) {\n          if ('selectorText' in rule) {\n            styleRules++;\n\n            // Each group that was used.\n            for (const selectorGroup of rule.selectorText.split(',')) {\n              // Each selector in the group.\n              for (const selector of selectorGroup.split(\\/[\\\\t\\\\n\\\\f\\\\r ]+\\/g)) {\n                if (selector.startsWith('.')) {\n                  // Class.\n                  stats.class.add(selector);\n                } else if (selector.startsWith('#')) {\n                  // Id.\n                  stats.id.add(selector);\n                } else if (selector.startsWith('*')) {\n                  // Universal.\n                  stats.universal.add(selector);\n                } else if (selector.startsWith('[')) {\n                  // Attribute.\n                  stats.attribute.add(selector);\n                } else {\n                  // Type or non-simple selector.\n                  const specialChars = \\/[#\\.:\\\\[\\\\]|\\\\+>~]\\/;\n                  if (specialChars.test(selector)) {\n                    stats.nonSimple.add(selector);\n                  } else {\n                    stats.type.add(selector);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return {\n        styleRules,\n        inlineStyles,\n        externalSheets,\n        stats: {\n          // Simple.\n          type: stats.type.size,\n          class: stats.class.size,\n          id: stats.id.size,\n          universal: stats.universal.size,\n          attribute: stats.attribute.size,\n\n          // Non-simple.\n          nonSimple: stats.nonSimple.size\n        }\n      }\n    })()`;\n    const {result} = await this.#runtimeAgent.invoke_evaluate({expression, returnByValue: true});\n\n    // TODO(paullewis): Handle errors properly.\n    if (result.type !== 'object') {\n      return;\n    }\n\n    return result.value;\n  }\n}\n\nSDK.SDKModel.SDKModel.register(CSSOverviewModel, {capabilities: SDK.Target.Capability.DOM, autostart: false});\n"],
  "mappings": "AAIA;AACA;AACA;AACA;AAEA;AAIA;AA8BO,sCAA+B,IAAI,SAAS,SAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhE,YAAY,QAA2B;AACrC,UAAM;AAEN,yBAAqB,OAAO;AAC5B,qBAAiB,OAAO;AACxB,6BAAyB,OAAO;AAChC,yBAAqB,OAAO;AAAA;AAAA,EAG9B,cAAc,MAAwC;AACpD,UAAM,kBAAkB;AAAA,MACtB,cAAc,OAAO,MAAM,cAAc,QAAQ;AAAA,MACjD,UAAU;AAAA,MACV,mBAAmB,KAAK,QAAQ,YAAY,UAAU,UAAU,SAAS,QAAQ,kBAAkB,OACnC,SAAS,QAAQ,kBAAkB;AAAA;AAGrG,SAAK,mBAAmB;AACxB,SAAK,mBAAmB,qBAAqB,EAAC,eAAe,MAAM;AAAA;AAAA,QAG/D,oBAA6C;AACjD,UAAM,mBAAmB,oBAAI;AAC7B,UAAM,aAAa,oBAAI;AACvB,UAAM,0BAA0B,oBAAI;AACpC,UAAM,aAAa,oBAAI;AACvB,UAAM,eAAe,oBAAI;AACzB,UAAM,WAAW,oBAAI;AACrB,UAAM,qBAAqB,oBAAI;AAC/B,UAAM,iBAAiB;AAAA,MACrB,gBAAgB;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,MAEF,2BAA2B;AAAA,MAC3B,gCAAgC;AAAA;AAGlC,UAAM,cAAc,CAAC,UAA2C;AAC9D,aAAO,MAAM,aAAa,MAAM,SAAS,OAAO,MAAM,OAAO,QAAQ,MAAM,SAAS,OAAO,MAAM,OAAO;AAAA;AAG1G,UAAM,aAAa,CAAC,IAAY,QAAgB,WAAmE;AACjH,UAAI,OAAO,IAAI;AACb;AAAA;AAIF,YAAM,YAAY,QAAQ;AAC1B,UAAI,CAAC,WAAW;AACd;AAAA;AAGF,YAAM,QAAQ,OAAO,MAAM,MAAM,MAAM;AACvC,UAAI,CAAC,SAAS,MAAM,OAAO,OAAO,GAAG;AACnC;AAAA;AAIF,YAAM,iBAAiB,YAAY;AACnC,UAAI,CAAC,gBAAgB;AACnB;AAAA;AAIF,YAAM,cAAc,OAAO,IAAI,mBAAmB,oBAAI;AACtD,kBAAY,IAAI;AAGhB,aAAO,IAAI,gBAAgB;AAE3B,aAAO;AAAA;AAGT,UAAM,YAAY,CAAC,aAA8B;AAC/C,YAAM,aAAa,oBAAI,IAAI;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAEF,aAAO,WAAW,IAAI,SAAS;AAAA;AAGjC,UAAM,oBAAoB,CAAC,aAA8B;AACvD,YAAM,aAAa,oBAAI,IAAI,CAAC,UAAU,SAAS,SAAS;AACxD,aAAO,WAAW,IAAI,SAAS;AAAA;AAGjC,UAAM,kCAAkC,CAAC,UAAkB,YAA6B;AACtF,YAAM,aAAa,oBAAI,IAAI,CAAC,MAAM,MAAM,SAAS;AACjD,aAAO,WAAW,IAAI,SAAS,kBAAkB,QAAQ,WAAW;AAAA;AAGtE,QAAI,eAAe;AAEnB,UAAM,EAAC,WAAW,YAAW,MAAM,uBAAuB,uBAAuB;AACjF,eAAW,EAAC,OAAO,YAAW,WAAW;AAEvC,sBAAgB,OAAO,UAAU;AAEjC,eAAS,MAAM,GAAG,MAAM,OAAO,OAAO,QAAQ,OAAO;AACnD,cAAM,SAAS,OAAO,OAAO;AAC7B,cAAM,UAAU,OAAO,UAAU;AACjC,YAAI,CAAC,MAAM,iBAAiB,CAAC,MAAM,UAAU;AAC3C;AAAA;AAEF,cAAM,SAAS,MAAM,cAAc;AACnC,cAAM,WAAW,MAAM,SAAS;AAEhC,cAAM,CAAC,oBAAoB,cAAc,SAAS,mBAAmB,mBAAmB,sBAAsB,sBAAsB,oBAAoB,oBAAoB,qBAAqB,qBAAqB,eAAe,aAAa,eAAe,eAAe,aAAa,QAAQ,UAAU,WAAW,SAAS,YAAY,UAAU,WAAW,oBAChW;AAEJ,mBAAW,oBAAoB,QAAQ;AACvC,cAAM,YAAY,WAAW,cAAc,QAAQ;AAEnD,YAAI,UAAU,QAAQ,YAAY;AAChC,qBAAW,SAAS,QAAQ;AAAA;AAG9B,YAAI,QAAQ,uBAAuB,OAAO;AACxC,qBAAW,mBAAmB,QAAQ;AAAA;AAGxC,YAAI,QAAQ,0BAA0B,OAAO;AAC3C,qBAAW,sBAAsB,QAAQ;AAAA;AAG3C,YAAI,QAAQ,wBAAwB,OAAO;AACzC,qBAAW,oBAAoB,QAAQ;AAAA;AAGzC,YAAI,QAAQ,yBAAyB,OAAO;AAC1C,qBAAW,qBAAqB,QAAQ;AAAA;AAY1C,YAAI,iBAAiB,kBAAkB,IAAI;AACzC,gBAAM,aAAa,QAAQ;AAC3B,gBAAM,iBAAiB,SAAS,IAAI,eAAe,oBAAI;AAEvD,gBAAM,YAAY;AAClB,gBAAM,cAAc;AACpB,gBAAM,kBAAkB;AAExB,gBAAM,OAAO,eAAe,IAAI,cAAc,oBAAI;AAClD,gBAAM,SAAS,eAAe,IAAI,gBAAgB,oBAAI;AACtD,gBAAM,aAAa,eAAe,IAAI,oBAAoB,oBAAI;AAE9D,cAAI,gBAAgB,IAAI;AACtB,kBAAM,gBAAgB,QAAQ;AAC9B,kBAAM,SAAQ,KAAK,IAAI,kBAAkB;AACzC,mBAAM,KAAK;AACX,iBAAK,IAAI,eAAe;AAAA;AAG1B,cAAI,kBAAkB,IAAI;AACxB,kBAAM,kBAAkB,QAAQ;AAChC,kBAAM,SAAQ,OAAO,IAAI,oBAAoB;AAC7C,mBAAM,KAAK;AACX,mBAAO,IAAI,iBAAiB;AAAA;AAG9B,cAAI,kBAAkB,IAAI;AACxB,kBAAM,kBAAkB,QAAQ;AAChC,kBAAM,SAAQ,WAAW,IAAI,oBAAoB;AACjD,mBAAM,KAAK;AACX,uBAAW,IAAI,iBAAiB;AAAA;AAIlC,yBAAe,IAAI,WAAW;AAC9B,yBAAe,IAAI,aAAa;AAChC,yBAAe,IAAI,iBAAiB;AACpC,mBAAS,IAAI,YAAY;AAAA;AAG3B,cAAM,yBACF,aAAa,OAAO,2BAA2B,OAAO,wBAAwB,SAAS,KACvF,OAAO,MAAM,MAAM,MAAM,QAAQ,OAAO,wBAAwB,SAChE;AACJ,YAAI,aAAa,wBAAwB;AACvC,gBAAM,eAAe,IAAI,YAAY,aAAa,aAAa;AAAA,YAC7D,kBAAkB,CAAC,uBAAuB,SAAS,OAAO,MAAM,OAAO;AAAA,YACvE,kBAAkB,gBAAgB,KAAK,QAAQ,eAAe;AAAA,YAC9D,oBAAoB,kBAAkB,KAAK,QAAQ,iBAAiB;AAAA;AAEtE,gBAAM,mBACF,UAAU,eAAe,OAAO,qBAAqB,OAAO,mBAAmB,OAAO;AAC1F,uBAAa,SAAS;AACtB,gBAAM,qBAAqB,YAAY;AACvC,gBAAM,2BAA2B,YAAY;AAC7C,gBAAM,MAAM,GAAG,sBAAsB;AACrC,cAAI,KAAK,QAAQ,YAAY,UAAU,SAAS;AAC9C,kBAAM,gBAAgB,aAAa;AACnC,kBAAM,YAAY,aAAa;AAC/B,kBAAM,SAAS,iBAAiB,YAAY,KAAK,IAAI,kBAAkB,YAAY;AACnF,gBAAI,CAAC,QAAQ;AACX,oBAAM,QAAQ;AAAA,gBACZ;AAAA,gBACA;AAAA,gBACA,WAAW;AAAA,gBACX,iBAAiB;AAAA,gBACjB,oBAAoB;AAAA,kBAClB,IAAI;AAAA,kBACJ,KAAK;AAAA,kBACL,MAAM;AAAA;AAAA;AAGV,kBAAI,wBAAwB,IAAI,MAAM;AACpC,wCAAwB,IAAI,KAAK,KAAK;AAAA,qBACjC;AACL,wCAAwB,IAAI,KAAK,CAAC;AAAA;AAAA;AAAA,iBAGjC;AACL,kBAAM,cAAc,aAAa,uBAAuB,SAAS;AACjE,kBAAM,eAAe,aAAa,uBAAuB,UAAU;AACnE,kBAAM,gBAAgB,aAAa,mBAAmB;AACtD,gBAAI,cAAc,iBAAiB,eAAe,eAAe;AAC/D,oBAAM,QAAQ;AAAA,gBACZ;AAAA,gBACA;AAAA,gBACA,WAAW;AAAA,gBACX,iBAAiB;AAAA,gBACjB,oBAAoB;AAAA,kBAClB,IAAI,cAAc;AAAA,kBAClB,KAAK,eAAe;AAAA,kBACpB,MAAM;AAAA;AAAA;AAGV,kBAAI,wBAAwB,IAAI,MAAM;AACpC,wCAAwB,IAAI,KAAK,KAAK;AAAA,qBACjC;AACL,wCAAwB,IAAI,KAAK,CAAC;AAAA;AAAA;AAAA;AAAA;AAM1C,sCAA8B,6BAC1B,oBAAoB,QAAQ,SAAS,aAAa,QAAQ,SAAS,UAAU;AAIjF,YAAI,CAAC,UAAU,QAAQ,cAAc,CAAC,kBAAkB,QAAQ,YAAY;AAC1E,wCAA8B,mCAC1B,oBAAoB,QAAQ,SAAS,YAAY,UAAU;AAAA;AAGjE,YAAI,qBAAqB,MAAM,CAAC,gCAAgC,QAAQ,WAAW,QAAQ,cAAc;AACvG,wCAA8B,iCAC1B,oBAAoB,QAAQ,SAAS,YAAY;AAAA;AAAA;AAAA;AAK3D,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA,EAIJ,wBAAwB,QAAoF;AAC1G,WAAO,eAAe,+BAA+B,EAAC;AAAA;AAAA,QAGlD,kBAAiE;AACrE,UAAM,UAAU,MAAM,eAAe;AACrC,UAAM,WAAW,oBAAI;AAErB,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA;AAGT,eAAW,SAAS,QAAQ,QAAQ;AAElC,UAAI,MAAM,WAAW,eAAe;AAClC;AAAA;AAGF,YAAM,UAAU,SAAS,IAAI,MAAM,SAAU;AAC7C,cAAQ,KAAK;AACb,eAAS,IAAI,MAAM,MAAM;AAAA;AAG3B,WAAO;AAAA;AAAA,QAGH,2BAA2D;AAG/D,UAAM,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoFnB,UAAM,EAAC,WAAU,MAAM,mBAAmB,gBAAgB,EAAC,YAAY,eAAe;AAGtF,QAAI,OAAO,SAAS,UAAU;AAC5B;AAAA;AAGF,WAAO,OAAO;AAAA;AAAA;AAIlB,IAAI,SAAS,SAAS,SAAS,kBAAkB,EAAC,cAAc,IAAI,OAAO,WAAW,KAAK,WAAW;",
  "names": []
}
