{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/lighthouse/LighthouseProtocolService.ts"],
  "sourcesContent": ["// Copyright 2018 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\n\nimport type * as ReportRenderer from './LighthouseReporterTypes.js';\n\n/**\n * @overview\n                                                   \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                                   \u2502CDP Backend \u2502\n                                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                        \u2502 \u25B2\n                                                        \u2502 \u2502 parallelConnection\n                          \u250C\u2510                            \u25BC \u2502                     \u250C\u2510\n                          \u2502\u2502   dispatchProtocolMessage     sendProtocolMessage  \u2502\u2502\n                          \u2502\u2502                     \u2502          \u25B2                   \u2502\u2502\n          ProtocolService \u2502\u2502                     |          \u2502                   \u2502\u2502\n                          \u2502\u2502    sendWithResponse \u25BC          \u2502                   \u2502\u2502\n                          \u2502\u2502              \u2502    send          onWorkerMessage    \u2502\u2502\n                          \u2514\u2518              \u2502    \u2502                 \u25B2              \u2514\u2518\n          worker boundary - - - - - - - - \u253C - -\u2502- - - - - - - - -\u2502- - - - - - - - - - - -\n                          \u250C\u2510              \u25BC    \u25BC                 \u2502                    \u250C\u2510\n                          \u2502\u2502   onFrontendMessage      notifyFrontendViaWorkerMessage  \u2502\u2502\n                          \u2502\u2502                   \u2502       \u25B2                              \u2502\u2502\n                          \u2502\u2502                   \u25BC       \u2502                              \u2502\u2502\nLighthouseWorkerService   \u2502\u2502          Either ConnectionProxy or LegacyPort            \u2502\u2502\n                          \u2502\u2502                           \u2502 \u25B2                            \u2502\u2502\n                          \u2502\u2502     \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\u2502\n                          \u2502\u2502     \u2502  Lighthouse    \u250C\u2500\u2500\u2500\u2500\u25BC\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u2502    \u2502\u2502\n                          \u2502\u2502     \u2502                \u2502connection \u2502                  \u2502    \u2502\u2502\n                          \u2502\u2502     \u2502                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                  \u2502    \u2502\u2502\n                          \u2514\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2518\n\n * All messages traversing the worker boundary are action-wrapped.\n * All messages over the parallelConnection speak pure CDP.\n * All messages within ConnectionProxy/LegacyPort speak pure CDP.\n * The foundational CDP connection is `parallelConnection`.\n * All connections within the worker are not actual ParallelConnection's.\n*/\n\nlet lastId = 1;\n\nexport interface LighthouseRun {\n  inspectedURL: Platform.DevToolsPath.UrlString;\n  categoryIDs: string[];\n  flags: Record<string, Object|undefined>;\n}\n\n/**\n * ProtocolService manages a connection between the frontend (Lighthouse panel) and the Lighthouse worker.\n */\nexport class ProtocolService {\n  private targetInfo?: {\n    mainSessionId: string,\n    mainTargetId: string,\n    mainFrameId: string,\n  };\n  private parallelConnection?: ProtocolClient.InspectorBackend.Connection;\n  private lighthouseWorkerPromise?: Promise<Worker>;\n  private lighthouseMessageUpdateCallback?: ((arg0: string) => void);\n\n  async attach(): Promise<void> {\n    await SDK.TargetManager.TargetManager.instance().suspendAllTargets();\n    const mainTarget = SDK.TargetManager.TargetManager.instance().mainTarget();\n    if (!mainTarget) {\n      throw new Error('Unable to find main target required for Lighthouse');\n    }\n    const childTargetManager = mainTarget.model(SDK.ChildTargetManager.ChildTargetManager);\n    if (!childTargetManager) {\n      throw new Error('Unable to find child target manager required for Lighthouse');\n    }\n    const resourceTreeModel = mainTarget.model(SDK.ResourceTreeModel.ResourceTreeModel);\n    if (!resourceTreeModel) {\n      throw new Error('Unable to find resource tree model required for Lighthouse');\n    }\n    const mainFrame = resourceTreeModel.mainFrame;\n    if (!mainFrame) {\n      throw new Error('Unable to find main frame required for Lighthouse');\n    }\n\n    const {connection, sessionId} = await childTargetManager.createParallelConnection(message => {\n      if (typeof message === 'string') {\n        message = JSON.parse(message);\n      }\n      this.dispatchProtocolMessage(message);\n    });\n\n    this.parallelConnection = connection;\n    this.targetInfo = {\n      mainTargetId: await childTargetManager.getParentTargetId(),\n      mainFrameId: mainFrame.id,\n      mainSessionId: sessionId,\n    };\n  }\n\n  getLocales(): readonly string[] {\n    return [i18n.DevToolsLocale.DevToolsLocale.instance().locale];\n  }\n\n  async startTimespan(currentLighthouseRun: LighthouseRun): Promise<void> {\n    const {inspectedURL, categoryIDs, flags} = currentLighthouseRun;\n\n    if (!this.targetInfo) {\n      throw new Error('Unable to get target info required for Lighthouse');\n    }\n\n    await this.sendWithResponse('startTimespan', {\n      url: inspectedURL,\n      categoryIDs,\n      flags,\n      locales: this.getLocales(),\n      target: this.targetInfo,\n    });\n  }\n\n  async collectLighthouseResults(currentLighthouseRun: LighthouseRun): Promise<ReportRenderer.RunnerResult> {\n    const {inspectedURL, categoryIDs, flags} = currentLighthouseRun;\n\n    if (!this.targetInfo) {\n      throw new Error('Unable to get target info required for Lighthouse');\n    }\n\n    let mode = flags.mode as string;\n    if (mode === 'timespan') {\n      mode = 'endTimespan';\n    }\n\n    return this.sendWithResponse(mode, {\n      url: inspectedURL,\n      categoryIDs,\n      flags,\n      locales: this.getLocales(),\n      target: this.targetInfo,\n    });\n  }\n\n  async detach(): Promise<void> {\n    const oldLighthouseWorker = this.lighthouseWorkerPromise;\n    const oldParallelConnection = this.parallelConnection;\n\n    // When detaching, make sure that we remove the old promises, before we\n    // perform any async cleanups. That way, if there is a message coming from\n    // lighthouse while we are in the process of cleaning up, we shouldn't deliver\n    // them to the backend.\n    this.lighthouseWorkerPromise = undefined;\n    this.parallelConnection = undefined;\n\n    if (oldLighthouseWorker) {\n      (await oldLighthouseWorker).terminate();\n    }\n    if (oldParallelConnection) {\n      await oldParallelConnection.disconnect();\n    }\n    await SDK.TargetManager.TargetManager.instance().resumeAllTargets();\n  }\n\n  registerStatusCallback(callback: (arg0: string) => void): void {\n    this.lighthouseMessageUpdateCallback = callback;\n  }\n\n  private dispatchProtocolMessage(message: Object): void {\n    // A message without a sessionId is the main session of the main target (call it \"Main session\").\n    // A parallel connection and session was made that connects to the same main target (call it \"Lighthouse session\").\n    // Messages from the \"Lighthouse session\" have a sessionId.\n    // Without some care, there is a risk of sending the same events for the same main frame to Lighthouse\u2013the backend\n    // will create events for the \"Main session\" and the \"Lighthouse session\".\n    // The workaround\u2013only send message to Lighthouse if:\n    //   * the message has a sessionId (is not for the \"Main session\")\n    //   * the message does not have a sessionId (is for the \"Main session\"), but only for the Target domain\n    //     (to kickstart autoAttach in LH).\n    const protocolMessage = message as {\n      sessionId?: string,\n      method?: string,\n    };\n    if (protocolMessage.sessionId || (protocolMessage.method && protocolMessage.method.startsWith('Target'))) {\n      void this.send('dispatchProtocolMessage', {message: JSON.stringify(message)});\n    }\n  }\n\n  private initWorker(): Promise<Worker> {\n    this.lighthouseWorkerPromise = new Promise<Worker>(resolve => {\n      const workerUrl = new URL('../../entrypoints/lighthouse_worker/lighthouse_worker.js', import.meta.url);\n      const remoteBaseSearchParam = new URL(self.location.href).searchParams.get('remoteBase');\n      if (remoteBaseSearchParam) {\n        // Allows Lighthouse worker to fetch remote locale files.\n        workerUrl.searchParams.set('remoteBase', remoteBaseSearchParam);\n      }\n      const worker = new Worker(workerUrl, {type: 'module'});\n\n      worker.addEventListener('message', event => {\n        if (event.data === 'workerReady') {\n          resolve(worker);\n          return;\n        }\n\n        this.onWorkerMessage(event);\n      });\n    });\n    return this.lighthouseWorkerPromise;\n  }\n\n  private async ensureWorkerExists(): Promise<Worker> {\n    let worker: Worker;\n    if (!this.lighthouseWorkerPromise) {\n      worker = await this.initWorker();\n    } else {\n      worker = await this.lighthouseWorkerPromise;\n    }\n    return worker;\n  }\n\n  private onWorkerMessage(event: MessageEvent): void {\n    const lighthouseMessage = JSON.parse(event.data);\n\n    if (lighthouseMessage.action === 'statusUpdate') {\n      if (this.lighthouseMessageUpdateCallback && lighthouseMessage.args && 'message' in lighthouseMessage.args) {\n        this.lighthouseMessageUpdateCallback(lighthouseMessage.args.message as string);\n      }\n    } else if (lighthouseMessage.action === 'sendProtocolMessage') {\n      if (lighthouseMessage.args && 'message' in lighthouseMessage.args) {\n        this.sendProtocolMessage(lighthouseMessage.args.message as string);\n      }\n    }\n  }\n\n  private sendProtocolMessage(message: string): void {\n    if (this.parallelConnection) {\n      this.parallelConnection.sendRawMessage(message);\n    }\n  }\n\n  private async send(action: string, args: {[x: string]: string|string[]|Object} = {}): Promise<void> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    worker.postMessage(JSON.stringify({id: messageId, action, args: {...args, id: messageId}}));\n  }\n\n  /** sendWithResponse currently only handles the original startLighthouse request and LHR-filled response. */\n  private async sendWithResponse(action: string, args: {[x: string]: string|string[]|Object} = {}):\n      Promise<ReportRenderer.RunnerResult> {\n    const worker = await this.ensureWorkerExists();\n    const messageId = lastId++;\n    const messageResult = new Promise<ReportRenderer.RunnerResult>(resolve => {\n      const workerListener = (event: MessageEvent): void => {\n        const lighthouseMessage = JSON.parse(event.data);\n\n        if (lighthouseMessage.id === messageId) {\n          worker.removeEventListener('message', workerListener);\n          resolve(lighthouseMessage.result);\n        }\n      };\n      worker.addEventListener('message', workerListener);\n    });\n    worker.postMessage(JSON.stringify({id: messageId, action, args: {...args, id: messageId}}));\n\n    return messageResult;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
