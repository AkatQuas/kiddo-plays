{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/network/NetworkTimeCalculator.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2008, 2009 Anthony Ricaud <rik@webkit.org>\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\n\nconst UIStrings = {\n  /**\n  *@description Latency download total format in Network Time Calculator of the Network panel\n  *@example {20ms} PH1\n  *@example {20ms} PH2\n  *@example {40ms} PH3\n  */\n  sLatencySDownloadSTotal: '{PH1} latency, {PH2} download ({PH3} total)',\n  /**\n  *@description Latency format in Network Time Calculator of the Network panel\n  *@example {20ms} PH1\n  */\n  sLatency: '{PH1} latency',\n  /**\n  * @description Duration of the download in ms/s shown for a completed network request.\n  * @example {5ms} PH1\n  */\n  sDownload: '{PH1} download',\n  /**\n  *@description From service worker format in Network Time Calculator of the Network panel\n  *@example {20ms latency} PH1\n  */\n  sFromServiceworker: '{PH1} (from `ServiceWorker`)',\n  /**\n  *@description From cache format in Network Time Calculator of the Network panel\n  *@example {20ms latency} PH1\n  */\n  sFromCache: '{PH1} (from cache)',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/network/NetworkTimeCalculator.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport interface Label {\n  left: string;\n  right: string;\n  tooltip?: string;\n}\n\nexport class NetworkTimeBoundary {\n  minimum: number;\n  maximum: number;\n  constructor(minimum: number, maximum: number) {\n    this.minimum = minimum;\n    this.maximum = maximum;\n  }\n\n  equals(other: NetworkTimeBoundary): boolean {\n    return (this.minimum === other.minimum) && (this.maximum === other.maximum);\n  }\n}\n\nexport class NetworkTimeCalculator extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    PerfUI.TimelineGrid.Calculator {\n  startAtZero: boolean;\n  private minimumBoundaryInternal: number;\n  private maximumBoundaryInternal: number;\n  private readonly boundryChangedEventThrottler: Common.Throttler.Throttler;\n  private window: NetworkTimeBoundary|null;\n  private workingArea?: number;\n\n  constructor(startAtZero: boolean) {\n    super();\n    this.startAtZero = startAtZero;\n    this.minimumBoundaryInternal = -1;\n    this.maximumBoundaryInternal = -1;\n    this.boundryChangedEventThrottler = new Common.Throttler.Throttler(0);\n    this.window = null;\n  }\n\n  setWindow(window: NetworkTimeBoundary|null): void {\n    this.window = window;\n    this.boundaryChanged();\n  }\n\n  setInitialUserFriendlyBoundaries(): void {\n    this.minimumBoundaryInternal = 0;\n    this.maximumBoundaryInternal = 1;\n  }\n\n  computePosition(time: number): number {\n    return (time - this.minimumBoundary()) / this.boundarySpan() * (this.workingArea || 0);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value, Boolean(precision));\n  }\n\n  minimumBoundary(): number {\n    return this.window ? this.window.minimum : this.minimumBoundaryInternal;\n  }\n\n  zeroTime(): number {\n    return this.minimumBoundaryInternal;\n  }\n\n  maximumBoundary(): number {\n    return this.window ? this.window.maximum : this.maximumBoundaryInternal;\n  }\n\n  boundary(): NetworkTimeBoundary {\n    return new NetworkTimeBoundary(this.minimumBoundary(), this.maximumBoundary());\n  }\n\n  boundarySpan(): number {\n    return this.maximumBoundary() - this.minimumBoundary();\n  }\n\n  reset(): void {\n    this.minimumBoundaryInternal = -1;\n    this.maximumBoundaryInternal = -1;\n    this.boundaryChanged();\n  }\n\n  value(): number {\n    return 0;\n  }\n\n  setDisplayWidth(clientWidth: number): void {\n    this.workingArea = clientWidth;\n  }\n\n  computeBarGraphPercentages(request: SDK.NetworkRequest.NetworkRequest): {\n    start: number,\n    middle: number,\n    end: number,\n  } {\n    let start;\n    let middle;\n    let end;\n    if (request.startTime !== -1) {\n      start = ((request.startTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      start = 0;\n    }\n\n    if (request.responseReceivedTime !== -1) {\n      middle = ((request.responseReceivedTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      middle = (this.startAtZero ? start : 100);\n    }\n\n    if (request.endTime !== -1) {\n      end = ((request.endTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    } else {\n      end = (this.startAtZero ? middle : 100);\n    }\n\n    if (this.startAtZero) {\n      end -= start;\n      middle -= start;\n      start = 0;\n    }\n\n    return {start: start, middle: middle, end: end};\n  }\n\n  computePercentageFromEventTime(eventTime: number): number {\n    // This function computes a percentage in terms of the total loading time\n    // of a specific event. If startAtZero is set, then this is useless, and we\n    // want to return 0.\n    if (eventTime !== -1 && !this.startAtZero) {\n      return ((eventTime - this.minimumBoundary()) / this.boundarySpan()) * 100;\n    }\n\n    return 0;\n  }\n\n  percentageToTime(percentage: number): number {\n    return percentage * this.boundarySpan() / 100 + this.minimumBoundary();\n  }\n\n  boundaryChanged(): void {\n    void this.boundryChangedEventThrottler.schedule(async () => {\n      this.dispatchEventToListeners(Events.BoundariesChanged);\n    });\n  }\n\n  updateBoundariesForEventTime(eventTime: number): void {\n    if (eventTime === -1 || this.startAtZero) {\n      return;\n    }\n\n    if (this.maximumBoundaryInternal === undefined || eventTime > this.maximumBoundaryInternal) {\n      this.maximumBoundaryInternal = eventTime;\n      this.boundaryChanged();\n    }\n  }\n\n  computeBarGraphLabels(request: SDK.NetworkRequest.NetworkRequest): Label {\n    let rightLabel = '';\n    if (request.responseReceivedTime !== -1 && request.endTime !== -1) {\n      rightLabel = i18n.TimeUtilities.secondsToString(request.endTime - request.responseReceivedTime);\n    }\n\n    const hasLatency = request.latency > 0;\n    const leftLabel = hasLatency ? i18n.TimeUtilities.secondsToString(request.latency) : rightLabel;\n\n    if (request.timing) {\n      return {left: leftLabel, right: rightLabel, tooltip: undefined};\n    }\n\n    let tooltip;\n    if (hasLatency && rightLabel) {\n      const total = i18n.TimeUtilities.secondsToString(request.duration);\n      tooltip = i18nString(UIStrings.sLatencySDownloadSTotal, {PH1: leftLabel, PH2: rightLabel, PH3: total});\n    } else if (hasLatency) {\n      tooltip = i18nString(UIStrings.sLatency, {PH1: leftLabel});\n    } else if (rightLabel) {\n      tooltip = i18nString(UIStrings.sDownload, {PH1: rightLabel});\n    }\n\n    if (request.fetchedViaServiceWorker) {\n      tooltip = i18nString(UIStrings.sFromServiceworker, {PH1: String(tooltip)});\n    } else if (request.cached()) {\n      tooltip = i18nString(UIStrings.sFromCache, {PH1: String(tooltip)});\n    }\n    return {left: leftLabel, right: rightLabel, tooltip: tooltip};\n  }\n\n  updateBoundaries(request: SDK.NetworkRequest.NetworkRequest): void {\n    const lowerBound = this.lowerBound(request);\n    const upperBound = this.upperBound(request);\n    let changed = false;\n    if (lowerBound !== -1 || this.startAtZero) {\n      changed = this.extendBoundariesToIncludeTimestamp(this.startAtZero ? 0 : lowerBound);\n    }\n    if (upperBound !== -1) {\n      changed = this.extendBoundariesToIncludeTimestamp(upperBound) || changed;\n    }\n    if (changed) {\n      this.boundaryChanged();\n    }\n  }\n\n  extendBoundariesToIncludeTimestamp(timestamp: number): boolean {\n    const previousMinimumBoundary = this.minimumBoundaryInternal;\n    const previousMaximumBoundary = this.maximumBoundaryInternal;\n    const minOffset = _minimumSpread;\n    if (this.minimumBoundaryInternal === -1 || this.maximumBoundaryInternal === -1) {\n      this.minimumBoundaryInternal = timestamp;\n      this.maximumBoundaryInternal = timestamp + minOffset;\n    } else {\n      this.minimumBoundaryInternal = Math.min(timestamp, this.minimumBoundaryInternal);\n      this.maximumBoundaryInternal =\n          Math.max(timestamp, this.minimumBoundaryInternal + minOffset, this.maximumBoundaryInternal);\n    }\n    return previousMinimumBoundary !== this.minimumBoundaryInternal ||\n        previousMaximumBoundary !== this.maximumBoundaryInternal;\n  }\n\n  lowerBound(_request: SDK.NetworkRequest.NetworkRequest): number {\n    return 0;\n  }\n\n  upperBound(_request: SDK.NetworkRequest.NetworkRequest): number {\n    return 0;\n  }\n}\n\n// TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const _minimumSpread = 0.1;\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  BoundariesChanged = 'BoundariesChanged',\n}\n\nexport type EventTypes = {\n  [Events.BoundariesChanged]: void,\n};\n\nexport class NetworkTransferTimeCalculator extends NetworkTimeCalculator {\n  constructor() {\n    super(false);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value - this.zeroTime(), Boolean(precision));\n  }\n\n  lowerBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.issueTime();\n  }\n\n  upperBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.endTime;\n  }\n}\n\nexport class NetworkTransferDurationCalculator extends NetworkTimeCalculator {\n  constructor() {\n    super(true);\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.secondsToString(value, Boolean(precision));\n  }\n\n  upperBound(request: SDK.NetworkRequest.NetworkRequest): number {\n    return request.duration;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
