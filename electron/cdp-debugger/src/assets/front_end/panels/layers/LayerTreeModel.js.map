{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/layers/LayerTreeModel.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport class LayerTreeModel extends SDK.SDKModel.SDKModel<EventTypes> {\n  readonly layerTreeAgent: ProtocolProxyApi.LayerTreeApi;\n  readonly paintProfilerModel: SDK.PaintProfiler.PaintProfilerModel;\n  private layerTreeInternal: SDK.LayerTreeBase.LayerTreeBase|null;\n  private readonly throttler: Common.Throttler.Throttler;\n  private enabled?: boolean;\n  private lastPaintRectByLayerId?: Map<string, Protocol.DOM.Rect>;\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.layerTreeAgent = target.layerTreeAgent();\n    target.registerLayerTreeDispatcher(new LayerTreeDispatcher(this));\n    this.paintProfilerModel =\n        target.model(SDK.PaintProfiler.PaintProfilerModel) as SDK.PaintProfiler.PaintProfilerModel;\n    const resourceTreeModel = target.model(SDK.ResourceTreeModel.ResourceTreeModel);\n    if (resourceTreeModel) {\n      resourceTreeModel.addEventListener(\n          SDK.ResourceTreeModel.Events.MainFrameNavigated, this.onMainFrameNavigated, this);\n    }\n    this.layerTreeInternal = null;\n    this.throttler = new Common.Throttler.Throttler(20);\n  }\n\n  async disable(): Promise<void> {\n    if (!this.enabled) {\n      return;\n    }\n    this.enabled = false;\n    await this.layerTreeAgent.invoke_disable();\n  }\n\n  enable(): void {\n    if (this.enabled) {\n      return;\n    }\n    this.enabled = true;\n    void this.forceEnable();\n  }\n\n  private async forceEnable(): Promise<void> {\n    this.lastPaintRectByLayerId = new Map();\n    if (!this.layerTreeInternal) {\n      this.layerTreeInternal = new AgentLayerTree(this);\n    }\n    await this.layerTreeAgent.invoke_enable();\n  }\n\n  layerTree(): SDK.LayerTreeBase.LayerTreeBase|null {\n    return this.layerTreeInternal;\n  }\n\n  async layerTreeChanged(layers: Protocol.LayerTree.Layer[]|null): Promise<void> {\n    if (!this.enabled) {\n      return;\n    }\n    void this.throttler.schedule(this.innerSetLayers.bind(this, layers));\n  }\n\n  private async innerSetLayers(layers: Protocol.LayerTree.Layer[]|null): Promise<void> {\n    const layerTree = this.layerTreeInternal as AgentLayerTree;\n\n    await layerTree.setLayers(layers);\n\n    if (!this.lastPaintRectByLayerId) {\n      this.lastPaintRectByLayerId = new Map();\n    }\n\n    for (const layerId of this.lastPaintRectByLayerId.keys()) {\n      const lastPaintRect = this.lastPaintRectByLayerId.get(layerId);\n      const layer = layerTree.layerById(layerId);\n      if (layer) {\n        (layer as AgentLayer).setLastPaintRect(lastPaintRect);\n      }\n    }\n\n    this.lastPaintRectByLayerId = new Map();\n\n    this.dispatchEventToListeners(Events.LayerTreeChanged);\n  }\n\n  layerPainted(layerId: string, clipRect: Protocol.DOM.Rect): void {\n    if (!this.enabled) {\n      return;\n    }\n    const layerTree = this.layerTreeInternal as AgentLayerTree;\n    const layer = layerTree.layerById(layerId) as AgentLayer;\n    if (!layer) {\n      if (!this.lastPaintRectByLayerId) {\n        this.lastPaintRectByLayerId = new Map();\n      }\n\n      this.lastPaintRectByLayerId.set(layerId, clipRect);\n      return;\n    }\n    layer.didPaint(clipRect);\n    this.dispatchEventToListeners(Events.LayerPainted, layer);\n  }\n\n  private onMainFrameNavigated(): void {\n    this.layerTreeInternal = null;\n    if (this.enabled) {\n      void this.forceEnable();\n    }\n  }\n}\n\nSDK.SDKModel.SDKModel.register(LayerTreeModel, {capabilities: SDK.Target.Capability.DOM, autostart: false});\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  LayerTreeChanged = 'LayerTreeChanged',\n  LayerPainted = 'LayerPainted',\n}\n\nexport type EventTypes = {\n  [Events.LayerTreeChanged]: void,\n  [Events.LayerPainted]: AgentLayer,\n};\n\nexport class AgentLayerTree extends SDK.LayerTreeBase.LayerTreeBase {\n  private layerTreeModel: LayerTreeModel;\n\n  constructor(layerTreeModel: LayerTreeModel) {\n    super(layerTreeModel.target());\n    this.layerTreeModel = layerTreeModel;\n  }\n\n  async setLayers(payload: Protocol.LayerTree.Layer[]|null): Promise<void> {\n    if (!payload) {\n      this.innerSetLayers(payload);\n      return;\n    }\n    const idsToResolve = new Set<Protocol.DOM.BackendNodeId>();\n    for (let i = 0; i < payload.length; ++i) {\n      const backendNodeId = payload[i].backendNodeId;\n      if (!backendNodeId || this.backendNodeIdToNode().has(backendNodeId)) {\n        continue;\n      }\n      idsToResolve.add(backendNodeId);\n    }\n    await this.resolveBackendNodeIds(idsToResolve);\n    this.innerSetLayers(payload);\n  }\n\n  private innerSetLayers(layers: Protocol.LayerTree.Layer[]|null): void {\n    this.setRoot(null);\n    this.setContentRoot(null);\n    // Payload will be null when not in the composited mode.\n    if (!layers) {\n      return;\n    }\n    let root;\n    const oldLayersById = this.layersById;\n    this.layersById = new Map();\n    for (let i = 0; i < layers.length; ++i) {\n      const layerId = layers[i].layerId;\n      let layer: AgentLayer|(AgentLayer | null) = oldLayersById.get(layerId) as AgentLayer | null;\n      if (layer) {\n        layer.reset(layers[i]);\n      } else {\n        layer = new AgentLayer(this.layerTreeModel, layers[i]);\n      }\n      this.layersById.set(layerId, layer);\n      const backendNodeId = layers[i].backendNodeId;\n      if (backendNodeId) {\n        layer.setNode(this.backendNodeIdToNode().get(backendNodeId) || null);\n      }\n      if (!this.contentRoot() && layer.drawsContent()) {\n        this.setContentRoot(layer);\n      }\n      const parentId = layer.parentId();\n      if (parentId) {\n        const parent = this.layersById.get(parentId);\n        if (!parent) {\n          throw new Error(`Missing parent ${parentId} for layer ${layerId}`);\n        }\n        parent.addChild(layer);\n      } else {\n        if (root) {\n          console.assert(false, 'Multiple root layers');\n        }\n        root = layer;\n      }\n    }\n    if (root) {\n      this.setRoot(root);\n      root.calculateQuad(new WebKitCSSMatrix());\n    }\n  }\n}\n\nexport class AgentLayer implements SDK.LayerTreeBase.Layer {\n  private scrollRectsInternal!: Protocol.LayerTree.ScrollRect[];\n  private quadInternal!: number[];\n  private childrenInternal!: AgentLayer[];\n  private image!: HTMLImageElement|null;\n  private parentInternal!: AgentLayer|null;\n  private layerPayload!: Protocol.LayerTree.Layer;\n  private layerTreeModel: LayerTreeModel;\n  private nodeInternal?: SDK.DOMModel.DOMNode|null;\n  lastPaintRectInternal?: Protocol.DOM.Rect;\n  private paintCountInternal?: number;\n  private stickyPositionConstraintInternal?: SDK.LayerTreeBase.StickyPositionConstraint|null;\n  constructor(layerTreeModel: LayerTreeModel, layerPayload: Protocol.LayerTree.Layer) {\n    this.layerTreeModel = layerTreeModel;\n    this.reset(layerPayload);\n  }\n\n  id(): Protocol.LayerTree.LayerId {\n    return this.layerPayload.layerId;\n  }\n\n  parentId(): Protocol.LayerTree.LayerId|null {\n    return this.layerPayload.parentLayerId || null;\n  }\n\n  parent(): SDK.LayerTreeBase.Layer|null {\n    return this.parentInternal;\n  }\n\n  isRoot(): boolean {\n    return !this.parentId();\n  }\n\n  children(): SDK.LayerTreeBase.Layer[] {\n    return this.childrenInternal;\n  }\n\n  addChild(childParam: SDK.LayerTreeBase.Layer): void {\n    const child = childParam as AgentLayer;\n    if (child.parentInternal) {\n      console.assert(false, 'Child already has a parent');\n    }\n    this.childrenInternal.push(child);\n    child.parentInternal = this;\n  }\n\n  setNode(node: SDK.DOMModel.DOMNode|null): void {\n    this.nodeInternal = node;\n  }\n\n  node(): SDK.DOMModel.DOMNode|null {\n    return this.nodeInternal || null;\n  }\n\n  nodeForSelfOrAncestor(): SDK.DOMModel.DOMNode|null {\n    let layer: (AgentLayer|null)|this = this;\n    for (; layer; layer = layer.parentInternal) {\n      if (layer.nodeInternal) {\n        return layer.nodeInternal;\n      }\n    }\n    return null;\n  }\n\n  offsetX(): number {\n    return this.layerPayload.offsetX;\n  }\n\n  offsetY(): number {\n    return this.layerPayload.offsetY;\n  }\n\n  width(): number {\n    return this.layerPayload.width;\n  }\n\n  height(): number {\n    return this.layerPayload.height;\n  }\n\n  transform(): number[]|null {\n    return this.layerPayload.transform || null;\n  }\n\n  quad(): number[] {\n    return this.quadInternal;\n  }\n\n  anchorPoint(): number[] {\n    return [\n      this.layerPayload.anchorX || 0,\n      this.layerPayload.anchorY || 0,\n      this.layerPayload.anchorZ || 0,\n    ];\n  }\n\n  invisible(): boolean {\n    return this.layerPayload.invisible || false;\n  }\n\n  paintCount(): number {\n    return this.paintCountInternal || this.layerPayload.paintCount;\n  }\n\n  lastPaintRect(): Protocol.DOM.Rect|null {\n    return this.lastPaintRectInternal || null;\n  }\n\n  setLastPaintRect(lastPaintRect?: Protocol.DOM.Rect): void {\n    this.lastPaintRectInternal = lastPaintRect;\n  }\n\n  scrollRects(): Protocol.LayerTree.ScrollRect[] {\n    return this.scrollRectsInternal;\n  }\n\n  stickyPositionConstraint(): SDK.LayerTreeBase.StickyPositionConstraint|null {\n    return this.stickyPositionConstraintInternal || null;\n  }\n\n  async requestCompositingReasonIds(): Promise<string[]> {\n    const reasons = await this.layerTreeModel.layerTreeAgent.invoke_compositingReasons({layerId: this.id()});\n    return reasons.compositingReasonIds || [];\n  }\n\n  drawsContent(): boolean {\n    return this.layerPayload.drawsContent;\n  }\n\n  gpuMemoryUsage(): number {\n    const bytesPerPixel = 4;\n    return this.drawsContent() ? this.width() * this.height() * bytesPerPixel : 0;\n  }\n\n  snapshots(): Promise<SDK.PaintProfiler.SnapshotWithRect|null>[] {\n    const promise = this.layerTreeModel.paintProfilerModel.makeSnapshot(this.id()).then(snapshot => {\n      if (!snapshot) {\n        return null;\n      }\n      return {rect: {x: 0, y: 0, width: this.width(), height: this.height()}, snapshot: snapshot};\n    });\n    return [promise];\n  }\n\n  didPaint(rect: Protocol.DOM.Rect): void {\n    this.lastPaintRectInternal = rect;\n    this.paintCountInternal = this.paintCount() + 1;\n    this.image = null;\n  }\n\n  reset(layerPayload: Protocol.LayerTree.Layer): void {\n    this.nodeInternal = null;\n    this.childrenInternal = [];\n    this.parentInternal = null;\n    this.paintCountInternal = 0;\n    this.layerPayload = layerPayload;\n    this.image = null;\n    this.scrollRectsInternal = this.layerPayload.scrollRects || [];\n    this.stickyPositionConstraintInternal = this.layerPayload.stickyPositionConstraint ?\n        new SDK.LayerTreeBase.StickyPositionConstraint(\n            this.layerTreeModel.layerTree(), this.layerPayload.stickyPositionConstraint) :\n        null;\n  }\n\n  private matrixFromArray(a: number[]): DOMMatrix {\n    function toFixed9(x: number): string {\n      return x.toFixed(9);\n    }\n    return new WebKitCSSMatrix('matrix3d(' + a.map(toFixed9).join(',') + ')');\n  }\n\n  private calculateTransformToViewport(parentTransform: DOMMatrix): DOMMatrix {\n    const offsetMatrix = new WebKitCSSMatrix().translate(this.layerPayload.offsetX, this.layerPayload.offsetY);\n    let matrix: DOMMatrix = offsetMatrix;\n\n    if (this.layerPayload.transform) {\n      const transformMatrix = this.matrixFromArray(this.layerPayload.transform);\n      const anchorVector = new UI.Geometry.Vector(\n          this.layerPayload.width * this.anchorPoint()[0], this.layerPayload.height * this.anchorPoint()[1],\n          this.anchorPoint()[2]);\n      const anchorPoint = UI.Geometry.multiplyVectorByMatrixAndNormalize(anchorVector, matrix);\n      const anchorMatrix = new WebKitCSSMatrix().translate(-anchorPoint.x, -anchorPoint.y, -anchorPoint.z);\n      matrix = anchorMatrix.inverse().multiply(transformMatrix.multiply(anchorMatrix.multiply(matrix)));\n    }\n\n    matrix = parentTransform.multiply(matrix);\n    return matrix;\n  }\n\n  private createVertexArrayForRect(width: number, height: number): number[] {\n    return [0, 0, 0, width, 0, 0, width, height, 0, 0, height, 0];\n  }\n\n  calculateQuad(parentTransform: DOMMatrix): void {\n    const matrix = this.calculateTransformToViewport(parentTransform);\n    this.quadInternal = [];\n    const vertices = this.createVertexArrayForRect(this.layerPayload.width, this.layerPayload.height);\n    for (let i = 0; i < 4; ++i) {\n      const point = UI.Geometry.multiplyVectorByMatrixAndNormalize(\n          new UI.Geometry.Vector(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]), matrix);\n      this.quadInternal.push(point.x, point.y);\n    }\n\n    function calculateQuadForLayer(layer: AgentLayer): void {\n      layer.calculateQuad(matrix);\n    }\n\n    this.childrenInternal.forEach(calculateQuadForLayer);\n  }\n}\n\nclass LayerTreeDispatcher implements ProtocolProxyApi.LayerTreeDispatcher {\n  private readonly layerTreeModel: LayerTreeModel;\n  constructor(layerTreeModel: LayerTreeModel) {\n    this.layerTreeModel = layerTreeModel;\n  }\n\n  layerTreeDidChange({layers}: Protocol.LayerTree.LayerTreeDidChangeEvent): void {\n    void this.layerTreeModel.layerTreeChanged(layers || null);\n  }\n\n  layerPainted({layerId, clip}: Protocol.LayerTree.LayerPaintedEvent): void {\n    this.layerTreeModel.layerPainted(layerId, clip);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
