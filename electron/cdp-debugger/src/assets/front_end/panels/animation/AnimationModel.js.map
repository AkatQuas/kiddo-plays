{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/animation/AnimationModel.ts"],
  "sourcesContent": ["// Copyright (c) 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as ProtocolProxyApi from '../../generated/protocol-proxy-api.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nexport class AnimationModel extends SDK.SDKModel.SDKModel<EventTypes> {\n  readonly runtimeModel: SDK.RuntimeModel.RuntimeModel;\n  readonly agent: ProtocolProxyApi.AnimationApi;\n  #animationsById: Map<string, AnimationImpl>;\n  readonly animationGroups: Map<string, AnimationGroup>;\n  #pendingAnimations: Set<string>;\n  playbackRate: number;\n  readonly #screenshotCapture?: ScreenshotCapture;\n  #enabled?: boolean;\n\n  constructor(target: SDK.Target.Target) {\n    super(target);\n    this.runtimeModel = (target.model(SDK.RuntimeModel.RuntimeModel) as SDK.RuntimeModel.RuntimeModel);\n    this.agent = target.animationAgent();\n    target.registerAnimationDispatcher(new AnimationDispatcher(this));\n    this.#animationsById = new Map();\n    this.animationGroups = new Map();\n    this.#pendingAnimations = new Set();\n    this.playbackRate = 1;\n    const resourceTreeModel =\n        (target.model(SDK.ResourceTreeModel.ResourceTreeModel) as SDK.ResourceTreeModel.ResourceTreeModel);\n    resourceTreeModel.addEventListener(SDK.ResourceTreeModel.Events.MainFrameNavigated, this.reset, this);\n    const screenCaptureModel = target.model(SDK.ScreenCaptureModel.ScreenCaptureModel);\n    if (screenCaptureModel) {\n      this.#screenshotCapture = new ScreenshotCapture(this, screenCaptureModel);\n    }\n  }\n\n  private reset(): void {\n    this.#animationsById.clear();\n    this.animationGroups.clear();\n    this.#pendingAnimations.clear();\n    this.dispatchEventToListeners(Events.ModelReset);\n  }\n\n  animationCreated(id: string): void {\n    this.#pendingAnimations.add(id);\n  }\n\n  animationCanceled(id: string): void {\n    this.#pendingAnimations.delete(id);\n    this.flushPendingAnimationsIfNeeded();\n  }\n\n  animationStarted(payload: Protocol.Animation.Animation): void {\n    // We are not interested in animations without effect or target.\n    if (!payload.source || !payload.source.backendNodeId) {\n      return;\n    }\n\n    const animation = AnimationImpl.parsePayload(this, payload);\n    if (!animation) {\n      return;\n    }\n\n    // Ignore Web Animations custom effects & groups.\n    const keyframesRule = animation.source().keyframesRule();\n    if (animation.type() === 'WebAnimation' && keyframesRule && keyframesRule.keyframes().length === 0) {\n      this.#pendingAnimations.delete(animation.id());\n    } else {\n      this.#animationsById.set(animation.id(), animation);\n      this.#pendingAnimations.add(animation.id());\n    }\n\n    this.flushPendingAnimationsIfNeeded();\n  }\n\n  private flushPendingAnimationsIfNeeded(): void {\n    for (const id of this.#pendingAnimations) {\n      if (!this.#animationsById.get(id)) {\n        return;\n      }\n    }\n\n    while (this.#pendingAnimations.size) {\n      this.matchExistingGroups(this.createGroupFromPendingAnimations());\n    }\n  }\n\n  private matchExistingGroups(incomingGroup: AnimationGroup): boolean {\n    let matchedGroup: AnimationGroup|null = null;\n    for (const group of this.animationGroups.values()) {\n      if (group.matches(incomingGroup)) {\n        matchedGroup = group;\n        group.update(incomingGroup);\n        break;\n      }\n    }\n\n    if (!matchedGroup) {\n      this.animationGroups.set(incomingGroup.id(), incomingGroup);\n      if (this.#screenshotCapture) {\n        this.#screenshotCapture.captureScreenshots(incomingGroup.finiteDuration(), incomingGroup.screenshotsInternal);\n      }\n    }\n    this.dispatchEventToListeners(Events.AnimationGroupStarted, matchedGroup || incomingGroup);\n    return Boolean(matchedGroup);\n  }\n\n  private createGroupFromPendingAnimations(): AnimationGroup {\n    console.assert(this.#pendingAnimations.size > 0);\n    const firstAnimationId = this.#pendingAnimations.values().next().value;\n    this.#pendingAnimations.delete(firstAnimationId);\n\n    const firstAnimation = this.#animationsById.get(firstAnimationId);\n    if (!firstAnimation) {\n      throw new Error('Unable to locate first animation');\n    }\n\n    const groupedAnimations = [firstAnimation];\n    const groupStartTime = firstAnimation.startTime();\n    const remainingAnimations = new Set<string>();\n    for (const id of this.#pendingAnimations) {\n      const anim = (this.#animationsById.get(id) as AnimationImpl);\n      if (anim.startTime() === groupStartTime) {\n        groupedAnimations.push(anim);\n      } else {\n        remainingAnimations.add(id);\n      }\n    }\n    this.#pendingAnimations = remainingAnimations;\n    return new AnimationGroup(this, firstAnimationId, groupedAnimations);\n  }\n\n  setPlaybackRate(playbackRate: number): void {\n    this.playbackRate = playbackRate;\n    void this.agent.invoke_setPlaybackRate({playbackRate});\n  }\n\n  releaseAnimations(animations: string[]): void {\n    void this.agent.invoke_releaseAnimations({animations});\n  }\n\n  async suspendModel(): Promise<void> {\n    this.reset();\n    await this.agent.invoke_disable();\n  }\n\n  async resumeModel(): Promise<void> {\n    if (!this.#enabled) {\n      return;\n    }\n    await this.agent.invoke_enable();\n  }\n\n  async ensureEnabled(): Promise<void> {\n    if (this.#enabled) {\n      return;\n    }\n    await this.agent.invoke_enable();\n    this.#enabled = true;\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  AnimationGroupStarted = 'AnimationGroupStarted',\n  ModelReset = 'ModelReset',\n}\n\nexport type EventTypes = {\n  [Events.AnimationGroupStarted]: AnimationGroup,\n  [Events.ModelReset]: void,\n};\n\nexport class AnimationImpl {\n  readonly #animationModel: AnimationModel;\n  readonly #payloadInternal: Protocol.Animation.Animation;\n  #sourceInternal: AnimationEffect;\n  #playStateInternal?: string;\n  constructor(animationModel: AnimationModel, payload: Protocol.Animation.Animation) {\n    this.#animationModel = animationModel;\n    this.#payloadInternal = payload;\n    this.#sourceInternal =\n        new AnimationEffect(animationModel, (this.#payloadInternal.source as Protocol.Animation.AnimationEffect));\n  }\n\n  static parsePayload(animationModel: AnimationModel, payload: Protocol.Animation.Animation): AnimationImpl {\n    return new AnimationImpl(animationModel, payload);\n  }\n\n  payload(): Protocol.Animation.Animation {\n    return this.#payloadInternal;\n  }\n\n  id(): string {\n    return this.#payloadInternal.id;\n  }\n\n  name(): string {\n    return this.#payloadInternal.name;\n  }\n\n  paused(): boolean {\n    return this.#payloadInternal.pausedState;\n  }\n\n  playState(): string {\n    return this.#playStateInternal || this.#payloadInternal.playState;\n  }\n\n  setPlayState(playState: string): void {\n    this.#playStateInternal = playState;\n  }\n\n  playbackRate(): number {\n    return this.#payloadInternal.playbackRate;\n  }\n\n  startTime(): number {\n    return this.#payloadInternal.startTime;\n  }\n\n  endTime(): number {\n    if (!this.source().iterations) {\n      return Infinity;\n    }\n    return this.startTime() + this.source().delay() + this.source().duration() * this.source().iterations() +\n        this.source().endDelay();\n  }\n\n  finiteDuration(): number {\n    const iterations = Math.min(this.source().iterations(), 3);\n    return this.source().delay() + this.source().duration() * iterations;\n  }\n\n  currentTime(): number {\n    return this.#payloadInternal.currentTime;\n  }\n\n  source(): AnimationEffect {\n    return this.#sourceInternal;\n  }\n\n  type(): Protocol.Animation.AnimationType {\n    return this.#payloadInternal.type;\n  }\n\n  overlaps(animation: AnimationImpl): boolean {\n    // Infinite animations\n    if (!this.source().iterations() || !animation.source().iterations()) {\n      return true;\n    }\n\n    const firstAnimation = this.startTime() < animation.startTime() ? this : animation;\n    const secondAnimation = firstAnimation === this ? animation : this;\n    return firstAnimation.endTime() >= secondAnimation.startTime();\n  }\n\n  setTiming(duration: number, delay: number): void {\n    void this.#sourceInternal.node().then(node => {\n      if (!node) {\n        throw new Error('Unable to find node');\n      }\n      this.updateNodeStyle(duration, delay, node);\n    });\n    this.#sourceInternal.durationInternal = duration;\n    this.#sourceInternal.delayInternal = delay;\n    void this.#animationModel.agent.invoke_setTiming({animationId: this.id(), duration, delay});\n  }\n\n  private updateNodeStyle(duration: number, delay: number, node: SDK.DOMModel.DOMNode): void {\n    let animationPrefix;\n    if (this.type() === Protocol.Animation.AnimationType.CSSTransition) {\n      animationPrefix = 'transition-';\n    } else if (this.type() === Protocol.Animation.AnimationType.CSSAnimation) {\n      animationPrefix = 'animation-';\n    } else {\n      return;\n    }\n\n    if (!node.id) {\n      throw new Error('Node has no id');\n    }\n\n    const cssModel = node.domModel().cssModel();\n    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + 'duration', duration + 'ms');\n    cssModel.setEffectivePropertyValueForNode(node.id, animationPrefix + 'delay', delay + 'ms');\n  }\n\n  async remoteObjectPromise(): Promise<SDK.RemoteObject.RemoteObject|null> {\n    const payload = await this.#animationModel.agent.invoke_resolveAnimation({animationId: this.id()});\n    if (!payload) {\n      return null;\n    }\n\n    return this.#animationModel.runtimeModel.createRemoteObject(payload.remoteObject);\n  }\n\n  cssId(): string {\n    return this.#payloadInternal.cssId || '';\n  }\n}\n\nexport class AnimationEffect {\n  #animationModel: AnimationModel;\n  readonly #payload: Protocol.Animation.AnimationEffect;\n  readonly #keyframesRuleInternal: KeyframesRule|undefined;\n  delayInternal: number;\n  durationInternal: number;\n  #deferredNodeInternal?: SDK.DOMModel.DeferredDOMNode;\n  constructor(animationModel: AnimationModel, payload: Protocol.Animation.AnimationEffect) {\n    this.#animationModel = animationModel;\n    this.#payload = payload;\n    if (payload.keyframesRule) {\n      this.#keyframesRuleInternal = new KeyframesRule(payload.keyframesRule);\n    }\n    this.delayInternal = this.#payload.delay;\n    this.durationInternal = this.#payload.duration;\n  }\n\n  delay(): number {\n    return this.delayInternal;\n  }\n\n  endDelay(): number {\n    return this.#payload.endDelay;\n  }\n\n  iterationStart(): number {\n    return this.#payload.iterationStart;\n  }\n\n  iterations(): number {\n    // Animations with zero duration, zero delays and infinite iterations can't be shown.\n    if (!this.delay() && !this.endDelay() && !this.duration()) {\n      return 0;\n    }\n    return this.#payload.iterations || Infinity;\n  }\n\n  duration(): number {\n    return this.durationInternal;\n  }\n\n  direction(): string {\n    return this.#payload.direction;\n  }\n\n  fill(): string {\n    return this.#payload.fill;\n  }\n\n  node(): Promise<SDK.DOMModel.DOMNode|null> {\n    if (!this.#deferredNodeInternal) {\n      this.#deferredNodeInternal =\n          new SDK.DOMModel.DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());\n    }\n    return this.#deferredNodeInternal.resolvePromise();\n  }\n\n  deferredNode(): SDK.DOMModel.DeferredDOMNode {\n    return new SDK.DOMModel.DeferredDOMNode(this.#animationModel.target(), this.backendNodeId());\n  }\n\n  backendNodeId(): Protocol.DOM.BackendNodeId {\n    return this.#payload.backendNodeId as Protocol.DOM.BackendNodeId;\n  }\n\n  keyframesRule(): KeyframesRule|null {\n    return this.#keyframesRuleInternal || null;\n  }\n\n  easing(): string {\n    return this.#payload.easing;\n  }\n}\n\nexport class KeyframesRule {\n  readonly #payload: Protocol.Animation.KeyframesRule;\n  #keyframesInternal: KeyframeStyle[];\n  constructor(payload: Protocol.Animation.KeyframesRule) {\n    this.#payload = payload;\n    this.#keyframesInternal = this.#payload.keyframes.map(function(keyframeStyle) {\n      return new KeyframeStyle(keyframeStyle);\n    });\n  }\n\n  private setKeyframesPayload(payload: Protocol.Animation.KeyframeStyle[]): void {\n    this.#keyframesInternal = payload.map(function(keyframeStyle) {\n      return new KeyframeStyle(keyframeStyle);\n    });\n  }\n\n  name(): string|undefined {\n    return this.#payload.name;\n  }\n\n  keyframes(): KeyframeStyle[] {\n    return this.#keyframesInternal;\n  }\n}\n\nexport class KeyframeStyle {\n  readonly #payload: Protocol.Animation.KeyframeStyle;\n  #offsetInternal: string;\n  constructor(payload: Protocol.Animation.KeyframeStyle) {\n    this.#payload = payload;\n    this.#offsetInternal = this.#payload.offset;\n  }\n\n  offset(): string {\n    return this.#offsetInternal;\n  }\n\n  setOffset(offset: number): void {\n    this.#offsetInternal = offset * 100 + '%';\n  }\n\n  offsetAsNumber(): number {\n    return parseFloat(this.#offsetInternal) / 100;\n  }\n\n  easing(): string {\n    return this.#payload.easing;\n  }\n}\n\nexport class AnimationGroup {\n  readonly #animationModel: AnimationModel;\n  readonly #idInternal: string;\n  #animationsInternal: AnimationImpl[];\n  #pausedInternal: boolean;\n  screenshotsInternal: string[];\n  readonly #screenshotImages: HTMLImageElement[];\n  constructor(animationModel: AnimationModel, id: string, animations: AnimationImpl[]) {\n    this.#animationModel = animationModel;\n    this.#idInternal = id;\n    this.#animationsInternal = animations;\n    this.#pausedInternal = false;\n    this.screenshotsInternal = [];\n\n    this.#screenshotImages = [];\n  }\n\n  id(): string {\n    return this.#idInternal;\n  }\n\n  animations(): AnimationImpl[] {\n    return this.#animationsInternal;\n  }\n\n  release(): void {\n    this.#animationModel.animationGroups.delete(this.id());\n    this.#animationModel.releaseAnimations(this.animationIds());\n  }\n\n  private animationIds(): string[] {\n    function extractId(animation: AnimationImpl): string {\n      return animation.id();\n    }\n\n    return this.#animationsInternal.map(extractId);\n  }\n\n  startTime(): number {\n    return this.#animationsInternal[0].startTime();\n  }\n\n  finiteDuration(): number {\n    let maxDuration = 0;\n    for (let i = 0; i < this.#animationsInternal.length; ++i) {\n      maxDuration = Math.max(maxDuration, this.#animationsInternal[i].finiteDuration());\n    }\n    return maxDuration;\n  }\n\n  seekTo(currentTime: number): void {\n    void this.#animationModel.agent.invoke_seekAnimations({animations: this.animationIds(), currentTime});\n  }\n\n  paused(): boolean {\n    return this.#pausedInternal;\n  }\n\n  togglePause(paused: boolean): void {\n    if (paused === this.#pausedInternal) {\n      return;\n    }\n    this.#pausedInternal = paused;\n    void this.#animationModel.agent.invoke_setPaused({animations: this.animationIds(), paused});\n  }\n\n  currentTimePromise(): Promise<number> {\n    let longestAnim: AnimationImpl|null = null;\n    for (const anim of this.#animationsInternal) {\n      if (!longestAnim || anim.endTime() > longestAnim.endTime()) {\n        longestAnim = anim;\n      }\n    }\n    if (!longestAnim) {\n      throw new Error('No longest animation found');\n    }\n\n    return this.#animationModel.agent.invoke_getCurrentTime({id: longestAnim.id()})\n        .then(({currentTime}) => currentTime || 0);\n  }\n\n  matches(group: AnimationGroup): boolean {\n    function extractId(anim: AnimationImpl): string {\n      if (anim.type() === Protocol.Animation.AnimationType.WebAnimation) {\n        return anim.type() + anim.id();\n      }\n      return anim.cssId();\n    }\n\n    if (this.#animationsInternal.length !== group.#animationsInternal.length) {\n      return false;\n    }\n    const left = this.#animationsInternal.map(extractId).sort();\n    const right = group.#animationsInternal.map(extractId).sort();\n    for (let i = 0; i < left.length; i++) {\n      if (left[i] !== right[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  update(group: AnimationGroup): void {\n    this.#animationModel.releaseAnimations(this.animationIds());\n    this.#animationsInternal = group.#animationsInternal;\n  }\n\n  screenshots(): HTMLImageElement[] {\n    for (let i = 0; i < this.screenshotsInternal.length; ++i) {\n      const image = new Image();\n      image.src = 'data:image/jpeg;base64,' + this.screenshotsInternal[i];\n      this.#screenshotImages.push(image);\n    }\n    this.screenshotsInternal = [];\n    return this.#screenshotImages;\n  }\n}\n\nexport class AnimationDispatcher implements ProtocolProxyApi.AnimationDispatcher {\n  readonly #animationModel: AnimationModel;\n  constructor(animationModel: AnimationModel) {\n    this.#animationModel = animationModel;\n  }\n\n  animationCreated({id}: Protocol.Animation.AnimationCreatedEvent): void {\n    this.#animationModel.animationCreated(id);\n  }\n\n  animationCanceled({id}: Protocol.Animation.AnimationCanceledEvent): void {\n    this.#animationModel.animationCanceled(id);\n  }\n\n  animationStarted({animation}: Protocol.Animation.AnimationStartedEvent): void {\n    this.#animationModel.animationStarted(animation);\n  }\n}\n\nexport class ScreenshotCapture {\n  #requests: Request[];\n  readonly #screenCaptureModel: SDK.ScreenCaptureModel.ScreenCaptureModel;\n  readonly #animationModel: AnimationModel;\n  #stopTimer?: number;\n  #endTime?: number;\n  #capturing?: boolean;\n  constructor(animationModel: AnimationModel, screenCaptureModel: SDK.ScreenCaptureModel.ScreenCaptureModel) {\n    this.#requests = [];\n    this.#screenCaptureModel = screenCaptureModel;\n    this.#animationModel = animationModel;\n    this.#animationModel.addEventListener(Events.ModelReset, this.stopScreencast, this);\n  }\n\n  captureScreenshots(duration: number, screenshots: string[]): void {\n    const screencastDuration = Math.min(duration / this.#animationModel.playbackRate, 3000);\n    const endTime = screencastDuration + window.performance.now();\n    this.#requests.push({endTime: endTime, screenshots: screenshots});\n\n    if (!this.#endTime || endTime > this.#endTime) {\n      clearTimeout(this.#stopTimer);\n      this.#stopTimer = window.setTimeout(this.stopScreencast.bind(this), screencastDuration);\n      this.#endTime = endTime;\n    }\n\n    if (this.#capturing) {\n      return;\n    }\n    this.#capturing = true;\n    this.#screenCaptureModel.startScreencast(\n        Protocol.Page.StartScreencastRequestFormat.Jpeg, 80, undefined, 300, 2, this.screencastFrame.bind(this),\n        _visible => {});\n  }\n\n  private screencastFrame(base64Data: string, _metadata: Protocol.Page.ScreencastFrameMetadata): void {\n    function isAnimating(request: Request): boolean {\n      return request.endTime >= now;\n    }\n\n    if (!this.#capturing) {\n      return;\n    }\n\n    const now = window.performance.now();\n    this.#requests = this.#requests.filter(isAnimating);\n    for (const request of this.#requests) {\n      request.screenshots.push(base64Data);\n    }\n  }\n\n  private stopScreencast(): void {\n    if (!this.#capturing) {\n      return;\n    }\n\n    this.#stopTimer = undefined;\n    this.#endTime = undefined;\n    this.#requests = [];\n    this.#capturing = false;\n    this.#screenCaptureModel.stopScreencast();\n  }\n}\n\nSDK.SDKModel.SDKModel.register(AnimationModel, {capabilities: SDK.Target.Capability.DOM, autostart: false});\nexport interface Request {\n  endTime: number;\n  screenshots: string[];\n}\n"],
  "mappings": "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",
  "names": []
}
