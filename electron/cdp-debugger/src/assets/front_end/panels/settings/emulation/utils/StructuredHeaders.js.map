{
  "version": 3,
  "sources": ["../../../../../../../../front_end/panels/settings/emulation/utils/StructuredHeaders.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// This provides parsing and serialization for HTTP structured headers as specified in:\n// https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19\n// (the ABNF fragments are quoted from the spec, unless otherwise specified,\n//  and the code pretty much just follows the algorithms given there).\n//\n// parseList, parseItem, serializeList, and serializeItem are the main entry points.\n//\n// Currently dictionary handling is not implemented (but would likely be easy\n// to add).  Serialization of decimals and byte sequences is also not\n// implemented.\n\nexport const enum ResultKind {\n  ERROR = 0,\n  PARAM_NAME = 1,\n  PARAMETER = 2,\n  PARAMETERS = 3,\n  ITEM = 4,\n  INTEGER = 5,\n  DECIMAL = 6,\n  STRING = 7,\n  TOKEN = 8,\n  BINARY = 9,\n  BOOLEAN = 10,\n  LIST = 11,\n  INNER_LIST = 12,\n  SERIALIZATION_RESULT = 13,\n}\n\nexport interface Error {\n  kind: ResultKind.ERROR;\n}\n\nexport interface Integer {\n  kind: ResultKind.INTEGER;\n  value: number;\n}\n\nexport interface Decimal {\n  kind: ResultKind.DECIMAL;\n  value: number;\n}\n\nexport interface String {\n  kind: ResultKind.STRING;\n  value: string;\n}\n\nexport interface Token {\n  kind: ResultKind.TOKEN;\n  value: string;\n}\n\nexport interface Binary {\n  kind: ResultKind.BINARY;\n  // This is undecoded base64\n  value: string;\n}\n\nexport interface Boolean {\n  kind: ResultKind.BOOLEAN;\n  value: boolean;\n}\n\n//  bare-item = sf-integer / sf-decimal / sf-string / sf-token\n//              / sf-binary / sf-boolean\nexport type BareItem = Integer|Decimal|String|Token|Binary|Boolean;\n\nexport interface ParamName {\n  kind: ResultKind.PARAM_NAME;\n  value: string;\n}\n\n// parameter     = param-name [ \"=\" param-value ]\n// param-value   = bare-item\nexport interface Parameter {\n  kind: ResultKind.PARAMETER;\n  name: ParamName;\n  value: BareItem;\n}\n\n// parameters  = *( \";\" *SP parameter )\nexport interface Parameters {\n  kind: ResultKind.PARAMETERS;\n  items: Parameter[];\n}\n\n// sf-item   = bare-item parameters\nexport interface Item {\n  kind: ResultKind.ITEM;\n  value: BareItem;\n  parameters: Parameters;\n}\n\n// inner-list    = \"(\" *SP [ sf-item *( 1*SP sf-item ) *SP ] \")\"\n//                   parameters\nexport interface InnerList {\n  kind: ResultKind.INNER_LIST;\n  items: Item[];\n  parameters: Parameters;\n}\n\n// list-member = sf-item / inner-list\nexport type ListMember = Item|InnerList;\n\n// sf-list = list-member *( OWS \",\" OWS list-member )\nexport interface List {\n  kind: ResultKind.LIST;\n  items: ListMember[];\n}\n\nexport interface SerializationResult {\n  kind: ResultKind.SERIALIZATION_RESULT;\n  value: string;\n}\n\nconst CHAR_MINUS: number = '-'.charCodeAt(0);\nconst CHAR_0: number = '0'.charCodeAt(0);\nconst CHAR_9: number = '9'.charCodeAt(0);\nconst CHAR_A: number = 'A'.charCodeAt(0);\nconst CHAR_Z: number = 'Z'.charCodeAt(0);\nconst CHAR_LOWER_A: number = 'a'.charCodeAt(0);\nconst CHAR_LOWER_Z: number = 'z'.charCodeAt(0);\nconst CHAR_DQUOTE: number = '\"'.charCodeAt(0);\nconst CHAR_COLON: number = ':'.charCodeAt(0);\nconst CHAR_QUESTION_MARK: number = '?'.charCodeAt(0);\nconst CHAR_STAR: number = '*'.charCodeAt(0);\nconst CHAR_UNDERSCORE: number = '_'.charCodeAt(0);\nconst CHAR_DOT: number = '.'.charCodeAt(0);\nconst CHAR_BACKSLASH: number = '\\\\'.charCodeAt(0);\nconst CHAR_SLASH: number = '/'.charCodeAt(0);\nconst CHAR_PLUS: number = '+'.charCodeAt(0);\nconst CHAR_EQUALS: number = '='.charCodeAt(0);\nconst CHAR_EXCLAMATION: number = '!'.charCodeAt(0);\nconst CHAR_HASH: number = '#'.charCodeAt(0);\nconst CHAR_DOLLAR: number = '$'.charCodeAt(0);\nconst CHAR_PERCENT: number = '%'.charCodeAt(0);\nconst CHAR_AND: number = '&'.charCodeAt(0);\nconst CHAR_SQUOTE: number = '\\''.charCodeAt(0);\nconst CHAR_HAT: number = '^'.charCodeAt(0);\nconst CHAR_BACKTICK: number = '`'.charCodeAt(0);\nconst CHAR_PIPE: number = '|'.charCodeAt(0);\nconst CHAR_TILDE: number = '~'.charCodeAt(0);\n\n// ASCII printable range.\nconst CHAR_MIN_ASCII_PRINTABLE: number = 0x20;\nconst CHAR_MAX_ASCII_PRINTABLE: number = 0x7e;\n\n// Note: structured headers operates over ASCII, not unicode, so these are\n// all indeed supposed to return false on things outside 32-127 range regardless\n// of them being other kinds of digits or letters.\nfunction isDigit(charCode: number|undefined): boolean {\n  // DIGIT = %x30-39 ; 0-9 (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return charCode >= CHAR_0 && charCode <= CHAR_9;\n}\n\nfunction isAlpha(charCode: number|undefined): boolean {\n  // ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z (from RFC 5234)\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_A && charCode <= CHAR_Z) || (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isLcAlpha(charCode: number|undefined): boolean {\n  // lcalpha = %x61-7A ; a-z\n  if (charCode === undefined) {\n    return false;\n  }\n  return (charCode >= CHAR_LOWER_A && charCode <= CHAR_LOWER_Z);\n}\n\nfunction isTChar(charCode: number|undefined): boolean {\n  if (charCode === undefined) {\n    return false;\n  }\n\n  // tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" /\n  // \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA (from RFC 7230)\n  if (isDigit(charCode) || isAlpha(charCode)) {\n    return true;\n  }\n  switch (charCode) {\n    case CHAR_EXCLAMATION:\n    case CHAR_HASH:\n    case CHAR_DOLLAR:\n    case CHAR_PERCENT:\n    case CHAR_AND:\n    case CHAR_SQUOTE:\n    case CHAR_STAR:\n    case CHAR_PLUS:\n    case CHAR_MINUS:\n    case CHAR_DOT:\n    case CHAR_HAT:\n    case CHAR_UNDERSCORE:\n    case CHAR_BACKTICK:\n    case CHAR_PIPE:\n    case CHAR_TILDE:\n      return true;\n    default:\n      return false;\n  }\n}\n\nclass Input {\n  private readonly data: string;\n  private pos: number;\n\n  constructor(input: string) {\n    this.data = input;\n    this.pos = 0;\n    // 4.2 step 2 is to discard any leading SP characters.\n    this.skipSP();\n  }\n\n  peek(): string|undefined {\n    return this.data[this.pos];\n  }\n\n  peekCharCode(): number|undefined {\n    return (this.pos < this.data.length ? this.data.charCodeAt(this.pos) : undefined);\n  }\n\n  eat(): void {\n    ++this.pos;\n  }\n\n  // Matches SP*.\n  // SP = %x20, from RFC 5234\n  skipSP(): void {\n    while (this.data[this.pos] === ' ') {\n      ++this.pos;\n    }\n  }\n\n  // Matches OWS\n  // OWS = *( SP / HTAB ) , from RFC 7230\n  skipOWS(): void {\n    while (this.data[this.pos] === ' ' || this.data[this.pos] === '\\t') {\n      ++this.pos;\n    }\n  }\n\n  atEnd(): boolean {\n    return (this.pos === this.data.length);\n  }\n\n  // 4.2 steps 6,7 --- checks for trailing characters.\n  allParsed(): boolean {\n    this.skipSP();\n    return (this.pos === this.data.length);\n  }\n}\n\nfunction makeError(): Error {\n  return {kind: ResultKind.ERROR};\n}\n\n// 4.2.1. Parsing a list\nfunction parseListInternal(input: Input): List|Error {\n  const result: List = {kind: ResultKind.LIST, items: []};\n\n  while (!input.atEnd()) {\n    const piece: ListMember|Error = parseItemOrInnerList(input);\n    if (piece.kind === ResultKind.ERROR) {\n      return piece;\n    }\n    result.items.push(piece);\n    input.skipOWS();\n    if (input.atEnd()) {\n      return result;\n    }\n\n    if (input.peek() !== ',') {\n      return makeError();\n    }\n    input.eat();\n    input.skipOWS();\n\n    // \"If input_string is empty, there is a trailing comma; fail parsing.\"\n    if (input.atEnd()) {\n      return makeError();\n    }\n  }\n  return result;  // this case corresponds to an empty list.\n}\n\n// 4.2.1.1.  Parsing an Item or Inner List\nfunction parseItemOrInnerList(input: Input): ListMember|Error {\n  if (input.peek() === '(') {\n    return parseInnerList(input);\n  }\n  return parseItemInternal(input);\n}\n\n// 4.2.1.2.  Parsing an Inner List\nfunction parseInnerList(input: Input): InnerList|Error {\n  if (input.peek() !== '(') {\n    return makeError();\n  }\n  input.eat();\n\n  const items: Item[] = [];\n  while (!input.atEnd()) {\n    input.skipSP();\n    if (input.peek() === ')') {\n      input.eat();\n      const params: Parameters|Error = parseParameters(input);\n      if (params.kind === ResultKind.ERROR) {\n        return params;\n      }\n      return {\n        kind: ResultKind.INNER_LIST,\n        items: items,\n        parameters: params,\n      };\n    }\n    const item: Item|Error = parseItemInternal(input);\n    if (item.kind === ResultKind.ERROR) {\n      return item;\n    }\n    items.push(item);\n    if (input.peek() !== ' ' && input.peek() !== ')') {\n      return makeError();\n    }\n  }\n\n  // Didn't see ), so error.\n  return makeError();\n}\n\n// 4.2.3.  Parsing an Item\nfunction parseItemInternal(input: Input): Item|Error {\n  const bareItem: BareItem|Error = parseBareItem(input);\n  if (bareItem.kind === ResultKind.ERROR) {\n    return bareItem;\n  }\n  const params: Parameters|Error = parseParameters(input);\n  if (params.kind === ResultKind.ERROR) {\n    return params;\n  }\n  return {kind: ResultKind.ITEM, value: bareItem, parameters: params};\n}\n\n// 4.2.3.1.  Parsing a Bare Item\nfunction parseBareItem(input: Input): BareItem|Error {\n  const upcoming = input.peekCharCode();\n  if (upcoming === CHAR_MINUS || isDigit(upcoming)) {\n    return parseIntegerOrDecimal(input);\n  }\n  if (upcoming === CHAR_DQUOTE) {\n    return parseString(input);\n  }\n  if (upcoming === CHAR_COLON) {\n    return parseByteSequence(input);\n  }\n  if (upcoming === CHAR_QUESTION_MARK) {\n    return parseBoolean(input);\n  }\n  if (upcoming === CHAR_STAR || isAlpha(upcoming)) {\n    return parseToken(input);\n  }\n  return makeError();\n}\n\n// 4.2.3.2.  Parsing Parameters\nfunction parseParameters(input: Input): Parameters|Error {\n  // The main noteworthy thing here is handling of duplicates and ordering:\n  //\n  // \"Note that Parameters are ordered as serialized\"\n  //\n  // \"If parameters already contains a name param_name (comparing\n  // character-for-character), overwrite its value.\"\n  //\n  // \"Note that when duplicate Parameter keys are encountered, this has the\n  // effect of ignoring all but the last instance.\"\n  const items: Map<string, Parameter> = new Map<string, Parameter>();\n  while (!input.atEnd()) {\n    if (input.peek() !== ';') {\n      break;\n    }\n    input.eat();\n    input.skipSP();\n    const paramName = parseKey(input);\n    if (paramName.kind === ResultKind.ERROR) {\n      return paramName;\n    }\n\n    let paramValue: BareItem = {kind: ResultKind.BOOLEAN, value: true};\n    if (input.peek() === '=') {\n      input.eat();\n      const parsedParamValue: BareItem|Error = parseBareItem(input);\n      if (parsedParamValue.kind === ResultKind.ERROR) {\n        return parsedParamValue;\n      }\n      paramValue = parsedParamValue;\n    }\n\n    // Delete any previous occurrence of duplicates to get the ordering right.\n    if (items.has(paramName.value)) {\n      items.delete(paramName.value);\n    }\n\n    items.set(paramName.value, {kind: ResultKind.PARAMETER, name: paramName, value: paramValue});\n  }\n\n  return {kind: ResultKind.PARAMETERS, items: [...items.values()]};\n}\n\n// 4.2.3.3.  Parsing a Key\nfunction parseKey(input: Input): ParamName|Error {\n  let outputString: string = '';\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isLcAlpha(first)) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (!isLcAlpha(upcoming) && !isDigit(upcoming) && upcoming !== CHAR_UNDERSCORE && upcoming !== CHAR_MINUS &&\n        upcoming !== CHAR_DOT && upcoming !== CHAR_STAR) {\n      break;\n    }\n    outputString += input.peek();\n    input.eat();\n  }\n\n  return {kind: ResultKind.PARAM_NAME, value: outputString};\n}\n\n// 4.2.4.  Parsing an Integer or Decimal\nfunction parseIntegerOrDecimal(input: Input): Integer|Decimal|Error {\n  let resultKind = ResultKind.INTEGER;\n  let sign: number = 1;\n  let inputNumber = '';\n  if (input.peek() === '-') {\n    input.eat();\n    sign = -1;\n  }\n\n  // This case includes end of input.\n  if (!isDigit(input.peekCharCode())) {\n    return makeError();\n  }\n\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    if (char !== undefined && isDigit(char)) {\n      input.eat();\n      inputNumber += String.fromCodePoint(char);\n    } else if (char === CHAR_DOT && resultKind === ResultKind.INTEGER) {\n      input.eat();\n      if (inputNumber.length > 12) {\n        return makeError();\n      }\n      inputNumber += '.';\n      resultKind = ResultKind.DECIMAL;\n    } else {\n      break;\n    }\n    if (resultKind === ResultKind.INTEGER && inputNumber.length > 15) {\n      return makeError();\n    }\n    if (resultKind === ResultKind.DECIMAL && inputNumber.length > 16) {\n      return makeError();\n    }\n  }\n\n  if (resultKind === ResultKind.INTEGER) {\n    const num = sign * Number.parseInt(inputNumber, 10);\n    if (num < -999999999999999 || num > 999999999999999) {\n      return makeError();\n    }\n    return {kind: ResultKind.INTEGER, value: num};\n  }\n  const afterDot = inputNumber.length - 1 - inputNumber.indexOf('.');\n  if (afterDot > 3 || afterDot === 0) {\n    return makeError();\n  }\n  return {kind: ResultKind.DECIMAL, value: sign * Number.parseFloat(inputNumber)};\n}\n\n// 4.2.5.  Parsing a String\nfunction parseString(input: Input): String|Error {\n  let outputString = '';\n  if (input.peek() !== '\"') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_BACKSLASH) {\n      if (input.atEnd()) {\n        return makeError();\n      }\n      const nextChar = input.peekCharCode();\n      input.eat();\n      if (nextChar !== CHAR_BACKSLASH && nextChar !== CHAR_DQUOTE) {\n        return makeError();\n      }\n      outputString += String.fromCodePoint(nextChar);\n    } else if (char === CHAR_DQUOTE) {\n      return {kind: ResultKind.STRING, value: outputString};\n    } else if (char<CHAR_MIN_ASCII_PRINTABLE || char>CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    } else {\n      outputString += String.fromCodePoint(char);\n    }\n  }\n\n  // No closing quote.\n  return makeError();\n}\n\n// 4.2.6.  Parsing a Token\nfunction parseToken(input: Input): Token|Error {\n  const first = input.peekCharCode();\n  if (first !== CHAR_STAR && !isAlpha(first)) {\n    return makeError();\n  }\n  let outputString = '';\n  while (!input.atEnd()) {\n    const upcoming = input.peekCharCode();\n    if (upcoming === undefined || !isTChar(upcoming) && upcoming !== CHAR_COLON && upcoming !== CHAR_SLASH) {\n      break;\n    }\n    input.eat();\n    outputString += String.fromCodePoint(upcoming);\n  }\n  return {kind: ResultKind.TOKEN, value: outputString};\n}\n\n// 4.2.7.  Parsing a Byte Sequence\nfunction parseByteSequence(input: Input): Binary|Error {\n  let outputString = '';\n  if (input.peek() !== ':') {\n    return makeError();\n  }\n  input.eat();\n  while (!input.atEnd()) {\n    const char = input.peekCharCode();\n    // can't happen due to atEnd(), but help the typechecker out.\n    if (char === undefined) {\n      return makeError();\n    }\n\n    input.eat();\n    if (char === CHAR_COLON) {\n      return {kind: ResultKind.BINARY, value: outputString};\n    }\n    if (isDigit(char) || isAlpha(char) || char === CHAR_PLUS || char === CHAR_SLASH || char === CHAR_EQUALS) {\n      outputString += String.fromCodePoint(char);\n    } else {\n      return makeError();\n    }\n  }\n\n  // No closing :\n  return makeError();\n}\n\n// 4.2.8.  Parsing a Boolean\nfunction parseBoolean(input: Input): Boolean|Error {\n  if (input.peek() !== '?') {\n    return makeError();\n  }\n  input.eat();\n  if (input.peek() === '0') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: false};\n  }\n  if (input.peek() === '1') {\n    input.eat();\n    return {kind: ResultKind.BOOLEAN, value: true};\n  }\n  return makeError();\n}\n\nexport function parseItem(input: string): Item|Error {\n  const i = new Input(input);\n  const result: Item|Error = parseItemInternal(i);\n  if (!i.allParsed()) {\n    return makeError();\n  }\n  return result;\n}\n\nexport function parseList(input: string): List|Error {\n  // No need to look for trailing stuff here since parseListInternal does it already.\n  return parseListInternal(new Input(input));\n}\n\n// 4.1.3.  Serializing an Item\nexport function serializeItem(input: Item): SerializationResult|Error {\n  const bareItemVal = serializeBareItem(input.value);\n  if (bareItemVal.kind === ResultKind.ERROR) {\n    return bareItemVal;\n  }\n  const paramVal = serializeParameters(input.parameters);\n  if (paramVal.kind === ResultKind.ERROR) {\n    return paramVal;\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: bareItemVal.value + paramVal.value};\n}\n\n// 4.1.1.  Serializing a List\nexport function serializeList(input: List): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const item = input.items[i];\n    if (item.kind === ResultKind.INNER_LIST) {\n      const itemResult = serializeInnerList(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    } else {\n      const itemResult = serializeItem(item);\n      if (itemResult.kind === ResultKind.ERROR) {\n        return itemResult;\n      }\n      outputPieces.push(itemResult.value);\n    }\n  }\n  const output = outputPieces.join(', ');\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.1.  Serializing an Inner List\nfunction serializeInnerList(input: InnerList): SerializationResult|Error {\n  const outputPieces: string[] = [];\n  for (let i = 0; i < input.items.length; ++i) {\n    const itemResult = serializeItem(input.items[i]);\n    if (itemResult.kind === ResultKind.ERROR) {\n      return itemResult;\n    }\n    outputPieces.push(itemResult.value);\n  }\n  let output = '(' + outputPieces.join(' ') + ')';\n  const paramResult = serializeParameters(input.parameters);\n  if (paramResult.kind === ResultKind.ERROR) {\n    return paramResult;\n  }\n  output += paramResult.value;\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.2.  Serializing Parameters\nfunction serializeParameters(input: Parameters): SerializationResult|Error {\n  let output = '';\n  for (const item of input.items) {\n    output += ';';\n    const nameResult = serializeKey(item.name);\n    if (nameResult.kind === ResultKind.ERROR) {\n      return nameResult;\n    }\n    output += nameResult.value;\n    const itemVal: BareItem = item.value;\n    if (itemVal.kind !== ResultKind.BOOLEAN || !itemVal.value) {\n      output += '=';\n      const itemValResult = serializeBareItem(itemVal);\n      if (itemValResult.kind === ResultKind.ERROR) {\n        return itemValResult;\n      }\n      output += itemValResult.value;\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.1.3.  Serializing a Key\nfunction serializeKey(input: ParamName): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isLcAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isLcAlpha(char) && !isDigit(char) && char !== CHAR_UNDERSCORE && char !== CHAR_MINUS && char !== CHAR_DOT &&\n        char !== CHAR_STAR) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n// 4.1.3.1.  Serializing a Bare Item\nfunction serializeBareItem(input: BareItem): SerializationResult|Error {\n  if (input.kind === ResultKind.INTEGER) {\n    return serializeInteger(input);\n  }\n  if (input.kind === ResultKind.DECIMAL) {\n    return serializeDecimal(input);\n  }\n  if (input.kind === ResultKind.STRING) {\n    return serializeString(input);\n  }\n  if (input.kind === ResultKind.TOKEN) {\n    return serializeToken(input);\n  }\n  if (input.kind === ResultKind.BOOLEAN) {\n    return serializeBoolean(input);\n  }\n  if (input.kind === ResultKind.BINARY) {\n    return serializeByteSequence(input);\n  }\n  return makeError();\n}\n\n// 4.1.4.  Serializing an Integer\nfunction serializeInteger(input: Integer): SerializationResult|Error {\n  if (input.value < -999999999999999 || input.value > 999999999999999 || !Number.isInteger(input.value)) {\n    return makeError();\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value.toString(10)};\n}\n\n// 4.1.5.  Serializing a Decimal\nfunction serializeDecimal(_input: Decimal): SerializationResult|Error {\n  throw 'Unimplemented';\n}\n\n// 4.1.6.  Serializing a String\nfunction serializeString(input: String): SerializationResult|Error {\n  // Only printable ASCII strings are supported by the spec.\n  for (let i = 0; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (char<CHAR_MIN_ASCII_PRINTABLE || char>CHAR_MAX_ASCII_PRINTABLE) {\n      return makeError();\n    }\n  }\n  let output = '\"';\n  for (let i = 0; i < input.value.length; ++i) {\n    const charStr = input.value[i];\n    if (charStr === '\"' || charStr === '\\\\') {\n      output += '\\\\';\n    }\n    output += charStr;\n  }\n  output += '\"';\n\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: output};\n}\n\n// 4.1.7.  Serializing a Token\nfunction serializeToken(input: Token): SerializationResult|Error {\n  if (input.value.length === 0) {\n    return makeError();\n  }\n\n  const firstChar = input.value.charCodeAt(0);\n  if (!isAlpha(firstChar) && firstChar !== CHAR_STAR) {\n    return makeError();\n  }\n\n  for (let i = 1; i < input.value.length; ++i) {\n    const char = input.value.charCodeAt(i);\n    if (!isTChar(char) && char !== CHAR_COLON && char !== CHAR_SLASH) {\n      return makeError();\n    }\n  }\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value};\n}\n\n// 4.1.8.  Serializing a Byte Sequence\nfunction serializeByteSequence(_input: Binary): SerializationResult|Error {\n  throw 'Unimplemented';\n}\n\n// 4.1.9.  Serializing a Boolean\nfunction serializeBoolean(input: Boolean): SerializationResult|Error {\n  return {kind: ResultKind.SERIALIZATION_RESULT, value: input.value ? '?1' : '?0'};\n}\n"],
  "mappings": "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",
  "names": []
}
