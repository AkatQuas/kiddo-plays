{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/timeline/PerformanceModel.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Bindings from '../../models/bindings/bindings.js';\nimport * as TimelineModel from '../../models/timeline_model/timeline_model.js';\n\nimport {TimelineUIUtils} from './TimelineUIUtils.js';\n\nexport class PerformanceModel extends Common.ObjectWrapper.ObjectWrapper<EventTypes> {\n  private mainTargetInternal: SDK.Target.Target|null;\n  private tracingModelInternal: SDK.TracingModel.TracingModel|null;\n  private filtersInternal: TimelineModel.TimelineModelFilter.TimelineModelFilter[];\n  private readonly timelineModelInternal: TimelineModel.TimelineModel.TimelineModelImpl;\n  private readonly frameModelInternal: TimelineModel.TimelineFrameModel.TimelineFrameModel;\n  private filmStripModelInternal: SDK.FilmStripModel.FilmStripModel|null;\n  private readonly irModel: TimelineModel.TimelineIRModel.TimelineIRModel;\n  private windowInternal: Window;\n  private readonly extensionTracingModels: {\n    title: string,\n    model: SDK.TracingModel.TracingModel,\n    timeOffset: number,\n  }[];\n  private recordStartTimeInternal?: number;\n\n  constructor() {\n    super();\n    this.mainTargetInternal = null;\n    this.tracingModelInternal = null;\n    this.filtersInternal = [];\n\n    this.timelineModelInternal = new TimelineModel.TimelineModel.TimelineModelImpl();\n    this.frameModelInternal = new TimelineModel.TimelineFrameModel.TimelineFrameModel(\n        event => TimelineUIUtils.eventStyle(event).category.name);\n    this.filmStripModelInternal = null;\n    this.irModel = new TimelineModel.TimelineIRModel.TimelineIRModel();\n\n    this.windowInternal = {left: 0, right: Infinity};\n\n    this.extensionTracingModels = [];\n    this.recordStartTimeInternal = undefined;\n  }\n\n  setMainTarget(target: SDK.Target.Target): void {\n    this.mainTargetInternal = target;\n  }\n\n  mainTarget(): SDK.Target.Target|null {\n    return this.mainTargetInternal;\n  }\n\n  setRecordStartTime(time: number): void {\n    this.recordStartTimeInternal = time;\n  }\n\n  recordStartTime(): number|undefined {\n    return this.recordStartTimeInternal;\n  }\n\n  setFilters(filters: TimelineModel.TimelineModelFilter.TimelineModelFilter[]): void {\n    this.filtersInternal = filters;\n  }\n\n  filters(): TimelineModel.TimelineModelFilter.TimelineModelFilter[] {\n    return this.filtersInternal;\n  }\n\n  isVisible(event: SDK.TracingModel.Event): boolean {\n    return this.filtersInternal.every(f => f.accept(event));\n  }\n\n  setTracingModel(model: SDK.TracingModel.TracingModel): void {\n    this.tracingModelInternal = model;\n    this.timelineModelInternal.setEvents(model);\n\n    let animationEvents: SDK.TracingModel.AsyncEvent[]|null = null;\n    for (const track of this.timelineModelInternal.tracks()) {\n      if (track.type === TimelineModel.TimelineModel.TrackType.Animation) {\n        animationEvents = track.asyncEvents;\n      }\n    }\n    if (animationEvents) {\n      this.irModel.populate([], animationEvents || []);\n    }\n\n    const mainTracks = this.timelineModelInternal.tracks().filter(\n        track => track.type === TimelineModel.TimelineModel.TrackType.MainThread && track.forMainFrame &&\n            track.events.length);\n    const threadData = mainTracks.map(track => {\n      const event = track.events[0];\n      return {thread: event.thread, time: event.startTime};\n    });\n    this.frameModelInternal.addTraceEvents(\n        this.mainTargetInternal, this.timelineModelInternal.inspectedTargetEvents(), threadData);\n\n    for (const entry of this.extensionTracingModels) {\n      entry.model.adjustTime(\n          this.tracingModelInternal.minimumRecordTime() + (entry.timeOffset / 1000) -\n          (this.recordStartTimeInternal as number));\n    }\n    this.autoWindowTimes();\n  }\n\n  addExtensionEvents(title: string, model: SDK.TracingModel.TracingModel, timeOffset: number): void {\n    this.extensionTracingModels.push({model: model, title: title, timeOffset: timeOffset});\n    if (!this.tracingModelInternal) {\n      return;\n    }\n    model.adjustTime(\n        this.tracingModelInternal.minimumRecordTime() + (timeOffset / 1000) - (this.recordStartTimeInternal as number));\n    this.dispatchEventToListeners(Events.ExtensionDataAdded);\n  }\n\n  tracingModel(): SDK.TracingModel.TracingModel {\n    if (!this.tracingModelInternal) {\n      throw 'call setTracingModel before accessing PerformanceModel';\n    }\n    return this.tracingModelInternal;\n  }\n\n  timelineModel(): TimelineModel.TimelineModel.TimelineModelImpl {\n    return this.timelineModelInternal;\n  }\n\n  filmStripModel(): SDK.FilmStripModel.FilmStripModel {\n    if (this.filmStripModelInternal) {\n      return this.filmStripModelInternal;\n    }\n    if (!this.tracingModelInternal) {\n      throw 'call setTracingModel before accessing PerformanceModel';\n    }\n    this.filmStripModelInternal = new SDK.FilmStripModel.FilmStripModel(this.tracingModelInternal);\n    return this.filmStripModelInternal;\n  }\n\n  frames(): TimelineModel.TimelineFrameModel.TimelineFrame[] {\n    return this.frameModelInternal.getFrames();\n  }\n\n  frameModel(): TimelineModel.TimelineFrameModel.TimelineFrameModel {\n    return this.frameModelInternal;\n  }\n\n  interactionRecords(): Common.SegmentedRange.Segment<TimelineModel.TimelineIRModel.Phases>[] {\n    return this.irModel.interactionRecords();\n  }\n\n  extensionInfo(): {\n    title: string,\n    model: SDK.TracingModel.TracingModel,\n  }[] {\n    return this.extensionTracingModels;\n  }\n\n  dispose(): void {\n    if (this.tracingModelInternal) {\n      this.tracingModelInternal.dispose();\n    }\n    for (const extensionEntry of this.extensionTracingModels) {\n      extensionEntry.model.dispose();\n    }\n  }\n\n  filmStripModelFrame(frame: TimelineModel.TimelineFrameModel.TimelineFrame): SDK.FilmStripModel.Frame|null {\n    // For idle frames, look at the state at the beginning of the frame.\n    const screenshotTime = frame.idle ? frame.startTime : frame.endTime;\n    const filmStripModel = (this.filmStripModelInternal as SDK.FilmStripModel.FilmStripModel);\n    const filmStripFrame = filmStripModel.frameByTimestamp(screenshotTime);\n    return filmStripFrame && filmStripFrame.timestamp - frame.endTime < 10 ? filmStripFrame : null;\n  }\n\n  save(stream: Common.StringOutputStream.OutputStream): Promise<DOMError|null> {\n    if (!this.tracingModelInternal) {\n      throw 'call setTracingModel before accessing PerformanceModel';\n    }\n    const backingStorage = (this.tracingModelInternal.backingStorage() as Bindings.TempFile.TempFileBackingStorage);\n    return backingStorage.writeToStream(stream);\n  }\n\n  setWindow(window: Window, animate?: boolean): void {\n    this.windowInternal = window;\n    this.dispatchEventToListeners(Events.WindowChanged, {window, animate});\n  }\n\n  window(): Window {\n    return this.windowInternal;\n  }\n\n  private autoWindowTimes(): void {\n    const timelineModel = this.timelineModelInternal;\n    let tasks: SDK.TracingModel.Event[] = [];\n    for (const track of timelineModel.tracks()) {\n      // Deliberately pick up last main frame's track.\n      if (track.type === TimelineModel.TimelineModel.TrackType.MainThread && track.forMainFrame) {\n        tasks = track.tasks;\n      }\n    }\n    if (!tasks.length) {\n      this.setWindow({left: timelineModel.minimumRecordTime(), right: timelineModel.maximumRecordTime()});\n      return;\n    }\n\n    function findLowUtilizationRegion(startIndex: number, stopIndex: number): number {\n      const threshold = 0.1;\n      let cutIndex = startIndex;\n      let cutTime = (tasks[cutIndex].startTime + (tasks[cutIndex].endTime as number)) / 2;\n      let usedTime = 0;\n      const step = Math.sign(stopIndex - startIndex);\n      for (let i = startIndex; i !== stopIndex; i += step) {\n        const task = tasks[i];\n        const taskTime = (task.startTime + (task.endTime as number)) / 2;\n        const interval = Math.abs(cutTime - taskTime);\n        if (usedTime < threshold * interval) {\n          cutIndex = i;\n          cutTime = taskTime;\n          usedTime = 0;\n        }\n        usedTime += (task.duration as number);\n      }\n      return cutIndex;\n    }\n    const rightIndex = findLowUtilizationRegion(tasks.length - 1, 0);\n    const leftIndex = findLowUtilizationRegion(0, rightIndex);\n    let leftTime: number = tasks[leftIndex].startTime;\n    let rightTime: number = (tasks[rightIndex].endTime as number);\n    const span = rightTime - leftTime;\n    const totalSpan = timelineModel.maximumRecordTime() - timelineModel.minimumRecordTime();\n    if (span < totalSpan * 0.1) {\n      leftTime = timelineModel.minimumRecordTime();\n      rightTime = timelineModel.maximumRecordTime();\n    } else {\n      leftTime = Math.max(leftTime - 0.05 * span, timelineModel.minimumRecordTime());\n      rightTime = Math.min(rightTime + 0.05 * span, timelineModel.maximumRecordTime());\n    }\n    this.setWindow({left: leftTime, right: rightTime});\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  ExtensionDataAdded = 'ExtensionDataAdded',\n  WindowChanged = 'WindowChanged',\n}\n\nexport interface WindowChangedEvent {\n  window: Window;\n  animate: boolean|undefined;\n}\n\nexport type EventTypes = {\n  [Events.ExtensionDataAdded]: void,\n  [Events.WindowChanged]: WindowChangedEvent,\n};\n\nexport interface Window {\n  left: number;\n  right: number;\n}\n"],
  "mappings": "AAIA;AACA;AAEA;AAEA;AAEO,sCAA+B,OAAO,cAAc,cAA0B;AAAA,EAC3E;AAAA,EACA;AAAA,EACA;AAAA,EACS;AAAA,EACA;AAAA,EACT;AAAA,EACS;AAAA,EACT;AAAA,EACS;AAAA,EAKT;AAAA,EAER,cAAc;AACZ;AACA,SAAK,qBAAqB;AAC1B,SAAK,uBAAuB;AAC5B,SAAK,kBAAkB;AAEvB,SAAK,wBAAwB,IAAI,cAAc,cAAc;AAC7D,SAAK,qBAAqB,IAAI,cAAc,mBAAmB,mBAC3D,WAAS,gBAAgB,WAAW,OAAO,SAAS;AACxD,SAAK,yBAAyB;AAC9B,SAAK,UAAU,IAAI,cAAc,gBAAgB;AAEjD,SAAK,iBAAiB,EAAC,MAAM,GAAG,OAAO;AAEvC,SAAK,yBAAyB;AAC9B,SAAK,0BAA0B;AAAA;AAAA,EAGjC,cAAc,QAAiC;AAC7C,SAAK,qBAAqB;AAAA;AAAA,EAG5B,aAAqC;AACnC,WAAO,KAAK;AAAA;AAAA,EAGd,mBAAmB,MAAoB;AACrC,SAAK,0BAA0B;AAAA;AAAA,EAGjC,kBAAoC;AAClC,WAAO,KAAK;AAAA;AAAA,EAGd,WAAW,SAAwE;AACjF,SAAK,kBAAkB;AAAA;AAAA,EAGzB,UAAmE;AACjE,WAAO,KAAK;AAAA;AAAA,EAGd,UAAU,OAAwC;AAChD,WAAO,KAAK,gBAAgB,MAAM,OAAK,EAAE,OAAO;AAAA;AAAA,EAGlD,gBAAgB,OAA4C;AAC1D,SAAK,uBAAuB;AAC5B,SAAK,sBAAsB,UAAU;AAErC,QAAI,kBAAsD;AAC1D,eAAW,SAAS,KAAK,sBAAsB,UAAU;AACvD,UAAI,MAAM,SAAS,cAAc,cAAc,UAAU,WAAW;AAClE,0BAAkB,MAAM;AAAA;AAAA;AAG5B,QAAI,iBAAiB;AACnB,WAAK,QAAQ,SAAS,IAAI,mBAAmB;AAAA;AAG/C,UAAM,aAAa,KAAK,sBAAsB,SAAS,OACnD,WAAS,MAAM,SAAS,cAAc,cAAc,UAAU,cAAc,MAAM,gBAC9E,MAAM,OAAO;AACrB,UAAM,aAAa,WAAW,IAAI,WAAS;AACzC,YAAM,QAAQ,MAAM,OAAO;AAC3B,aAAO,EAAC,QAAQ,MAAM,QAAQ,MAAM,MAAM;AAAA;AAE5C,SAAK,mBAAmB,eACpB,KAAK,oBAAoB,KAAK,sBAAsB,yBAAyB;AAEjF,eAAW,SAAS,KAAK,wBAAwB;AAC/C,YAAM,MAAM,WACR,KAAK,qBAAqB,sBAAuB,MAAM,aAAa,MACnE,KAAK;AAAA;AAEZ,SAAK;AAAA;AAAA,EAGP,mBAAmB,OAAe,OAAsC,YAA0B;AAChG,SAAK,uBAAuB,KAAK,EAAC,OAAc,OAAc;AAC9D,QAAI,CAAC,KAAK,sBAAsB;AAC9B;AAAA;AAEF,UAAM,WACF,KAAK,qBAAqB,sBAAuB,aAAa,MAAS,KAAK;AAChF,SAAK,yBAAyB,OAAO;AAAA;AAAA,EAGvC,eAA8C;AAC5C,QAAI,CAAC,KAAK,sBAAsB;AAC9B,YAAM;AAAA;AAER,WAAO,KAAK;AAAA;AAAA,EAGd,gBAA+D;AAC7D,WAAO,KAAK;AAAA;AAAA,EAGd,iBAAoD;AAClD,QAAI,KAAK,wBAAwB;AAC/B,aAAO,KAAK;AAAA;AAEd,QAAI,CAAC,KAAK,sBAAsB;AAC9B,YAAM;AAAA;AAER,SAAK,yBAAyB,IAAI,IAAI,eAAe,eAAe,KAAK;AACzE,WAAO,KAAK;AAAA;AAAA,EAGd,SAA2D;AACzD,WAAO,KAAK,mBAAmB;AAAA;AAAA,EAGjC,aAAkE;AAChE,WAAO,KAAK;AAAA;AAAA,EAGd,qBAA4F;AAC1F,WAAO,KAAK,QAAQ;AAAA;AAAA,EAGtB,gBAGI;AACF,WAAO,KAAK;AAAA;AAAA,EAGd,UAAgB;AACd,QAAI,KAAK,sBAAsB;AAC7B,WAAK,qBAAqB;AAAA;AAE5B,eAAW,kBAAkB,KAAK,wBAAwB;AACxD,qBAAe,MAAM;AAAA;AAAA;AAAA,EAIzB,oBAAoB,OAAsF;AAExG,UAAM,iBAAiB,MAAM,OAAO,MAAM,YAAY,MAAM;AAC5D,UAAM,iBAAkB,KAAK;AAC7B,UAAM,iBAAiB,eAAe,iBAAiB;AACvD,WAAO,kBAAkB,eAAe,YAAY,MAAM,UAAU,KAAK,iBAAiB;AAAA;AAAA,EAG5F,KAAK,QAAwE;AAC3E,QAAI,CAAC,KAAK,sBAAsB;AAC9B,YAAM;AAAA;AAER,UAAM,iBAAkB,KAAK,qBAAqB;AAClD,WAAO,eAAe,cAAc;AAAA;AAAA,EAGtC,UAAU,QAAgB,SAAyB;AACjD,SAAK,iBAAiB;AACtB,SAAK,yBAAyB,OAAO,eAAe,EAAC,QAAQ;AAAA;AAAA,EAG/D,SAAiB;AACf,WAAO,KAAK;AAAA;AAAA,EAGN,kBAAwB;AAC9B,UAAM,gBAAgB,KAAK;AAC3B,QAAI,QAAkC;AACtC,eAAW,SAAS,cAAc,UAAU;AAE1C,UAAI,MAAM,SAAS,cAAc,cAAc,UAAU,cAAc,MAAM,cAAc;AACzF,gBAAQ,MAAM;AAAA;AAAA;AAGlB,QAAI,CAAC,MAAM,QAAQ;AACjB,WAAK,UAAU,EAAC,MAAM,cAAc,qBAAqB,OAAO,cAAc;AAC9E;AAAA;AAGF,sCAAkC,YAAoB,WAA2B;AAC/E,YAAM,YAAY;AAClB,UAAI,WAAW;AACf,UAAI,UAAW,OAAM,UAAU,YAAa,MAAM,UAAU,WAAsB;AAClF,UAAI,WAAW;AACf,YAAM,OAAO,KAAK,KAAK,YAAY;AACnC,eAAS,IAAI,YAAY,MAAM,WAAW,KAAK,MAAM;AACnD,cAAM,OAAO,MAAM;AACnB,cAAM,WAAY,MAAK,YAAa,KAAK,WAAsB;AAC/D,cAAM,WAAW,KAAK,IAAI,UAAU;AACpC,YAAI,WAAW,YAAY,UAAU;AACnC,qBAAW;AACX,oBAAU;AACV,qBAAW;AAAA;AAEb,oBAAa,KAAK;AAAA;AAEpB,aAAO;AAAA;AAET,UAAM,aAAa,yBAAyB,MAAM,SAAS,GAAG;AAC9D,UAAM,YAAY,yBAAyB,GAAG;AAC9C,QAAI,WAAmB,MAAM,WAAW;AACxC,QAAI,YAAqB,MAAM,YAAY;AAC3C,UAAM,OAAO,YAAY;AACzB,UAAM,YAAY,cAAc,sBAAsB,cAAc;AACpE,QAAI,OAAO,YAAY,KAAK;AAC1B,iBAAW,cAAc;AACzB,kBAAY,cAAc;AAAA,WACrB;AACL,iBAAW,KAAK,IAAI,WAAW,OAAO,MAAM,cAAc;AAC1D,kBAAY,KAAK,IAAI,YAAY,OAAO,MAAM,cAAc;AAAA;AAE9D,SAAK,UAAU,EAAC,MAAM,UAAU,OAAO;AAAA;AAAA;AAMpC,WAAK,SAAL,kBAAK,YAAL;AACL,kCAAqB;AACrB,6BAAgB;AAFN;AAAA;",
  "names": []
}
