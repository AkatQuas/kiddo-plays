{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/timeline/TimelineFlameChartDataProvider.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2014 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport * as TimelineModel from '../../models/timeline_model/timeline_model.js';\nimport * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as ThemeSupport from '../../ui/legacy/theme_support/theme_support.js';\n\nimport timelineFlamechartPopoverStyles from './timelineFlamechartPopover.css.js';\n\nimport type {PerformanceModel} from './PerformanceModel.js';\nimport {FlameChartStyle, Selection, TimelineFlameChartMarker} from './TimelineFlameChartView.js';\nimport {TimelineSelection} from './TimelinePanel.js';\nimport type {TimelineCategory} from './TimelineUIUtils.js';\nimport {TimelineUIUtils, assignLayoutShiftsToClusters} from './TimelineUIUtils.js';\n\nconst UIStrings = {\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  onIgnoreList: 'On ignore list',\n  /**\n  *@description Text that refers to the animation of the web page\n  */\n  animation: 'Animation',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  timings: 'Timings',\n  /**\n  *@description Title of the Console tool\n  */\n  console: 'Console',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  *@example {example.com} PH1\n  */\n  mainS: 'Main \u2014 {PH1}',\n  /**\n  *@description Text that refers to the main target\n  */\n  main: 'Main',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  *@example {https://example.com} PH1\n  */\n  frameS: 'Frame \u2014 {PH1}',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  subframe: 'Subframe',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  raster: 'Raster',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  *@example {2} PH1\n  */\n  rasterizerThreadS: 'Rasterizer Thread {PH1}',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  gpu: 'GPU',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  thread: 'Thread',\n  /**\n  *@description Text in Timeline for the Experience title\n  */\n  experience: 'Experience',\n  /**\n  *@description Text for rendering frames\n  */\n  frames: 'Frames',\n  /**\n  * @description Text in the Performance panel to show how long was spent in a particular part of the code.\n  * The first placeholder is the total time taken for this node and all children, the second is the self time\n  * (time taken in this node, without children included).\n  *@example {10ms} PH1\n  *@example {10ms} PH2\n  */\n  sSelfS: '{PH1} (self {PH2})',\n  /**\n  *@description Tooltip text for the number of CLS occurences in Timeline\n  *@example {4} PH1\n  */\n  occurrencesS: 'Occurrences: {PH1}',\n  /**\n  *@description Text in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  idleFrame: 'Idle Frame',\n  /**\n  *@description Text in Timeline Frame Chart Data Provider of the Performance panel\n  */\n  droppedFrame: 'Dropped Frame',\n  /**\n  *@description Text in Timeline Frame Chart Data Provider of the Performance panel\n  */\n  partiallyPresentedFrame: 'Partially Presented Frame',\n  /**\n  *@description Text for a rendering frame\n  */\n  frame: 'Frame',\n  /**\n  *@description Warning text content in Timeline Flame Chart Data Provider of the Performance panel\n  */\n  longFrame: 'Long frame',\n  /**\n  * @description Text for the name of a thread of the page. Used when there are multiple threads but\n  * a more specific name for this thread is not available. The placeholder is a number that uniquely\n  * identifies this thread.\n  * @example {1} PH1\n  */\n  threadS: 'Thread {PH1}',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/TimelineFlameChartDataProvider.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\ntype TimelineFlameChartEntry = (SDK.FilmStripModel.Frame|SDK.TracingModel.Event|\n                                TimelineModel.TimelineFrameModel.TimelineFrame|TimelineModel.TimelineIRModel.Phases);\nexport class TimelineFlameChartDataProvider extends Common.ObjectWrapper.ObjectWrapper<EventTypes> implements\n    PerfUI.FlameChart.FlameChartDataProvider {\n  private readonly font: string;\n  private droppedFramePatternCanvas: HTMLCanvasElement;\n  private partialFramePatternCanvas: HTMLCanvasElement;\n  private timelineDataInternal: PerfUI.FlameChart.TimelineData|null;\n  private currentLevel: number;\n  private performanceModel: PerformanceModel|null;\n  private model: TimelineModel.TimelineModel.TimelineModelImpl|null;\n  private minimumBoundaryInternal: number;\n  private readonly maximumBoundary: number;\n  private timeSpan: number;\n  private readonly consoleColorGenerator: Common.Color.Generator;\n  private readonly extensionColorGenerator: Common.Color.Generator;\n  private readonly headerLevel1: PerfUI.FlameChart.GroupStyle;\n  private readonly headerLevel2: PerfUI.FlameChart.GroupStyle;\n  private readonly staticHeader: PerfUI.FlameChart.GroupStyle;\n  private framesHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly collapsibleTimingsHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly timingsHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly screenshotsHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly animationsHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly experienceHeader: PerfUI.FlameChart.GroupStyle;\n  private readonly flowEventIndexById: Map<string, number>;\n  private entryData!: TimelineFlameChartEntry[];\n  private entryTypeByLevel!: EntryType[];\n  private markers!: TimelineFlameChartMarker[];\n  private asyncColorByInteractionPhase!: Map<TimelineModel.TimelineIRModel.Phases, string>;\n  private screenshotImageCache!: Map<SDK.FilmStripModel.Frame, HTMLImageElement|null>;\n  private extensionInfo!: {\n    title: string,\n    model: SDK.TracingModel.TracingModel,\n  }[];\n  private entryIndexToTitle!: string[];\n  private asyncColorByCategory!: Map<TimelineCategory, string>;\n  private lastInitiatorEntry!: number;\n  private entryParent!: SDK.TracingModel.Event[];\n  private frameGroup?: PerfUI.FlameChart.Group;\n  private lastSelection?: Selection;\n  private colorForEvent?: ((arg0: SDK.TracingModel.Event) => string);\n\n  constructor() {\n    super();\n    this.reset();\n    this.font = '11px ' + Host.Platform.fontFamily();\n    this.droppedFramePatternCanvas = document.createElement('canvas');\n    this.partialFramePatternCanvas = document.createElement('canvas');\n    this.preparePatternCanvas();\n    this.timelineDataInternal = null;\n    this.currentLevel = 0;\n    this.performanceModel = null;\n    this.model = null;\n    this.minimumBoundaryInternal = 0;\n    this.maximumBoundary = 0;\n    this.timeSpan = 0;\n\n    this.consoleColorGenerator = new Common.Color.Generator(\n        {\n          min: 30,\n          max: 55,\n          count: undefined,\n        },\n        {min: 70, max: 100, count: 6}, 50, 0.7);\n    this.extensionColorGenerator = new Common.Color.Generator(\n        {\n          min: 210,\n          max: 300,\n          count: undefined,\n        },\n        {min: 70, max: 100, count: 6}, 70, 0.7);\n\n    this.headerLevel1 = this.buildGroupStyle({shareHeaderLine: false});\n    this.headerLevel2 = this.buildGroupStyle({padding: 2, nestingLevel: 1, collapsible: false});\n    this.staticHeader = this.buildGroupStyle({collapsible: false});\n    this.framesHeader = this.buildGroupStyle({useFirstLineForOverview: true});\n    this.collapsibleTimingsHeader =\n        this.buildGroupStyle({shareHeaderLine: true, useFirstLineForOverview: true, collapsible: true});\n    this.timingsHeader =\n        this.buildGroupStyle({shareHeaderLine: true, useFirstLineForOverview: true, collapsible: false});\n    this.screenshotsHeader =\n        this.buildGroupStyle({useFirstLineForOverview: true, nestingLevel: 1, collapsible: false, itemsHeight: 150});\n    this.animationsHeader = this.buildGroupStyle({useFirstLineForOverview: false});\n    this.experienceHeader = this.buildGroupStyle({collapsible: false});\n\n    ThemeSupport.ThemeSupport.instance().addEventListener(ThemeSupport.ThemeChangeEvent.eventName, () => {\n      const headers = [\n        this.headerLevel1,\n        this.headerLevel2,\n        this.staticHeader,\n        this.framesHeader,\n        this.collapsibleTimingsHeader,\n        this.timingsHeader,\n        this.screenshotsHeader,\n        this.animationsHeader,\n        this.experienceHeader,\n      ];\n      for (const header of headers) {\n        header.color = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary');\n        header.backgroundColor = ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background');\n      }\n    });\n\n    this.flowEventIndexById = new Map();\n  }\n\n  private buildGroupStyle(extra: Object): PerfUI.FlameChart.GroupStyle {\n    const defaultGroupStyle = {\n      padding: 4,\n      height: 17,\n      collapsible: true,\n      color: ThemeSupport.ThemeSupport.instance().getComputedValue('--color-text-primary'),\n      backgroundColor: ThemeSupport.ThemeSupport.instance().getComputedValue('--color-background'),\n      font: this.font,\n      nestingLevel: 0,\n      shareHeaderLine: true,\n    };\n    return Object.assign(defaultGroupStyle, extra);\n  }\n\n  setModel(performanceModel: PerformanceModel|null): void {\n    this.reset();\n    this.performanceModel = performanceModel;\n    this.model = performanceModel && performanceModel.timelineModel();\n  }\n\n  groupTrack(group: PerfUI.FlameChart.Group): TimelineModel.TimelineModel.Track|null {\n    return group.track || null;\n  }\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  navStartTimes(): Map<any, any> {\n    if (!this.model) {\n      return new Map();\n    }\n\n    return this.model.navStartTimes();\n  }\n\n  entryTitle(entryIndex: number): string|null {\n    const entryTypes = EntryType;\n    const entryType = this.entryType(entryIndex);\n    if (entryType === entryTypes.Event) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      if (event.phase === SDK.TracingModel.Phase.AsyncStepInto ||\n          event.phase === SDK.TracingModel.Phase.AsyncStepPast) {\n        return event.name + ':' + event.args['step'];\n      }\n      if (eventToDisallowRoot.get(event)) {\n        return i18nString(UIStrings.onIgnoreList);\n      }\n      if (this.performanceModel && this.performanceModel.timelineModel().isMarkerEvent(event)) {\n        return TimelineUIUtils.markerShortTitle(event);\n      }\n      return TimelineUIUtils.eventTitle(event);\n    }\n    if (entryType === entryTypes.ExtensionEvent) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      return event.name;\n    }\n    if (entryType === entryTypes.Screenshot) {\n      return '';\n    }\n    let title: Common.UIString.LocalizedString|string = this.entryIndexToTitle[entryIndex];\n    if (!title) {\n      title = `Unexpected entryIndex ${entryIndex}`;\n      console.error(title);\n    }\n    return title;\n  }\n\n  textColor(index: number): string {\n    const event = this.entryData[index];\n    return event && eventToDisallowRoot.get((event as SDK.TracingModel.Event)) ? '#888' : FlameChartStyle.textColor;\n  }\n\n  entryFont(_index: number): string|null {\n    return this.font;\n  }\n\n  reset(): void {\n    this.currentLevel = 0;\n    this.timelineDataInternal = null;\n    this.entryData = [];\n    this.entryParent = [];\n    this.entryTypeByLevel = [];\n    this.entryIndexToTitle = [];\n    this.markers = [];\n    this.asyncColorByCategory = new Map();\n    this.asyncColorByInteractionPhase = new Map();\n    this.extensionInfo = [];\n    this.screenshotImageCache = new Map();\n  }\n\n  maxStackDepth(): number {\n    return this.currentLevel;\n  }\n\n  timelineData(): PerfUI.FlameChart.TimelineData {\n    if (this.timelineDataInternal) {\n      return this.timelineDataInternal;\n    }\n\n    this.timelineDataInternal = new PerfUI.FlameChart.TimelineData([], [], [], []);\n    if (!this.model) {\n      return this.timelineDataInternal;\n    }\n\n    this.flowEventIndexById.clear();\n    this.minimumBoundaryInternal = this.model.minimumRecordTime();\n    this.timeSpan = this.model.isEmpty() ? 1000 : this.model.maximumRecordTime() - this.minimumBoundaryInternal;\n    this.currentLevel = 0;\n\n    if (this.model.isGenericTrace()) {\n      this.processGenericTrace();\n    } else {\n      this.processInspectorTrace();\n    }\n\n    return this.timelineDataInternal;\n  }\n\n  private processGenericTrace(): void {\n    const processGroupStyle = this.buildGroupStyle({shareHeaderLine: false});\n    const threadGroupStyle = this.buildGroupStyle({padding: 2, nestingLevel: 1, shareHeaderLine: false});\n    const eventEntryType = EntryType.Event;\n    const tracksByProcess =\n        new Platform.MapUtilities.Multimap<SDK.TracingModel.Process, TimelineModel.TimelineModel.Track>();\n    if (!this.model) {\n      return;\n    }\n    for (const track of this.model.tracks()) {\n      if (track.thread !== null) {\n        tracksByProcess.set(track.thread.process(), track);\n      } else {\n        // The Timings track can reach this point, so we should probably do something more useful.\n        console.error('Failed to process track');\n      }\n    }\n    for (const process of tracksByProcess.keysArray()) {\n      if (tracksByProcess.size > 1) {\n        const name = `${process.name()} ${process.id()}`;\n        this.appendHeader(name, processGroupStyle, false /* selectable */);\n      }\n      for (const track of tracksByProcess.get(process)) {\n        const group = this.appendSyncEvents(\n            track, track.events, track.name, threadGroupStyle, eventEntryType, true /* selectable */);\n        if (this.timelineDataInternal &&\n            (!this.timelineDataInternal.selectedGroup ||\n             track.name === TimelineModel.TimelineModel.TimelineModelImpl.BrowserMainThreadName)) {\n          this.timelineDataInternal.selectedGroup = group;\n        }\n      }\n    }\n  }\n\n  private processInspectorTrace(): void {\n    this.appendFrames();\n    this.appendInteractionRecords();\n\n    const eventEntryType = EntryType.Event;\n\n    const weight = (track: TimelineModel.TimelineModel.Track): 1|2|3|4|5|6|7|8|9|10|- 1 => {\n      switch (track.type) {\n        case TimelineModel.TimelineModel.TrackType.Animation:\n          return 1;\n        case TimelineModel.TimelineModel.TrackType.Timings:\n          return 2;\n        case TimelineModel.TimelineModel.TrackType.Console:\n          return 3;\n        case TimelineModel.TimelineModel.TrackType.Experience:\n          return 4;\n        case TimelineModel.TimelineModel.TrackType.MainThread:\n          return track.forMainFrame ? 5 : 6;\n        case TimelineModel.TimelineModel.TrackType.Worker:\n          return 7;\n        case TimelineModel.TimelineModel.TrackType.Raster:\n          return 8;\n        case TimelineModel.TimelineModel.TrackType.GPU:\n          return 9;\n        case TimelineModel.TimelineModel.TrackType.Other:\n          return 10;\n        default:\n          return -1;\n      }\n    };\n\n    if (!this.model) {\n      return;\n    }\n\n    const tracks = this.model.tracks().slice();\n    tracks.sort((a, b) => weight(a) - weight(b));\n    let rasterCount = 0;\n    for (const track of tracks) {\n      switch (track.type) {\n        case TimelineModel.TimelineModel.TrackType.Animation: {\n          this.appendAsyncEventsGroup(\n              track, i18nString(UIStrings.animation), track.asyncEvents, this.animationsHeader, eventEntryType,\n              false /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Timings: {\n          const style = track.asyncEvents.length > 0 ? this.collapsibleTimingsHeader : this.timingsHeader;\n          const group = this.appendHeader(i18nString(UIStrings.timings), style, true /* selectable */);\n          group.track = track;\n          this.appendPageMetrics();\n          this.copyPerfMarkEvents(track);\n          this.appendSyncEvents(track, track.events, null, null, eventEntryType, true /* selectable */);\n          this.appendAsyncEventsGroup(track, null, track.asyncEvents, null, eventEntryType, true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Console: {\n          this.appendAsyncEventsGroup(\n              track, i18nString(UIStrings.console), track.asyncEvents, this.headerLevel1, eventEntryType,\n              true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.MainThread: {\n          if (track.forMainFrame) {\n            const group = this.appendSyncEvents(\n                track, track.events,\n                track.url ? i18nString(UIStrings.mainS, {PH1: track.url}) : i18nString(UIStrings.main),\n                this.headerLevel1, eventEntryType, true /* selectable */);\n            if (group && this.timelineDataInternal) {\n              this.timelineDataInternal.selectedGroup = group;\n            }\n          } else {\n            this.appendSyncEvents(\n                track, track.events,\n                track.url ? i18nString(UIStrings.frameS, {PH1: track.url}) : i18nString(UIStrings.subframe),\n                this.headerLevel1, eventEntryType, true /* selectable */);\n          }\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Worker: {\n          this.appendSyncEvents(\n              track, track.events, track.name, this.headerLevel1, eventEntryType, true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Raster: {\n          if (!rasterCount) {\n            this.appendHeader(i18nString(UIStrings.raster), this.headerLevel1, false /* selectable */);\n          }\n          ++rasterCount;\n          this.appendSyncEvents(\n              track, track.events, i18nString(UIStrings.rasterizerThreadS, {PH1: rasterCount}), this.headerLevel2,\n              eventEntryType, true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.GPU: {\n          this.appendSyncEvents(\n              track, track.events, i18nString(UIStrings.gpu), this.headerLevel1, eventEntryType, true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Other: {\n          this.appendSyncEvents(\n              track, track.events, track.name || i18nString(UIStrings.thread), this.headerLevel1, eventEntryType,\n              true /* selectable */);\n          this.appendAsyncEventsGroup(\n              track, track.name, track.asyncEvents, this.headerLevel1, eventEntryType, true /* selectable */);\n          break;\n        }\n\n        case TimelineModel.TimelineModel.TrackType.Experience: {\n          this.appendSyncEvents(\n              track, track.events, i18nString(UIStrings.experience), this.experienceHeader, eventEntryType,\n              true /* selectable */);\n          break;\n        }\n      }\n    }\n    if (this.timelineDataInternal && this.timelineDataInternal.selectedGroup) {\n      this.timelineDataInternal.selectedGroup.expanded = true;\n    }\n\n    for (let extensionIndex = 0; extensionIndex < this.extensionInfo.length; extensionIndex++) {\n      this.innerAppendExtensionEvents(extensionIndex);\n    }\n\n    this.markers.sort((a, b) => a.startTime() - b.startTime());\n    if (this.timelineDataInternal) {\n      this.timelineDataInternal.markers = this.markers;\n    }\n    this.flowEventIndexById.clear();\n  }\n\n  minimumBoundary(): number {\n    return this.minimumBoundaryInternal;\n  }\n\n  totalTime(): number {\n    return this.timeSpan;\n  }\n\n  search(startTime: number, endTime: number, filter: TimelineModel.TimelineModelFilter.TimelineModelFilter): number[] {\n    const result = [];\n    const entryTypes = EntryType;\n    this.timelineData();\n    for (let i = 0; i < this.entryData.length; ++i) {\n      if (this.entryType(i) !== entryTypes.Event) {\n        continue;\n      }\n      const event = (this.entryData[i] as SDK.TracingModel.Event);\n      if (event.startTime > endTime) {\n        continue;\n      }\n      if ((event.endTime || event.startTime) < startTime) {\n        continue;\n      }\n      if (filter.accept(event)) {\n        result.push(i);\n      }\n    }\n    result.sort(\n        (a, b) => SDK.TracingModel.Event.compareStartTime(\n            (this.entryData[a] as SDK.TracingModel.Event), (this.entryData[b] as SDK.TracingModel.Event)));\n    return result;\n  }\n\n  private appendSyncEvents(\n      track: TimelineModel.TimelineModel.Track|null, events: SDK.TracingModel.Event[], title: string|null,\n      style: PerfUI.FlameChart.GroupStyle|null, entryType: EntryType, selectable: boolean): PerfUI.FlameChart.Group\n      |null {\n    if (!events.length) {\n      return null;\n    }\n    if (!this.performanceModel || !this.model) {\n      return null;\n    }\n    const isExtension = entryType === EntryType.ExtensionEvent;\n    const openEvents = [];\n    const ignoreListingEnabled = !isExtension && Root.Runtime.experiments.isEnabled('ignoreListJSFramesOnTimeline');\n    let maxStackDepth = 0;\n    let group: PerfUI.FlameChart.Group|null = null;\n    if (track && track.type === TimelineModel.TimelineModel.TrackType.MainThread) {\n      group = this.appendHeader((title as string), (style as PerfUI.FlameChart.GroupStyle), selectable);\n      group.track = track;\n    }\n    for (let i = 0; i < events.length; ++i) {\n      const e = events[i];\n      // Skip Layout Shifts and TTI events when dealing with the main thread.\n      if (this.performanceModel) {\n        const isInteractiveTime = this.performanceModel.timelineModel().isInteractiveTimeEvent(e);\n        const isLayoutShift = this.performanceModel.timelineModel().isLayoutShiftEvent(e);\n        const skippableEvent = isInteractiveTime || isLayoutShift;\n\n        if (track && track.type === TimelineModel.TimelineModel.TrackType.MainThread && skippableEvent) {\n          continue;\n        }\n      }\n\n      if (this.performanceModel && this.performanceModel.timelineModel().isLayoutShiftEvent(e)) {\n        // Expand layout shift events to the size of the frame in which it is situated.\n        for (const frame of this.performanceModel.frames()) {\n          // Locate the correct frame and expand the event accordingly.\n          if (typeof e.endTime === 'undefined') {\n            e.setEndTime(e.startTime);\n          }\n\n          const isAfterStartTime = e.startTime >= frame.startTime;\n          const isBeforeEndTime = e.endTime && e.endTime <= frame.endTime;\n          const eventIsInFrame = isAfterStartTime && isBeforeEndTime;\n\n          if (!eventIsInFrame) {\n            continue;\n          }\n\n          e.startTime = frame.startTime;\n          e.setEndTime(frame.endTime);\n        }\n      }\n\n      if (!isExtension && this.performanceModel.timelineModel().isMarkerEvent(e)) {\n        this.markers.push(new TimelineFlameChartMarker(\n            e.startTime, e.startTime - this.model.minimumRecordTime(), TimelineUIUtils.markerStyleForEvent(e)));\n      }\n      if (!SDK.TracingModel.TracingModel.isFlowPhase(e.phase)) {\n        if (!e.endTime && e.phase !== SDK.TracingModel.Phase.Instant) {\n          continue;\n        }\n        if (SDK.TracingModel.TracingModel.isAsyncPhase(e.phase)) {\n          continue;\n        }\n        if (!isExtension && !this.performanceModel.isVisible(e)) {\n          continue;\n        }\n      }\n      while (openEvents.length &&\n             // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n             // @ts-expect-error\n             ((openEvents[openEvents.length - 1] as SDK.TracingModel.Event).endTime) <= e.startTime) {\n        openEvents.pop();\n      }\n      eventToDisallowRoot.set(e, false);\n      if (ignoreListingEnabled && this.isIgnoreListedEvent(e)) {\n        const parent = openEvents[openEvents.length - 1];\n        if (parent && eventToDisallowRoot.get(parent)) {\n          continue;\n        }\n        eventToDisallowRoot.set(e, true);\n      }\n      if (!group && title) {\n        group = this.appendHeader(title, (style as PerfUI.FlameChart.GroupStyle), selectable);\n        if (selectable) {\n          group.track = track;\n        }\n      }\n\n      const level = this.currentLevel + openEvents.length;\n      const index = this.appendEvent(e, level);\n      if (openEvents.length) {\n        this.entryParent[index] = (openEvents[openEvents.length - 1] as SDK.TracingModel.Event);\n      }\n      if (!isExtension && this.performanceModel.timelineModel().isMarkerEvent(e)) {\n        // @ts-ignore This is invalid code, but we should keep it for now\n        this.timelineDataInternal.entryTotalTimes[this.entryData.length] = undefined;\n      }\n\n      maxStackDepth = Math.max(maxStackDepth, openEvents.length + 1);\n      if (e.endTime) {\n        openEvents.push(e);\n      }\n    }\n    this.entryTypeByLevel.length = this.currentLevel + maxStackDepth;\n    this.entryTypeByLevel.fill(entryType, this.currentLevel);\n    this.currentLevel += maxStackDepth;\n    return group;\n  }\n\n  private isIgnoreListedEvent(event: SDK.TracingModel.Event): boolean {\n    if (event.name !== TimelineModel.TimelineModel.RecordType.JSFrame) {\n      return false;\n    }\n    const url = event.args['data']['url'] as Platform.DevToolsPath.UrlString;\n    return url && this.isIgnoreListedURL(url);\n  }\n\n  private isIgnoreListedURL(url: Platform.DevToolsPath.UrlString): boolean {\n    return Bindings.IgnoreListManager.IgnoreListManager.instance().isIgnoreListedURL(url);\n  }\n\n  private appendAsyncEventsGroup(\n      track: TimelineModel.TimelineModel.Track|null, title: string|null, events: SDK.TracingModel.AsyncEvent[],\n      style: PerfUI.FlameChart.GroupStyle|null, entryType: EntryType, selectable: boolean): PerfUI.FlameChart.Group\n      |null {\n    if (!events.length) {\n      return null;\n    }\n    const lastUsedTimeByLevel: number[] = [];\n    let group: PerfUI.FlameChart.Group|null = null;\n    for (let i = 0; i < events.length; ++i) {\n      const asyncEvent = events[i];\n      if (!this.performanceModel || !this.performanceModel.isVisible(asyncEvent)) {\n        continue;\n      }\n      if (!group && title) {\n        group = this.appendHeader(title, (style as PerfUI.FlameChart.GroupStyle), selectable);\n        if (selectable) {\n          group.track = track;\n        }\n      }\n      const startTime = asyncEvent.startTime;\n      let level;\n      for (level = 0; level < lastUsedTimeByLevel.length && lastUsedTimeByLevel[level] > startTime; ++level) {\n      }\n      this.appendAsyncEvent(asyncEvent, this.currentLevel + level);\n      lastUsedTimeByLevel[level] = (asyncEvent.endTime as number);\n    }\n    this.entryTypeByLevel.length = this.currentLevel + lastUsedTimeByLevel.length;\n    this.entryTypeByLevel.fill(entryType, this.currentLevel);\n    this.currentLevel += lastUsedTimeByLevel.length;\n    return group;\n  }\n\n  private appendInteractionRecords(): void {\n    if (!this.performanceModel) {\n      return;\n    }\n    const interactionRecords = this.performanceModel.interactionRecords();\n    if (!interactionRecords.length) {\n      return;\n    }\n    for (const segment of interactionRecords) {\n      const index = this.entryData.length;\n      this.entryData.push((segment.data as TimelineModel.TimelineIRModel.Phases));\n      this.entryIndexToTitle[index] = (segment.data as string);\n      if (this.timelineDataInternal) {\n        this.timelineDataInternal.entryLevels[index] = this.currentLevel;\n        this.timelineDataInternal.entryTotalTimes[index] = segment.end - segment.begin;\n        this.timelineDataInternal.entryStartTimes[index] = segment.begin;\n      }\n    }\n    this.entryTypeByLevel[this.currentLevel++] = EntryType.InteractionRecord;\n  }\n\n  private appendPageMetrics(): void {\n    this.entryTypeByLevel[this.currentLevel] = EntryType.Event;\n\n    if (!this.performanceModel || !this.model) {\n      return;\n    }\n\n    const metricEvents: SDK.TracingModel.Event[] = [];\n    const lcpEvents = [];\n    const layoutShifts: SDK.TracingModel.Event[] = [];\n    const timelineModel = this.performanceModel.timelineModel();\n    for (const track of this.model.tracks()) {\n      for (const event of track.events) {\n        if (timelineModel.isLayoutShiftEvent(event)) {\n          layoutShifts.push(event);\n        }\n\n        if (!timelineModel.isMarkerEvent(event)) {\n          continue;\n        }\n        if (timelineModel.isLCPCandidateEvent(event) || timelineModel.isLCPInvalidateEvent(event)) {\n          lcpEvents.push(event);\n        } else {\n          metricEvents.push(event);\n        }\n      }\n    }\n\n    // Only the LCP event with the largest candidate index is relevant.\n    // Do not record an LCP event if it is an invalidate event.\n    if (lcpEvents.length > 0) {\n      const lcpEventsByNavigationId = new Map<string, SDK.TracingModel.Event>();\n      for (const e of lcpEvents) {\n        const key = e.args['data']['navigationId'];\n        const previousLastEvent = lcpEventsByNavigationId.get(key);\n\n        if (!previousLastEvent || previousLastEvent.args['data']['candidateIndex'] < e.args['data']['candidateIndex']) {\n          lcpEventsByNavigationId.set(key, e);\n        }\n      }\n\n      const latestCandidates = Array.from(lcpEventsByNavigationId.values());\n      const latestEvents = latestCandidates.filter(e => timelineModel.isLCPCandidateEvent(e));\n\n      metricEvents.push(...latestEvents);\n    }\n\n    if (layoutShifts.length) {\n      assignLayoutShiftsToClusters(layoutShifts);\n    }\n\n    metricEvents.sort(SDK.TracingModel.Event.compareStartTime);\n    if (this.timelineDataInternal) {\n      const totalTimes = this.timelineDataInternal.entryTotalTimes;\n      for (const event of metricEvents) {\n        this.appendEvent(event, this.currentLevel);\n        totalTimes[totalTimes.length - 1] = Number.NaN;\n      }\n    }\n\n    ++this.currentLevel;\n  }\n\n  /**\n   * This function pushes a copy of each performance.mark() event from the Main track\n   * into Timings so they can be appended to the performance UI.\n   * Performance.mark() are a part of the \"blink.user_timing\" category alongside\n   * Navigation and Resource Timing events, so we must filter them out before pushing.\n   */\n  private copyPerfMarkEvents(timingTrack: TimelineModel.TimelineModel.Track|null): void {\n    this.entryTypeByLevel[this.currentLevel] = EntryType.Event;\n    if (!this.performanceModel || !this.model || !timingTrack) {\n      return;\n    }\n    const timelineModel = this.performanceModel.timelineModel();\n    const ResourceTimingNames = [\n      'workerStart',\n      'redirectStart',\n      'redirectEnd',\n      'fetchStart',\n      'domainLookupStart',\n      'domainLookupEnd',\n      'connectStart',\n      'connectEnd',\n      'secureConnectionStart',\n      'requestStart',\n      'responseStart',\n      'responseEnd',\n    ];\n    const NavTimingNames = [\n      'navigationStart',\n      'unloadEventStart',\n      'unloadEventEnd',\n      'redirectStart',\n      'redirectEnd',\n      'fetchStart',\n      'domainLookupStart',\n      'domainLookupEnd',\n      'connectStart',\n      'connectEnd',\n      'secureConnectionStart',\n      'requestStart',\n      'responseStart',\n      'responseEnd',\n      'domLoading',\n      'domInteractive',\n      'domContentLoadedEventStart',\n      'domContentLoadedEventEnd',\n      'domComplete',\n      'loadEventStart',\n      'loadEventEnd',\n    ];\n    const IgnoreNames = [...ResourceTimingNames, ...NavTimingNames];\n    for (const track of this.model.tracks()) {\n      if (track.type === TimelineModel.TimelineModel.TrackType.MainThread) {\n        for (const event of track.events) {\n          if (timelineModel.isUserTimingEvent(event)) {\n            if (IgnoreNames.includes(event.name)) {\n              continue;\n            }\n            if (SDK.TracingModel.TracingModel.isAsyncPhase(event.phase)) {\n              continue;\n            }\n            event.setEndTime(event.startTime);\n            timingTrack.events.push(event);\n          }\n        }\n      }\n    }\n\n    ++this.currentLevel;\n  }\n\n  private appendFrames(): void {\n    if (!this.performanceModel || !this.timelineDataInternal || !this.model) {\n      return;\n    }\n    const screenshots = this.performanceModel.filmStripModel().frames();\n    const hasFilmStrip = Boolean(screenshots.length);\n    this.framesHeader.collapsible = hasFilmStrip;\n    this.appendHeader(i18nString(UIStrings.frames), this.framesHeader, false /* selectable */);\n    this.frameGroup = this.timelineDataInternal.groups[this.timelineDataInternal.groups.length - 1];\n    const style = TimelineUIUtils.markerStyleForFrame();\n\n    this.entryTypeByLevel[this.currentLevel] = EntryType.Frame;\n    for (const frame of this.performanceModel.frames()) {\n      this.markers.push(\n          new TimelineFlameChartMarker(frame.startTime, frame.startTime - this.model.minimumRecordTime(), style));\n      this.appendFrame(frame);\n    }\n    ++this.currentLevel;\n\n    if (!hasFilmStrip) {\n      return;\n    }\n    this.appendHeader('', this.screenshotsHeader, false /* selectable */);\n    this.entryTypeByLevel[this.currentLevel] = EntryType.Screenshot;\n    let prevTimestamp: number|undefined;\n    for (const screenshot of screenshots) {\n      this.entryData.push(screenshot);\n      (this.timelineDataInternal.entryLevels as number[]).push(this.currentLevel);\n      (this.timelineDataInternal.entryStartTimes as number[]).push(screenshot.timestamp);\n      if (prevTimestamp) {\n        (this.timelineDataInternal.entryTotalTimes as number[]).push(screenshot.timestamp - prevTimestamp);\n      }\n      prevTimestamp = screenshot.timestamp;\n    }\n    if (screenshots.length && prevTimestamp !== undefined) {\n      (this.timelineDataInternal.entryTotalTimes as number[]).push(this.model.maximumRecordTime() - prevTimestamp);\n    }\n    ++this.currentLevel;\n  }\n\n  private entryType(entryIndex: number): EntryType {\n    return this.entryTypeByLevel[(this.timelineDataInternal as PerfUI.FlameChart.TimelineData).entryLevels[entryIndex]];\n  }\n\n  prepareHighlightedEntryInfo(entryIndex: number): Element|null {\n    let time = '';\n    let title;\n    let warning;\n    let nameSpanTimelineInfoTime = 'timeline-info-time';\n\n    const type = this.entryType(entryIndex);\n    if (type === EntryType.Event) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      const totalTime = event.duration;\n      const selfTime = event.selfTime;\n      const eps = 1e-6;\n      if (typeof totalTime === 'number') {\n        time = Math.abs(totalTime - selfTime) > eps && selfTime > eps ?\n            i18nString(UIStrings.sSelfS, {\n              PH1: i18n.TimeUtilities.millisToString(totalTime, true),\n              PH2: i18n.TimeUtilities.millisToString(selfTime, true),\n            }) :\n            i18n.TimeUtilities.millisToString(totalTime, true);\n      }\n      if (this.performanceModel && this.performanceModel.timelineModel().isMarkerEvent(event)) {\n        title = TimelineUIUtils.eventTitle(event);\n      } else {\n        title = this.entryTitle(entryIndex);\n      }\n      warning = TimelineUIUtils.eventWarning(event);\n\n      if (this.model && this.model.isLayoutShiftEvent(event)) {\n        // TODO: Update this to be dynamic when the trace data supports it.\n        const occurrences = 1;\n        time = i18nString(UIStrings.occurrencesS, {PH1: occurrences});\n      }\n\n      if (this.model && this.model.isParseHTMLEvent(event)) {\n        const startLine = event.args['beginData']['startLine'];\n        const endLine = event.args['endData'] && event.args['endData']['endLine'];\n        const url = Bindings.ResourceUtils.displayNameForURL(event.args['beginData']['url']);\n        const range = (endLine !== -1 || endLine === startLine) ? `${startLine}...${endLine}` : startLine;\n        title += ` - ${url} [${range}]`;\n      }\n\n    } else if (type === EntryType.Frame) {\n      const frame = (this.entryData[entryIndex] as TimelineModel.TimelineFrameModel.TimelineFrame);\n      time = i18n.TimeUtilities.preciseMillisToString(frame.duration, 1);\n\n      if (frame.idle) {\n        title = i18nString(UIStrings.idleFrame);\n      } else if (frame.dropped) {\n        if (frame.isPartial) {\n          title = i18nString(UIStrings.partiallyPresentedFrame);\n        } else {\n          title = i18nString(UIStrings.droppedFrame);\n        }\n        nameSpanTimelineInfoTime = 'timeline-info-warning';\n      } else {\n        title = i18nString(UIStrings.frame);\n      }\n\n      if (frame.hasWarnings()) {\n        warning = document.createElement('span');\n        warning.textContent = i18nString(UIStrings.longFrame);\n      }\n    } else {\n      return null;\n    }\n\n    const element = document.createElement('div');\n    const root = UI.Utils.createShadowRootWithCoreStyles(element, {\n      cssFile: [timelineFlamechartPopoverStyles],\n      delegatesFocus: undefined,\n    });\n    const contents = root.createChild('div', 'timeline-flamechart-popover');\n    contents.createChild('span', nameSpanTimelineInfoTime).textContent = time;\n    contents.createChild('span', 'timeline-info-title').textContent = title;\n    if (warning) {\n      warning.classList.add('timeline-info-warning');\n      contents.appendChild(warning);\n    }\n    return element;\n  }\n\n  entryColor(entryIndex: number): string {\n    function patchColorAndCache<KEY>(cache: Map<KEY, string>, key: KEY, lookupColor: (arg0: KEY) => string): string {\n      let color = cache.get(key);\n      if (color) {\n        return color;\n      }\n      const parsedColor = Common.Color.Color.parse(lookupColor(key));\n      if (!parsedColor) {\n        throw new Error('Could not parse color from entry');\n      }\n      color = parsedColor.setAlpha(0.7).asString(Common.Color.Format.RGBA) || '';\n      cache.set(key, color);\n      return color;\n    }\n\n    if (!this.performanceModel || !this.model) {\n      return '';\n    }\n\n    const entryTypes = EntryType;\n    const type = this.entryType(entryIndex);\n    if (type === entryTypes.Event) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      if (this.model.isGenericTrace()) {\n        return this.genericTraceEventColor(event);\n      }\n      if (this.performanceModel.timelineModel().isMarkerEvent(event)) {\n        return TimelineUIUtils.markerStyleForEvent(event).color;\n      }\n      if (!SDK.TracingModel.TracingModel.isAsyncPhase(event.phase) && this.colorForEvent) {\n        return this.colorForEvent(event);\n      }\n      if (event.hasCategory(TimelineModel.TimelineModel.TimelineModelImpl.Category.Console) ||\n          event.hasCategory(TimelineModel.TimelineModel.TimelineModelImpl.Category.UserTiming)) {\n        return this.consoleColorGenerator.colorForID(event.name);\n      }\n      if (event.hasCategory(TimelineModel.TimelineModel.TimelineModelImpl.Category.LatencyInfo)) {\n        const phase = TimelineModel.TimelineIRModel.TimelineIRModel.phaseForEvent(event) ||\n            TimelineModel.TimelineIRModel.Phases.Uncategorized;\n        return patchColorAndCache(this.asyncColorByInteractionPhase, phase, TimelineUIUtils.interactionPhaseColor);\n      }\n      const category = TimelineUIUtils.eventStyle(event).category;\n      return patchColorAndCache(this.asyncColorByCategory, category, () => category.color);\n    }\n    if (type === entryTypes.Frame) {\n      return 'white';\n    }\n    if (type === entryTypes.InteractionRecord) {\n      return 'transparent';\n    }\n    if (type === entryTypes.ExtensionEvent) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      return this.extensionColorGenerator.colorForID(event.name);\n    }\n    return '';\n  }\n\n  private genericTraceEventColor(event: SDK.TracingModel.Event): string {\n    const key = event.categoriesString || event.name;\n    return key ? `hsl(${Platform.StringUtilities.hashCode(key) % 300 + 30}, 40%, 70%)` : '#ccc';\n  }\n\n  private preparePatternCanvas(): void {\n    // Set the candy stripe pattern to 17px so it repeats well.\n    const size = 17;\n    this.droppedFramePatternCanvas.width = size;\n    this.droppedFramePatternCanvas.height = size;\n\n    this.partialFramePatternCanvas.width = size;\n    this.partialFramePatternCanvas.height = size;\n\n    const ctx = this.droppedFramePatternCanvas.getContext('2d');\n    if (ctx) {\n      // Make a dense solid-line pattern.\n      ctx.translate(size * 0.5, size * 0.5);\n      ctx.rotate(Math.PI * 0.25);\n      ctx.translate(-size * 0.5, -size * 0.5);\n\n      ctx.fillStyle = 'rgb(255, 255, 255)';\n      for (let x = -size; x < size * 2; x += 3) {\n        ctx.fillRect(x, -size, 1, size * 3);\n      }\n    }\n\n    const ctx2 = this.partialFramePatternCanvas.getContext('2d');\n    if (ctx2) {\n      // Make a sparse dashed-line pattern.\n      ctx2.strokeStyle = 'rgb(255, 255, 255)';\n      ctx2.lineWidth = 2;\n      ctx2.beginPath();\n      ctx2.moveTo(17, 0);\n      ctx2.lineTo(10, 7);\n      ctx2.moveTo(8, 9);\n      ctx2.lineTo(2, 15);\n      ctx2.stroke();\n    }\n  }\n\n  private drawFrame(\n      entryIndex: number, context: CanvasRenderingContext2D, text: string|null, barX: number, barY: number,\n      barWidth: number, barHeight: number): void {\n    const hPadding = 1;\n    const frame = (this.entryData[entryIndex] as TimelineModel.TimelineFrameModel.TimelineFrame);\n    barX += hPadding;\n    barWidth -= 2 * hPadding;\n    if (frame.idle) {\n      context.fillStyle = 'white';\n    } else if (frame.dropped) {\n      if (frame.isPartial) {\n        // For partially presented frame boxes, paint a yellow background with\n        // a sparse white dashed-line pattern overlay.\n        context.fillStyle = '#f0e442';\n        context.fillRect(barX, barY, barWidth, barHeight);\n\n        const overlay = context.createPattern(this.partialFramePatternCanvas, 'repeat');\n        context.fillStyle = overlay || context.fillStyle;\n      } else {\n        // For dropped frame boxes, paint a red background with a dense white\n        // solid-line pattern overlay.\n        context.fillStyle = '#f08080';\n        context.fillRect(barX, barY, barWidth, barHeight);\n\n        const overlay = context.createPattern(this.droppedFramePatternCanvas, 'repeat');\n        context.fillStyle = overlay || context.fillStyle;\n      }\n    } else if (frame.hasWarnings()) {\n      context.fillStyle = '#fad1d1';\n    } else {\n      context.fillStyle = '#d7f0d1';\n    }\n    context.fillRect(barX, barY, barWidth, barHeight);\n\n    const frameDurationText = i18n.TimeUtilities.preciseMillisToString(frame.duration, 1);\n    const textWidth = context.measureText(frameDurationText).width;\n    if (textWidth <= barWidth) {\n      context.fillStyle = this.textColor(entryIndex);\n      context.fillText(frameDurationText, barX + (barWidth - textWidth) / 2, barY + barHeight - 4);\n    }\n  }\n\n  private async drawScreenshot(\n      entryIndex: number, context: CanvasRenderingContext2D, barX: number, barY: number, barWidth: number,\n      barHeight: number): Promise<void> {\n    const screenshot = (this.entryData[entryIndex] as SDK.FilmStripModel.Frame);\n    if (!this.screenshotImageCache.has(screenshot)) {\n      this.screenshotImageCache.set(screenshot, null);\n      const data = await screenshot.imageDataPromise();\n      const image = await UI.UIUtils.loadImageFromData(data);\n      this.screenshotImageCache.set(screenshot, image);\n      this.dispatchEventToListeners(Events.DataChanged);\n      return;\n    }\n\n    const image = this.screenshotImageCache.get(screenshot);\n    if (!image) {\n      return;\n    }\n    const imageX = barX + 1;\n    const imageY = barY + 1;\n    const imageHeight = barHeight - 2;\n    const scale = imageHeight / image.naturalHeight;\n    const imageWidth = Math.floor(image.naturalWidth * scale);\n    context.save();\n    context.beginPath();\n    context.rect(barX, barY, barWidth, barHeight);\n    context.clip();\n    context.drawImage(image, imageX, imageY, imageWidth, imageHeight);\n    context.strokeStyle = '#ccc';\n    context.strokeRect(imageX - 0.5, imageY - 0.5, Math.min(barWidth - 1, imageWidth + 1), imageHeight);\n    context.restore();\n  }\n\n  decorateEntry(\n      entryIndex: number, context: CanvasRenderingContext2D, text: string|null, barX: number, barY: number,\n      barWidth: number, barHeight: number, unclippedBarX: number, timeToPixels: number): boolean {\n    const data = this.entryData[entryIndex];\n    const type = this.entryType(entryIndex);\n    const entryTypes = EntryType;\n\n    if (type === entryTypes.Frame) {\n      this.drawFrame(entryIndex, context, text, barX, barY, barWidth, barHeight);\n      return true;\n    }\n\n    if (type === entryTypes.Screenshot) {\n      void this.drawScreenshot(entryIndex, context, barX, barY, barWidth, barHeight);\n      return true;\n    }\n\n    if (type === entryTypes.InteractionRecord) {\n      const color = TimelineUIUtils.interactionPhaseColor((data as TimelineModel.TimelineIRModel.Phases));\n      context.fillStyle = color;\n      context.fillRect(barX, barY, barWidth - 1, 2);\n      context.fillRect(barX, barY - 3, 2, 3);\n      context.fillRect(barX + barWidth - 3, barY - 3, 2, 3);\n      return false;\n    }\n\n    if (type === entryTypes.Event) {\n      const event = (data as SDK.TracingModel.Event);\n      if (event.hasCategory(TimelineModel.TimelineModel.TimelineModelImpl.Category.LatencyInfo)) {\n        const timeWaitingForMainThread =\n            TimelineModel.TimelineModel.TimelineData.forEvent(event).timeWaitingForMainThread;\n        if (timeWaitingForMainThread) {\n          context.fillStyle = 'hsla(0, 70%, 60%, 1)';\n          const width = Math.floor(unclippedBarX - barX + timeWaitingForMainThread * timeToPixels);\n          context.fillRect(barX, barY + barHeight - 3, width, 2);\n        }\n      }\n      if (TimelineModel.TimelineModel.TimelineData.forEvent(event).warning) {\n        paintWarningDecoration(barX, barWidth - 1.5);\n      }\n    }\n\n    function paintWarningDecoration(x: number, width: number): void {\n      const /** @const */ triangleSize = 8;\n      context.save();\n      context.beginPath();\n      context.rect(x, barY, width, barHeight);\n      context.clip();\n      context.beginPath();\n      context.fillStyle = 'red';\n      context.moveTo(x + width - triangleSize, barY);\n      context.lineTo(x + width, barY);\n      context.lineTo(x + width, barY + triangleSize);\n      context.fill();\n      context.restore();\n    }\n\n    return false;\n  }\n\n  forceDecoration(entryIndex: number): boolean {\n    const entryTypes = EntryType;\n    const type = this.entryType(entryIndex);\n    if (type === entryTypes.Frame) {\n      return true;\n    }\n    if (type === entryTypes.Screenshot) {\n      return true;\n    }\n\n    if (type === entryTypes.Event) {\n      const event = (this.entryData[entryIndex] as SDK.TracingModel.Event);\n      return Boolean(TimelineModel.TimelineModel.TimelineData.forEvent(event).warning);\n    }\n    return false;\n  }\n\n  appendExtensionEvents(entry: {\n    title: string,\n    model: SDK.TracingModel.TracingModel,\n  }): void {\n    this.extensionInfo.push(entry);\n    if (this.timelineDataInternal) {\n      this.innerAppendExtensionEvents(this.extensionInfo.length - 1);\n    }\n  }\n\n  private innerAppendExtensionEvents(index: number): void {\n    const entry = this.extensionInfo[index];\n    const entryType = EntryType.ExtensionEvent;\n    const allThreads = [...entry.model.sortedProcesses().map(process => process.sortedThreads())].flat();\n    if (!allThreads.length) {\n      return;\n    }\n\n    const singleTrack =\n        allThreads.length === 1 && (!allThreads[0].events().length || !allThreads[0].asyncEvents().length);\n    if (!singleTrack) {\n      this.appendHeader(entry.title, this.headerLevel1, false /* selectable */);\n    }\n    const style = singleTrack ? this.headerLevel2 : this.headerLevel1;\n    let threadIndex = 0;\n    for (const thread of allThreads) {\n      const title = singleTrack ? entry.title : thread.name() || i18nString(UIStrings.threadS, {PH1: ++threadIndex});\n      this.appendAsyncEventsGroup(null, title, thread.asyncEvents(), style, entryType, false /* selectable */);\n      this.appendSyncEvents(null, thread.events(), title, style, entryType, false /* selectable */);\n    }\n  }\n\n  private appendHeader(title: string, style: PerfUI.FlameChart.GroupStyle, selectable: boolean):\n      PerfUI.FlameChart.Group {\n    const group =\n        ({startLevel: this.currentLevel, name: title, style: style, selectable: selectable} as PerfUI.FlameChart.Group);\n    (this.timelineDataInternal as PerfUI.FlameChart.TimelineData).groups.push(group);\n    return group;\n  }\n\n  private appendEvent(event: SDK.TracingModel.Event, level: number): number {\n    const index = this.entryData.length;\n    this.entryData.push(event);\n    const timelineData = (this.timelineDataInternal as PerfUI.FlameChart.TimelineData);\n    timelineData.entryLevels[index] = level;\n    timelineData.entryTotalTimes[index] = event.duration || InstantEventVisibleDurationMs;\n    timelineData.entryStartTimes[index] = event.startTime;\n    indexForEvent.set(event, index);\n    return index;\n  }\n\n  private appendAsyncEvent(asyncEvent: SDK.TracingModel.AsyncEvent, level: number): void {\n    const steps = asyncEvent.steps;\n    // If we have past steps, put the end event for each range rather than start one.\n    const eventOffset = steps.length > 1 && steps[1].phase === SDK.TracingModel.Phase.AsyncStepPast ? 1 : 0;\n    for (let i = 0; i < steps.length - 1; ++i) {\n      const index = this.entryData.length;\n      this.entryData.push(steps[i + eventOffset]);\n      const startTime = steps[i].startTime;\n      const timelineData = (this.timelineDataInternal as PerfUI.FlameChart.TimelineData);\n      timelineData.entryLevels[index] = level;\n      timelineData.entryTotalTimes[index] = steps[i + 1].startTime - startTime;\n      timelineData.entryStartTimes[index] = startTime;\n    }\n  }\n\n  private appendFrame(frame: TimelineModel.TimelineFrameModel.TimelineFrame): void {\n    const index = this.entryData.length;\n    this.entryData.push(frame);\n    this.entryIndexToTitle[index] = i18n.TimeUtilities.millisToString(frame.duration, true);\n    if (!this.timelineDataInternal) {\n      return;\n    }\n    this.timelineDataInternal.entryLevels[index] = this.currentLevel;\n    this.timelineDataInternal.entryTotalTimes[index] = frame.duration;\n    this.timelineDataInternal.entryStartTimes[index] = frame.startTime;\n  }\n\n  createSelection(entryIndex: number): TimelineSelection|null {\n    const type = this.entryType(entryIndex);\n    let timelineSelection: TimelineSelection|null = null;\n    if (type === EntryType.Event) {\n      timelineSelection = TimelineSelection.fromTraceEvent((this.entryData[entryIndex] as SDK.TracingModel.Event));\n    } else if (type === EntryType.Frame) {\n      timelineSelection =\n          TimelineSelection.fromFrame((this.entryData[entryIndex] as TimelineModel.TimelineFrameModel.TimelineFrame));\n    }\n    if (timelineSelection) {\n      this.lastSelection = new Selection(timelineSelection, entryIndex);\n    }\n    return timelineSelection;\n  }\n\n  formatValue(value: number, precision?: number): string {\n    return i18n.TimeUtilities.preciseMillisToString(value, precision);\n  }\n\n  canJumpToEntry(_entryIndex: number): boolean {\n    return false;\n  }\n\n  entryIndexForSelection(selection: TimelineSelection|null): number {\n    if (!selection || selection.type() === TimelineSelection.Type.Range) {\n      return -1;\n    }\n\n    if (this.lastSelection && this.lastSelection.timelineSelection.object() === selection.object()) {\n      return this.lastSelection.entryIndex;\n    }\n    const index = this.entryData.indexOf(\n        (selection.object() as SDK.TracingModel.Event | TimelineModel.TimelineIRModel.Phases |\n         TimelineModel.TimelineFrameModel.TimelineFrame));\n    if (index !== -1) {\n      this.lastSelection = new Selection(selection, index);\n    }\n    return index;\n  }\n\n  buildFlowForInitiator(entryIndex: number): boolean {\n    if (this.lastInitiatorEntry === entryIndex) {\n      return false;\n    }\n    this.lastInitiatorEntry = entryIndex;\n    let event = this.eventByIndex(entryIndex);\n    const td = this.timelineDataInternal;\n    if (!td) {\n      return false;\n    }\n    td.flowStartTimes = [];\n    td.flowStartLevels = [];\n    td.flowEndTimes = [];\n    td.flowEndLevels = [];\n    while (event) {\n      // Find the closest ancestor with an initiator.\n      let initiator;\n      for (; event; event = this.eventParent(event)) {\n        initiator = TimelineModel.TimelineModel.TimelineData.forEvent(event).initiator();\n        if (initiator) {\n          break;\n        }\n      }\n      if (!initiator || !event) {\n        break;\n      }\n      const eventIndex = (indexForEvent.get(event) as number);\n      const initiatorIndex = (indexForEvent.get(initiator) as number);\n      td.flowStartTimes.push(initiator.endTime || initiator.startTime);\n      td.flowStartLevels.push(td.entryLevels[initiatorIndex]);\n      td.flowEndTimes.push(event.startTime);\n      td.flowEndLevels.push(td.entryLevels[eventIndex]);\n      event = initiator;\n    }\n    return true;\n  }\n\n  private eventParent(event: SDK.TracingModel.Event): SDK.TracingModel.Event|null {\n    const eventIndex = indexForEvent.get(event);\n    if (eventIndex === undefined) {\n      return null;\n    }\n    return this.entryParent[eventIndex] || null;\n  }\n\n  eventByIndex(entryIndex: number): SDK.TracingModel.Event|null {\n    return entryIndex >= 0 && this.entryType(entryIndex) === EntryType.Event ?\n        this.entryData[entryIndex] as SDK.TracingModel.Event :\n        null;\n  }\n\n  entryDataByIndex(entryIndex: number): TimelineFlameChartEntry {\n    return this.entryData[entryIndex];\n  }\n\n  setEventColorMapping(colorForEvent: (arg0: SDK.TracingModel.Event) => string): void {\n    this.colorForEvent = colorForEvent;\n  }\n}\n\nexport const InstantEventVisibleDurationMs = 0.001;\n\nconst eventToDisallowRoot = new WeakMap<SDK.TracingModel.Event, boolean>();\nconst indexForEvent = new WeakMap<SDK.TracingModel.Event, number>();\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  DataChanged = 'DataChanged',\n}\n\nexport type EventTypes = {\n  [Events.DataChanged]: void,\n};\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum EntryType {\n  Frame = 'Frame',\n  Event = 'Event',\n  InteractionRecord = 'InteractionRecord',\n  ExtensionEvent = 'ExtensionEvent',\n  Screenshot = 'Screenshot',\n}\n"],
  "mappings": "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",
  "names": []
}
