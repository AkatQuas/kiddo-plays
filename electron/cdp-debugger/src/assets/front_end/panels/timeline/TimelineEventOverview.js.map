{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/timeline/TimelineEventOverview.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as TimelineModel from '../../models/timeline_model/timeline_model.js';\nimport * as PerfUI from '../../ui/legacy/components/perf_ui/perf_ui.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as Coverage from '../coverage/coverage.js';\nimport * as Protocol from '../../generated/protocol.js';\n\nimport type {PerformanceModel} from './PerformanceModel.js';\nimport type {EventDispatchTypeDescriptor, TimelineCategory} from './TimelineUIUtils.js';\nimport {TimelineUIUtils} from './TimelineUIUtils.js';\n\nconst UIStrings = {\n  /**\n  *@description Short for Network. Label for the network requests section of the Performance panel.\n  */\n  net: 'NET',\n  /**\n  *@description Text in Timeline Event Overview of the Performance panel\n  */\n  cpu: 'CPU',\n  /**\n  *@description Text in Timeline Event Overview of the Performance panel\n  */\n  heap: 'HEAP',\n  /**\n  *@description Heap size label text content in Timeline Event Overview of the Performance panel\n  *@example {10 MB} PH1\n  *@example {30 MB} PH2\n  */\n  sSDash: '{PH1} \u2013 {PH2}',\n  /**\n  *@description Text in Timeline Event Overview of the Performance panel\n  */\n  coverage: 'COVERAGE',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/timeline/TimelineEventOverview.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class TimelineEventOverview extends PerfUI.TimelineOverviewPane.TimelineOverviewBase {\n  protected model: PerformanceModel|null;\n  constructor(id: string, title: string|null) {\n    super();\n    this.element.id = 'timeline-overview-' + id;\n    this.element.classList.add('overview-strip');\n    this.model = null;\n    if (title) {\n      this.element.createChild('div', 'timeline-overview-strip-title').textContent = title;\n    }\n  }\n\n  setModel(model: PerformanceModel|null): void {\n    this.model = model;\n  }\n\n  renderBar(begin: number, end: number, position: number, height: number, color: string): void {\n    const x = begin;\n    const width = end - begin;\n    const ctx = this.context();\n    ctx.fillStyle = color;\n    ctx.fillRect(x, position, width, height);\n  }\n}\n\nexport class TimelineEventOverviewInput extends TimelineEventOverview {\n  constructor() {\n    super('input', null);\n  }\n\n  update(): void {\n    super.update();\n    if (!this.model) {\n      return;\n    }\n    const height = this.height();\n    const descriptors = TimelineUIUtils.eventDispatchDesciptors();\n    const descriptorsByType = new Map<string, EventDispatchTypeDescriptor>();\n    let maxPriority = -1;\n    for (const descriptor of descriptors) {\n      for (const type of descriptor.eventTypes) {\n        descriptorsByType.set(type, descriptor);\n      }\n      maxPriority = Math.max(maxPriority, descriptor.priority);\n    }\n\n    const minWidth = 2 * window.devicePixelRatio;\n    const timeOffset = this.model.timelineModel().minimumRecordTime();\n    const timeSpan = this.model.timelineModel().maximumRecordTime() - timeOffset;\n    const canvasWidth = this.width();\n    const scale = canvasWidth / timeSpan;\n\n    for (let priority = 0; priority <= maxPriority; ++priority) {\n      for (const track of this.model.timelineModel().tracks()) {\n        for (let i = 0; i < track.events.length; ++i) {\n          const event = track.events[i];\n          if (event.name !== TimelineModel.TimelineModel.RecordType.EventDispatch) {\n            continue;\n          }\n          const descriptor = descriptorsByType.get(event.args['data']['type']);\n          if (!descriptor || descriptor.priority !== priority) {\n            continue;\n          }\n          if (event.endTime === undefined) {\n            continue;\n          }\n          const start =\n              Platform.NumberUtilities.clamp(Math.floor((event.startTime - timeOffset) * scale), 0, canvasWidth);\n          const end = Platform.NumberUtilities.clamp(Math.ceil((event.endTime - timeOffset) * scale), 0, canvasWidth);\n          const width = Math.max(end - start, minWidth);\n          this.renderBar(start, start + width, 0, height, descriptor.color);\n        }\n      }\n    }\n  }\n}\n\nexport class TimelineEventOverviewNetwork extends TimelineEventOverview {\n  constructor() {\n    super('network', i18nString(UIStrings.net));\n  }\n\n  update(): void {\n    super.update();\n    if (!this.model) {\n      return;\n    }\n    const timelineModel = this.model.timelineModel();\n    const bandHeight = this.height() / 2;\n    const timeOffset = timelineModel.minimumRecordTime();\n    const timeSpan = timelineModel.maximumRecordTime() - timeOffset;\n    const canvasWidth = this.width();\n    const scale = canvasWidth / timeSpan;\n    const highPath = new Path2D();\n    const lowPath = new Path2D();\n    const highPrioritySet = new Set([\n      Protocol.Network.ResourcePriority.VeryHigh,\n      Protocol.Network.ResourcePriority.High,\n      Protocol.Network.ResourcePriority.Medium,\n    ]);\n    for (const request of timelineModel.networkRequests()) {\n      const path = highPrioritySet.has(request.priority) ? highPath : lowPath;\n      const s = Math.max(Math.floor((request.startTime - timeOffset) * scale), 0);\n      const e = Math.min(Math.ceil((request.endTime - timeOffset) * scale + 1), canvasWidth);\n      path.rect(s, 0, e - s, bandHeight - 1);\n    }\n    const ctx = this.context();\n    ctx.save();\n    ctx.fillStyle = 'hsl(214, 60%, 60%)';\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ctx.fill((highPath as any));\n    ctx.translate(0, bandHeight);\n    ctx.fillStyle = 'hsl(214, 80%, 80%)';\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ctx.fill((lowPath as any));\n    ctx.restore();\n  }\n}\n\nconst categoryToIndex = new WeakMap<TimelineCategory, number>();\n\nexport class TimelineEventOverviewCPUActivity extends TimelineEventOverview {\n  private backgroundCanvas: HTMLCanvasElement;\n  constructor() {\n    super('cpu-activity', i18nString(UIStrings.cpu));\n    this.backgroundCanvas = (this.element.createChild('canvas', 'fill background') as HTMLCanvasElement);\n  }\n\n  resetCanvas(): void {\n    super.resetCanvas();\n    this.backgroundCanvas.width = this.element.clientWidth * window.devicePixelRatio;\n    this.backgroundCanvas.height = this.element.clientHeight * window.devicePixelRatio;\n  }\n\n  update(): void {\n    super.update();\n    if (!this.model) {\n      return;\n    }\n    const timelineModel = this.model.timelineModel();\n    const quantSizePx = 4 * window.devicePixelRatio;\n    const width = this.width();\n    const height = this.height();\n    const baseLine = height;\n    const timeOffset = timelineModel.minimumRecordTime();\n    const timeSpan = timelineModel.maximumRecordTime() - timeOffset;\n    const scale = width / timeSpan;\n    const quantTime = quantSizePx / scale;\n    const categories = TimelineUIUtils.categories();\n    const categoryOrder = TimelineUIUtils.getTimelineMainEventCategories();\n    const otherIndex = categoryOrder.indexOf('other');\n    const idleIndex = 0;\n    console.assert(idleIndex === categoryOrder.indexOf('idle'));\n    for (let i = idleIndex + 1; i < categoryOrder.length; ++i) {\n      categoryToIndex.set(categories[categoryOrder[i]], i);\n    }\n\n    const backgroundContext = (this.backgroundCanvas.getContext('2d') as CanvasRenderingContext2D | null);\n    if (!backgroundContext) {\n      throw new Error('Could not find 2d canvas');\n    }\n    for (const track of timelineModel.tracks()) {\n      if (track.type === TimelineModel.TimelineModel.TrackType.MainThread && track.forMainFrame) {\n        drawThreadEvents(this.context(), track.events);\n      } else {\n        drawThreadEvents(backgroundContext, track.events);\n      }\n    }\n    applyPattern(backgroundContext);\n\n    function drawThreadEvents(ctx: CanvasRenderingContext2D, events: SDK.TracingModel.Event[]): void {\n      const quantizer = new Quantizer(timeOffset, quantTime, drawSample);\n      let x = 0;\n      const categoryIndexStack: number[] = [];\n      const paths: Path2D[] = [];\n      const lastY: number[] = [];\n      for (let i = 0; i < categoryOrder.length; ++i) {\n        paths[i] = new Path2D();\n        paths[i].moveTo(0, height);\n        lastY[i] = height;\n      }\n\n      function drawSample(counters: number[]): void {\n        let y = baseLine;\n        for (let i = idleIndex + 1; i < categoryOrder.length; ++i) {\n          const h = (counters[i] || 0) / quantTime * height;\n          y -= h;\n          paths[i].bezierCurveTo(x, lastY[i], x, y, x + quantSizePx / 2, y);\n          lastY[i] = y;\n        }\n        x += quantSizePx;\n      }\n\n      function onEventStart(e: SDK.TracingModel.Event): void {\n        const index = categoryIndexStack.length ? categoryIndexStack[categoryIndexStack.length - 1] : idleIndex;\n        quantizer.appendInterval(e.startTime, (index as number));\n        categoryIndexStack.push(categoryToIndex.get(TimelineUIUtils.eventStyle(e).category) || otherIndex);\n      }\n\n      function onEventEnd(e: SDK.TracingModel.Event): void {\n        const lastCategoryIndex = categoryIndexStack.pop();\n        if (e.endTime !== undefined && lastCategoryIndex) {\n          quantizer.appendInterval(e.endTime, lastCategoryIndex);\n        }\n      }\n\n      TimelineModel.TimelineModel.TimelineModelImpl.forEachEvent(events, onEventStart, onEventEnd);\n      quantizer.appendInterval(timeOffset + timeSpan + quantTime, idleIndex);  // Kick drawing the last bucket.\n      for (let i = categoryOrder.length - 1; i > 0; --i) {\n        paths[i].lineTo(width, height);\n        ctx.fillStyle = categories[categoryOrder[i]].color;\n        ctx.fill(paths[i]);\n      }\n    }\n\n    function applyPattern(ctx: CanvasRenderingContext2D): void {\n      const step = 4 * window.devicePixelRatio;\n      ctx.save();\n      ctx.lineWidth = step / Math.sqrt(8);\n      for (let x = 0.5; x < width + height; x += step) {\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x - height, height);\n      }\n      ctx.globalCompositeOperation = 'destination-out';\n      ctx.stroke();\n      ctx.restore();\n    }\n  }\n}\n\nexport class TimelineEventOverviewResponsiveness extends TimelineEventOverview {\n  constructor() {\n    super('responsiveness', null);\n  }\n\n  update(): void {\n    super.update();\n    if (!this.model) {\n      return;\n    }\n    const height = this.height();\n\n    const timeOffset = this.model.timelineModel().minimumRecordTime();\n    const timeSpan = this.model.timelineModel().maximumRecordTime() - timeOffset;\n    const scale = this.width() / timeSpan;\n    const frames = this.model.frames();\n    const ctx = this.context();\n    const fillPath = new Path2D();\n    const markersPath = new Path2D();\n    for (let i = 0; i < frames.length; ++i) {\n      const frame = frames[i];\n      if (!frame.hasWarnings()) {\n        continue;\n      }\n      paintWarningDecoration(frame.startTime, frame.duration);\n    }\n\n    for (const track of this.model.timelineModel().tracks()) {\n      const events = track.events;\n      for (let i = 0; i < events.length; ++i) {\n        if (!TimelineModel.TimelineModel.TimelineData.forEvent(events[i]).warning) {\n          continue;\n        }\n        const duration = events[i].duration;\n        if (duration !== undefined) {\n          paintWarningDecoration(events[i].startTime, duration);\n        }\n      }\n    }\n\n    ctx.fillStyle = 'hsl(0, 80%, 90%)';\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 2 * window.devicePixelRatio;\n    ctx.fill(fillPath);\n    ctx.stroke(markersPath);\n\n    function paintWarningDecoration(time: number, duration: number): void {\n      const x = Math.round(scale * (time - timeOffset));\n      const w = Math.round(scale * duration);\n      fillPath.rect(x, 0, w, height);\n      markersPath.moveTo(x + w, 0);\n      markersPath.lineTo(x + w, height);\n    }\n  }\n}\n\nexport class TimelineFilmStripOverview extends TimelineEventOverview {\n  private frameToImagePromise: Map<SDK.FilmStripModel.Frame, Promise<HTMLImageElement>>;\n  private lastFrame: SDK.FilmStripModel.Frame|null;\n  private lastElement: Element|null;\n  private drawGeneration?: symbol;\n  private emptyImage?: HTMLImageElement;\n  private imageWidth?: number;\n\n  constructor() {\n    super('filmstrip', null);\n    this.frameToImagePromise = new Map();\n    this.lastFrame = null;\n    this.lastElement = null;\n    this.reset();\n  }\n\n  update(): void {\n    super.update();\n    const frames = this.model ? this.model.filmStripModel().frames() : [];\n    if (!frames.length) {\n      return;\n    }\n\n    const drawGeneration = Symbol('drawGeneration');\n    this.drawGeneration = drawGeneration;\n    void this.imageByFrame(frames[0]).then(image => {\n      if (this.drawGeneration !== drawGeneration) {\n        return;\n      }\n      if (!image || !image.naturalWidth || !image.naturalHeight) {\n        return;\n      }\n      const imageHeight = this.height() - 2 * TimelineFilmStripOverview.Padding;\n      const imageWidth = Math.ceil(imageHeight * image.naturalWidth / image.naturalHeight);\n      const popoverScale = Math.min(200 / image.naturalWidth, 1);\n      this.emptyImage = new Image(image.naturalWidth * popoverScale, image.naturalHeight * popoverScale);\n      this.drawFrames(imageWidth, imageHeight);\n    });\n  }\n\n  private async imageByFrame(frame: SDK.FilmStripModel.Frame): Promise<HTMLImageElement|null> {\n    let imagePromise: Promise<HTMLImageElement|null>|undefined = this.frameToImagePromise.get(frame);\n    if (!imagePromise) {\n      const data = await frame.imageDataPromise();\n      imagePromise = UI.UIUtils.loadImageFromData(data);\n      this.frameToImagePromise.set(frame, (imagePromise as Promise<HTMLImageElement>));\n    }\n    return imagePromise;\n  }\n\n  private drawFrames(imageWidth: number, imageHeight: number): void {\n    if (!imageWidth || !this.model) {\n      return;\n    }\n    const filmStripModel = this.model.filmStripModel();\n    if (!filmStripModel.frames().length) {\n      return;\n    }\n    const padding = TimelineFilmStripOverview.Padding;\n    const width = this.width();\n    const zeroTime = filmStripModel.zeroTime();\n    const spanTime = filmStripModel.spanTime();\n    const scale = spanTime / width;\n    const context = this.context();\n    const drawGeneration = this.drawGeneration;\n\n    context.beginPath();\n    for (let x = padding; x < width; x += imageWidth + 2 * padding) {\n      const time = zeroTime + (x + imageWidth / 2) * scale;\n      const frame = filmStripModel.frameByTimestamp(time);\n      if (!frame) {\n        continue;\n      }\n      context.rect(x - 0.5, 0.5, imageWidth + 1, imageHeight + 1);\n      void this.imageByFrame(frame).then(drawFrameImage.bind(this, x));\n    }\n    context.strokeStyle = '#ddd';\n    context.stroke();\n\n    function drawFrameImage(this: TimelineFilmStripOverview, x: number, image: HTMLImageElement|null): void {\n      // Ignore draws deferred from a previous update call.\n      if (this.drawGeneration !== drawGeneration || !image) {\n        return;\n      }\n      context.drawImage(image, x, 1, imageWidth, imageHeight);\n    }\n  }\n\n  async overviewInfoPromise(x: number): Promise<Element|null> {\n    if (!this.model || !this.model.filmStripModel().frames().length) {\n      return null;\n    }\n\n    const calculator = this.calculator();\n    if (!calculator) {\n      return null;\n    }\n    const time = calculator.positionToTime(x);\n    const frame = this.model.filmStripModel().frameByTimestamp(time);\n    if (frame === this.lastFrame) {\n      return this.lastElement;\n    }\n    const imagePromise = frame ? this.imageByFrame(frame) : Promise.resolve(this.emptyImage);\n    const image = await imagePromise;\n    const element = document.createElement('div');\n    element.classList.add('frame');\n    if (image) {\n      element.createChild('div', 'thumbnail').appendChild(image);\n    }\n    this.lastFrame = frame;\n    this.lastElement = element;\n    return element;\n  }\n\n  reset(): void {\n    this.lastFrame = null;\n    this.lastElement = null;\n    this.frameToImagePromise = new Map();\n    this.imageWidth = 0;\n  }\n\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static readonly Padding = 2;\n}\n\nexport class TimelineEventOverviewMemory extends TimelineEventOverview {\n  private heapSizeLabel: HTMLElement;\n  constructor() {\n    super('memory', i18nString(UIStrings.heap));\n    this.heapSizeLabel = this.element.createChild('div', 'memory-graph-label');\n  }\n\n  resetHeapSizeLabels(): void {\n    this.heapSizeLabel.textContent = '';\n  }\n\n  update(): void {\n    super.update();\n    const ratio = window.devicePixelRatio;\n\n    if (!this.model) {\n      this.resetHeapSizeLabels();\n      return;\n    }\n\n    const tracks = this.model.timelineModel().tracks().filter(\n        track => track.type === TimelineModel.TimelineModel.TrackType.MainThread && track.forMainFrame);\n    const trackEvents = tracks.map(track => track.events);\n\n    const lowerOffset = 3 * ratio;\n    let maxUsedHeapSize = 0;\n    let minUsedHeapSize = 100000000000;\n    const minTime = this.model.timelineModel().minimumRecordTime();\n    const maxTime = this.model.timelineModel().maximumRecordTime();\n\n    function isUpdateCountersEvent(event: SDK.TracingModel.Event): boolean {\n      return event.name === TimelineModel.TimelineModel.RecordType.UpdateCounters;\n    }\n    for (let i = 0; i < trackEvents.length; i++) {\n      trackEvents[i] = trackEvents[i].filter(isUpdateCountersEvent);\n    }\n\n    function calculateMinMaxSizes(event: SDK.TracingModel.Event): void {\n      const counters = event.args.data;\n      if (!counters || !counters.jsHeapSizeUsed) {\n        return;\n      }\n      maxUsedHeapSize = Math.max(maxUsedHeapSize, counters.jsHeapSizeUsed);\n      minUsedHeapSize = Math.min(minUsedHeapSize, counters.jsHeapSizeUsed);\n    }\n    for (let i = 0; i < trackEvents.length; i++) {\n      trackEvents[i].forEach(calculateMinMaxSizes);\n    }\n    minUsedHeapSize = Math.min(minUsedHeapSize, maxUsedHeapSize);\n\n    const lineWidth = 1;\n    const width = this.width();\n    const height = this.height() - lowerOffset;\n    const xFactor = width / (maxTime - minTime);\n    const yFactor = (height - lineWidth) / Math.max(maxUsedHeapSize - minUsedHeapSize, 1);\n\n    const histogram = new Array(width);\n\n    function buildHistogram(event: SDK.TracingModel.Event): void {\n      const counters = event.args.data;\n      if (!counters || !counters.jsHeapSizeUsed) {\n        return;\n      }\n      const x = Math.round((event.startTime - minTime) * xFactor);\n      const y = Math.round((counters.jsHeapSizeUsed - minUsedHeapSize) * yFactor);\n      // TODO(alph): use sum instead of max.\n      histogram[x] = Math.max(histogram[x] || 0, y);\n    }\n    for (let i = 0; i < trackEvents.length; i++) {\n      trackEvents[i].forEach(buildHistogram);\n    }\n\n    const ctx = this.context();\n    const heightBeyondView = height + lowerOffset + lineWidth;\n\n    ctx.translate(0.5, 0.5);\n    ctx.beginPath();\n    ctx.moveTo(-lineWidth, heightBeyondView);\n    let y = 0;\n    let isFirstPoint = true;\n    let lastX = 0;\n    for (let x = 0; x < histogram.length; x++) {\n      if (typeof histogram[x] === 'undefined') {\n        continue;\n      }\n      if (isFirstPoint) {\n        isFirstPoint = false;\n        y = histogram[x];\n        ctx.lineTo(-lineWidth, height - y);\n      }\n      const nextY = histogram[x];\n      if (Math.abs(nextY - y) > 2 && Math.abs(x - lastX) > 1) {\n        ctx.lineTo(x, height - y);\n      }\n      y = nextY;\n      ctx.lineTo(x, height - y);\n      lastX = x;\n    }\n    ctx.lineTo(width + lineWidth, height - y);\n    ctx.lineTo(width + lineWidth, heightBeyondView);\n    ctx.closePath();\n\n    ctx.fillStyle = 'hsla(220, 90%, 70%, 0.2)';\n    ctx.fill();\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = 'hsl(220, 90%, 70%)';\n    ctx.stroke();\n\n    this.heapSizeLabel.textContent = i18nString(UIStrings.sSDash, {\n      PH1: Platform.NumberUtilities.bytesToString(minUsedHeapSize),\n      PH2: Platform.NumberUtilities.bytesToString(maxUsedHeapSize),\n    });\n  }\n}\n\nexport class Quantizer {\n  private lastTime: number;\n  private quantDuration: number;\n  private readonly callback: (arg0: Array<number>) => void;\n  private counters: number[];\n  private remainder: number;\n  constructor(startTime: number, quantDuration: number, callback: (arg0: Array<number>) => void) {\n    this.lastTime = startTime;\n    this.quantDuration = quantDuration;\n    this.callback = callback;\n    this.counters = [];\n    this.remainder = quantDuration;\n  }\n\n  appendInterval(time: number, group: number): void {\n    let interval = time - this.lastTime;\n    if (interval <= this.remainder) {\n      this.counters[group] = (this.counters[group] || 0) + interval;\n      this.remainder -= interval;\n      this.lastTime = time;\n      return;\n    }\n    this.counters[group] = (this.counters[group] || 0) + this.remainder;\n    this.callback(this.counters);\n    interval -= this.remainder;\n    while (interval >= this.quantDuration) {\n      const counters = [];\n      counters[group] = this.quantDuration;\n      this.callback(counters);\n      interval -= this.quantDuration;\n    }\n    this.counters = [];\n    this.counters[group] = interval;\n    this.lastTime = time;\n    this.remainder = this.quantDuration - interval;\n  }\n}\n\nexport class TimelineEventOverviewCoverage extends TimelineEventOverview {\n  private heapSizeLabel: HTMLElement;\n  private coverageModel?: Coverage.CoverageModel.CoverageModel|null;\n  constructor() {\n    super('coverage', i18nString(UIStrings.coverage));\n    this.heapSizeLabel = this.element.createChild('div', 'timeline-overview-coverage-label');\n  }\n\n  resetHeapSizeLabels(): void {\n    this.heapSizeLabel.textContent = '';\n  }\n\n  setModel(model: PerformanceModel|null): void {\n    super.setModel(model);\n    if (model) {\n      const mainTarget = model.mainTarget();\n      if (mainTarget) {\n        this.coverageModel = mainTarget.model(Coverage.CoverageModel.CoverageModel);\n      }\n    }\n  }\n\n  update(): void {\n    super.update();\n    const ratio = window.devicePixelRatio;\n\n    if (!this.coverageModel) {\n      return;\n    }\n\n    let total = 0;\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    let total_used = 0;\n    const usedByTimestamp = new Map<number, number>();\n    const totalByTimestamp = new Map<number, Set<Coverage.CoverageModel.CoverageInfo>>();\n    for (const urlInfo of this.coverageModel.entries()) {\n      for (const info of urlInfo.entries()) {\n        total += info.getSize();\n        for (const [stamp, used] of info.usedByTimestamp()) {\n          total_used += used;\n\n          let uniqueTimestamps = totalByTimestamp.get(stamp);\n\n          if (uniqueTimestamps === undefined) {\n            uniqueTimestamps = new Set();\n            totalByTimestamp.set(stamp, uniqueTimestamps);\n          }\n          uniqueTimestamps.add(info);\n\n          const previousCount = usedByTimestamp.get(stamp);\n\n          if (previousCount === undefined) {\n            usedByTimestamp.set(stamp, used);\n          } else {\n            usedByTimestamp.set(stamp, previousCount + used);\n          }\n        }\n      }\n    }\n\n    const seen = new Set<Coverage.CoverageModel.CoverageInfo>();\n    const coverageByTimestamp = new Map<number, number>();\n    let sumTotal = 0, sumUsed = 0;\n\n    const sortedByTimestamp = Array.from(totalByTimestamp.entries()).sort((a, b) => a[0] - b[0]);\n    for (const [stamp, infos] of sortedByTimestamp) {\n      for (const info of infos.values()) {\n        if (seen.has(info)) {\n          continue;\n        }\n\n        seen.add(info);\n        sumTotal += info.getSize();\n      }\n      sumUsed += usedByTimestamp.get(stamp) || 0;\n      coverageByTimestamp.set(stamp, sumUsed / sumTotal);\n    }\n\n    const percentUsed = total ? Math.round(100 * total_used / total) : 0;\n    const lowerOffset = 3 * ratio;\n\n    const millisecondsPerSecond = 1000;\n    if (!this.model) {\n      return;\n    }\n    const minTime = this.model.timelineModel().minimumRecordTime() / millisecondsPerSecond;\n    const maxTime = this.model.timelineModel().maximumRecordTime() / millisecondsPerSecond;\n\n    const lineWidth = 1;\n    const width = this.width();\n    const height = this.height() - lowerOffset;\n    const xFactor = width / (maxTime - minTime);\n    const yFactor = height - lineWidth;\n\n    let yOffset = 0;\n    const ctx = this.context();\n    const heightBeyondView = height + lowerOffset + lineWidth;\n    ctx.translate(0.5, 0.5);\n    ctx.beginPath();\n    ctx.moveTo(-lineWidth, heightBeyondView);\n\n    ctx.lineTo(-lineWidth, height - yOffset);\n\n    let previous: (number|null)|null = null;\n    for (const stamp of this.coverageModel.getCoverageUpdateTimes()) {\n      const coverage: number|null = coverageByTimestamp.get(stamp) || previous;\n      previous = coverage;\n      if (!coverage) {\n        continue;\n      }\n      if (stamp > maxTime) {\n        break;\n      }\n      const x = (stamp - minTime) * xFactor;\n      yOffset = coverage * yFactor;\n      ctx.lineTo(x, height - yOffset);\n    }\n\n    const white = 'hsl(0, 100%, 100%)';\n    const blue = 'hsl(220, 90%, 70%)';\n    const transparentBlue = 'hsla(220, 90%, 70%, 0.2)';\n\n    ctx.lineTo(width + lineWidth, height - yOffset);\n    ctx.lineTo(width + lineWidth, heightBeyondView);\n    ctx.closePath();\n    ctx.fillStyle = transparentBlue;\n    ctx.fill();\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = blue;\n    ctx.stroke();\n\n    previous = null;\n    for (const stamp of this.coverageModel.getCoverageUpdateTimes()) {\n      const coverage: number|null = coverageByTimestamp.get(stamp) || previous;\n      previous = coverage;\n      if (!coverage) {\n        continue;\n      }\n      ctx.beginPath();\n      const x = (stamp - minTime) * xFactor;\n      const y = height - coverage * yFactor;\n      ctx.arc(x, y, 2 * lineWidth, 0, 2 * Math.PI, false);\n      ctx.closePath();\n      ctx.stroke();\n      ctx.fillStyle = coverageByTimestamp.has(stamp) ? blue : white;\n      ctx.fill();\n    }\n\n    this.heapSizeLabel.textContent = `${percentUsed}% used`;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
