{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/elements/StyleEditorWidget.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as IconButton from '../../ui/components/icon_button/icon_button.js';\nimport * as UI from '../../ui/legacy/legacy.js';\nimport type * as ElementsComponents from './components/components.js';\n\nimport type {StylePropertiesSection} from './StylePropertiesSection.js';\nimport {StylePropertyTreeElement} from './StylePropertyTreeElement.js';\nimport type {StylesSidebarPane} from './StylesSidebarPane.js';\n\ntype PropertySelectedEvent = ElementsComponents.StylePropertyEditor.PropertySelectedEvent;\ntype PropertyDeselectedEvent = ElementsComponents.StylePropertyEditor.PropertyDeselectedEvent;\n\nlet instance: StyleEditorWidget|null = null;\ninterface Editor extends HTMLElement {\n  data: {\n    authoredProperties: Map<String, String>,\n    computedProperties: Map<String, String>,\n  };\n  getEditableProperties(): Array<{propertyName: string}>;\n}\n\n/**\n * Thin UI.Widget wrapper around style editors to allow using it as a popover.\n */\nexport class StyleEditorWidget extends UI.Widget.VBox {\n  private editor?: Editor;\n  private pane?: StylesSidebarPane;\n  private section?: StylePropertiesSection;\n  private editorContainer: HTMLElement;\n\n  #triggerKey: string|undefined;\n\n  constructor() {\n    super(true);\n    this.contentElement.tabIndex = 0;\n    this.setDefaultFocusedElement(this.contentElement);\n    this.editorContainer = document.createElement('div');\n    this.contentElement.appendChild(this.editorContainer);\n    this.onPropertySelected = this.onPropertySelected.bind(this);\n    this.onPropertyDeselected = this.onPropertyDeselected.bind(this);\n  }\n\n  getSection(): StylePropertiesSection|undefined {\n    return this.section;\n  }\n\n  async onPropertySelected(event: PropertySelectedEvent): Promise<void> {\n    if (!this.section) {\n      return;\n    }\n    const target = ensureTreeElementForProperty(this.section, event.data.name);\n    target.property.value = event.data.value;\n    target.updateTitle();\n    await target.applyStyleText(target.renderedPropertyText(), false);\n    await this.render();\n  }\n\n  async onPropertyDeselected(event: PropertyDeselectedEvent): Promise<void> {\n    if (!this.section) {\n      return;\n    }\n    const target = ensureTreeElementForProperty(this.section, event.data.name);\n    await target.applyStyleText('', false);\n    await this.render();\n  }\n\n  bindContext(pane: StylesSidebarPane, section: StylePropertiesSection): void {\n    this.pane = pane;\n    this.section = section;\n    this.editor?.addEventListener('propertyselected', this.onPropertySelected);\n    this.editor?.addEventListener('propertydeselected', this.onPropertyDeselected);\n  }\n\n  setTriggerKey(value: string): void {\n    this.#triggerKey = value;\n  }\n\n  getTriggerKey(): string|undefined {\n    return this.#triggerKey;\n  }\n\n  unbindContext(): void {\n    this.pane = undefined;\n    this.section = undefined;\n    this.editor?.removeEventListener('propertyselected', this.onPropertySelected);\n    this.editor?.removeEventListener('propertydeselected', this.onPropertyDeselected);\n  }\n\n  async render(): Promise<void> {\n    if (!this.editor) {\n      return;\n    }\n    this.editor.data = {\n      authoredProperties: this.section ? getAuthoredStyles(this.section, this.editor.getEditableProperties()) :\n                                         new Map(),\n      computedProperties: this.pane ? await fetchComputedStyles(this.pane) : new Map(),\n    };\n  }\n\n  static instance(): StyleEditorWidget {\n    if (!instance) {\n      instance = new StyleEditorWidget();\n    }\n    return instance;\n  }\n\n  setEditor(editorClass: {new(): Editor}): void {\n    if (!(this.editor instanceof editorClass)) {\n      this.contentElement.removeChildren();\n      this.editor = new editorClass();\n      this.contentElement.appendChild(this.editor);\n    }\n  }\n\n  static createTriggerButton(\n      pane: StylesSidebarPane, section: StylePropertiesSection, editorClass: {new(): Editor}, buttonTitle: string,\n      triggerKey: string): HTMLElement {\n    const triggerButton = createButton(buttonTitle);\n\n    triggerButton.onclick = async(event): Promise<void> => {\n      event.stopPropagation();\n      const popoverHelper = pane.swatchPopoverHelper();\n      const widget = StyleEditorWidget.instance();\n      widget.setEditor(editorClass);\n      widget.bindContext(pane, section);\n      widget.setTriggerKey(triggerKey);\n      await widget.render();\n      const scrollerElement = triggerButton.enclosingNodeOrSelfWithClass('style-panes-wrapper');\n      const onScroll = (): void => {\n        popoverHelper.hide(true);\n      };\n      popoverHelper.show(widget, triggerButton, () => {\n        widget.unbindContext();\n        if (scrollerElement) {\n          scrollerElement.removeEventListener('scroll', onScroll);\n        }\n      });\n      if (scrollerElement) {\n        scrollerElement.addEventListener('scroll', onScroll);\n      }\n    };\n\n    return triggerButton;\n  }\n}\n\nfunction createButton(buttonTitle: string): HTMLButtonElement {\n  const button = document.createElement('button');\n  button.classList.add('styles-pane-button');\n  button.tabIndex = 0;\n  button.title = buttonTitle;\n  button.onmouseup = (event): void => {\n    // Stop propagation to prevent the property editor from being activated.\n    event.stopPropagation();\n  };\n  const icon = new IconButton.Icon.Icon();\n  icon.data = {iconName: 'flex-wrap-icon', color: 'var(--color-text-secondary)', width: '12px', height: '12px'};\n  button.appendChild(icon);\n  return button;\n}\n\nfunction ensureTreeElementForProperty(section: StylePropertiesSection, propertyName: string): StylePropertyTreeElement {\n  const target = section.propertiesTreeOutline.rootElement().children().find(\n      child => child instanceof StylePropertyTreeElement && child.property.name === propertyName);\n  if (target) {\n    return target as StylePropertyTreeElement;\n  }\n  const newTarget = section.addNewBlankProperty();\n  newTarget.property.name = propertyName;\n  return newTarget;\n}\n\nasync function fetchComputedStyles(pane: StylesSidebarPane): Promise<Map<string, string>> {\n  const computedStyleModel = pane.computedStyleModel();\n  const style = await computedStyleModel.fetchComputedStyle();\n  return style ? style.computedStyle : new Map();\n}\n\nfunction getAuthoredStyles(\n    section: StylePropertiesSection, editableProperties: Array<{propertyName: string}>): Map<string, string> {\n  const authoredProperties = new Map();\n  const editablePropertiesSet = new Set(editableProperties.map(prop => prop.propertyName));\n  for (const prop of section.style().leadingProperties()) {\n    if (editablePropertiesSet.has(prop.name)) {\n      authoredProperties.set(prop.name, prop.value);\n    }\n  }\n  return authoredProperties;\n}\n"],
  "mappings": "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",
  "names": []
}
