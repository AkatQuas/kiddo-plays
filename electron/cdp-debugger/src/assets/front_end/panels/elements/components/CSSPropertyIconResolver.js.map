{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/elements/components/CSSPropertyIconResolver.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nconst writingModesAffectingFlexDirection = new Set([\n  'tb',\n  'tb-rl',\n  'vertical-lr',\n  'vertical-rl',\n]);\n\n// eslint-disable-next-line rulesdir/const_enum\nexport enum PhysicalDirection {\n  LEFT_TO_RIGHT = 'left-to-right',\n  RIGHT_TO_LEFT = 'right-to-left',\n  BOTTOM_TO_TOP = 'bottom-to-top',\n  TOP_TO_BOTTOM = 'top-to-bottom',\n}\n\ntype DirectionsDict = {\n  [key: string]: PhysicalDirection,\n};\n\nexport type IconInfo = {\n  iconName: string,\n  rotate: number,\n  scaleX: number,\n  scaleY: number,\n};\n\ntype ComputedStyles = Map<string, string>;\n\nexport function reverseDirection(direction: PhysicalDirection): PhysicalDirection {\n  if (direction === PhysicalDirection.LEFT_TO_RIGHT) {\n    return PhysicalDirection.RIGHT_TO_LEFT;\n  }\n  if (direction === PhysicalDirection.RIGHT_TO_LEFT) {\n    return PhysicalDirection.LEFT_TO_RIGHT;\n  }\n  if (direction === PhysicalDirection.TOP_TO_BOTTOM) {\n    return PhysicalDirection.BOTTOM_TO_TOP;\n  }\n  if (direction === PhysicalDirection.BOTTOM_TO_TOP) {\n    return PhysicalDirection.TOP_TO_BOTTOM;\n  }\n  throw new Error('Unknown PhysicalFlexDirection');\n}\n\nfunction extendWithReverseDirections(directions: DirectionsDict): DirectionsDict {\n  return {\n    ...directions,\n    'row-reverse': reverseDirection(directions.row),\n    'column-reverse': reverseDirection(directions.column),\n  };\n}\n\n/**\n * Returns absolute directions for rows, columns,\n * reverse rows and reverse column taking into account the direction and writing-mode attributes.\n */\nexport function getPhysicalDirections(computedStyles: ComputedStyles): DirectionsDict {\n  const isRtl = computedStyles.get('direction') === 'rtl';\n  const writingMode = computedStyles.get('writing-mode');\n  const isVertical = writingMode && writingModesAffectingFlexDirection.has(writingMode);\n\n  if (isVertical) {\n    return extendWithReverseDirections({\n      row: isRtl ? PhysicalDirection.BOTTOM_TO_TOP : PhysicalDirection.TOP_TO_BOTTOM,\n      column: writingMode === 'vertical-lr' ? PhysicalDirection.LEFT_TO_RIGHT : PhysicalDirection.RIGHT_TO_LEFT,\n    });\n  }\n\n  return extendWithReverseDirections({\n    row: isRtl ? PhysicalDirection.RIGHT_TO_LEFT : PhysicalDirection.LEFT_TO_RIGHT,\n    column: PhysicalDirection.TOP_TO_BOTTOM,\n  });\n}\n\n/**\n * Rotates the flex direction icon in such way that it indicates\n * the desired `direction` and the arrow in the icon is always at the bottom\n * or at the right.\n *\n * By default, the icon is pointing top-down with the arrow on the right-hand side.\n */\nexport function rotateFlexDirectionIcon(direction: PhysicalDirection): IconInfo {\n  // Default to LTR.\n  let flipX = true;\n  let flipY = false;\n  let rotate = -90;\n\n  if (direction === PhysicalDirection.RIGHT_TO_LEFT) {\n    rotate = 90;\n    flipY = false;\n    flipX = false;\n  } else if (direction === PhysicalDirection.TOP_TO_BOTTOM) {\n    rotate = 0;\n    flipX = false;\n    flipY = false;\n  } else if (direction === PhysicalDirection.BOTTOM_TO_TOP) {\n    rotate = 0;\n    flipX = false;\n    flipY = true;\n  }\n\n  return {\n    iconName: 'flex-direction-icon',\n    rotate: rotate,\n    scaleX: flipX ? -1 : 1,\n    scaleY: flipY ? -1 : 1,\n  };\n}\n\nexport function rotateAlignContentIcon(iconName: string, direction: PhysicalDirection): IconInfo {\n  return {\n    iconName,\n    rotate: direction === PhysicalDirection.RIGHT_TO_LEFT ? 90 :\n                                                            (direction === PhysicalDirection.LEFT_TO_RIGHT ? -90 : 0),\n    scaleX: 1,\n    scaleY: 1,\n  };\n}\n\nexport function rotateJustifyContentIcon(iconName: string, direction: PhysicalDirection): IconInfo {\n  return {\n    iconName,\n    rotate: direction === PhysicalDirection.TOP_TO_BOTTOM ? 90 :\n                                                            (direction === PhysicalDirection.BOTTOM_TO_TOP ? -90 : 0),\n    scaleX: direction === PhysicalDirection.RIGHT_TO_LEFT ? -1 : 1,\n    scaleY: 1,\n  };\n}\n\nexport function rotateJustifyItemsIcon(iconName: string, direction: PhysicalDirection): IconInfo {\n  return {\n    iconName,\n    rotate: direction === PhysicalDirection.TOP_TO_BOTTOM ? 90 :\n                                                            (direction === PhysicalDirection.BOTTOM_TO_TOP ? -90 : 0),\n    scaleX: direction === PhysicalDirection.RIGHT_TO_LEFT ? -1 : 1,\n    scaleY: 1,\n  };\n}\n\nexport function rotateAlignItemsIcon(iconName: string, direction: PhysicalDirection): IconInfo {\n  return {\n    iconName,\n    rotate: direction === PhysicalDirection.RIGHT_TO_LEFT ? 90 :\n                                                            (direction === PhysicalDirection.LEFT_TO_RIGHT ? -90 : 0),\n    scaleX: 1,\n    scaleY: 1,\n  };\n}\n\nfunction flexDirectionIcon(value: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateFlexDirectionIcon(directions[value]);\n  }\n  return getIcon;\n}\n\nfunction flexAlignContentIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    const flexDirectionToPhysicalDirection = new Map([\n      ['column', directions.row],\n      ['row', directions.column],\n      ['column-reverse', directions.row],\n      ['row-reverse', directions.column],\n    ]);\n    const computedFlexDirection = computedStyles.get('flex-direction') || 'row';\n    const iconDirection = flexDirectionToPhysicalDirection.get(computedFlexDirection);\n    if (!iconDirection) {\n      throw new Error('Unknown direction for flex-align icon');\n    }\n    return rotateAlignContentIcon(iconName, iconDirection);\n  }\n  return getIcon;\n}\n\nfunction gridAlignContentIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateAlignContentIcon(iconName, directions.column);\n  }\n  return getIcon;\n}\n\nfunction flexJustifyContentIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateJustifyContentIcon(iconName, directions[computedStyles.get('flex-direction') || 'row']);\n  }\n  return getIcon;\n}\n\nfunction gridJustifyContentIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateJustifyContentIcon(iconName, directions.row);\n  }\n  return getIcon;\n}\n\nfunction gridJustifyItemsIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateJustifyItemsIcon(iconName, directions.row);\n  }\n  return getIcon;\n}\n\nfunction flexAlignItemsIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    const flexDirectionToPhysicalDirection = new Map([\n      ['column', directions.row],\n      ['row', directions.column],\n      ['column-reverse', directions.row],\n      ['row-reverse', directions.column],\n    ]);\n    const computedFlexDirection = computedStyles.get('flex-direction') || 'row';\n    const iconDirection = flexDirectionToPhysicalDirection.get(computedFlexDirection);\n    if (!iconDirection) {\n      throw new Error('Unknown direction for flex-align icon');\n    }\n    return rotateAlignItemsIcon(iconName, iconDirection);\n  }\n  return getIcon;\n}\n\nfunction gridAlignItemsIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    return rotateAlignItemsIcon(iconName, directions.column);\n  }\n  return getIcon;\n}\n\n/**\n * The baseline icon contains the letter A to indicate that we're aligning based on where the text baseline is.\n * Therefore we're not rotating this icon like the others, as this would become confusing. Plus baseline alignment\n * is likely only really useful in horizontal flow cases.\n */\nfunction baselineIcon(): IconInfo {\n  return {\n    iconName: 'baseline-icon',\n    rotate: 0,\n    scaleX: 1,\n    scaleY: 1,\n  };\n}\n\nfunction flexAlignSelfIcon(iconName: string): (styles: ComputedStyles, parentStyles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles, parentComputedStyles: ComputedStyles): IconInfo {\n    return flexAlignItemsIcon(iconName)(parentComputedStyles);\n  }\n  return getIcon;\n}\n\nfunction gridAlignSelfIcon(iconName: string): (styles: ComputedStyles, parentStyles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles, parentComputedStyles: ComputedStyles): IconInfo {\n    return gridAlignItemsIcon(iconName)(parentComputedStyles);\n  }\n  return getIcon;\n}\n\nexport function roateFlexWrapIcon(iconName: string, direction: PhysicalDirection): IconInfo {\n  return {\n    iconName,\n    rotate: direction === PhysicalDirection.BOTTOM_TO_TOP || direction === PhysicalDirection.TOP_TO_BOTTOM ? 90 : 0,\n    scaleX: 1,\n    scaleY: 1,\n  };\n}\n\nfunction flexWrapIcon(iconName: string): (styles: ComputedStyles) => IconInfo {\n  function getIcon(computedStyles: ComputedStyles): IconInfo {\n    const directions = getPhysicalDirections(computedStyles);\n    const computedFlexDirection = computedStyles.get('flex-direction') || 'row';\n    return roateFlexWrapIcon(iconName, directions[computedFlexDirection]);\n  }\n  return getIcon;\n}\n\nconst flexContainerIcons = new Map([\n  ['flex-direction: row', flexDirectionIcon('row')],\n  ['flex-direction: column', flexDirectionIcon('column')],\n  ['flex-direction: column-reverse', flexDirectionIcon('column-reverse')],\n  ['flex-direction: row-reverse', flexDirectionIcon('row-reverse')],\n  ['flex-direction: initial', flexDirectionIcon('row')],\n  ['flex-direction: unset', flexDirectionIcon('row')],\n  ['flex-direction: revert', flexDirectionIcon('row')],\n  ['align-content: center', flexAlignContentIcon('align-content-center-icon')],\n  ['align-content: space-around', flexAlignContentIcon('align-content-space-around-icon')],\n  ['align-content: space-between', flexAlignContentIcon('align-content-space-between-icon')],\n  ['align-content: stretch', flexAlignContentIcon('align-content-stretch-icon')],\n  ['align-content: space-evenly', flexAlignContentIcon('align-content-space-evenly-icon')],\n  ['align-content: flex-end', flexAlignContentIcon('align-content-end-icon')],\n  ['align-content: flex-start', flexAlignContentIcon('align-content-start-icon')],\n  // TODO(crbug.com/1139945): Start & end should be enabled once Chromium supports them for flexbox.\n  // ['align-content: start', flexAlignContentIcon('align-content-start-icon')],\n  // ['align-content: end', flexAlignContentIcon('align-content-end-icon')],\n  ['align-content: normal', flexAlignContentIcon('align-content-stretch-icon')],\n  ['align-content: revert', flexAlignContentIcon('align-content-stretch-icon')],\n  ['align-content: unset', flexAlignContentIcon('align-content-stretch-icon')],\n  ['align-content: initial', flexAlignContentIcon('align-content-stretch-icon')],\n  ['justify-content: center', flexJustifyContentIcon('justify-content-center-icon')],\n  ['justify-content: space-around', flexJustifyContentIcon('justify-content-space-around-icon')],\n  ['justify-content: space-between', flexJustifyContentIcon('justify-content-space-between-icon')],\n  ['justify-content: space-evenly', flexJustifyContentIcon('justify-content-space-evenly-icon')],\n  ['justify-content: flex-end', flexJustifyContentIcon('justify-content-flex-end-icon')],\n  ['justify-content: flex-start', flexJustifyContentIcon('justify-content-flex-start-icon')],\n  ['align-items: stretch', flexAlignItemsIcon('align-items-stretch-icon')],\n  ['align-items: flex-end', flexAlignItemsIcon('align-items-flex-end-icon')],\n  ['align-items: flex-start', flexAlignItemsIcon('align-items-flex-start-icon')],\n  ['align-items: center', flexAlignItemsIcon('align-items-center-icon')],\n  ['align-items: baseline', baselineIcon],\n  ['align-content: baseline', baselineIcon],\n  ['flex-wrap: wrap', flexWrapIcon('flex-wrap-icon')],\n  ['flex-wrap: nowrap', flexWrapIcon('flex-nowrap-icon')],\n]);\n\nconst flexItemIcons = new Map([\n  ['align-self: baseline', baselineIcon],\n  ['align-self: center', flexAlignSelfIcon('align-self-center-icon')],\n  ['align-self: flex-start', flexAlignSelfIcon('align-self-flex-start-icon')],\n  ['align-self: flex-end', flexAlignSelfIcon('align-self-flex-end-icon')],\n  ['align-self: stretch', flexAlignSelfIcon('align-self-stretch-icon')],\n]);\n\nconst gridContainerIcons = new Map([\n  ['align-content: center', gridAlignContentIcon('align-content-center-icon')],\n  ['align-content: space-around', gridAlignContentIcon('align-content-space-around-icon')],\n  ['align-content: space-between', gridAlignContentIcon('align-content-space-between-icon')],\n  ['align-content: stretch', gridAlignContentIcon('align-content-stretch-icon')],\n  ['align-content: space-evenly', gridAlignContentIcon('align-content-space-evenly-icon')],\n  ['align-content: end', gridAlignContentIcon('align-content-end-icon')],\n  ['align-content: start', gridAlignContentIcon('align-content-start-icon')],\n  ['align-content: baseline', baselineIcon],\n  ['justify-content: center', gridJustifyContentIcon('justify-content-center-icon')],\n  ['justify-content: space-around', gridJustifyContentIcon('justify-content-space-around-icon')],\n  ['justify-content: space-between', gridJustifyContentIcon('justify-content-space-between-icon')],\n  ['justify-content: space-evenly', gridJustifyContentIcon('justify-content-space-evenly-icon')],\n  ['justify-content: end', gridJustifyContentIcon('justify-content-flex-end-icon')],\n  ['justify-content: start', gridJustifyContentIcon('justify-content-flex-start-icon')],\n  ['align-items: stretch', gridAlignItemsIcon('align-items-stretch-icon')],\n  ['align-items: end', gridAlignItemsIcon('align-items-flex-end-icon')],\n  ['align-items: start', gridAlignItemsIcon('align-items-flex-start-icon')],\n  ['align-items: center', gridAlignItemsIcon('align-items-center-icon')],\n  ['align-items: baseline', baselineIcon],\n  ['justify-items: center', gridJustifyItemsIcon('justify-items-center-icon')],\n  ['justify-items: stretch', gridJustifyItemsIcon('justify-items-stretch-icon')],\n  ['justify-items: end', gridJustifyItemsIcon('justify-items-end-icon')],\n  ['justify-items: start', gridJustifyItemsIcon('justify-items-start-icon')],\n  ['justify-items: baseline', baselineIcon],\n]);\n\nconst gridItemIcons = new Map([\n  ['align-self: baseline', baselineIcon],\n  ['align-self: center', gridAlignSelfIcon('align-self-center-icon')],\n  ['align-self: start', gridAlignSelfIcon('align-self-flex-start-icon')],\n  ['align-self: end', gridAlignSelfIcon('align-self-flex-end-icon')],\n  ['align-self: stretch', gridAlignSelfIcon('align-self-stretch-icon')],\n]);\n\nconst isFlexContainer = (computedStyles?: ComputedStyles|null): boolean => {\n  const display = computedStyles?.get('display');\n  return display === 'flex' || display === 'inline-flex';\n};\n\nconst isGridContainer = (computedStyles?: ComputedStyles|null): boolean => {\n  const display = computedStyles?.get('display');\n  return display === 'grid' || display === 'inline-grid';\n};\n\nexport function findIcon(\n    text: string, computedStyles: ComputedStyles|null, parentComputedStyles?: ComputedStyles|null): IconInfo|null {\n  if (isFlexContainer(computedStyles)) {\n    const icon = findFlexContainerIcon(text, computedStyles);\n    if (icon) {\n      return icon;\n    }\n  }\n  if (isFlexContainer(parentComputedStyles)) {\n    const icon = findFlexItemIcon(text, computedStyles, parentComputedStyles);\n    if (icon) {\n      return icon;\n    }\n  }\n  if (isGridContainer(computedStyles)) {\n    const icon = findGridContainerIcon(text, computedStyles);\n    if (icon) {\n      return icon;\n    }\n  }\n  if (isGridContainer(parentComputedStyles)) {\n    const icon = findGridItemIcon(text, computedStyles, parentComputedStyles);\n    if (icon) {\n      return icon;\n    }\n  }\n  return null;\n}\n\nexport function findFlexContainerIcon(text: string, computedStyles: ComputedStyles|null): IconInfo|null {\n  const resolver = flexContainerIcons.get(text);\n  if (resolver) {\n    return resolver(computedStyles || new Map());\n  }\n  return null;\n}\n\nexport function findFlexItemIcon(\n    text: string, computedStyles: ComputedStyles|null, parentComputedStyles?: ComputedStyles|null): IconInfo|null {\n  const resolver = flexItemIcons.get(text);\n  if (resolver) {\n    return resolver(computedStyles || new Map(), parentComputedStyles || new Map());\n  }\n  return null;\n}\n\nexport function findGridContainerIcon(text: string, computedStyles: ComputedStyles|null): IconInfo|null {\n  const resolver = gridContainerIcons.get(text);\n  if (resolver) {\n    return resolver(computedStyles || new Map());\n  }\n  return null;\n}\n\nexport function findGridItemIcon(\n    text: string, computedStyles: ComputedStyles|null, parentComputedStyles?: ComputedStyles|null): IconInfo|null {\n  const resolver = gridItemIcons.get(text);\n  if (resolver) {\n    return resolver(computedStyles || new Map(), parentComputedStyles || new Map());\n  }\n  return null;\n}\n"],
  "mappings": "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",
  "names": []
}
