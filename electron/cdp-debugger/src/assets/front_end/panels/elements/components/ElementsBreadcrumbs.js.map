{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/elements/components/ElementsBreadcrumbs.ts"],
  "sourcesContent": ["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as ComponentHelpers from '../../../ui/components/helpers/helpers.js';\nimport * as Coordinator from '../../../ui/components/render_coordinator/render_coordinator.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\n\nimport elementsBreadcrumbsStyles from './elementsBreadcrumbs.css.js';\n\nimport type {UserScrollPosition} from './ElementsBreadcrumbsUtils.js';\nimport {crumbsToRender} from './ElementsBreadcrumbsUtils.js';\nimport type * as SDK from '../../../core/sdk/sdk.js';\nimport type {DOMNode} from './Helper.js';\n\nimport * as NodeText from '../../../ui/components/node_text/node_text.js';\n\nconst UIStrings = {\n  /**\n  * @description Accessible name for DOM tree breadcrumb navigation.\n  */\n  breadcrumbs: 'DOM tree breadcrumbs',\n};\n\nconst str_ = i18n.i18n.registerUIStrings('panels/elements/components/ElementsBreadcrumbs.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class NodeSelectedEvent extends Event {\n  static readonly eventName = 'breadcrumbsnodeselected';\n  legacyDomNode: SDK.DOMModel.DOMNode;\n\n  constructor(node: DOMNode) {\n    super(NodeSelectedEvent.eventName, {});\n    this.legacyDomNode = node.legacyDomNode;\n  }\n}\n\nexport interface ElementsBreadcrumbsData {\n  selectedNode: DOMNode|null;\n  crumbs: DOMNode[];\n}\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nexport class ElementsBreadcrumbs extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-elements-breadcrumbs`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n  readonly #resizeObserver = new ResizeObserver(() => this.#checkForOverflowOnResize());\n\n  #crumbsData: readonly DOMNode[] = [];\n  #selectedDOMNode: Readonly<DOMNode>|null = null;\n  #overflowing = false;\n  #userScrollPosition: UserScrollPosition = 'start';\n  #isObservingResize = false;\n  #userHasManuallyScrolled = false;\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [elementsBreadcrumbsStyles];\n  }\n\n  set data(data: ElementsBreadcrumbsData) {\n    this.#selectedDOMNode = data.selectedNode;\n    this.#crumbsData = data.crumbs;\n    this.#userHasManuallyScrolled = false;\n    void this.#update();\n  }\n\n  disconnectedCallback(): void {\n    this.#isObservingResize = false;\n    this.#resizeObserver.disconnect();\n  }\n\n  #onCrumbClick(node: DOMNode): (event: Event) => void {\n    return (event: Event): void => {\n      event.preventDefault();\n      this.dispatchEvent(new NodeSelectedEvent(node));\n    };\n  }\n\n  /*\n   * When the window is resized, we need to check if we either:\n   * 1) overflowing, and now the window is big enough that we don't need to\n   * 2) not overflowing, and now the window is small and we do need to\n   *\n   * If either of these are true, we toggle the overflowing state accordingly and trigger a re-render.\n   */\n  async #checkForOverflowOnResize(): Promise<void> {\n    const wrappingElement = this.#shadow.querySelector('.crumbs');\n    const crumbs = this.#shadow.querySelector('.crumbs-scroll-container');\n    if (!wrappingElement || !crumbs) {\n      return;\n    }\n\n    const totalContainingWidth = await coordinator.read<number>(() => wrappingElement.clientWidth);\n    const totalCrumbsWidth = await coordinator.read<number>(() => crumbs.clientWidth);\n\n    if (totalCrumbsWidth >= totalContainingWidth && this.#overflowing === false) {\n      this.#overflowing = true;\n      this.#userScrollPosition = 'start';\n      void this.#render();\n    } else if (totalCrumbsWidth < totalContainingWidth && this.#overflowing === true) {\n      this.#overflowing = false;\n      this.#userScrollPosition = 'start';\n      void this.#render();\n    }\n  }\n\n  async #update(): Promise<void> {\n    await this.#render();\n    this.#engageResizeObserver();\n    void this.#ensureSelectedNodeIsVisible();\n  }\n\n  #onCrumbMouseMove(node: DOMNode): () => void {\n    return (): void => node.highlightNode();\n  }\n\n  #onCrumbMouseLeave(node: DOMNode): () => void {\n    return (): void => node.clearHighlight();\n  }\n\n  #onCrumbFocus(node: DOMNode): () => void {\n    return (): void => node.highlightNode();\n  }\n\n  #onCrumbBlur(node: DOMNode): () => void {\n    return (): void => node.clearHighlight();\n  }\n\n  #engageResizeObserver(): void {\n    if (!this.#resizeObserver || this.#isObservingResize === true) {\n      return;\n    }\n\n    const crumbs = this.#shadow.querySelector('.crumbs');\n\n    if (!crumbs) {\n      return;\n    }\n\n    this.#resizeObserver.observe(crumbs);\n    this.#isObservingResize = true;\n  }\n\n  /**\n   * This method runs after render and checks if the crumbs are too large for\n   * their container and therefore we need to render the overflow buttons at\n   * either end which the user can use to scroll back and forward through the crumbs.\n   * If it finds that we are overflowing, it sets the instance variable and\n   * triggers a re-render. If we are not overflowing, this method returns and\n   * does nothing.\n   */\n  async #checkForOverflow(): Promise<void> {\n    const crumbScrollContainer = this.#shadow.querySelector('.crumbs-scroll-container');\n    const crumbWindow = this.#shadow.querySelector('.crumbs-window');\n\n    if (!crumbScrollContainer || !crumbWindow) {\n      return;\n    }\n\n    const crumbWindowWidth = await coordinator.read<number>(() => {\n      return crumbWindow.clientWidth;\n    });\n\n    const scrollContainerWidth = await coordinator.read<number>(() => {\n      return crumbScrollContainer.clientWidth;\n    });\n\n    const paddingAllowance = 20;\n    const maxChildWidth = crumbWindowWidth - paddingAllowance;\n\n    if (scrollContainerWidth < maxChildWidth) {\n      if (this.#overflowing) {\n        // We were overflowing, but now we have enough room, so re-render with\n        // overflowing set to false so the overflow buttons get removed.\n        this.#overflowing = false;\n        void this.#render();\n      }\n      return;\n    }\n\n    // We don't have enough room, so if we are not currently overflowing, mark\n    // as overflowing and re-render to update the UI.\n    if (!this.#overflowing) {\n      this.#overflowing = true;\n      void this.#render();\n    }\n  }\n\n  #onCrumbsWindowScroll(event: Event): void {\n    if (!event.target) {\n      return;\n    }\n\n    /* not all Events are DOM Events so the TS Event def doesn't have\n     * .target typed as an Element but in this case we're getting this\n     * from a DOM event so we're confident of having .target and it\n     * being an element\n     */\n    const scrollWindow = event.target as Element;\n\n    this.#updateScrollState(scrollWindow);\n  }\n\n  #updateScrollState(scrollWindow: Element): void {\n    const maxScrollLeft = scrollWindow.scrollWidth - scrollWindow.clientWidth;\n    const currentScroll = scrollWindow.scrollLeft;\n\n    /**\n     * When we check if the user is at the beginning or end of the crumbs (such\n     * that we disable the relevant button - you can't keep scrolling right if\n     * you're at the last breadcrumb) we want to not check exact numbers but\n     * give a bit of padding. This means if the user has scrolled to nearly the\n     * end but not quite (e.g. there are 2 more pixels they could scroll) we'll\n     * mark it as them being at the end. This variable controls how much padding\n     * we apply. So if a user has scrolled to within 10px of the end, we count\n     * them as being at the end and disable the button.\n     */\n    const scrollBeginningAndEndPadding = 10;\n\n    if (currentScroll < scrollBeginningAndEndPadding) {\n      this.#userScrollPosition = 'start';\n    } else if (currentScroll >= maxScrollLeft - scrollBeginningAndEndPadding) {\n      this.#userScrollPosition = 'end';\n    } else {\n      this.#userScrollPosition = 'middle';\n    }\n\n    void this.#render();\n  }\n\n  #onOverflowClick(direction: 'left'|'right'): () => void {\n    return (): void => {\n      this.#userHasManuallyScrolled = true;\n      const scrollWindow = this.#shadow.querySelector('.crumbs-window');\n\n      if (!scrollWindow) {\n        return;\n      }\n\n      const amountToScrollOnClick = scrollWindow.clientWidth / 2;\n\n      const newScrollAmount = direction === 'left' ?\n          Math.max(Math.floor(scrollWindow.scrollLeft - amountToScrollOnClick), 0) :\n          scrollWindow.scrollLeft + amountToScrollOnClick;\n\n      scrollWindow.scrollTo({\n        behavior: 'smooth',\n        left: newScrollAmount,\n      });\n    };\n  }\n\n  #renderOverflowButton(direction: 'left'|'right', disabled: boolean): LitHtml.TemplateResult {\n    const buttonStyles = LitHtml.Directives.classMap({\n      overflow: true,\n      [direction]: true,\n      hidden: this.#overflowing === false,\n    });\n\n    return LitHtml.html`\n      <button\n        class=${buttonStyles}\n        @click=${this.#onOverflowClick(direction)}\n        ?disabled=${disabled}\n        aria-label=\"Scroll ${direction}\"\n      >&hellip;</button>\n      `;\n  }\n\n  async #render(): Promise<void> {\n    const crumbs = crumbsToRender(this.#crumbsData, this.#selectedDOMNode);\n\n    await coordinator.write('Breadcrumbs render', () => {\n      // Disabled until https://crbug.com/1079231 is fixed.\n      // clang-format off\n      LitHtml.render(LitHtml.html`\n        <nav class=\"crumbs\" aria-label=${i18nString(UIStrings.breadcrumbs)}>\n          ${this.#renderOverflowButton('left', this.#userScrollPosition === 'start')}\n\n          <div class=\"crumbs-window\" @scroll=${this.#onCrumbsWindowScroll}>\n            <ul class=\"crumbs-scroll-container\">\n              ${crumbs.map(crumb => {\n                const crumbClasses = {\n                  crumb: true,\n                  selected: crumb.selected,\n                };\n                // eslint-disable-next-line rulesdir/ban_a_tags_in_lit_html\n                return LitHtml.html`\n                  <li class=${LitHtml.Directives.classMap(crumbClasses)}\n                    data-node-id=${crumb.node.id}\n                    data-crumb=\"true\"\n                  >\n                    <a href=\"#\"\n                      draggable=false\n                      class=\"crumb-link\"\n                      @click=${this.#onCrumbClick(crumb.node)}\n                      @mousemove=${this.#onCrumbMouseMove(crumb.node)}\n                      @mouseleave=${this.#onCrumbMouseLeave(crumb.node)}\n                      @focus=${this.#onCrumbFocus(crumb.node)}\n                      @blur=${this.#onCrumbBlur(crumb.node)}\n                    ><${NodeText.NodeText.NodeText.litTagName} data-node-title=${crumb.title.main} .data=${{\n                      nodeTitle: crumb.title.main,\n                      nodeId: crumb.title.extras.id,\n                      nodeClasses: crumb.title.extras.classes,\n                    } as NodeText.NodeText.NodeTextData}></${NodeText.NodeText.NodeText.litTagName}></a>\n                  </li>`;\n              })}\n            </ul>\n          </div>\n          ${this.#renderOverflowButton('right', this.#userScrollPosition === 'end')}\n        </nav>\n      `, this.#shadow, { host: this });\n      // clang-format on\n    });\n\n    void this.#checkForOverflow();\n  }\n\n  async #ensureSelectedNodeIsVisible(): Promise<void> {\n    /*\n     * If the user has manually scrolled the crumbs in either direction, we\n     * effectively hand control over the scrolling down to them. This is to\n     * prevent the user manually scrolling to the end, and then us scrolling\n     * them back to the selected node. The moment they click either scroll\n     * button we set userHasManuallyScrolled, and we reset it when we get new\n     * data in. This means if the user clicks on a different element in the\n     * tree, we will auto-scroll that element into view, because we'll get new\n     * data and hence the flag will be reset.\n     */\n    if (!this.#selectedDOMNode || !this.#shadow || !this.#overflowing || this.#userHasManuallyScrolled) {\n      return;\n    }\n    const activeCrumbId = this.#selectedDOMNode.id;\n    const activeCrumb = this.#shadow.querySelector(`.crumb[data-node-id=\"${activeCrumbId}\"]`);\n\n    if (activeCrumb) {\n      await coordinator.scroll(() => {\n        activeCrumb.scrollIntoView({\n          behavior: 'smooth',\n        });\n      });\n    }\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-elements-breadcrumbs', ElementsBreadcrumbs);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-elements-breadcrumbs': ElementsBreadcrumbs;\n  }\n\n  interface HTMLElementEventMap {\n    [NodeSelectedEvent.eventName]: NodeSelectedEvent;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
