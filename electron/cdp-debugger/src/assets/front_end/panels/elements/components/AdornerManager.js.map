{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/elements/components/AdornerManager.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const enum AdornerCategories {\n  SECURITY = 'Security',\n  LAYOUT = 'Layout',\n  DEFAULT = 'Default',\n}\n\nexport interface AdornerSetting {\n  adorner: string;\n  isEnabled: boolean;\n}\n\nexport type AdornerSettingsMap = Map<string, boolean>;\n\nexport interface RegisteredAdorner {\n  readonly name: string;\n  readonly category: AdornerCategories;\n  readonly enabledByDefault: boolean;\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum RegisteredAdorners {\n  GRID = 'grid',\n  FLEX = 'flex',\n  AD = 'ad',\n  SCROLL_SNAP = 'scroll-snap',\n  CONTAINER = 'container',\n  SLOT = 'slot',\n  TOP_LAYER = 'top-layer',\n}\n\n// This enum-like const object serves as the authoritative registry for all the\n// adorners available.\nexport function getRegisteredAdorner(which: RegisteredAdorners): RegisteredAdorner {\n  switch (which) {\n    case RegisteredAdorners.GRID:\n      return {\n        name: 'grid',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.FLEX:\n      return {\n        name: 'flex',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.AD:\n      return {\n        name: 'ad',\n        category: AdornerCategories.SECURITY,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.SCROLL_SNAP:\n      return {\n        name: 'scroll-snap',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.CONTAINER:\n      return {\n        name: 'container',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.SLOT:\n      return {\n        name: 'slot',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n    case RegisteredAdorners.TOP_LAYER:\n      return {\n        name: 'top-layer',\n        category: AdornerCategories.LAYOUT,\n        enabledByDefault: true,\n      };\n  }\n}\n\nlet adornerNameToCategoryMap: Map<string, AdornerCategories>|undefined = undefined;\n\nfunction getCategoryFromAdornerName(name: string): AdornerCategories {\n  if (!adornerNameToCategoryMap) {\n    adornerNameToCategoryMap = new Map();\n    for (const {name, category} of Object.values(RegisteredAdorners).map(getRegisteredAdorner)) {\n      adornerNameToCategoryMap.set(name, category);\n    }\n  }\n  return adornerNameToCategoryMap.get(name) || AdornerCategories.DEFAULT;\n}\n\nexport const DefaultAdornerSettings: AdornerSetting[] =\n    Object.values(RegisteredAdorners).map(getRegisteredAdorner).map(({name, enabledByDefault}) => ({\n                                                                      adorner: name,\n                                                                      isEnabled: enabledByDefault,\n                                                                    }));\n\ninterface SettingStore<Setting> {\n  get(): Setting;\n  set(setting: Setting): void;\n}\n\nexport class AdornerManager {\n  #adornerSettings: AdornerSettingsMap = new Map();\n  #settingStore: SettingStore<AdornerSetting[]>;\n\n  constructor(settingStore: SettingStore<AdornerSetting[]>) {\n    this.#settingStore = settingStore;\n    this.#syncSettings();\n  }\n\n  updateSettings(settings: AdornerSettingsMap): void {\n    this.#adornerSettings = settings;\n    this.#persistCurrentSettings();\n  }\n\n  getSettings(): Readonly<AdornerSettingsMap> {\n    return this.#adornerSettings;\n  }\n\n  isAdornerEnabled(adornerText: string): boolean {\n    return this.#adornerSettings.get(adornerText) || false;\n  }\n\n  #persistCurrentSettings(): void {\n    const settingList = [];\n    for (const [adorner, isEnabled] of this.#adornerSettings) {\n      settingList.push({adorner, isEnabled});\n    }\n    this.#settingStore.set(settingList);\n  }\n\n  #loadSettings(): void {\n    const settingList = this.#settingStore.get();\n    for (const setting of settingList) {\n      this.#adornerSettings.set(setting.adorner, setting.isEnabled);\n    }\n  }\n\n  #syncSettings(): void {\n    this.#loadSettings();\n\n    // Prune outdated adorners and add new ones to the persistence.\n    const outdatedAdorners = new Set(this.#adornerSettings.keys());\n    for (const {adorner, isEnabled} of DefaultAdornerSettings) {\n      outdatedAdorners.delete(adorner);\n      if (!this.#adornerSettings.has(adorner)) {\n        this.#adornerSettings.set(adorner, isEnabled);\n      }\n    }\n    for (const outdatedAdorner of outdatedAdorners) {\n      this.#adornerSettings.delete(outdatedAdorner);\n    }\n\n    this.#persistCurrentSettings();\n  }\n}\n\nconst OrderedAdornerCategories = [\n  AdornerCategories.SECURITY,\n  AdornerCategories.LAYOUT,\n  AdornerCategories.DEFAULT,\n];\n\n// Use idx + 1 for the order to avoid JavaScript's 0 == false issue\nexport const AdornerCategoryOrder = new Map(OrderedAdornerCategories.map((category, idx) => [category, idx + 1]));\n\nexport function compareAdornerNamesByCategory(nameA: string, nameB: string): number {\n  const orderA = AdornerCategoryOrder.get(getCategoryFromAdornerName(nameA)) || Number.POSITIVE_INFINITY;\n  const orderB = AdornerCategoryOrder.get(getCategoryFromAdornerName(nameB)) || Number.POSITIVE_INFINITY;\n  return orderA - orderB;\n}\n"],
  "mappings": "AAIO,WAAW,oBAAX,kBAAW,uBAAX;AACL,mCAAW;AACX,iCAAS;AACT,kCAAU;AAHM;AAAA;AAqBX,WAAK,qBAAL,kBAAK,wBAAL;AACL,gCAAO;AACP,gCAAO;AACP,8BAAK;AACL,uCAAc;AACd,qCAAY;AACZ,gCAAO;AACP,qCAAY;AAPF;AAAA;AAYL,qCAA8B,OAA8C;AACjF,UAAQ;AAAA,SACD;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA,SAEjB;AACH,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,QACV,kBAAkB;AAAA;AAAA;AAAA;AAK1B,IAAI,2BAAqE;AAEzE,oCAAoC,MAAiC;AACnE,MAAI,CAAC,0BAA0B;AAC7B,+BAA2B,oBAAI;AAC/B,eAAW,EAAC,aAAM,cAAa,OAAO,OAAO,oBAAoB,IAAI,uBAAuB;AAC1F,+BAAyB,IAAI,OAAM;AAAA;AAAA;AAGvC,SAAO,yBAAyB,IAAI,SAAS;AAAA;AAGxC,aAAM,yBACT,OAAO,OAAO,oBAAoB,IAAI,sBAAsB,IAAI,CAAC,EAAC,MAAM,uBAAuB;AAAA,EAC7B,SAAS;AAAA,EACT,WAAW;AAAA;AAQ1E,4BAAqB;AAAA,qBACa,oBAAI;AAAA;AAAA,EAG3C,YAAY,cAA8C;AACxD,yBAAqB;AACrB;AAAA;AAAA,EAGF,eAAe,UAAoC;AACjD,4BAAwB;AACxB;AAAA;AAAA,EAGF,cAA4C;AAC1C,WAAO;AAAA;AAAA,EAGT,iBAAiB,aAA8B;AAC7C,WAAO,sBAAsB,IAAI,gBAAgB;AAAA;AAAA,4BAGnB;AAC9B,UAAM,cAAc;AACpB,eAAW,CAAC,SAAS,cAAc,uBAAuB;AACxD,kBAAY,KAAK,EAAC,SAAS;AAAA;AAE7B,uBAAmB,IAAI;AAAA;AAAA,kBAGH;AACpB,UAAM,cAAc,mBAAmB;AACvC,eAAW,WAAW,aAAa;AACjC,4BAAsB,IAAI,QAAQ,SAAS,QAAQ;AAAA;AAAA;AAAA,kBAIjC;AACpB;AAGA,UAAM,mBAAmB,IAAI,IAAI,sBAAsB;AACvD,eAAW,EAAC,SAAS,eAAc,wBAAwB;AACzD,uBAAiB,OAAO;AACxB,UAAI,CAAC,sBAAsB,IAAI,UAAU;AACvC,8BAAsB,IAAI,SAAS;AAAA;AAAA;AAGvC,eAAW,mBAAmB,kBAAkB;AAC9C,4BAAsB,OAAO;AAAA;AAG/B;AAAA;AAAA;AAIJ,MAAM,2BAA2B;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA;AAIK,aAAM,uBAAuB,IAAI,IAAI,yBAAyB,IAAI,CAAC,UAAU,QAAQ,CAAC,UAAU,MAAM;AAEtG,8CAAuC,OAAe,OAAuB;AAClF,QAAM,SAAS,qBAAqB,IAAI,2BAA2B,WAAW,OAAO;AACrF,QAAM,SAAS,qBAAqB,IAAI,2BAA2B,WAAW,OAAO;AACrF,SAAO,SAAS;AAAA;",
  "names": []
}
