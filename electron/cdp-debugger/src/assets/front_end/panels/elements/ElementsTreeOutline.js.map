{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/elements/ElementsTreeOutline.ts"],
  "sourcesContent": ["// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.\n * Copyright (C) 2008 Matt Lilek <webkit@mattlilek.com>\n * Copyright (C) 2009 Joseph Pecoraro\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1.  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n * 2.  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * 3.  Neither the name of Apple Computer, Inc. (\"Apple\") nor the names of\n *     its contributors may be used to endorse or promote products derived\n *     from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as CodeHighlighter from '../../ui/components/code_highlighter/code_highlighter.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport {linkifyDeferredNodeReference} from './DOMLinkifier.js';\nimport {ElementsPanel} from './ElementsPanel.js';\nimport {ElementsTreeElement, InitialChildrenLimit} from './ElementsTreeElement.js';\nimport elementsTreeOutlineStyles from './elementsTreeOutline.css.js';\nimport {ImagePreviewPopover} from './ImagePreviewPopover.js';\nimport {TopLayerContainer} from './TopLayerContainer.js';\n\nimport type {MarkerDecoratorRegistration} from './MarkerDecorator.js';\n\nconst UIStrings = {\n  /**\n  *@description ARIA accessible name in Elements Tree Outline of the Elements panel\n  */\n  pageDom: 'Page DOM',\n  /**\n  *@description A context menu item to store a value as a global variable the Elements Panel\n  */\n  storeAsGlobalVariable: 'Store as global variable',\n  /**\n  *@description Tree element expand all button element button text content in Elements Tree Outline of the Elements panel\n  *@example {3} PH1\n  */\n  showAllNodesDMore: 'Show All Nodes ({PH1} More)',\n  /**\n  *@description Link text content in Elements Tree Outline of the Elements panel\n  */\n  reveal: 'reveal',\n  /**\n   * @description A context menu item to open the badge settings pane\n   */\n  adornerSettings: 'Badge settings\\u2026',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/elements/ElementsTreeOutline.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst elementsTreeOutlineByDOMModel = new WeakMap<SDK.DOMModel.DOMModel, ElementsTreeOutline>();\n\nconst populatedTreeElements = new Set<ElementsTreeElement>();\n\nexport class ElementsTreeOutline extends\n    Common.ObjectWrapper.eventMixin<ElementsTreeOutline.EventTypes, typeof UI.TreeOutline.TreeOutline>(\n        UI.TreeOutline.TreeOutline) {\n  treeElementByNode: WeakMap<SDK.DOMModel.DOMNode, ElementsTreeElement>;\n  private readonly shadowRoot: ShadowRoot;\n  readonly elementInternal: HTMLElement;\n  private includeRootDOMNode: boolean;\n  private selectEnabled: boolean|undefined;\n  private rootDOMNodeInternal: SDK.DOMModel.DOMNode|null;\n  selectedDOMNodeInternal: SDK.DOMModel.DOMNode|null;\n  private visible: boolean;\n  private readonly imagePreviewPopover: ImagePreviewPopover;\n  private updateRecords: Map<SDK.DOMModel.DOMNode, UpdateRecord>;\n  private treeElementsBeingUpdated: Set<ElementsTreeElement>;\n  decoratorExtensions: MarkerDecoratorRegistration[]|null;\n  private showHTMLCommentsSetting: Common.Settings.Setting<boolean>;\n  private multilineEditing?: MultilineEditorController|null;\n  private visibleWidthInternal?: number;\n  private clipboardNodeData?: ClipboardData;\n  private isXMLMimeTypeInternal?: boolean|null;\n  suppressRevealAndSelect: boolean = false;\n  private previousHoveredElement?: UI.TreeOutline.TreeElement;\n  private treeElementBeingDragged?: ElementsTreeElement;\n  private dragOverTreeElement?: ElementsTreeElement;\n  private updateModifiedNodesTimeout?: number;\n  private topLayerContainer?: TopLayerContainer;\n\n  constructor(omitRootDOMNode?: boolean, selectEnabled?: boolean, hideGutter?: boolean) {\n    super();\n    this.treeElementByNode = new WeakMap();\n    const shadowContainer = document.createElement('div');\n    this.shadowRoot = UI.Utils.createShadowRootWithCoreStyles(\n        shadowContainer,\n        {cssFile: [elementsTreeOutlineStyles, CodeHighlighter.Style.default], delegatesFocus: undefined});\n    const outlineDisclosureElement = this.shadowRoot.createChild('div', 'elements-disclosure');\n\n    this.elementInternal = this.element;\n    this.elementInternal.classList.add('elements-tree-outline', 'source-code');\n    if (hideGutter) {\n      this.elementInternal.classList.add('elements-hide-gutter');\n    }\n    UI.ARIAUtils.setAccessibleName(this.elementInternal, i18nString(UIStrings.pageDom));\n    this.elementInternal.addEventListener('focusout', this.onfocusout.bind(this), false);\n    this.elementInternal.addEventListener('mousedown', this.onmousedown.bind(this), false);\n    this.elementInternal.addEventListener('mousemove', this.onmousemove.bind(this), false);\n    this.elementInternal.addEventListener('mouseleave', this.onmouseleave.bind(this), false);\n    this.elementInternal.addEventListener('dragstart', this.ondragstart.bind(this), false);\n    this.elementInternal.addEventListener('dragover', this.ondragover.bind(this), false);\n    this.elementInternal.addEventListener('dragleave', this.ondragleave.bind(this), false);\n    this.elementInternal.addEventListener('drop', this.ondrop.bind(this), false);\n    this.elementInternal.addEventListener('dragend', this.ondragend.bind(this), false);\n    this.elementInternal.addEventListener('contextmenu', this.contextMenuEventFired.bind(this), false);\n    this.elementInternal.addEventListener('clipboard-beforecopy', this.onBeforeCopy.bind(this), false);\n    this.elementInternal.addEventListener('clipboard-copy', this.onCopyOrCut.bind(this, false), false);\n    this.elementInternal.addEventListener('clipboard-cut', this.onCopyOrCut.bind(this, true), false);\n    this.elementInternal.addEventListener('clipboard-paste', this.onPaste.bind(this), false);\n    this.elementInternal.addEventListener('keydown', this.onKeyDown.bind(this), false);\n\n    outlineDisclosureElement.appendChild(this.elementInternal);\n    this.element = shadowContainer;\n\n    this.includeRootDOMNode = !omitRootDOMNode;\n    this.selectEnabled = selectEnabled;\n    this.rootDOMNodeInternal = null;\n    this.selectedDOMNodeInternal = null;\n\n    this.visible = false;\n\n    this.imagePreviewPopover = new ImagePreviewPopover(\n        this.contentElement,\n        event => {\n          let link: (Element|null) = (event.target as Element | null);\n          while (link && !ImagePreviewPopover.getImageURL(link)) {\n            link = link.parentElementOrShadowHost();\n          }\n          return link;\n        },\n        link => {\n          const listItem = UI.UIUtils.enclosingNodeOrSelfWithNodeName(link, 'li');\n          if (!listItem) {\n            return null;\n          }\n\n          const treeElement =\n              (UI.TreeOutline.TreeElement.getTreeElementBylistItemNode(listItem) as ElementsTreeElement | undefined);\n          if (!treeElement) {\n            return null;\n          }\n          return treeElement.node();\n        });\n\n    this.updateRecords = new Map();\n    this.treeElementsBeingUpdated = new Set();\n\n    this.decoratorExtensions = null;\n\n    this.showHTMLCommentsSetting = Common.Settings.Settings.instance().moduleSetting('showHTMLComments');\n    this.showHTMLCommentsSetting.addChangeListener(this.onShowHTMLCommentsChange.bind(this));\n    this.setUseLightSelectionColor(true);\n  }\n\n  static forDOMModel(domModel: SDK.DOMModel.DOMModel): ElementsTreeOutline|null {\n    return elementsTreeOutlineByDOMModel.get(domModel) || null;\n  }\n\n  private onShowHTMLCommentsChange(): void {\n    const selectedNode = this.selectedDOMNode();\n    if (selectedNode && selectedNode.nodeType() === Node.COMMENT_NODE && !this.showHTMLCommentsSetting.get()) {\n      this.selectDOMNode(selectedNode.parentNode);\n    }\n    this.update();\n  }\n\n  setWordWrap(wrap: boolean): void {\n    this.elementInternal.classList.toggle('elements-tree-nowrap', !wrap);\n  }\n\n  setMultilineEditing(multilineEditing: MultilineEditorController|null): void {\n    this.multilineEditing = multilineEditing;\n  }\n\n  visibleWidth(): number {\n    return this.visibleWidthInternal || 0;\n  }\n\n  setVisibleWidth(width: number): void {\n    this.visibleWidthInternal = width;\n    if (this.multilineEditing) {\n      this.multilineEditing.resize();\n    }\n  }\n\n  private setClipboardData(data: ClipboardData|null): void {\n    if (this.clipboardNodeData) {\n      const treeElement = this.findTreeElement(this.clipboardNodeData.node);\n      if (treeElement) {\n        treeElement.setInClipboard(false);\n      }\n      delete this.clipboardNodeData;\n    }\n\n    if (data) {\n      const treeElement = this.findTreeElement(data.node);\n      if (treeElement) {\n        treeElement.setInClipboard(true);\n      }\n      this.clipboardNodeData = data;\n    }\n  }\n\n  resetClipboardIfNeeded(removedNode: SDK.DOMModel.DOMNode): void {\n    if (this.clipboardNodeData && this.clipboardNodeData.node === removedNode) {\n      this.setClipboardData(null);\n    }\n  }\n\n  private onBeforeCopy(event: Event): void {\n    event.handled = true;\n  }\n\n  private onCopyOrCut(isCut: boolean, event: Event): void {\n    this.setClipboardData(null);\n    // @ts-ignore this bound in the main entry point\n    const originalEvent = event['original'];\n\n    if (!originalEvent || !originalEvent.target) {\n      return;\n    }\n\n    // Don't prevent the normal copy if the user has a selection.\n    if (originalEvent.target instanceof Node && originalEvent.target.hasSelection()) {\n      return;\n    }\n\n    // Do not interfere with text editing.\n    if (UI.UIUtils.isEditing()) {\n      return;\n    }\n\n    const targetNode = this.selectedDOMNode();\n    if (!targetNode) {\n      return;\n    }\n\n    if (!originalEvent.clipboardData) {\n      return;\n    }\n    originalEvent.clipboardData.clearData();\n    event.handled = true;\n\n    this.performCopyOrCut(isCut, targetNode);\n  }\n\n  performCopyOrCut(isCut: boolean, node: SDK.DOMModel.DOMNode|null): void {\n    if (!node) {\n      return;\n    }\n    if (isCut && (node.isShadowRoot() || node.ancestorUserAgentShadowRoot())) {\n      return;\n    }\n\n    void node.copyNode();\n    this.setClipboardData({node: node, isCut: isCut});\n  }\n\n  canPaste(targetNode: SDK.DOMModel.DOMNode): boolean {\n    if (targetNode.isShadowRoot() || targetNode.ancestorUserAgentShadowRoot()) {\n      return false;\n    }\n\n    if (!this.clipboardNodeData) {\n      return false;\n    }\n\n    const node = this.clipboardNodeData.node;\n    if (this.clipboardNodeData.isCut && (node === targetNode || node.isAncestor(targetNode))) {\n      return false;\n    }\n\n    if (targetNode.domModel() !== node.domModel()) {\n      return false;\n    }\n    return true;\n  }\n\n  pasteNode(targetNode: SDK.DOMModel.DOMNode): void {\n    if (this.canPaste(targetNode)) {\n      this.performPaste(targetNode);\n    }\n  }\n\n  duplicateNode(targetNode: SDK.DOMModel.DOMNode): void {\n    this.performDuplicate(targetNode);\n  }\n\n  private onPaste(event: Event): void {\n    // Do not interfere with text editing.\n    if (UI.UIUtils.isEditing()) {\n      return;\n    }\n\n    const targetNode = this.selectedDOMNode();\n    if (!targetNode || !this.canPaste(targetNode)) {\n      return;\n    }\n\n    event.handled = true;\n    this.performPaste(targetNode);\n  }\n\n  private performPaste(targetNode: SDK.DOMModel.DOMNode): void {\n    if (!this.clipboardNodeData) {\n      return;\n    }\n    if (this.clipboardNodeData.isCut) {\n      this.clipboardNodeData.node.moveTo(targetNode, null, expandCallback.bind(this));\n      this.setClipboardData(null);\n    } else {\n      this.clipboardNodeData.node.copyTo(targetNode, null, expandCallback.bind(this));\n    }\n\n    function expandCallback(\n        this: ElementsTreeOutline, error: string|null, pastedNode: SDK.DOMModel.DOMNode|null): void {\n      if (error || !pastedNode) {\n        return;\n      }\n      this.selectDOMNode(pastedNode);\n    }\n  }\n\n  private performDuplicate(targetNode: SDK.DOMModel.DOMNode): void {\n    if (targetNode.isInShadowTree()) {\n      return;\n    }\n\n    const parentNode = targetNode.parentNode ? targetNode.parentNode : targetNode;\n    if (parentNode.nodeName() === '#document') {\n      return;\n    }\n\n    targetNode.copyTo(parentNode, targetNode.nextSibling);\n  }\n\n  setVisible(visible: boolean): void {\n    if (visible === this.visible) {\n      return;\n    }\n    this.visible = visible;\n    if (!this.visible) {\n      this.imagePreviewPopover.hide();\n      if (this.multilineEditing) {\n        this.multilineEditing.cancel();\n      }\n      return;\n    }\n\n    this.runPendingUpdates();\n    if (this.selectedDOMNodeInternal) {\n      this.revealAndSelectNode(this.selectedDOMNodeInternal, false);\n    }\n  }\n\n  get rootDOMNode(): SDK.DOMModel.DOMNode|null {\n    return this.rootDOMNodeInternal;\n  }\n\n  set rootDOMNode(x: SDK.DOMModel.DOMNode|null) {\n    if (this.rootDOMNodeInternal === x) {\n      return;\n    }\n\n    this.rootDOMNodeInternal = x;\n\n    this.isXMLMimeTypeInternal = x && x.isXMLNode();\n\n    this.update();\n  }\n\n  get isXMLMimeType(): boolean {\n    return Boolean(this.isXMLMimeTypeInternal);\n  }\n\n  selectedDOMNode(): SDK.DOMModel.DOMNode|null {\n    return this.selectedDOMNodeInternal;\n  }\n\n  selectDOMNode(node: SDK.DOMModel.DOMNode|null, focus?: boolean): void {\n    if (this.selectedDOMNodeInternal === node) {\n      this.revealAndSelectNode(node, !focus);\n      return;\n    }\n\n    this.selectedDOMNodeInternal = node;\n    this.revealAndSelectNode(node, !focus);\n\n    // The revealAndSelectNode() method might find a different element if there is inlined text,\n    // and the select() call would change the selectedDOMNode and reenter this setter. So to\n    // avoid calling selectedNodeChanged() twice, first check if selectedDOMNodeInternal is the same\n    // node as the one passed in.\n    if (this.selectedDOMNodeInternal === node) {\n      this.selectedNodeChanged(Boolean(focus));\n    }\n  }\n\n  editing(): boolean {\n    const node = this.selectedDOMNode();\n    if (!node) {\n      return false;\n    }\n    const treeElement = this.findTreeElement(node);\n    if (!treeElement) {\n      return false;\n    }\n    return treeElement.isEditing() || false;\n  }\n\n  update(): void {\n    const selectedNode = this.selectedDOMNode();\n    this.removeChildren();\n    if (!this.rootDOMNode) {\n      return;\n    }\n\n    if (this.includeRootDOMNode) {\n      const treeElement = this.createElementTreeElement(this.rootDOMNode);\n      this.appendChild(treeElement);\n    } else {\n      // FIXME: this could use findTreeElement to reuse a tree element if it already exists\n      const children = this.visibleChildren(this.rootDOMNode);\n      for (const child of children) {\n        const treeElement = this.createElementTreeElement(child);\n        this.appendChild(treeElement);\n      }\n    }\n\n    if (selectedNode) {\n      this.revealAndSelectNode(selectedNode, true);\n    }\n  }\n\n  selectedNodeChanged(focus: boolean): void {\n    this.dispatchEventToListeners(\n        ElementsTreeOutline.Events.SelectedNodeChanged, {node: this.selectedDOMNodeInternal, focus: focus});\n  }\n\n  private fireElementsTreeUpdated(nodes: SDK.DOMModel.DOMNode[]): void {\n    this.dispatchEventToListeners(ElementsTreeOutline.Events.ElementsTreeUpdated, nodes);\n  }\n\n  findTreeElement(node: SDK.DOMModel.DOMNode): ElementsTreeElement|null {\n    let treeElement = this.lookUpTreeElement(node);\n    if (!treeElement && node.nodeType() === Node.TEXT_NODE) {\n      // The text node might have been inlined if it was short, so try to find the parent element.\n      treeElement = this.lookUpTreeElement(node.parentNode);\n    }\n\n    return treeElement as ElementsTreeElement | null;\n  }\n\n  private lookUpTreeElement(node: SDK.DOMModel.DOMNode|null): UI.TreeOutline.TreeElement|null {\n    if (!node) {\n      return null;\n    }\n\n    const cachedElement = this.treeElementByNode.get(node);\n    if (cachedElement) {\n      return cachedElement;\n    }\n\n    // Walk up the parent pointers from the desired node\n    const ancestors = [];\n    let currentNode;\n    for (currentNode = node.parentNode; currentNode; currentNode = currentNode.parentNode) {\n      ancestors.push(currentNode);\n      if (this.treeElementByNode.has(currentNode)) {  // stop climbing as soon as we hit\n        break;\n      }\n    }\n\n    if (!currentNode) {\n      return null;\n    }\n\n    // Walk down to populate each ancestor's children, to fill in the tree and the cache.\n    for (let i = ancestors.length - 1; i >= 0; --i) {\n      const child = ancestors[i - 1] || node;\n      const treeElement = this.treeElementByNode.get(ancestors[i]);\n      if (treeElement) {\n        void treeElement.onpopulate();  // fill the cache with the children of treeElement\n        if (child.index && child.index >= treeElement.expandedChildrenLimit()) {\n          this.setExpandedChildrenLimit(treeElement, child.index + 1);\n        }\n      }\n    }\n\n    return this.treeElementByNode.get(node) || null;\n  }\n\n  createTreeElementFor(node: SDK.DOMModel.DOMNode): ElementsTreeElement|null {\n    let treeElement = this.findTreeElement(node);\n    if (treeElement) {\n      return treeElement;\n    }\n    if (!node.parentNode) {\n      return null;\n    }\n\n    treeElement = this.createTreeElementFor(node.parentNode);\n    return treeElement ? this.showChild(treeElement, node) : null;\n  }\n\n  private revealAndSelectNode(node: SDK.DOMModel.DOMNode|null, omitFocus: boolean): void {\n    if (this.suppressRevealAndSelect) {\n      return;\n    }\n\n    if (!this.includeRootDOMNode && node === this.rootDOMNode && this.rootDOMNode) {\n      node = this.rootDOMNode.firstChild;\n    }\n    if (!node) {\n      return;\n    }\n    const treeElement = this.createTreeElementFor(node);\n    if (!treeElement) {\n      return;\n    }\n\n    treeElement.revealAndSelect(omitFocus);\n  }\n\n  treeElementFromEventInternal(event: MouseEvent): UI.TreeOutline.TreeElement|null {\n    const scrollContainer = this.element.parentElement;\n    if (!scrollContainer) {\n      return null;\n    }\n    // We choose this X coordinate based on the knowledge that our list\n    // items extend at least to the right edge of the outer <ol> container.\n    // In the no-word-wrap mode the outer <ol> may be wider than the tree container\n    // (and partially hidden), in which case we are left to use only its right boundary.\n    const x = scrollContainer.totalOffsetLeft() + scrollContainer.offsetWidth - 18;\n\n    const y = event.pageY;\n\n    // Our list items have 1-pixel cracks between them vertically. We avoid\n    // the cracks by checking slightly above and slightly below the mouse\n    // and seeing if we hit the same element each time.\n    const elementUnderMouse = this.treeElementFromPoint(x, y);\n    const elementAboveMouse = this.treeElementFromPoint(x, y - 2);\n    let element;\n    if (elementUnderMouse === elementAboveMouse) {\n      element = elementUnderMouse;\n    } else {\n      element = this.treeElementFromPoint(x, y + 2);\n    }\n\n    return element;\n  }\n\n  private onfocusout(_event: Event): void {\n    SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n  }\n\n  private onmousedown(event: MouseEvent): void {\n    const element = this.treeElementFromEventInternal(event);\n\n    if (!element || element.isEventWithinDisclosureTriangle(event)) {\n      return;\n    }\n\n    element.select();\n  }\n\n  setHoverEffect(treeElement: UI.TreeOutline.TreeElement|null): void {\n    if (this.previousHoveredElement === treeElement) {\n      return;\n    }\n\n    if (this.previousHoveredElement instanceof ElementsTreeElement) {\n      this.previousHoveredElement.hovered = false;\n      delete this.previousHoveredElement;\n    }\n\n    if (treeElement instanceof ElementsTreeElement) {\n      treeElement.hovered = true;\n      this.previousHoveredElement = treeElement;\n    }\n  }\n\n  private onmousemove(event: MouseEvent): void {\n    const element = this.treeElementFromEventInternal(event);\n    if (element && this.previousHoveredElement === element) {\n      return;\n    }\n\n    this.setHoverEffect(element);\n    this.highlightTreeElement(\n        (element as UI.TreeOutline.TreeElement), !UI.KeyboardShortcut.KeyboardShortcut.eventHasEitherCtrlOrMeta(event));\n  }\n\n  private highlightTreeElement(element: UI.TreeOutline.TreeElement, showInfo: boolean): void {\n    if (element instanceof ElementsTreeElement) {\n      element.node().domModel().overlayModel().highlightInOverlay(\n          {node: element.node(), selectorList: undefined}, 'all', showInfo);\n      return;\n    }\n\n    if (element instanceof ShortcutTreeElement) {\n      element.domModel().overlayModel().highlightInOverlay(\n          {deferredNode: element.deferredNode(), selectorList: undefined}, 'all', showInfo);\n    }\n  }\n\n  private onmouseleave(_event: MouseEvent): void {\n    this.setHoverEffect(null);\n    SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n  }\n\n  private ondragstart(event: DragEvent): boolean|undefined {\n    const node = (event.target as Node | null);\n    if (!node || node.hasSelection()) {\n      return false;\n    }\n    if (node.nodeName === 'A') {\n      return false;\n    }\n\n    const treeElement = this.validDragSourceOrTarget(this.treeElementFromEventInternal(event));\n    if (!treeElement) {\n      return false;\n    }\n\n    if (treeElement.node().nodeName() === 'BODY' || treeElement.node().nodeName() === 'HEAD') {\n      return false;\n    }\n\n    if (!event.dataTransfer || !treeElement.listItemElement.textContent) {\n      return;\n    }\n    event.dataTransfer.setData('text/plain', treeElement.listItemElement.textContent.replace(/\\u200b/g, ''));\n    event.dataTransfer.effectAllowed = 'copyMove';\n    this.treeElementBeingDragged = treeElement;\n\n    SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n\n    return true;\n  }\n\n  private ondragover(event: DragEvent): boolean {\n    if (!this.treeElementBeingDragged) {\n      return false;\n    }\n\n    const treeElement = this.validDragSourceOrTarget(this.treeElementFromEventInternal(event));\n    if (!treeElement) {\n      return false;\n    }\n\n    let node: (SDK.DOMModel.DOMNode|null) = (treeElement.node() as SDK.DOMModel.DOMNode | null);\n    while (node) {\n      if (node === this.treeElementBeingDragged.nodeInternal) {\n        return false;\n      }\n      node = node.parentNode;\n    }\n\n    treeElement.listItemElement.classList.add('elements-drag-over');\n    this.dragOverTreeElement = treeElement;\n    event.preventDefault();\n    if (event.dataTransfer) {\n      event.dataTransfer.dropEffect = 'move';\n    }\n    return false;\n  }\n\n  private ondragleave(event: DragEvent): boolean {\n    this.clearDragOverTreeElementMarker();\n    event.preventDefault();\n    return false;\n  }\n\n  private validDragSourceOrTarget(treeElement: UI.TreeOutline.TreeElement|null): ElementsTreeElement|null {\n    if (!treeElement) {\n      return null;\n    }\n\n    if (!(treeElement instanceof ElementsTreeElement)) {\n      return null;\n    }\n    const elementsTreeElement = (treeElement as ElementsTreeElement);\n\n    const node = elementsTreeElement.node();\n    if (!node.parentNode || node.parentNode.nodeType() !== Node.ELEMENT_NODE) {\n      return null;\n    }\n\n    return elementsTreeElement;\n  }\n\n  private ondrop(event: DragEvent): void {\n    event.preventDefault();\n    const treeElement = this.treeElementFromEventInternal(event);\n    if (treeElement instanceof ElementsTreeElement) {\n      this.doMove(treeElement);\n    }\n  }\n\n  private doMove(treeElement: ElementsTreeElement): void {\n    if (!this.treeElementBeingDragged) {\n      return;\n    }\n\n    let parentNode;\n    let anchorNode;\n\n    if (treeElement.isClosingTag()) {\n      // Drop onto closing tag -> insert as last child.\n      parentNode = treeElement.node();\n    } else {\n      const dragTargetNode = treeElement.node();\n      parentNode = dragTargetNode.parentNode;\n      anchorNode = dragTargetNode;\n    }\n\n    if (!parentNode || !anchorNode) {\n      return;\n    }\n    const wasExpanded = this.treeElementBeingDragged.expanded;\n    this.treeElementBeingDragged.nodeInternal.moveTo(\n        parentNode, anchorNode, this.selectNodeAfterEdit.bind(this, wasExpanded));\n\n    delete this.treeElementBeingDragged;\n  }\n\n  private ondragend(event: DragEvent): void {\n    event.preventDefault();\n    this.clearDragOverTreeElementMarker();\n    delete this.treeElementBeingDragged;\n  }\n\n  private clearDragOverTreeElementMarker(): void {\n    if (this.dragOverTreeElement) {\n      this.dragOverTreeElement.listItemElement.classList.remove('elements-drag-over');\n      delete this.dragOverTreeElement;\n    }\n  }\n\n  private contextMenuEventFired(event: MouseEvent): void {\n    const treeElement = this.treeElementFromEventInternal(event);\n    if (treeElement instanceof ElementsTreeElement) {\n      this.showContextMenu(treeElement, event);\n    }\n  }\n\n  showContextMenu(treeElement: ElementsTreeElement, event: Event): void {\n    if (UI.UIUtils.isEditing()) {\n      return;\n    }\n\n    const contextMenu = new UI.ContextMenu.ContextMenu(event);\n    const isPseudoElement = Boolean(treeElement.node().pseudoType());\n    const isTag = treeElement.node().nodeType() === Node.ELEMENT_NODE && !isPseudoElement;\n    const node = (event.target as Node | null);\n    if (!node) {\n      return;\n    }\n    let textNode: Element|null = node.enclosingNodeOrSelfWithClass('webkit-html-text-node');\n    if (textNode && textNode.classList.contains('bogus')) {\n      textNode = null;\n    }\n    const commentNode = node.enclosingNodeOrSelfWithClass('webkit-html-comment');\n    contextMenu.saveSection().appendItem(\n        i18nString(UIStrings.storeAsGlobalVariable), this.saveNodeToTempVariable.bind(this, treeElement.node()));\n    if (textNode) {\n      treeElement.populateTextContextMenu(contextMenu, textNode);\n    } else if (isTag) {\n      treeElement.populateTagContextMenu(contextMenu, event);\n    } else if (commentNode) {\n      treeElement.populateNodeContextMenu(contextMenu);\n    } else if (isPseudoElement) {\n      treeElement.populateScrollIntoView(contextMenu);\n    }\n\n    contextMenu.viewSection().appendItem(i18nString(UIStrings.adornerSettings), () => {\n      ElementsPanel.instance().showAdornerSettingsPane();\n    });\n\n    contextMenu.appendApplicableItems(treeElement.node());\n    void contextMenu.show();\n  }\n\n  private async saveNodeToTempVariable(node: SDK.DOMModel.DOMNode): Promise<void> {\n    const remoteObjectForConsole = await node.resolveToObject();\n    await SDK.ConsoleModel.ConsoleModel.instance().saveToTempVariable(\n        UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext), remoteObjectForConsole);\n  }\n\n  runPendingUpdates(): void {\n    this.updateModifiedNodes();\n  }\n\n  private onKeyDown(event: Event): void {\n    const keyboardEvent = (event as KeyboardEvent);\n    if (UI.UIUtils.isEditing()) {\n      return;\n    }\n    const node = this.selectedDOMNode();\n    if (!node) {\n      return;\n    }\n    const treeElement = this.treeElementByNode.get(node);\n    if (!treeElement) {\n      return;\n    }\n\n    if (UI.KeyboardShortcut.KeyboardShortcut.eventHasCtrlEquivalentKey(keyboardEvent) && node.parentNode) {\n      if (keyboardEvent.key === 'ArrowUp' && node.previousSibling) {\n        node.moveTo(node.parentNode, node.previousSibling, this.selectNodeAfterEdit.bind(this, treeElement.expanded));\n        keyboardEvent.consume(true);\n        return;\n      }\n      if (keyboardEvent.key === 'ArrowDown' && node.nextSibling) {\n        node.moveTo(\n            node.parentNode, node.nextSibling.nextSibling, this.selectNodeAfterEdit.bind(this, treeElement.expanded));\n        keyboardEvent.consume(true);\n        return;\n      }\n    }\n  }\n\n  toggleEditAsHTML(node: SDK.DOMModel.DOMNode, startEditing?: boolean, callback?: (() => void)): void {\n    const treeElement = this.treeElementByNode.get(node);\n    if (!treeElement || !treeElement.hasEditableNode()) {\n      return;\n    }\n\n    if (node.pseudoType()) {\n      return;\n    }\n\n    const parentNode = node.parentNode;\n    const index = node.index;\n    const wasExpanded = treeElement.expanded;\n\n    treeElement.toggleEditAsHTML(editingFinished.bind(this), startEditing);\n\n    function editingFinished(this: ElementsTreeOutline, success: boolean): void {\n      if (callback) {\n        callback();\n      }\n      if (!success) {\n        return;\n      }\n\n      // Select it and expand if necessary. We force tree update so that it processes dom events and is up to date.\n      this.runPendingUpdates();\n\n      if (!index) {\n        return;\n      }\n\n      const children = parentNode && parentNode.children();\n      const newNode = children ? children[index] || parentNode : parentNode;\n      if (!newNode) {\n        return;\n      }\n\n      this.selectDOMNode(newNode, true);\n\n      if (wasExpanded) {\n        const newTreeItem = this.findTreeElement(newNode);\n        if (newTreeItem) {\n          newTreeItem.expand();\n        }\n      }\n    }\n  }\n\n  selectNodeAfterEdit(wasExpanded: boolean, error: string|null, newNode: SDK.DOMModel.DOMNode|null): ElementsTreeElement\n      |null {\n    if (error) {\n      return null;\n    }\n\n    // Select it and expand if necessary. We force tree update so that it processes dom events and is up to date.\n    this.runPendingUpdates();\n\n    if (!newNode) {\n      return null;\n    }\n\n    this.selectDOMNode(newNode, true);\n\n    const newTreeItem = this.findTreeElement(newNode);\n    if (wasExpanded) {\n      if (newTreeItem) {\n        newTreeItem.expand();\n      }\n    }\n    return newTreeItem;\n  }\n\n  /**\n   * Runs a script on the node's remote object that toggles a class name on\n   * the node and injects a stylesheet into the head of the node's document\n   * containing a rule to set \"visibility: hidden\" on the class and all it's\n   * ancestors.\n   */\n  async toggleHideElement(node: SDK.DOMModel.DOMNode): Promise<void> {\n    const pseudoType = node.pseudoType();\n    const effectiveNode = pseudoType ? node.parentNode : node;\n    if (!effectiveNode) {\n      return;\n    }\n\n    const hidden = node.marker('hidden-marker');\n    const object = await effectiveNode.resolveToObject('');\n\n    if (!object) {\n      return;\n    }\n\n    await object.callFunction(\n        (toggleClassAndInjectStyleRule as (this: Object, ...arg1: unknown[]) => void),\n        [{value: pseudoType}, {value: !hidden}]);\n    object.release();\n    node.setMarker('hidden-marker', hidden ? null : true);\n\n    function toggleClassAndInjectStyleRule(this: Element, pseudoType: string|null, hidden: boolean): void {\n      const classNamePrefix = '__web-inspector-hide';\n      const classNameSuffix = '-shortcut__';\n      const styleTagId = '__web-inspector-hide-shortcut-style__';\n      const selectors = [];\n      selectors.push('.__web-inspector-hide-shortcut__');\n      selectors.push('.__web-inspector-hide-shortcut__ *');\n      selectors.push('.__web-inspector-hidebefore-shortcut__::before');\n      selectors.push('.__web-inspector-hideafter-shortcut__::after');\n      const selector = selectors.join(', ');\n      const ruleBody = '    visibility: hidden !important;';\n      const rule = '\\n' + selector + '\\n{\\n' + ruleBody + '\\n}\\n';\n      const className = classNamePrefix + (pseudoType || '') + classNameSuffix;\n      this.classList.toggle(className, hidden);\n\n      let localRoot: Element|HTMLHeadElement = this;\n      while (localRoot.parentNode) {\n        localRoot = (localRoot.parentNode as Element);\n      }\n      if (localRoot.nodeType === Node.DOCUMENT_NODE) {\n        localRoot = document.head;\n      }\n\n      let style = localRoot.querySelector('style#' + styleTagId);\n      if (style) {\n        return;\n      }\n\n      style = document.createElement('style');\n      style.id = styleTagId;\n      style.textContent = rule;\n\n      localRoot.appendChild(style);\n    }\n  }\n\n  isToggledToHidden(node: SDK.DOMModel.DOMNode): boolean {\n    return Boolean(node.marker('hidden-marker'));\n  }\n\n  private reset(): void {\n    this.rootDOMNode = null;\n    this.selectDOMNode(null, false);\n    this.imagePreviewPopover.hide();\n    delete this.clipboardNodeData;\n    SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n    this.updateRecords.clear();\n  }\n\n  wireToDOMModel(domModel: SDK.DOMModel.DOMModel): void {\n    elementsTreeOutlineByDOMModel.set(domModel, this);\n    domModel.addEventListener(SDK.DOMModel.Events.MarkersChanged, this.markersChanged, this);\n    domModel.addEventListener(SDK.DOMModel.Events.NodeInserted, this.nodeInserted, this);\n    domModel.addEventListener(SDK.DOMModel.Events.NodeRemoved, this.nodeRemoved, this);\n    domModel.addEventListener(SDK.DOMModel.Events.AttrModified, this.attributeModified, this);\n    domModel.addEventListener(SDK.DOMModel.Events.AttrRemoved, this.attributeRemoved, this);\n    domModel.addEventListener(SDK.DOMModel.Events.CharacterDataModified, this.characterDataModified, this);\n    domModel.addEventListener(SDK.DOMModel.Events.DocumentUpdated, this.documentUpdated, this);\n    domModel.addEventListener(SDK.DOMModel.Events.ChildNodeCountUpdated, this.childNodeCountUpdated, this);\n    domModel.addEventListener(SDK.DOMModel.Events.DistributedNodesChanged, this.distributedNodesChanged, this);\n    domModel.addEventListener(SDK.DOMModel.Events.TopLayerElementsChanged, this.topLayerElementsChanged, this);\n  }\n\n  unwireFromDOMModel(domModel: SDK.DOMModel.DOMModel): void {\n    domModel.removeEventListener(SDK.DOMModel.Events.MarkersChanged, this.markersChanged, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.NodeInserted, this.nodeInserted, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.NodeRemoved, this.nodeRemoved, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.AttrModified, this.attributeModified, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.AttrRemoved, this.attributeRemoved, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.CharacterDataModified, this.characterDataModified, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.DocumentUpdated, this.documentUpdated, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.ChildNodeCountUpdated, this.childNodeCountUpdated, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.DistributedNodesChanged, this.distributedNodesChanged, this);\n    domModel.removeEventListener(SDK.DOMModel.Events.TopLayerElementsChanged, this.topLayerElementsChanged, this);\n    elementsTreeOutlineByDOMModel.delete(domModel);\n  }\n\n  private addUpdateRecord(node: SDK.DOMModel.DOMNode): UpdateRecord {\n    let record = this.updateRecords.get(node);\n    if (!record) {\n      record = new UpdateRecord();\n      this.updateRecords.set(node, record);\n    }\n    return record;\n  }\n\n  private updateRecordForHighlight(node: SDK.DOMModel.DOMNode): UpdateRecord|null {\n    if (!this.visible) {\n      return null;\n    }\n    return this.updateRecords.get(node) || null;\n  }\n\n  private documentUpdated(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMModel>): void {\n    const domModel = event.data;\n    this.reset();\n    if (domModel.existingDocument()) {\n      this.rootDOMNode = domModel.existingDocument();\n    }\n  }\n\n  private attributeModified(event: Common.EventTarget.EventTargetEvent<{node: SDK.DOMModel.DOMNode, name: string}>):\n      void {\n    const {node} = event.data;\n    this.addUpdateRecord(node).attributeModified(event.data.name);\n    this.updateModifiedNodesSoon();\n  }\n\n  private attributeRemoved(event: Common.EventTarget.EventTargetEvent<{node: SDK.DOMModel.DOMNode, name: string}>):\n      void {\n    const {node} = event.data;\n    this.addUpdateRecord(node).attributeRemoved(event.data.name);\n    this.updateModifiedNodesSoon();\n  }\n\n  private characterDataModified(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMNode>): void {\n    const node = event.data;\n    this.addUpdateRecord(node).charDataModified();\n    // Text could be large and force us to render itself as the child in the tree outline.\n    if (node.parentNode && node.parentNode.firstChild === node.parentNode.lastChild) {\n      this.addUpdateRecord(node.parentNode).childrenModified();\n    }\n    this.updateModifiedNodesSoon();\n  }\n\n  private nodeInserted(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMNode>): void {\n    const node = event.data;\n    this.addUpdateRecord((node.parentNode as SDK.DOMModel.DOMNode)).nodeInserted(node);\n    this.updateModifiedNodesSoon();\n  }\n\n  private nodeRemoved(\n      event: Common.EventTarget.EventTargetEvent<{node: SDK.DOMModel.DOMNode, parent: SDK.DOMModel.DOMNode}>): void {\n    const {node, parent} = event.data;\n    this.resetClipboardIfNeeded(node);\n    this.addUpdateRecord(parent).nodeRemoved(node);\n    this.updateModifiedNodesSoon();\n  }\n\n  private childNodeCountUpdated(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMNode>): void {\n    const node = event.data;\n    this.addUpdateRecord(node).childrenModified();\n    this.updateModifiedNodesSoon();\n  }\n\n  private distributedNodesChanged(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMNode>): void {\n    const node = event.data;\n    this.addUpdateRecord(node).childrenModified();\n    this.updateModifiedNodesSoon();\n  }\n\n  private updateModifiedNodesSoon(): void {\n    if (!this.updateRecords.size) {\n      return;\n    }\n    if (this.updateModifiedNodesTimeout) {\n      return;\n    }\n    this.updateModifiedNodesTimeout = window.setTimeout(this.updateModifiedNodes.bind(this), 50);\n  }\n\n  private updateModifiedNodes(): void {\n    if (this.updateModifiedNodesTimeout) {\n      clearTimeout(this.updateModifiedNodesTimeout);\n      delete this.updateModifiedNodesTimeout;\n    }\n\n    const updatedNodes = [...this.updateRecords.keys()];\n    const hidePanelWhileUpdating = updatedNodes.length > 10;\n\n    let treeOutlineContainerElement;\n    let originalScrollTop;\n    if (hidePanelWhileUpdating) {\n      treeOutlineContainerElement = (this.element.parentNode as Element | null);\n      originalScrollTop = treeOutlineContainerElement ? treeOutlineContainerElement.scrollTop : 0;\n      this.elementInternal.classList.add('hidden');\n    }\n    const rootNodeUpdateRecords = this.rootDOMNodeInternal && this.updateRecords.get(this.rootDOMNodeInternal);\n    if (rootNodeUpdateRecords && rootNodeUpdateRecords.hasChangedChildren()) {\n      // Document's children have changed, perform total update.\n      this.update();\n    } else {\n      for (const [node, record] of this.updateRecords) {\n        if (record.hasChangedChildren()) {\n          this.updateModifiedParentNode((node as SDK.DOMModel.DOMNode));\n        } else {\n          this.updateModifiedNode((node as SDK.DOMModel.DOMNode));\n        }\n      }\n    }\n\n    if (hidePanelWhileUpdating) {\n      this.elementInternal.classList.remove('hidden');\n      if (treeOutlineContainerElement && originalScrollTop) {\n        treeOutlineContainerElement.scrollTop = originalScrollTop;\n      }\n    }\n\n    this.updateRecords.clear();\n    this.fireElementsTreeUpdated(updatedNodes);\n  }\n\n  private updateModifiedNode(node: SDK.DOMModel.DOMNode): void {\n    const treeElement = this.findTreeElement(node);\n    if (treeElement) {\n      treeElement.updateTitle(this.updateRecordForHighlight(node));\n    }\n  }\n\n  private updateModifiedParentNode(node: SDK.DOMModel.DOMNode): void {\n    const parentTreeElement = this.findTreeElement(node);\n    if (parentTreeElement) {\n      parentTreeElement.setExpandable(this.hasVisibleChildren(node));\n      parentTreeElement.updateTitle(this.updateRecordForHighlight(node));\n      if (populatedTreeElements.has(parentTreeElement)) {\n        this.updateChildren(parentTreeElement);\n      }\n    }\n  }\n\n  populateTreeElement(treeElement: ElementsTreeElement): Promise<void> {\n    if (treeElement.childCount() || !treeElement.isExpandable()) {\n      return Promise.resolve();\n    }\n\n    return new Promise<void>(resolve => {\n             treeElement.node().getChildNodes(() => {\n               populatedTreeElements.add(treeElement);\n               this.updateModifiedParentNode(treeElement.node());\n               resolve();\n             });\n           })\n        .then(() => {\n          if (treeElement.node().nodeName() === 'BODY') {\n            void this.createTopLayerContainer(treeElement);\n          }\n        });\n  }\n\n  async createTopLayerContainer(bodyElement: ElementsTreeElement): Promise<void> {\n    if (!this.topLayerContainer) {\n      this.topLayerContainer = new TopLayerContainer(bodyElement);\n    }\n    this.topLayerContainer.updateBody(bodyElement);\n    await this.updateTopLayerContainer();\n  }\n\n  async updateTopLayerContainer(): Promise<void> {\n    if (this.topLayerContainer) {\n      const bodyElement = this.topLayerContainer.bodyElement;\n      if (!bodyElement.children().includes(this.topLayerContainer) && !this.topLayerContainer.parent &&\n          !this.topLayerContainer.treeOutline) {\n        bodyElement.insertChild(this.topLayerContainer, bodyElement.childCount() - 1);\n      }\n      this.topLayerContainer.removeChildren();\n      const topLayerElementsExists = await this.topLayerContainer.addTopLayerElementsAsChildren();\n      if (!topLayerElementsExists) {\n        bodyElement.removeChild(this.topLayerContainer);\n      }\n    }\n  }\n\n  private createElementTreeElement(node: SDK.DOMModel.DOMNode, isClosingTag?: boolean): ElementsTreeElement {\n    const treeElement = new ElementsTreeElement(node, isClosingTag);\n    treeElement.setExpandable(!isClosingTag && this.hasVisibleChildren(node));\n    if (node.nodeType() === Node.ELEMENT_NODE && node.parentNode && node.parentNode.nodeType() === Node.DOCUMENT_NODE &&\n        !node.parentNode.parentNode) {\n      treeElement.setCollapsible(false);\n    }\n\n    if (node.hasAssignedSlot()) {\n      treeElement.createSlotLink(node.assignedSlot);\n    }\n\n    treeElement.selectable = Boolean(this.selectEnabled);\n    return treeElement;\n  }\n\n  private showChild(treeElement: ElementsTreeElement, child: SDK.DOMModel.DOMNode): ElementsTreeElement|null {\n    if (treeElement.isClosingTag()) {\n      return null;\n    }\n\n    const index = this.visibleChildren(treeElement.node()).indexOf(child);\n    if (index === -1) {\n      return null;\n    }\n\n    if (index >= treeElement.expandedChildrenLimit()) {\n      this.setExpandedChildrenLimit(treeElement, index + 1);\n    }\n    return treeElement.childAt(index) as ElementsTreeElement;\n  }\n\n  private visibleChildren(node: SDK.DOMModel.DOMNode): SDK.DOMModel.DOMNode[] {\n    let visibleChildren = ElementsTreeElement.visibleShadowRoots(node);\n\n    const contentDocument = node.contentDocument();\n    if (contentDocument) {\n      visibleChildren.push(contentDocument);\n    }\n\n    const templateContent = node.templateContent();\n    if (templateContent) {\n      visibleChildren.push(templateContent);\n    }\n\n    visibleChildren.push(...node.pageTransitionPseudoElements());\n\n    const markerPseudoElement = node.markerPseudoElement();\n    if (markerPseudoElement) {\n      visibleChildren.push(markerPseudoElement);\n    }\n\n    const beforePseudoElement = node.beforePseudoElement();\n    if (beforePseudoElement) {\n      visibleChildren.push(beforePseudoElement);\n    }\n\n    if (node.childNodeCount()) {\n      // Children may be stale when the outline is not wired to receive DOMModel updates.\n      let children: SDK.DOMModel.DOMNode[] = node.children() || [];\n      if (!this.showHTMLCommentsSetting.get()) {\n        children = children.filter(n => n.nodeType() !== Node.COMMENT_NODE);\n      }\n      visibleChildren = visibleChildren.concat(children);\n    }\n\n    const afterPseudoElement = node.afterPseudoElement();\n    if (afterPseudoElement) {\n      visibleChildren.push(afterPseudoElement);\n    }\n\n    return visibleChildren;\n  }\n\n  private hasVisibleChildren(node: SDK.DOMModel.DOMNode): boolean {\n    if (node.isIframe()) {\n      return true;\n    }\n    if (node.isPortal()) {\n      return true;\n    }\n    if (node.contentDocument()) {\n      return true;\n    }\n    if (node.templateContent()) {\n      return true;\n    }\n    if (ElementsTreeElement.visibleShadowRoots(node).length) {\n      return true;\n    }\n    if (node.hasPseudoElements()) {\n      return true;\n    }\n    if (node.isInsertionPoint()) {\n      return true;\n    }\n    return Boolean(node.childNodeCount()) && !ElementsTreeElement.canShowInlineText(node);\n  }\n\n  private createExpandAllButtonTreeElement(treeElement: ElementsTreeElement): UI.TreeOutline.TreeElement {\n    const button = UI.UIUtils.createTextButton('', handleLoadAllChildren.bind(this));\n    button.value = '';\n    const expandAllButtonElement = new UI.TreeOutline.TreeElement(button);\n    expandAllButtonElement.selectable = false;\n    expandAllButtonElement.button = button;\n    return expandAllButtonElement;\n\n    function handleLoadAllChildren(this: ElementsTreeOutline, event: Event): void {\n      const visibleChildCount = this.visibleChildren(treeElement.node()).length;\n      this.setExpandedChildrenLimit(\n          treeElement, Math.max(visibleChildCount, treeElement.expandedChildrenLimit() + InitialChildrenLimit));\n      event.consume();\n    }\n  }\n\n  setExpandedChildrenLimit(treeElement: ElementsTreeElement, expandedChildrenLimit: number): void {\n    if (treeElement.expandedChildrenLimit() === expandedChildrenLimit) {\n      return;\n    }\n\n    treeElement.setExpandedChildrenLimit(expandedChildrenLimit);\n    if (treeElement.treeOutline && !this.treeElementsBeingUpdated.has(treeElement)) {\n      this.updateModifiedParentNode(treeElement.node());\n    }\n  }\n\n  private updateChildren(treeElement: ElementsTreeElement): void {\n    if (!treeElement.isExpandable()) {\n      if (!treeElement.treeOutline) {\n        return;\n      }\n      const selectedTreeElement = treeElement.treeOutline.selectedTreeElement;\n      if (selectedTreeElement && selectedTreeElement.hasAncestor(treeElement)) {\n        treeElement.select(true);\n      }\n      treeElement.removeChildren();\n      return;\n    }\n\n    console.assert(!treeElement.isClosingTag());\n\n    this.innerUpdateChildren(treeElement);\n  }\n\n  insertChildElement(\n      treeElement: ElementsTreeElement|TopLayerContainer, child: SDK.DOMModel.DOMNode, index: number,\n      isClosingTag?: boolean): ElementsTreeElement {\n    const newElement = this.createElementTreeElement(child, isClosingTag);\n    treeElement.insertChild(newElement, index);\n    return newElement;\n  }\n\n  private moveChild(treeElement: ElementsTreeElement, child: ElementsTreeElement, targetIndex: number): void {\n    if (treeElement.indexOfChild(child) === targetIndex) {\n      return;\n    }\n    const wasSelected = child.selected;\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n    treeElement.insertChild(child, targetIndex);\n    if (wasSelected) {\n      child.select();\n    }\n  }\n\n  private innerUpdateChildren(treeElement: ElementsTreeElement): void {\n    if (this.treeElementsBeingUpdated.has(treeElement)) {\n      return;\n    }\n\n    this.treeElementsBeingUpdated.add(treeElement);\n\n    const node = treeElement.node();\n    const visibleChildren = this.visibleChildren(node);\n    const visibleChildrenSet = new Set<SDK.DOMModel.DOMNode>(visibleChildren);\n\n    // Remove any tree elements that no longer have this node as their parent and save\n    // all existing elements that could be reused. This also removes closing tag element.\n    const existingTreeElements = new Map<SDK.DOMModel.DOMNode, UI.TreeOutline.TreeElement&ElementsTreeElement>();\n    for (let i = treeElement.childCount() - 1; i >= 0; --i) {\n      const existingTreeElement = treeElement.childAt(i);\n      if (!(existingTreeElement instanceof ElementsTreeElement)) {\n        // Remove expand all button and shadow host toolbar.\n        treeElement.removeChildAtIndex(i);\n        continue;\n      }\n      const elementsTreeElement = (existingTreeElement as ElementsTreeElement);\n      const existingNode = elementsTreeElement.node();\n\n      if (visibleChildrenSet.has(existingNode)) {\n        existingTreeElements.set(existingNode, existingTreeElement);\n        continue;\n      }\n\n      treeElement.removeChildAtIndex(i);\n    }\n\n    for (let i = 0; i < visibleChildren.length && i < treeElement.expandedChildrenLimit(); ++i) {\n      const child = visibleChildren[i];\n      const existingTreeElement = existingTreeElements.get(child) || this.findTreeElement(child);\n      if (existingTreeElement && existingTreeElement !== treeElement) {\n        // If an existing element was found, just move it.\n        this.moveChild(treeElement, existingTreeElement, i);\n      } else {\n        // No existing element found, insert a new element.\n        const newElement = this.insertChildElement(treeElement, child, i);\n        if (this.updateRecordForHighlight(node) && treeElement.expanded) {\n          ElementsTreeElement.animateOnDOMUpdate(newElement);\n        }\n        // If a node was inserted in the middle of existing list dynamically we might need to increase the limit.\n        if (treeElement.childCount() > treeElement.expandedChildrenLimit()) {\n          this.setExpandedChildrenLimit(treeElement, treeElement.expandedChildrenLimit() + 1);\n        }\n      }\n    }\n\n    // Update expand all button.\n    const expandedChildCount = treeElement.childCount();\n    if (visibleChildren.length > expandedChildCount) {\n      const targetButtonIndex = expandedChildCount;\n      if (!treeElement.expandAllButtonElement) {\n        treeElement.expandAllButtonElement = this.createExpandAllButtonTreeElement(treeElement);\n      }\n      treeElement.insertChild(treeElement.expandAllButtonElement, targetButtonIndex);\n      treeElement.expandAllButtonElement.title =\n          i18nString(UIStrings.showAllNodesDMore, {PH1: visibleChildren.length - expandedChildCount});\n    } else if (treeElement.expandAllButtonElement) {\n      treeElement.expandAllButtonElement = null;\n    }\n\n    // Insert shortcuts to distributed children.\n    if (node.isInsertionPoint()) {\n      for (const distributedNode of node.distributedNodes()) {\n        treeElement.appendChild(new ShortcutTreeElement(distributedNode));\n      }\n    }\n\n    // Insert close tag.\n    if (node.nodeType() === Node.ELEMENT_NODE && !node.pseudoType() && treeElement.isExpandable()) {\n      this.insertChildElement(treeElement, node, treeElement.childCount(), true);\n    }\n\n    this.treeElementsBeingUpdated.delete(treeElement);\n  }\n\n  private markersChanged(event: Common.EventTarget.EventTargetEvent<SDK.DOMModel.DOMNode>): void {\n    const node = event.data;\n    const treeElement = this.treeElementByNode.get(node);\n    if (treeElement) {\n      treeElement.updateDecorations();\n    }\n  }\n\n  private async topLayerElementsChanged(): Promise<void> {\n    await this.updateTopLayerContainer();\n  }\n\n  private static treeOutlineSymbol = Symbol('treeOutline');\n}\n\nexport namespace ElementsTreeOutline {\n  // TODO(crbug.com/1167717): Make this a const enum again\n  // eslint-disable-next-line rulesdir/const_enum\n  export enum Events {\n    SelectedNodeChanged = 'SelectedNodeChanged',\n    ElementsTreeUpdated = 'ElementsTreeUpdated',\n  }\n\n  export type EventTypes = {\n    [Events.SelectedNodeChanged]: {node: SDK.DOMModel.DOMNode|null, focus: boolean},\n    [Events.ElementsTreeUpdated]: SDK.DOMModel.DOMNode[],\n  };\n}\n\n// clang-format off\nexport const MappedCharToEntity = new Map<string, string>([\n  ['\\xA0', 'nbsp'],\n  ['\\xAD', 'shy'],\n  ['\\u2002', 'ensp'],\n  ['\\u2003', 'emsp'],\n  ['\\u2009', 'thinsp'],\n  ['\\u200A', 'hairsp'],\n  ['\\u200B', 'ZeroWidthSpace'],\n  ['\\u200C', 'zwnj'],\n  ['\\u200D', 'zwj'],\n  ['\\u200E', 'lrm'],\n  ['\\u200F', 'rlm'],\n  ['\\u202A', '#x202A'],\n  ['\\u202B', '#x202B'],\n  ['\\u202C', '#x202C'],\n  ['\\u202D', '#x202D'],\n  ['\\u202E', '#x202E'],\n  ['\\u2060', 'NoBreak'],\n  ['\\uFEFF', '#xFEFF'],\n]);\n// clang-format on\n\nexport class UpdateRecord {\n  private modifiedAttributes?: Set<string>;\n  private removedAttributes?: Set<string>;\n  private hasChangedChildrenInternal?: boolean;\n  private hasRemovedChildrenInternal?: boolean;\n  private charDataModifiedInternal?: boolean;\n\n  attributeModified(attrName: string): void {\n    if (this.removedAttributes && this.removedAttributes.has(attrName)) {\n      this.removedAttributes.delete(attrName);\n    }\n    if (!this.modifiedAttributes) {\n      this.modifiedAttributes = (new Set() as Set<string>);\n    }\n    this.modifiedAttributes.add(attrName);\n  }\n\n  attributeRemoved(attrName: string): void {\n    if (this.modifiedAttributes && this.modifiedAttributes.has(attrName)) {\n      this.modifiedAttributes.delete(attrName);\n    }\n    if (!this.removedAttributes) {\n      this.removedAttributes = (new Set() as Set<string>);\n    }\n    this.removedAttributes.add(attrName);\n  }\n\n  nodeInserted(_node: SDK.DOMModel.DOMNode): void {\n    this.hasChangedChildrenInternal = true;\n  }\n\n  nodeRemoved(_node: SDK.DOMModel.DOMNode): void {\n    this.hasChangedChildrenInternal = true;\n    this.hasRemovedChildrenInternal = true;\n  }\n\n  charDataModified(): void {\n    this.charDataModifiedInternal = true;\n  }\n\n  childrenModified(): void {\n    this.hasChangedChildrenInternal = true;\n  }\n\n  isAttributeModified(attributeName: string): boolean {\n    return this.modifiedAttributes !== null && this.modifiedAttributes !== undefined &&\n        this.modifiedAttributes.has(attributeName);\n  }\n\n  hasRemovedAttributes(): boolean {\n    return this.removedAttributes !== null && this.removedAttributes !== undefined &&\n        Boolean(this.removedAttributes.size);\n  }\n\n  isCharDataModified(): boolean {\n    return Boolean(this.charDataModifiedInternal);\n  }\n\n  hasChangedChildren(): boolean {\n    return Boolean(this.hasChangedChildrenInternal);\n  }\n\n  hasRemovedChildren(): boolean {\n    return Boolean(this.hasRemovedChildrenInternal);\n  }\n}\n\nlet rendererInstance: Renderer;\n\nexport class Renderer implements UI.UIUtils.Renderer {\n  static instance(opts: {\n    forceNew: boolean|null,\n  } = {forceNew: null}): Renderer {\n    const {forceNew} = opts;\n    if (!rendererInstance || forceNew) {\n      rendererInstance = new Renderer();\n    }\n    return rendererInstance;\n  }\n\n  async render(object: Object): Promise<{\n    node: Node,\n    tree: UI.TreeOutline.TreeOutline|null,\n  }|null> {\n    let node: SDK.DOMModel.DOMNode|(SDK.DOMModel.DOMNode | null)|null = null;\n\n    if (object instanceof SDK.DOMModel.DOMNode) {\n      node = (object as SDK.DOMModel.DOMNode);\n    } else if (object instanceof SDK.DOMModel.DeferredDOMNode) {\n      node = await (object as SDK.DOMModel.DeferredDOMNode).resolvePromise();\n    }\n\n    if (!node) {\n      // Can't render not-a-node, or couldn't resolve deferred node.\n      return null;\n    }\n\n    const treeOutline = new ElementsTreeOutline(\n        /* omitRootDOMNode: */ false, /* selectEnabled: */ true, /* hideGutter: */ true);\n    treeOutline.rootDOMNode = node;\n    const firstChild = treeOutline.firstChild();\n    if (firstChild && !firstChild.isExpandable()) {\n      treeOutline.element.classList.add('single-node');\n    }\n    treeOutline.setVisible(true);\n    // @ts-ignore used in console_test_runner\n    treeOutline.element.treeElementForTest = firstChild;\n    treeOutline.setShowSelectionOnKeyboardFocus(/* show: */ true, /* preventTabOrder: */ true);\n    return {node: treeOutline.element, tree: treeOutline};\n  }\n}\n\nexport class ShortcutTreeElement extends UI.TreeOutline.TreeElement {\n  private readonly nodeShortcut: SDK.DOMModel.DOMNodeShortcut;\n  private hoveredInternal?: boolean;\n  constructor(nodeShortcut: SDK.DOMModel.DOMNodeShortcut) {\n    super('');\n    this.listItemElement.createChild('div', 'selection fill');\n    const title = this.listItemElement.createChild('span', 'elements-tree-shortcut-title');\n    let text = nodeShortcut.nodeName.toLowerCase();\n    if (nodeShortcut.nodeType === Node.ELEMENT_NODE) {\n      text = '<' + text + '>';\n    }\n    title.textContent = '\\u21AA ' + text;\n\n    const link = (linkifyDeferredNodeReference(nodeShortcut.deferredNode) as Element);\n    UI.UIUtils.createTextChild(this.listItemElement, ' ');\n    link.classList.add('elements-tree-shortcut-link');\n    link.textContent = i18nString(UIStrings.reveal);\n    this.listItemElement.appendChild(link);\n    this.nodeShortcut = nodeShortcut;\n  }\n\n  get hovered(): boolean {\n    return Boolean(this.hoveredInternal);\n  }\n\n  set hovered(x: boolean) {\n    if (this.hoveredInternal === x) {\n      return;\n    }\n    this.hoveredInternal = x;\n    this.listItemElement.classList.toggle('hovered', x);\n  }\n\n  deferredNode(): SDK.DOMModel.DeferredDOMNode {\n    return this.nodeShortcut.deferredNode;\n  }\n\n  domModel(): SDK.DOMModel.DOMModel {\n    return this.nodeShortcut.deferredNode.domModel();\n  }\n\n  onselect(selectedByUser?: boolean): boolean {\n    if (!selectedByUser) {\n      return true;\n    }\n    this.nodeShortcut.deferredNode.highlight();\n    this.nodeShortcut.deferredNode.resolve(resolved.bind(this));\n    function resolved(this: ShortcutTreeElement, node: SDK.DOMModel.DOMNode|null): void {\n      if (node && this.treeOutline instanceof ElementsTreeOutline) {\n        this.treeOutline.selectedDOMNodeInternal = node;\n        this.treeOutline.selectedNodeChanged(false);\n      }\n    }\n    return true;\n  }\n}\n\nexport interface MultilineEditorController {\n  cancel: () => void;\n  commit: () => void;\n  resize: () => void;\n}\n\nexport interface ClipboardData {\n  node: SDK.DOMModel.DOMNode;\n  isCut: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
