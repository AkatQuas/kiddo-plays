{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/elements/TopLayerContainer.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport * as ElementsComponents from './components/components.js';\nimport * as ElementsTreeOutline from './ElementsTreeOutline.js';\n\nimport type {ElementsTreeElement} from './ElementsTreeElement.js';\n\nconst UIStrings = {\n  /**\n   * @description Top layer is rendered closest to the user within a viewport, therefore its elements always appear on top of all other content\n   */\n  topLayer: 'top-layer',\n};\n\nconst str_ = i18n.i18n.registerUIStrings('panels/elements/TopLayerContainer.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nexport class TopLayerContainer extends UI.TreeOutline.TreeElement {\n  treeOutline: ElementsTreeOutline.ElementsTreeOutline|null;\n  domModel: SDK.DOMModel.DOMModel;\n  currentTopLayerElements: Set<ElementsTreeElement>;\n  bodyElement: ElementsTreeElement;\n\n  constructor(bodyElement: ElementsTreeElement) {\n    super('#top-layer');\n    this.bodyElement = bodyElement;\n    this.domModel = bodyElement.node().domModel();\n    this.treeOutline = null;\n    this.currentTopLayerElements = new Set();\n  }\n\n  updateBody(bodyElement: ElementsTreeElement): void {\n    this.bodyElement = bodyElement;\n  }\n\n  async addTopLayerElementsAsChildren(): Promise<boolean> {\n    this.removeCurrentTopLayerElementsAdorners();\n    this.currentTopLayerElements = new Set();\n    const newTopLayerElementsIDs = await this.domModel.getTopLayerElements();\n    if (newTopLayerElementsIDs === null) {\n      return false;\n    }\n    let topLayerElementIndex = 0;\n    if (newTopLayerElementsIDs) {\n      for (const elementID of newTopLayerElementsIDs) {\n        const topLayerDOMNode = this.domModel.idToDOMNode.get(elementID);\n        // Will need to add support for backdrop in the future.\n        if (topLayerDOMNode && topLayerDOMNode.nodeName() !== '::backdrop') {\n          topLayerElementIndex++;\n          const topLayerElementShortcut = new SDK.DOMModel.DOMNodeShortcut(\n              this.domModel.target(), topLayerDOMNode.backendNodeId(), 0, topLayerDOMNode.nodeName());\n          const topLayerTreeElement = this.treeOutline?.treeElementByNode.get(topLayerDOMNode);\n          const topLayerElementRepresentation = new ElementsTreeOutline.ShortcutTreeElement(topLayerElementShortcut);\n          if (topLayerTreeElement && !this.currentTopLayerElements.has(topLayerTreeElement)) {\n            this.appendChild(topLayerElementRepresentation);\n            this.addTopLayerAdorner(topLayerTreeElement, topLayerElementRepresentation, topLayerElementIndex);\n            this.currentTopLayerElements.add(topLayerTreeElement);\n          }\n        }\n      }\n    }\n    return topLayerElementIndex > 0;\n  }\n\n  private removeCurrentTopLayerElementsAdorners(): void {\n    for (const topLayerElement of this.currentTopLayerElements) {\n      topLayerElement.removeAllAdorners();\n    }\n  }\n\n  private addTopLayerAdorner(\n      element: ElementsTreeElement, topLayerElementRepresentation: ElementsTreeOutline.ShortcutTreeElement,\n      topLayerElementIndex: number): void {\n    const config = ElementsComponents.AdornerManager.getRegisteredAdorner(\n        ElementsComponents.AdornerManager.RegisteredAdorners.TOP_LAYER);\n    const adornerContent = document.createElement('span');\n    adornerContent.textContent = ` top-layer (${topLayerElementIndex}) `;\n    const adorner = element?.adorn(config, adornerContent);\n    if (adorner) {\n      const onClick = (((): void => {\n                         topLayerElementRepresentation.revealAndSelect();\n                       }) as EventListener);\n      adorner.addInteraction(onClick, {\n        isToggle: false,\n        shouldPropagateOnKeydown: false,\n        ariaLabelDefault: i18nString(UIStrings.topLayer),\n        ariaLabelActive: i18nString(UIStrings.topLayer),\n      });\n      adorner.addEventListener('mousedown', e => e.consume(), false);\n    }\n  }\n}\n"],
  "mappings": "AAGA;AACA;AACA;AAEA;AACA;AAIA,MAAM,YAAY;AAAA,EAIhB,UAAU;AAAA;AAGZ,MAAM,OAAO,KAAK,KAAK,kBAAkB,wCAAwC;AACjF,MAAM,aAAa,KAAK,KAAK,mBAAmB,KAAK,QAAW;AAEzD,uCAAgC,GAAG,YAAY,YAAY;AAAA,EAChE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,aAAkC;AAC5C,UAAM;AACN,SAAK,cAAc;AACnB,SAAK,WAAW,YAAY,OAAO;AACnC,SAAK,cAAc;AACnB,SAAK,0BAA0B,oBAAI;AAAA;AAAA,EAGrC,WAAW,aAAwC;AACjD,SAAK,cAAc;AAAA;AAAA,QAGf,gCAAkD;AACtD,SAAK;AACL,SAAK,0BAA0B,oBAAI;AACnC,UAAM,yBAAyB,MAAM,KAAK,SAAS;AACnD,QAAI,2BAA2B,MAAM;AACnC,aAAO;AAAA;AAET,QAAI,uBAAuB;AAC3B,QAAI,wBAAwB;AAC1B,iBAAW,aAAa,wBAAwB;AAC9C,cAAM,kBAAkB,KAAK,SAAS,YAAY,IAAI;AAEtD,YAAI,mBAAmB,gBAAgB,eAAe,cAAc;AAClE;AACA,gBAAM,0BAA0B,IAAI,IAAI,SAAS,gBAC7C,KAAK,SAAS,UAAU,gBAAgB,iBAAiB,GAAG,gBAAgB;AAChF,gBAAM,sBAAsB,KAAK,aAAa,kBAAkB,IAAI;AACpE,gBAAM,gCAAgC,IAAI,oBAAoB,oBAAoB;AAClF,cAAI,uBAAuB,CAAC,KAAK,wBAAwB,IAAI,sBAAsB;AACjF,iBAAK,YAAY;AACjB,iBAAK,mBAAmB,qBAAqB,+BAA+B;AAC5E,iBAAK,wBAAwB,IAAI;AAAA;AAAA;AAAA;AAAA;AAKzC,WAAO,uBAAuB;AAAA;AAAA,EAGxB,wCAA8C;AACpD,eAAW,mBAAmB,KAAK,yBAAyB;AAC1D,sBAAgB;AAAA;AAAA;AAAA,EAIZ,mBACJ,SAA8B,+BAC9B,sBAAoC;AACtC,UAAM,SAAS,mBAAmB,eAAe,qBAC7C,mBAAmB,eAAe,mBAAmB;AACzD,UAAM,iBAAiB,SAAS,cAAc;AAC9C,mBAAe,cAAc,eAAe;AAC5C,UAAM,UAAU,SAAS,MAAM,QAAQ;AACvC,QAAI,SAAS;AACX,YAAM,UAAY,MAAY;AACX,sCAA8B;AAAA;AAEjD,cAAQ,eAAe,SAAS;AAAA,QAC9B,UAAU;AAAA,QACV,0BAA0B;AAAA,QAC1B,kBAAkB,WAAW,UAAU;AAAA,QACvC,iBAAiB,WAAW,UAAU;AAAA;AAExC,cAAQ,iBAAiB,aAAa,OAAK,EAAE,WAAW;AAAA;AAAA;AAAA;",
  "names": []
}
