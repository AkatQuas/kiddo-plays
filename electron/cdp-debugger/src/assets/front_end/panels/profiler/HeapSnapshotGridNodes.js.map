{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/profiler/HeapSnapshotGridNodes.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\nimport * as DataGrid from '../../ui/legacy/components/data_grid/data_grid.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport type {ChildrenProvider} from './ChildrenProvider.js';\nimport type {\n  AllocationDataGrid, HeapSnapshotConstructorsDataGrid, HeapSnapshotDiffDataGrid, HeapSnapshotSortableDataGrid} from\n  './HeapSnapshotDataGrids.js';\nimport {HeapSnapshotSortableDataGridEvents} from './HeapSnapshotDataGrids.js';\nimport type {HeapSnapshotProviderProxy, HeapSnapshotProxy} from './HeapSnapshotProxy.js';\nimport type {DataDisplayDelegate} from './ProfileHeader.js';\n\nconst UIStrings = {\n  /**\n  *@description Generic text with two placeholders separated by a comma\n  *@example {1 613 680} PH1\n  *@example {44 %} PH2\n  */\n  genericStringsTwoPlaceholders: '{PH1}, {PH2}',\n  /**\n  *@description Text in Heap Snapshot Grid Nodes of a profiler tool\n  */\n  internalArray: '(internal array)[]',\n  /**\n  *@description Text in Heap Snapshot Grid Nodes of a profiler tool\n  */\n  userObjectReachableFromWindow: 'User object reachable from window',\n  /**\n  *@description Text in Heap Snapshot Grid Nodes of a profiler tool\n  */\n  detachedFromDomTree: 'Detached from DOM tree',\n  /**\n  *@description Text in Heap Snapshot Grid Nodes of a profiler tool\n  */\n  previewIsNotAvailable: 'Preview is not available',\n  /**\n  *@description A context menu item in the Heap Profiler Panel of a profiler tool\n  */\n  revealInSummaryView: 'Reveal in Summary view',\n  /**\n  *@description Text for the summary view\n  */\n  summary: 'Summary',\n  /**\n  *@description A context menu item in the Heap Profiler Panel of a profiler tool\n  *@example {SomeClassConstructor} PH1\n  *@example {12345} PH2\n  */\n  revealObjectSWithIdSInSummary: 'Reveal object \\'\\'{PH1}\\'\\' with id @{PH2} in Summary view',\n  /**\n  *@description Text to store an HTML element or JavaScript variable or expression result as a global variable\n  */\n  storeAsGlobalVariable: 'Store as global variable',\n  /**\n  *@description Text in Heap Snapshot Grid Nodes of a profiler tool that indicates an element contained in another\n  * element.\n  */\n  inElement: 'in',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/profiler/HeapSnapshotGridNodes.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\n\nclass HeapSnapshotGridNodeBase extends DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode> {}\n\nexport class HeapSnapshotGridNode extends\n    Common.ObjectWrapper.eventMixin<HeapSnapshotGridNode.EventTypes, typeof HeapSnapshotGridNodeBase>(\n        HeapSnapshotGridNodeBase) {\n  dataGridInternal: HeapSnapshotSortableDataGrid;\n  instanceCount: number;\n  readonly savedChildren: Map<number, HeapSnapshotGridNode>;\n  retrievedChildrenRanges: {\n    from: number,\n    to: number,\n  }[];\n  providerObject: ChildrenProvider|null;\n  reachableFromWindow: boolean;\n  populated?: boolean;\n\n  constructor(tree: HeapSnapshotSortableDataGrid, hasChildren: boolean) {\n    super(null, hasChildren);\n    this.dataGridInternal = tree;\n    this.instanceCount = 0;\n\n    this.savedChildren = new Map();\n\n    /**\n     * List of position ranges for all visible nodes: [startPos1, endPos1),...,[startPosN, endPosN)\n     * Position is an item position in the provider.\n     */\n    this.retrievedChildrenRanges = [];\n\n    this.providerObject = null;\n    this.reachableFromWindow = false;\n  }\n\n  get name(): string|undefined {\n    return undefined;\n  }\n\n  heapSnapshotDataGrid(): HeapSnapshotSortableDataGrid {\n    return this.dataGridInternal;\n  }\n\n  createProvider(): ChildrenProvider {\n    throw new Error('Not implemented.');\n  }\n\n  comparator(): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    throw new Error('Not implemented.');\n  }\n\n  getHash(): number {\n    throw new Error('Not implemented.');\n  }\n  createChildNode(_item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotGridNode {\n    throw new Error('Not implemented.');\n  }\n\n  retainersDataSource(): {\n    snapshot: HeapSnapshotProxy,\n    snapshotNodeIndex: number,\n  }|null {\n    return null;\n  }\n\n  provider(): ChildrenProvider {\n    if (!this.providerObject) {\n      this.providerObject = this.createProvider();\n    }\n    return this.providerObject;\n  }\n\n  createCell(columnId: string): HTMLElement {\n    return super.createCell(columnId);\n  }\n\n  collapse(): void {\n    super.collapse();\n    this.dataGridInternal.updateVisibleNodes(true);\n  }\n\n  expand(): void {\n    super.expand();\n    this.dataGridInternal.updateVisibleNodes(true);\n  }\n\n  dispose(): void {\n    if (this.providerObject) {\n      this.providerObject.dispose();\n    }\n    for (let node: (HeapSnapshotGridNode|null) = (this.children[0] as HeapSnapshotGridNode | null); node;\n         node = (node.traverseNextNode(true, this, true) as HeapSnapshotGridNode | null)) {\n      node.dispose();\n    }\n  }\n\n  queryObjectContent(_heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel, _objectGroupName: string):\n      Promise<SDK.RemoteObject.RemoteObject> {\n    throw new Error('Not implemented.');\n  }\n\n  tryQueryObjectContent(_heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel, _objectGroupName: string):\n      Promise<SDK.RemoteObject.RemoteObject|null> {\n    throw new Error('Not implemented.');\n  }\n\n  populateContextMenu(\n      _contextMenu: UI.ContextMenu.ContextMenu, _dataDisplayDelegate: DataDisplayDelegate,\n      _heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null): void {\n  }\n\n  toPercentString(num: number): string {\n    return num.toFixed(0) + '\\xa0%';  // \\xa0 is a non-breaking space.\n  }\n\n  toUIDistance(distance: number): string {\n    const baseSystemDistance = HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance;\n    return distance >= 0 && distance < baseSystemDistance ? distance.toString() : '\\u2212';\n  }\n\n  allChildren(): HeapSnapshotGridNode[] {\n    return this.dataGridInternal.allChildren(this) as HeapSnapshotGridNode[];\n  }\n\n  removeChildByIndex(index: number): void {\n    this.dataGridInternal.removeChildByIndex(this, index);\n  }\n\n  childForPosition(nodePosition: number): HeapSnapshotGridNode|null {\n    let indexOfFirstChildInRange = 0;\n    for (let i = 0; i < this.retrievedChildrenRanges.length; i++) {\n      const range = this.retrievedChildrenRanges[i];\n      if (range.from <= nodePosition && nodePosition < range.to) {\n        const childIndex = indexOfFirstChildInRange + nodePosition - range.from;\n        return this.allChildren()[childIndex];\n      }\n      indexOfFirstChildInRange += range.to - range.from + 1;\n    }\n    return null;\n  }\n\n  createValueCell(columnId: string): HTMLElement {\n    const cell = (UI.Fragment.html`<td class=\"numeric-column\" />` as HTMLElement);\n    const dataGrid = (this.dataGrid as HeapSnapshotSortableDataGrid);\n    if (dataGrid.snapshot && dataGrid.snapshot.totalSize !== 0) {\n      const div = document.createElement('div');\n      const valueSpan = UI.Fragment.html`<span>${this.data[columnId]}</span>`;\n      div.appendChild(valueSpan);\n      const percentColumn = columnId + '-percent';\n      if (percentColumn in this.data) {\n        const percentSpan = UI.Fragment.html`<span class=\"percent-column\">${this.data[percentColumn]}</span>`;\n        div.appendChild(percentSpan);\n        div.classList.add('profile-multiple-values');\n        UI.ARIAUtils.markAsHidden(valueSpan);\n        UI.ARIAUtils.markAsHidden(percentSpan);\n        this.setCellAccessibleName(\n            i18nString(\n                UIStrings.genericStringsTwoPlaceholders, {PH1: this.data[columnId], PH2: this.data[percentColumn]}),\n            cell, columnId);\n      }\n      cell.appendChild(div);\n    }\n    return cell;\n  }\n\n  populate(): void {\n    if (this.populated) {\n      return;\n    }\n    this.populated = true;\n    void this.provider().sortAndRewind(this.comparator()).then(() => this.populateChildren());\n  }\n\n  expandWithoutPopulate(): Promise<void> {\n    // Make sure default populate won't take action.\n    this.populated = true;\n    this.expand();\n    return this.provider().sortAndRewind(this.comparator());\n  }\n\n  childHashForEntity(entity: HeapSnapshotModel.HeapSnapshotModel.Node|\n                     HeapSnapshotModel.HeapSnapshotModel.Edge): number {\n    if ('edgeIndex' in entity) {\n      return entity.edgeIndex;\n    }\n    return entity.id;\n  }\n\n  populateChildren(fromPosition?: number|null, toPosition?: number|null): Promise<void> {\n    return new Promise(resolve => {\n      fromPosition = fromPosition || 0;\n      toPosition = toPosition || fromPosition + this.dataGridInternal.defaultPopulateCount();\n      let firstNotSerializedPosition: number = fromPosition;\n      serializeNextChunk.call(this, toPosition);\n\n      function serializeNextChunk(this: HeapSnapshotGridNode, toPosition: number): void {\n        if (firstNotSerializedPosition >= toPosition) {\n          return;\n        }\n        const end = Math.min(firstNotSerializedPosition + this.dataGridInternal.defaultPopulateCount(), toPosition);\n        void this.provider()\n            .serializeItemsRange(firstNotSerializedPosition, end)\n            .then(itemsRange => childrenRetrieved.call(this, itemsRange, toPosition));\n        firstNotSerializedPosition = end;\n      }\n\n      function insertRetrievedChild(\n          this: HeapSnapshotGridNode,\n          item: HeapSnapshotModel.HeapSnapshotModel.Node|HeapSnapshotModel.HeapSnapshotModel.Edge,\n          insertionIndex: number): void {\n        if (this.savedChildren) {\n          const hash = this.childHashForEntity(item);\n          const child = this.savedChildren.get(hash);\n          if (child) {\n            this.dataGridInternal.insertChild(this, child, insertionIndex);\n            return;\n          }\n        }\n        this.dataGridInternal.insertChild(this, this.createChildNode(item), insertionIndex);\n      }\n\n      function insertShowMoreButton(\n          this: HeapSnapshotGridNode, from: number, to: number, insertionIndex: number): void {\n        const button = (new DataGrid.ShowMoreDataGridNode.ShowMoreDataGridNode(\n            this.populateChildren.bind(this), from, to, this.dataGridInternal.defaultPopulateCount()));\n        this.dataGridInternal.insertChild(this, (button as unknown as HeapSnapshotGridNode), insertionIndex);\n      }\n\n      function childrenRetrieved(\n          this: HeapSnapshotGridNode, itemsRange: HeapSnapshotModel.HeapSnapshotModel.ItemsRange,\n          toPosition: number): void {\n        let itemIndex = 0;\n        let itemPosition: number = itemsRange.startPosition;\n        const items = itemsRange.items;\n        let insertionIndex = 0;\n\n        if (!this.retrievedChildrenRanges.length) {\n          if (itemsRange.startPosition > 0) {\n            this.retrievedChildrenRanges.push({from: 0, to: 0});\n            insertShowMoreButton.call(this, 0, itemsRange.startPosition, insertionIndex++);\n          }\n          this.retrievedChildrenRanges.push({from: itemsRange.startPosition, to: itemsRange.endPosition});\n          for (let i = 0, l = items.length; i < l; ++i) {\n            insertRetrievedChild.call(this, items[i], insertionIndex++);\n          }\n          if (itemsRange.endPosition < itemsRange.totalLength) {\n            insertShowMoreButton.call(this, itemsRange.endPosition, itemsRange.totalLength, insertionIndex++);\n          }\n        } else {\n          let rangeIndex = 0;\n          let found = false;\n          let range: {\n            from: number,\n            to: number,\n          } = {from: 0, to: 0};\n          while (rangeIndex < this.retrievedChildrenRanges.length) {\n            range = this.retrievedChildrenRanges[rangeIndex];\n            if (range.to >= itemPosition) {\n              found = true;\n              break;\n            }\n            insertionIndex += range.to - range.from;\n            // Skip the button if there is one.\n            if (range.to < itemsRange.totalLength) {\n              insertionIndex += 1;\n            }\n            ++rangeIndex;\n          }\n\n          if (!found || itemsRange.startPosition < range.from) {\n            // Update previous button.\n            const button =\n                this.allChildren()[insertionIndex - 1] as unknown as DataGrid.ShowMoreDataGridNode.ShowMoreDataGridNode;\n            button.setEndPosition(itemsRange.startPosition);\n            insertShowMoreButton.call(\n                this, itemsRange.startPosition, found ? range.from : itemsRange.totalLength, insertionIndex);\n            range = {from: itemsRange.startPosition, to: itemsRange.startPosition};\n            if (!found) {\n              rangeIndex = this.retrievedChildrenRanges.length;\n            }\n            this.retrievedChildrenRanges.splice(rangeIndex, 0, range);\n          } else {\n            insertionIndex += itemPosition - range.from;\n          }\n          // At this point insertionIndex is always an index before button or between nodes.\n          // Also it is always true here that range.from <= itemPosition <= range.to\n\n          // Stretch the range right bound to include all new items.\n          while (range.to < itemsRange.endPosition) {\n            // Skip already added nodes.\n            const skipCount = range.to - itemPosition;\n            insertionIndex += skipCount;\n            itemIndex += skipCount;\n            itemPosition = range.to;\n\n            // We're at the position before button: ...<?node>x<button>\n            const nextRange = this.retrievedChildrenRanges[rangeIndex + 1];\n            let newEndOfRange: number = nextRange ? nextRange.from : itemsRange.totalLength;\n            if (newEndOfRange > itemsRange.endPosition) {\n              newEndOfRange = itemsRange.endPosition;\n            }\n            while (itemPosition < newEndOfRange) {\n              insertRetrievedChild.call(this, items[itemIndex++], insertionIndex++);\n              ++itemPosition;\n            }\n\n            // Merge with the next range.\n            if (nextRange && newEndOfRange === nextRange.from) {\n              range.to = nextRange.to;\n              // Remove \"show next\" button if there is one.\n              this.removeChildByIndex(insertionIndex);\n              this.retrievedChildrenRanges.splice(rangeIndex + 1, 1);\n            } else {\n              range.to = newEndOfRange;\n              // Remove or update next button.\n              if (newEndOfRange === itemsRange.totalLength) {\n                this.removeChildByIndex(insertionIndex);\n              } else {\n                (this.allChildren()[insertionIndex] as unknown as DataGrid.ShowMoreDataGridNode.ShowMoreDataGridNode)\n                    .setStartPosition(itemsRange.endPosition);\n              }\n            }\n          }\n        }\n\n        // TODO: fix this.\n        this.instanceCount += items.length;\n        if (firstNotSerializedPosition < toPosition) {\n          serializeNextChunk.call(this, toPosition);\n          return;\n        }\n\n        if (this.expanded) {\n          this.dataGridInternal.updateVisibleNodes(true);\n        }\n        resolve();\n        this.dispatchEventToListeners(HeapSnapshotGridNode.Events.PopulateComplete);\n      }\n    });\n  }\n\n  saveChildren(): void {\n    this.savedChildren.clear();\n    const children = this.allChildren();\n    for (let i = 0, l = children.length; i < l; ++i) {\n      const child = children[i];\n      if (!child.expanded) {\n        continue;\n      }\n      this.savedChildren.set(child.getHash(), child);\n    }\n  }\n\n  async sort(): Promise<void> {\n    this.dataGridInternal.recursiveSortingEnter();\n\n    await this.provider().sortAndRewind(this.comparator());\n\n    this.saveChildren();\n    this.dataGridInternal.removeAllChildren(this);\n    this.retrievedChildrenRanges = [];\n    const instanceCount = this.instanceCount;\n    this.instanceCount = 0;\n\n    await this.populateChildren(0, instanceCount);\n\n    for (const child of this.allChildren()) {\n      if (child.expanded) {\n        void child.sort();\n      }\n    }\n    this.dataGridInternal.recursiveSortingLeave();\n  }\n}\n\nexport namespace HeapSnapshotGridNode {\n  // TODO(crbug.com/1167717): Make this a const enum again\n  // eslint-disable-next-line rulesdir/const_enum\n  export enum Events {\n    PopulateComplete = 'PopulateComplete',\n  }\n\n  export type EventTypes = {\n    [Events.PopulateComplete]: void,\n  };\n}\n\nexport abstract class HeapSnapshotGenericObjectNode extends HeapSnapshotGridNode {\n  referenceName?: string|null;\n  readonly nameInternal: string|undefined;\n  readonly type: string|undefined;\n  readonly distance: number|undefined;\n  shallowSize: number|undefined;\n  readonly retainedSize: number|undefined;\n  snapshotNodeId: number|undefined;\n  snapshotNodeIndex: number|undefined;\n  detachedDOMTreeNode: boolean|undefined;\n  linkElement?: Element;\n\n  constructor(dataGrid: HeapSnapshotSortableDataGrid, node: HeapSnapshotModel.HeapSnapshotModel.Node) {\n    super(dataGrid, false);\n    // node is null for DataGrid root nodes.\n    if (!node) {\n      return;\n    }\n    this.referenceName = null;\n    this.nameInternal = node.name;\n    this.type = node.type;\n    this.distance = node.distance;\n    this.shallowSize = node.selfSize;\n    this.retainedSize = node.retainedSize;\n    this.snapshotNodeId = node.id;\n    this.snapshotNodeIndex = node.nodeIndex;\n    if (this.type === 'string') {\n      this.reachableFromWindow = true;\n    } else if (this.type === 'object' && this.nameInternal.startsWith('Window')) {\n      this.nameInternal = this.shortenWindowURL(this.nameInternal, false);\n      this.reachableFromWindow = true;\n    } else if (node.canBeQueried) {\n      this.reachableFromWindow = true;\n    }\n    if (node.detachedDOMTreeNode) {\n      this.detachedDOMTreeNode = true;\n    }\n\n    const snapshot = (dataGrid.snapshot as HeapSnapshotProxy);\n    const shallowSizePercent = this.shallowSize / snapshot.totalSize * 100.0;\n    const retainedSizePercent = this.retainedSize / snapshot.totalSize * 100.0;\n    this.data = {\n      'distance': this.toUIDistance(this.distance),\n      'shallowSize': Platform.NumberUtilities.withThousandsSeparator(this.shallowSize),\n      'retainedSize': Platform.NumberUtilities.withThousandsSeparator(this.retainedSize),\n      'shallowSize-percent': this.toPercentString(shallowSizePercent),\n      'retainedSize-percent': this.toPercentString(retainedSizePercent),\n    };\n  }\n\n  get name(): string|undefined {\n    return this.nameInternal;\n  }\n\n  retainersDataSource(): {\n    snapshot: HeapSnapshotProxy,\n    snapshotNodeIndex: number,\n  }|null {\n    return this.snapshotNodeIndex === undefined ? null : {\n      snapshot: (this.dataGridInternal.snapshot as HeapSnapshotProxy),\n      snapshotNodeIndex: this.snapshotNodeIndex,\n    };\n  }\n\n  createCell(columnId: string): HTMLElement {\n    const cell = columnId !== 'object' ? this.createValueCell(columnId) : this.createObjectCell();\n    return cell;\n  }\n\n  createObjectCell(): HTMLElement {\n    let value: string|(string | undefined) = this.nameInternal;\n    let valueStyle = 'object';\n    switch (this.type) {\n      case 'concatenated string':\n      case 'string':\n        value = `\"${value}\"`;\n        valueStyle = 'string';\n        break;\n      case 'regexp':\n        value = `/${value}/`;\n        valueStyle = 'string';\n        break;\n      case 'closure':\n        value = `${value}()`;\n        valueStyle = 'function';\n        break;\n      case 'bigint':\n        valueStyle = 'bigint';\n        break;\n      case 'number':\n        valueStyle = 'number';\n        break;\n      case 'hidden':\n      case 'object shape':\n        valueStyle = 'null';\n        break;\n      case 'array':\n        value = value ? `${value}[]` : i18nString(UIStrings.internalArray);\n        break;\n    }\n    return this.createObjectCellWithValue(valueStyle, value || '');\n  }\n\n  createObjectCellWithValue(valueStyle: string, value: string): HTMLElement {\n    const fragment = UI.Fragment.Fragment.build`\n  <td class=\"object-column disclosure\">\n  <div class=\"source-code event-properties\" style=\"overflow: visible;\" $=\"container\">\n  <span class=\"value object-value-${valueStyle}\">${value}</span>\n  <span class=\"object-value-id\">@${this.snapshotNodeId}</span>\n  </div>\n  </td>`;\n    const div = fragment.$('container');\n    this.prefixObjectCell(div);\n    if (this.reachableFromWindow) {\n      div.appendChild(UI.Fragment.html`<span class=\"heap-object-tag\" title=\"${\n          i18nString(UIStrings.userObjectReachableFromWindow)}\">\uD83D\uDDD6</span>`);\n    }\n    if (this.detachedDOMTreeNode) {\n      div.appendChild(UI.Fragment.html`<span class=\"heap-object-tag\" title=\"${\n          i18nString(UIStrings.detachedFromDomTree)}\">\u2700</span>`);\n    }\n    void this.appendSourceLocation(div);\n    const cell = (fragment.element() as HTMLElement);\n    if (this.depth) {\n      cell.style.setProperty(\n          'padding-left', (this.depth * (this.dataGrid as HeapSnapshotSortableDataGrid).indentWidth) + 'px');\n    }\n    return cell;\n  }\n\n  prefixObjectCell(_div: Element): void {\n  }\n\n  async appendSourceLocation(div: Element): Promise<void> {\n    const linkContainer = UI.Fragment.html`<span class=\"heap-object-source-link\" />`;\n    div.appendChild(linkContainer);\n    const link = await this.dataGridInternal.dataDisplayDelegate().linkifyObject((this.snapshotNodeIndex as number));\n    if (link) {\n      linkContainer.appendChild(link);\n      this.linkElement = link;\n    } else {\n      linkContainer.remove();\n    }\n  }\n\n  async queryObjectContent(heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel, objectGroupName: string):\n      Promise<SDK.RemoteObject.RemoteObject> {\n    const remoteObject = await this.tryQueryObjectContent(heapProfilerModel, objectGroupName);\n    return remoteObject ||\n        heapProfilerModel.runtimeModel().createRemoteObjectFromPrimitiveValue(\n            i18nString(UIStrings.previewIsNotAvailable));\n  }\n\n  async tryQueryObjectContent(heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel, objectGroupName: string):\n      Promise<SDK.RemoteObject.RemoteObject|null> {\n    if (this.type === 'string') {\n      return heapProfilerModel.runtimeModel().createRemoteObjectFromPrimitiveValue(this.nameInternal);\n    }\n    return await heapProfilerModel.objectForSnapshotObjectId(\n        String(this.snapshotNodeId) as Protocol.HeapProfiler.HeapSnapshotObjectId, objectGroupName);\n  }\n\n  async updateHasChildren(): Promise<void> {\n    const isEmpty = await this.provider().isEmpty();\n    this.setHasChildren(!isEmpty);\n  }\n\n  shortenWindowURL(fullName: string, hasObjectId: boolean): string {\n    const startPos = fullName.indexOf('/');\n    const endPos = hasObjectId ? fullName.indexOf('@') : fullName.length;\n    if (startPos === -1 || endPos === -1) {\n      return fullName;\n    }\n    const fullURL = fullName.substring(startPos + 1, endPos).trimLeft();\n    let url = Platform.StringUtilities.trimURL(fullURL);\n    if (url.length > 40) {\n      url = Platform.StringUtilities.trimMiddle(url, 40);\n    }\n    return fullName.substr(0, startPos + 2) + url + fullName.substr(endPos);\n  }\n\n  populateContextMenu(\n      contextMenu: UI.ContextMenu.ContextMenu, dataDisplayDelegate: DataDisplayDelegate,\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null): void {\n    contextMenu.revealSection().appendItem(i18nString(UIStrings.revealInSummaryView), () => {\n      dataDisplayDelegate.showObject(String(this.snapshotNodeId), i18nString(UIStrings.summary));\n    });\n\n    if (this.referenceName) {\n      for (const match of this.referenceName.matchAll(/\\((?<objectName>[^@)]*) @(?<snapshotNodeId>\\d+)\\)/g)) {\n        const {objectName, snapshotNodeId} = (match.groups as {\n          objectName: string,\n          snapshotNodeId: string,\n        });\n        contextMenu.revealSection().appendItem(\n            i18nString(UIStrings.revealObjectSWithIdSInSummary, {PH1: objectName, PH2: snapshotNodeId}), () => {\n              dataDisplayDelegate.showObject(snapshotNodeId, i18nString(UIStrings.summary));\n            });\n      }\n    }\n\n    if (heapProfilerModel) {\n      contextMenu.revealSection().appendItem(i18nString(UIStrings.storeAsGlobalVariable), async () => {\n        const remoteObject =\n            await this.tryQueryObjectContent((heapProfilerModel as SDK.HeapProfilerModel.HeapProfilerModel), '');\n        if (!remoteObject) {\n          Common.Console.Console.instance().error(i18nString(UIStrings.previewIsNotAvailable));\n        } else {\n          await SDK.ConsoleModel.ConsoleModel.instance().saveToTempVariable(\n              UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext), remoteObject);\n        }\n      });\n    }\n  }\n}\n\nexport class HeapSnapshotObjectNode extends HeapSnapshotGenericObjectNode {\n  referenceName: string;\n  readonly referenceType: string;\n  readonly edgeIndex: number;\n  readonly snapshot: HeapSnapshotProxy;\n  parentObjectNode: HeapSnapshotObjectNode|null;\n  readonly cycledWithAncestorGridNode: HeapSnapshotObjectNode|null;\n\n  constructor(\n      dataGrid: HeapSnapshotSortableDataGrid, snapshot: HeapSnapshotProxy,\n      edge: HeapSnapshotModel.HeapSnapshotModel.Edge, parentObjectNode: HeapSnapshotObjectNode|null) {\n    super(dataGrid, edge.node);\n    this.referenceName = edge.name;\n    this.referenceType = edge.type;\n    this.edgeIndex = edge.edgeIndex;\n    this.snapshot = snapshot;\n\n    this.parentObjectNode = parentObjectNode;\n    this.cycledWithAncestorGridNode = this.findAncestorWithSameSnapshotNodeId();\n    if (!this.cycledWithAncestorGridNode) {\n      void this.updateHasChildren();\n    }\n\n    const data = this.data;\n    data['count'] = '';\n    data['addedCount'] = '';\n    data['removedCount'] = '';\n    data['countDelta'] = '';\n    data['addedSize'] = '';\n    data['removedSize'] = '';\n    data['sizeDelta'] = '';\n  }\n\n  retainersDataSource(): {\n    snapshot: HeapSnapshotProxy,\n    snapshotNodeIndex: number,\n  }|null {\n    return this.snapshotNodeIndex === undefined ? null :\n                                                  {snapshot: this.snapshot, snapshotNodeIndex: this.snapshotNodeIndex};\n  }\n\n  createProvider(): HeapSnapshotProviderProxy {\n    if (this.snapshotNodeIndex === undefined) {\n      throw new Error('Cannot create a provider on a root node');\n    }\n    return this.snapshot.createEdgesProvider(this.snapshotNodeIndex);\n  }\n\n  findAncestorWithSameSnapshotNodeId(): HeapSnapshotObjectNode|null {\n    let ancestor: (HeapSnapshotObjectNode|null) = this.parentObjectNode;\n    while (ancestor) {\n      if (ancestor.snapshotNodeId === this.snapshotNodeId) {\n        return ancestor;\n      }\n      ancestor = ancestor.parentObjectNode;\n    }\n    return null;\n  }\n\n  createChildNode(item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotObjectNode {\n    return new HeapSnapshotObjectNode(\n        this.dataGridInternal, this.snapshot, (item as HeapSnapshotModel.HeapSnapshotModel.Edge), this);\n  }\n\n  getHash(): number {\n    return this.edgeIndex;\n  }\n\n  comparator(): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    const sortAscending = this.dataGridInternal.isSortOrderAscending();\n    const sortColumnId = this.dataGridInternal.sortColumnId();\n    switch (sortColumnId) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            '!edgeName', sortAscending, 'retainedSize', false);\n      case 'count':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('!edgeName', true, 'retainedSize', false);\n      case 'shallowSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, '!edgeName', true);\n      case 'retainedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            'retainedSize', sortAscending, '!edgeName', true);\n      case 'distance':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('distance', sortAscending, 'name', true);\n      default:\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('!edgeName', true, 'retainedSize', false);\n    }\n  }\n\n  prefixObjectCell(div: Element): void {\n    let name: string = this.referenceName || '(empty)';\n    let nameClass = 'name';\n    switch (this.referenceType) {\n      case 'context':\n        nameClass = 'object-value-number';\n        break;\n      case 'internal':\n      case 'hidden':\n      case 'weak':\n        nameClass = 'object-value-null';\n        break;\n      case 'element':\n        name = `[${name}]`;\n        break;\n    }\n    if (this.cycledWithAncestorGridNode) {\n      div.classList.add('cycled-ancessor-node');\n    }\n    div.prepend(UI.Fragment.html`<span class=\"property-name ${nameClass}\">${name}</span>\n  <span class=\"grayed\">${this.edgeNodeSeparator()}</span>`);\n  }\n\n  edgeNodeSeparator(): string {\n    return '::';\n  }\n}\n\nexport class HeapSnapshotRetainingObjectNode extends HeapSnapshotObjectNode {\n  constructor(\n      dataGrid: HeapSnapshotSortableDataGrid, snapshot: HeapSnapshotProxy,\n      edge: HeapSnapshotModel.HeapSnapshotModel.Edge, parentRetainingObjectNode: HeapSnapshotRetainingObjectNode|null) {\n    super(dataGrid, snapshot, edge, parentRetainingObjectNode);\n  }\n\n  createProvider(): HeapSnapshotProviderProxy {\n    if (this.snapshotNodeIndex === undefined) {\n      throw new Error('Cannot create providers on root nodes');\n    }\n    return this.snapshot.createRetainingEdgesProvider(this.snapshotNodeIndex);\n  }\n\n  createChildNode(item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotRetainingObjectNode {\n    return new HeapSnapshotRetainingObjectNode(\n        this.dataGridInternal, this.snapshot, (item as HeapSnapshotModel.HeapSnapshotModel.Edge), this);\n  }\n\n  edgeNodeSeparator(): string {\n    // TODO(l10n): improve description or clarify intention.\n    return i18nString(UIStrings.inElement);\n  }\n\n  expand(): void {\n    this.expandRetainersChain(20);\n  }\n\n  expandRetainersChain(maxExpandLevels: number): void {\n    if (!this.populated) {\n      void this.once(HeapSnapshotGridNode.Events.PopulateComplete)\n          .then(() => this.expandRetainersChain(maxExpandLevels));\n      this.populate();\n      return;\n    }\n    super.expand();\n    if (--maxExpandLevels > 0 && this.children.length > 0) {\n      const retainer = (this.children[0] as HeapSnapshotRetainingObjectNode);\n      if ((retainer.distance || 0) > 1) {\n        retainer.expandRetainersChain(maxExpandLevels);\n        return;\n      }\n    }\n    this.dataGridInternal.dispatchEventToListeners(HeapSnapshotSortableDataGridEvents.ExpandRetainersComplete);\n  }\n}\n\nexport class HeapSnapshotInstanceNode extends HeapSnapshotGenericObjectNode {\n  readonly baseSnapshotOrSnapshot: HeapSnapshotProxy;\n  readonly isDeletedNode: boolean;\n  constructor(\n      dataGrid: HeapSnapshotSortableDataGrid, snapshot: HeapSnapshotProxy,\n      node: HeapSnapshotModel.HeapSnapshotModel.Node, isDeletedNode: boolean) {\n    super(dataGrid, node);\n    this.baseSnapshotOrSnapshot = snapshot;\n    this.isDeletedNode = isDeletedNode;\n    void this.updateHasChildren();\n\n    const data = this.data;\n    data['count'] = '';\n    data['countDelta'] = '';\n    data['sizeDelta'] = '';\n    if (this.isDeletedNode) {\n      data['addedCount'] = '';\n      data['addedSize'] = '';\n      data['removedCount'] = '\\u2022';\n      data['removedSize'] = Platform.NumberUtilities.withThousandsSeparator(this.shallowSize || 0);\n    } else {\n      data['addedCount'] = '\\u2022';\n      data['addedSize'] = Platform.NumberUtilities.withThousandsSeparator(this.shallowSize || 0);\n      data['removedCount'] = '';\n      data['removedSize'] = '';\n    }\n  }\n\n  retainersDataSource(): {\n    snapshot: HeapSnapshotProxy,\n    snapshotNodeIndex: number,\n  }|null {\n    return this.snapshotNodeIndex === undefined ?\n        null :\n        {snapshot: this.baseSnapshotOrSnapshot, snapshotNodeIndex: this.snapshotNodeIndex};\n  }\n\n  createProvider(): HeapSnapshotProviderProxy {\n    if (this.snapshotNodeIndex === undefined) {\n      throw new Error('Cannot create providers on root nodes');\n    }\n    return this.baseSnapshotOrSnapshot.createEdgesProvider(this.snapshotNodeIndex);\n  }\n\n  createChildNode(item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotObjectNode {\n    return new HeapSnapshotObjectNode(\n        this.dataGridInternal, this.baseSnapshotOrSnapshot, (item as HeapSnapshotModel.HeapSnapshotModel.Edge), null);\n  }\n\n  getHash(): number {\n    if (this.snapshotNodeId === undefined) {\n      throw new Error('Cannot hash root nodes');\n    }\n    return this.snapshotNodeId;\n  }\n\n  comparator(): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    const sortAscending = this.dataGridInternal.isSortOrderAscending();\n    const sortColumnId = this.dataGridInternal.sortColumnId();\n    switch (sortColumnId) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            '!edgeName', sortAscending, 'retainedSize', false);\n      case 'distance':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            'distance', sortAscending, 'retainedSize', false);\n      case 'count':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('!edgeName', true, 'retainedSize', false);\n      case 'addedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, '!edgeName', true);\n      case 'removedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, '!edgeName', true);\n      case 'shallowSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, '!edgeName', true);\n      case 'retainedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            'retainedSize', sortAscending, '!edgeName', true);\n      default:\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('!edgeName', true, 'retainedSize', false);\n    }\n  }\n}\n\nexport class HeapSnapshotConstructorNode extends HeapSnapshotGridNode {\n  readonly nameInternal: string;\n  readonly nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter;\n  readonly distance: number;\n  readonly count: number;\n  readonly shallowSize: number;\n  readonly retainedSize: number;\n\n  constructor(\n      dataGrid: HeapSnapshotConstructorsDataGrid, className: string,\n      aggregate: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter) {\n    super(dataGrid, aggregate.count > 0);\n    this.nameInternal = className;\n    this.nodeFilter = nodeFilter;\n    this.distance = aggregate.distance;\n    this.count = aggregate.count;\n    this.shallowSize = aggregate.self;\n    this.retainedSize = aggregate.maxRet;\n\n    const snapshot = (dataGrid.snapshot as HeapSnapshotProxy);\n    const retainedSizePercent = this.retainedSize / snapshot.totalSize * 100.0;\n    const shallowSizePercent = this.shallowSize / snapshot.totalSize * 100.0;\n    this.data = {\n      'object': className,\n      'count': Platform.NumberUtilities.withThousandsSeparator(this.count),\n      'distance': this.toUIDistance(this.distance),\n      'shallowSize': Platform.NumberUtilities.withThousandsSeparator(this.shallowSize),\n      'retainedSize': Platform.NumberUtilities.withThousandsSeparator(this.retainedSize),\n      'shallowSize-percent': this.toPercentString(shallowSizePercent),\n      'retainedSize-percent': this.toPercentString(retainedSizePercent),\n    };\n  }\n\n  get name(): string|undefined {\n    return this.nameInternal;\n  }\n\n  createProvider(): HeapSnapshotProviderProxy {\n    return (this.dataGridInternal.snapshot as HeapSnapshotProxy)\n               .createNodesProviderForClass(this.nameInternal, this.nodeFilter) as HeapSnapshotProviderProxy;\n  }\n\n  async populateNodeBySnapshotObjectId(snapshotObjectId: number): Promise<HeapSnapshotGridNode[]> {\n    this.dataGridInternal.resetNameFilter();\n    await this.expandWithoutPopulate();\n\n    const nodePosition = await this.provider().nodePosition(snapshotObjectId);\n    if (nodePosition === -1) {\n      this.collapse();\n      return [];\n    }\n\n    await this.populateChildren(nodePosition, null);\n\n    const node = (this.childForPosition(nodePosition) as HeapSnapshotGridNode | null);\n    return node ? [this, node] : [];\n  }\n\n  filteredOut(filterValue: string): boolean {\n    return this.nameInternal.toLowerCase().indexOf(filterValue) === -1;\n  }\n\n  createCell(columnId: string): HTMLElement {\n    const cell = columnId === 'object' ? super.createCell(columnId) : this.createValueCell(columnId);\n    if (columnId === 'object' && this.count > 1) {\n      cell.appendChild(UI.Fragment.html`<span class=\"objects-count\">\u00D7${this.count}</span>`);\n    }\n    return cell;\n  }\n\n  createChildNode(item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotInstanceNode {\n    return new HeapSnapshotInstanceNode(\n        this.dataGridInternal, (this.dataGridInternal.snapshot as HeapSnapshotProxy),\n        (item as HeapSnapshotModel.HeapSnapshotModel.Node), false);\n  }\n\n  comparator(): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    const sortAscending = this.dataGridInternal.isSortOrderAscending();\n    const sortColumnId = this.dataGridInternal.sortColumnId();\n    switch (sortColumnId) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', sortAscending, 'id', true);\n      case 'distance':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            'distance', sortAscending, 'retainedSize', false);\n      case 'shallowSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, 'id', true);\n      case 'retainedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('retainedSize', sortAscending, 'id', true);\n      default:\n        throw new Error(`Invalid sort column id ${sortColumnId}`);\n    }\n  }\n}\n\nexport class HeapSnapshotDiffNodesProvider implements ChildrenProvider {\n  addedNodesProvider: HeapSnapshotProviderProxy;\n  deletedNodesProvider: HeapSnapshotProviderProxy;\n  addedCount: number;\n  removedCount: number;\n  constructor(\n      addedNodesProvider: HeapSnapshotProviderProxy, deletedNodesProvider: HeapSnapshotProviderProxy,\n      addedCount: number, removedCount: number) {\n    this.addedNodesProvider = addedNodesProvider;\n    this.deletedNodesProvider = deletedNodesProvider;\n    this.addedCount = addedCount;\n    this.removedCount = removedCount;\n  }\n\n  dispose(): void {\n    this.addedNodesProvider.dispose();\n    this.deletedNodesProvider.dispose();\n  }\n\n  nodePosition(_snapshotObjectId: number): Promise<number> {\n    throw new Error('Unreachable');\n  }\n\n  isEmpty(): Promise<boolean> {\n    return Promise.resolve(false);\n  }\n\n  async serializeItemsRange(beginPosition: number, endPosition: number):\n      Promise<HeapSnapshotModel.HeapSnapshotModel.ItemsRange> {\n    let itemsRange;\n    let addedItems;\n    if (beginPosition < this.addedCount) {\n      itemsRange = await this.addedNodesProvider.serializeItemsRange(beginPosition, endPosition);\n\n      for (const item of itemsRange.items) {\n        item.isAddedNotRemoved = true;\n      }\n\n      if (itemsRange.endPosition >= endPosition) {\n        itemsRange.totalLength = this.addedCount + this.removedCount;\n        return itemsRange;\n      }\n\n      addedItems = itemsRange;\n      itemsRange = await this.deletedNodesProvider.serializeItemsRange(0, endPosition - itemsRange.endPosition);\n    } else {\n      addedItems = new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(0, 0, 0, []);\n      itemsRange = await this.deletedNodesProvider.serializeItemsRange(\n          beginPosition - this.addedCount, endPosition - this.addedCount);\n    }\n\n    if (!addedItems.items.length) {\n      addedItems.startPosition = this.addedCount + itemsRange.startPosition;\n    }\n    for (const item of itemsRange.items) {\n      item.isAddedNotRemoved = false;\n    }\n    addedItems.items.push(...itemsRange.items);\n    addedItems.endPosition = this.addedCount + itemsRange.endPosition;\n    addedItems.totalLength = this.addedCount + this.removedCount;\n    return addedItems;\n  }\n\n  async sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): Promise<void> {\n    await this.addedNodesProvider.sortAndRewind(comparator);\n    await this.deletedNodesProvider.sortAndRewind(comparator);\n  }\n}\n\nexport class HeapSnapshotDiffNode extends HeapSnapshotGridNode {\n  readonly nameInternal: string;\n  readonly addedCount: number;\n  readonly removedCount: number;\n  readonly countDelta: number;\n  readonly addedSize: number;\n  readonly removedSize: number;\n  readonly sizeDelta: number;\n  readonly deletedIndexes: number[];\n\n  constructor(\n      dataGrid: HeapSnapshotDiffDataGrid, className: string,\n      diffForClass: HeapSnapshotModel.HeapSnapshotModel.DiffForClass) {\n    super(dataGrid, true);\n    this.nameInternal = className;\n    this.addedCount = diffForClass.addedCount;\n    this.removedCount = diffForClass.removedCount;\n    this.countDelta = diffForClass.countDelta;\n    this.addedSize = diffForClass.addedSize;\n    this.removedSize = diffForClass.removedSize;\n    this.sizeDelta = diffForClass.sizeDelta;\n    this.deletedIndexes = diffForClass.deletedIndexes;\n    this.data = {\n      'object': className,\n      'addedCount': Platform.NumberUtilities.withThousandsSeparator(this.addedCount),\n      'removedCount': Platform.NumberUtilities.withThousandsSeparator(this.removedCount),\n      'countDelta': this.signForDelta(this.countDelta) +\n          Platform.NumberUtilities.withThousandsSeparator(Math.abs(this.countDelta)),\n      'addedSize': Platform.NumberUtilities.withThousandsSeparator(this.addedSize),\n      'removedSize': Platform.NumberUtilities.withThousandsSeparator(this.removedSize),\n      'sizeDelta':\n          this.signForDelta(this.sizeDelta) + Platform.NumberUtilities.withThousandsSeparator(Math.abs(this.sizeDelta)),\n    };\n  }\n\n  get name(): string|undefined {\n    return this.nameInternal;\n  }\n\n  createProvider(): HeapSnapshotDiffNodesProvider {\n    const tree = this.dataGridInternal as HeapSnapshotDiffDataGrid;\n    if (tree.snapshot === null || tree.baseSnapshot === undefined || tree.baseSnapshot.uid === undefined) {\n      throw new Error('Data sources have not been set correctly');\n    }\n    const addedNodesProvider = tree.snapshot.createAddedNodesProvider(tree.baseSnapshot.uid, this.nameInternal);\n    const deletedNodesProvider = tree.baseSnapshot.createDeletedNodesProvider(this.deletedIndexes);\n    if (!addedNodesProvider || !deletedNodesProvider) {\n      throw new Error('Failed to create node providers');\n    }\n    return new HeapSnapshotDiffNodesProvider(\n        addedNodesProvider, deletedNodesProvider, this.addedCount, this.removedCount);\n  }\n\n  createCell(columnId: string): HTMLElement {\n    const cell = super.createCell(columnId);\n    if (columnId !== 'object') {\n      cell.classList.add('numeric-column');\n    }\n    return cell;\n  }\n\n  createChildNode(item: HeapSnapshotModel.HeapSnapshotModel.Node|\n                  HeapSnapshotModel.HeapSnapshotModel.Edge): HeapSnapshotInstanceNode {\n    const dataGrid = (this.dataGridInternal as HeapSnapshotDiffDataGrid);\n    if (item.isAddedNotRemoved) {\n      if (dataGrid.snapshot === null) {\n        throw new Error('Data sources have not been set correctly');\n      }\n      return new HeapSnapshotInstanceNode(\n          this.dataGridInternal, dataGrid.snapshot, (item as HeapSnapshotModel.HeapSnapshotModel.Node), false);\n    }\n    if (dataGrid.baseSnapshot === undefined) {\n      throw new Error('Data sources have not been set correctly');\n    }\n    return new HeapSnapshotInstanceNode(\n        this.dataGridInternal, dataGrid.baseSnapshot, (item as HeapSnapshotModel.HeapSnapshotModel.Node), true);\n  }\n\n  comparator(): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    const sortAscending = this.dataGridInternal.isSortOrderAscending();\n    const sortColumnId = this.dataGridInternal.sortColumnId();\n    switch (sortColumnId) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', sortAscending, 'id', true);\n      case 'addedCount':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', true, 'id', true);\n      case 'removedCount':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', true, 'id', true);\n      case 'countDelta':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', true, 'id', true);\n      case 'addedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, 'id', true);\n      case 'removedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, 'id', true);\n      case 'sizeDelta':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('selfSize', sortAscending, 'id', true);\n      default:\n        throw new Error(`Invalid sort column ${sortColumnId}`);\n    }\n  }\n\n  filteredOut(filterValue: string): boolean {\n    return this.nameInternal.toLowerCase().indexOf(filterValue) === -1;\n  }\n\n  signForDelta(delta: number): ''|'+'|'\u2212' {\n    if (delta === 0) {\n      return '';\n    }\n    if (delta > 0) {\n      return '+';\n    }\n    return '\\u2212';  // Math minus sign, same width as plus.\n  }\n}\n\nexport class AllocationGridNode extends HeapSnapshotGridNode {\n  populated: boolean;\n  readonly allocationNode: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode;\n\n  constructor(dataGrid: AllocationDataGrid, data: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode) {\n    super(dataGrid, data.hasChildren);\n    this.populated = false;\n    this.allocationNode = data;\n    this.data = {\n      'liveCount': Platform.NumberUtilities.withThousandsSeparator(data.liveCount),\n      'count': Platform.NumberUtilities.withThousandsSeparator(data.count),\n      'liveSize': Platform.NumberUtilities.withThousandsSeparator(data.liveSize),\n      'size': Platform.NumberUtilities.withThousandsSeparator(data.size),\n      'name': data.name,\n    };\n  }\n\n  populate(): void {\n    if (this.populated) {\n      return;\n    }\n    void this.doPopulate();\n  }\n\n  async doPopulate(): Promise<void> {\n    this.populated = true;\n\n    const callers =\n        await (this.dataGridInternal.snapshot as HeapSnapshotProxy).allocationNodeCallers(this.allocationNode.id);\n\n    const callersChain = callers.nodesWithSingleCaller;\n    let parentNode: AllocationGridNode = (this as AllocationGridNode);\n    const dataGrid = (this.dataGridInternal as AllocationDataGrid);\n    for (const caller of callersChain) {\n      const child = new AllocationGridNode(dataGrid, caller);\n      dataGrid.appendNode(parentNode, child);\n      parentNode = child;\n      parentNode.populated = true;\n      if (this.expanded) {\n        parentNode.expand();\n      }\n    }\n\n    const callersBranch = callers.branchingCallers;\n    callersBranch.sort((this.dataGridInternal as AllocationDataGrid).createComparator());\n    for (const caller of callersBranch) {\n      dataGrid.appendNode(parentNode, new AllocationGridNode(dataGrid, caller));\n    }\n    dataGrid.updateVisibleNodes(true);\n  }\n\n  expand(): void {\n    super.expand();\n    if (this.children.length === 1) {\n      this.children[0].expand();\n    }\n  }\n\n  createCell(columnId: string): HTMLElement {\n    if (columnId !== 'name') {\n      return this.createValueCell(columnId);\n    }\n\n    const cell = super.createCell(columnId);\n    const allocationNode = this.allocationNode;\n    const heapProfilerModel = this.dataGridInternal.heapProfilerModel();\n    if (allocationNode.scriptId) {\n      const linkifier = (this.dataGridInternal as AllocationDataGrid).linkifier;\n      const urlElement = linkifier.linkifyScriptLocation(\n          heapProfilerModel ? heapProfilerModel.target() : null,\n          String(allocationNode.scriptId) as Protocol.Runtime.ScriptId,\n          allocationNode.scriptName as Platform.DevToolsPath.UrlString, allocationNode.line - 1, {\n            columnNumber: allocationNode.column - 1,\n            inlineFrameIndex: 0,\n            className: 'profile-node-file',\n          });\n      urlElement.style.maxWidth = '75%';\n      cell.insertBefore(urlElement, cell.firstChild);\n    }\n    return cell;\n  }\n\n  allocationNodeId(): number {\n    return this.allocationNode.id;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
