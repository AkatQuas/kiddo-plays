{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/profiler/BottomUpProfileDataGrid.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/*\n * Copyright (C) 2009 280 North Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n// Bottom Up Profiling shows the entire callstack backwards:\n// The root node is a representation of each individual function called, and each child of that node represents\n// a reverse-callstack showing how many of those calls came from it. So, unlike top-down, the statistics in\n// each child still represent the root node. We have to be particularly careful of recursion with this mode\n// because a root node can represent itself AND an ancestor.\n\nimport * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as UI from '../../ui/legacy/legacy.js';\n\nimport type {Formatter} from './ProfileDataGrid.js';\nimport {ProfileDataGridNode, ProfileDataGridTree} from './ProfileDataGrid.js';\nimport type {TopDownProfileDataGridTree} from './TopDownProfileDataGrid.js';\n\nexport interface NodeInfo {\n  ancestor: SDK.ProfileTreeModel.ProfileNode;\n  focusNode: SDK.ProfileTreeModel.ProfileNode;\n  totalAccountedFor: boolean;\n}\n\nexport class BottomUpProfileDataGridNode extends ProfileDataGridNode {\n  remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(profileNode: SDK.ProfileTreeModel.ProfileNode, owningTree: TopDownProfileDataGridTree) {\n    super(profileNode, owningTree, profileNode.parent !== null && Boolean(profileNode.parent.parent));\n    this.remainingNodeInfos = [];\n  }\n\n  static sharedPopulate(container: BottomUpProfileDataGridNode|BottomUpProfileDataGridTree): void {\n    if (container.remainingNodeInfos === undefined) {\n      return;\n    }\n    const remainingNodeInfos = container.remainingNodeInfos;\n    const count = remainingNodeInfos.length;\n\n    for (let index = 0; index < count; ++index) {\n      const nodeInfo = remainingNodeInfos[index];\n      const ancestor = nodeInfo.ancestor;\n      const focusNode = nodeInfo.focusNode;\n      let child: BottomUpProfileDataGridNode|(BottomUpProfileDataGridNode | null) =\n          (container.findChild(ancestor) as BottomUpProfileDataGridNode | null);\n\n      // If we already have this child, then merge the data together.\n      if (child) {\n        const totalAccountedFor = nodeInfo.totalAccountedFor;\n\n        child.self += focusNode.self;\n\n        if (!totalAccountedFor) {\n          child.total += focusNode.total;\n        }\n      } else {\n        child = new BottomUpProfileDataGridNode(ancestor, (container.tree as TopDownProfileDataGridTree));\n\n        if (ancestor !== focusNode) {\n          // But the actual statistics from the \"root\" node (bottom of the callstack).\n          child.self = focusNode.self;\n          child.total = focusNode.total;\n        }\n\n        container.appendChild(child);\n      }\n\n      const parent = ancestor.parent;\n      if (parent && parent.parent) {\n        nodeInfo.ancestor = parent;\n        if (!child.remainingNodeInfos) {\n          child.remainingNodeInfos = [];\n        }\n        child.remainingNodeInfos.push(nodeInfo);\n      }\n    }\n\n    delete container.remainingNodeInfos;\n  }\n\n  takePropertiesFromProfileDataGridNode(profileDataGridNode: ProfileDataGridNode): void {\n    this.save();\n    this.self = profileDataGridNode.self;\n    this.total = profileDataGridNode.total;\n  }\n\n  /**\n   * When focusing, we keep just the members of the callstack.\n   */\n  keepOnlyChild(child: ProfileDataGridNode): void {\n    this.save();\n\n    this.removeChildren();\n    this.appendChild(child);\n  }\n\n  exclude(aCallUID: string): void {\n    if (this.remainingNodeInfos) {\n      this.populate();\n    }\n\n    this.save();\n\n    const children = this.children;\n    let index = this.children.length;\n\n    while (index--) {\n      (children[index] as BottomUpProfileDataGridNode).exclude(aCallUID);\n    }\n\n    const child = this.childrenByCallUID.get(aCallUID);\n\n    if (child) {\n      this.merge(child, true);\n    }\n  }\n\n  restore(): void {\n    super.restore();\n\n    if (!this.children.length) {\n      this.setHasChildren(this.willHaveChildren(this.profileNode));\n    }\n  }\n\n  merge(child: ProfileDataGridNode, shouldAbsorb: boolean): void {\n    this.self -= child.self;\n    super.merge(child, shouldAbsorb);\n  }\n\n  populateChildren(): void {\n    BottomUpProfileDataGridNode.sharedPopulate(this);\n  }\n\n  willHaveChildren(profileNode: SDK.ProfileTreeModel.ProfileNode): boolean {\n    // In bottom up mode, our parents are our children since we display an inverted tree.\n    // However, we don't want to show the very top parent since it is redundant.\n    return Boolean(profileNode.parent && profileNode.parent.parent);\n  }\n}\n\nexport class BottomUpProfileDataGridTree extends ProfileDataGridTree {\n  deepSearch: boolean;\n  remainingNodeInfos: NodeInfo[]|undefined;\n\n  constructor(\n      formatter: Formatter, searchableView: UI.SearchableView.SearchableView,\n      rootProfileNode: SDK.ProfileTreeModel.ProfileNode, total: number) {\n    super(formatter, searchableView, total);\n    this.deepSearch = false;\n\n    // Iterate each node in pre-order.\n    let profileNodeUIDs = 0;\n    const profileNodeGroups = [[], [rootProfileNode]];\n    const visitedProfileNodesForCallUID = new Map<string, Set<number>>();\n\n    this.remainingNodeInfos = [];\n\n    for (let profileNodeGroupIndex = 0; profileNodeGroupIndex < profileNodeGroups.length; ++profileNodeGroupIndex) {\n      const parentProfileNodes = profileNodeGroups[profileNodeGroupIndex];\n      const profileNodes = profileNodeGroups[++profileNodeGroupIndex];\n      const count = profileNodes.length;\n\n      const profileNodeUIDValues = new WeakMap<SDK.ProfileTreeModel.ProfileNode, number>();\n\n      for (let index = 0; index < count; ++index) {\n        const profileNode = profileNodes[index];\n\n        if (!profileNodeUIDValues.get(profileNode)) {\n          profileNodeUIDValues.set(profileNode, ++profileNodeUIDs);\n        }\n\n        if (profileNode.parent) {\n          // The total time of this ancestor is accounted for if we're in any form of recursive cycle.\n          let visitedNodes = visitedProfileNodesForCallUID.get(profileNode.callUID);\n          let totalAccountedFor = false;\n\n          if (!visitedNodes) {\n            visitedNodes = new Set();\n            visitedProfileNodesForCallUID.set(profileNode.callUID, visitedNodes);\n          } else {\n            // The total time for this node has already been accounted for iff one of it's parents has already been visited.\n            // We can do this check in this style because we are traversing the tree in pre-order.\n            const parentCount = parentProfileNodes.length;\n            for (let parentIndex = 0; parentIndex < parentCount; ++parentIndex) {\n              const parentUID = profileNodeUIDValues.get(parentProfileNodes[parentIndex]);\n              if (parentUID && visitedNodes.has(parentUID)) {\n                totalAccountedFor = true;\n                break;\n              }\n            }\n          }\n\n          const uid = profileNodeUIDValues.get(profileNode);\n          if (uid) {\n            visitedNodes.add(uid);\n          }\n\n          this.remainingNodeInfos.push(\n              {ancestor: profileNode, focusNode: profileNode, totalAccountedFor: totalAccountedFor});\n        }\n\n        const children = profileNode.children;\n        if (children.length) {\n          profileNodeGroups.push(parentProfileNodes.concat([profileNode]));\n          profileNodeGroups.push(children);\n        }\n      }\n    }\n\n    // Populate the top level nodes.\n    ProfileDataGridNode.populate(this);\n\n    return this;\n  }\n\n  /**\n   * When focusing, we keep the entire callstack up to this ancestor.\n   */\n  focus(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    let currentNode: ProfileDataGridNode = profileDataGridNode;\n    let focusNode: (ProfileDataGridNode&BottomUpProfileDataGridNode)|ProfileDataGridNode = profileDataGridNode;\n\n    while (currentNode.parent && (currentNode instanceof BottomUpProfileDataGridNode)) {\n      currentNode.takePropertiesFromProfileDataGridNode(profileDataGridNode);\n\n      focusNode = currentNode;\n      currentNode = (currentNode.parent as ProfileDataGridNode);\n\n      if (currentNode instanceof BottomUpProfileDataGridNode) {\n        currentNode.keepOnlyChild(focusNode);\n      }\n    }\n\n    this.children = [focusNode];\n    this.total = profileDataGridNode.total;\n  }\n\n  exclude(profileDataGridNode: ProfileDataGridNode): void {\n    if (!profileDataGridNode) {\n      return;\n    }\n\n    this.save();\n\n    const excludedCallUID = profileDataGridNode.callUID;\n    const excludedTopLevelChild = this.childrenByCallUID.get(excludedCallUID);\n\n    // If we have a top level node that is excluded, get rid of it completely (not keeping children),\n    // since bottom up data relies entirely on the root node.\n    if (excludedTopLevelChild) {\n      Platform.ArrayUtilities.removeElement(this.children, excludedTopLevelChild);\n    }\n\n    const children = this.children;\n    const count = children.length;\n\n    for (let index = 0; index < count; ++index) {\n      (children[index] as BottomUpProfileDataGridNode).exclude(excludedCallUID);\n    }\n\n    if (this.lastComparator) {\n      this.sort(this.lastComparator, true);\n    }\n  }\n\n  populateChildren(): void {\n    BottomUpProfileDataGridNode.sharedPopulate(this);\n  }\n}\n"],
  "mappings": "AAkCA;AAKA;AASO,iDAA0C,oBAAoB;AAAA,EACnE;AAAA,EAEA,YAAY,aAA+C,YAAwC;AACjG,UAAM,aAAa,YAAY,YAAY,WAAW,QAAQ,QAAQ,YAAY,OAAO;AACzF,SAAK,qBAAqB;AAAA;AAAA,SAGrB,eAAe,WAA0E;AAC9F,QAAI,UAAU,uBAAuB,QAAW;AAC9C;AAAA;AAEF,UAAM,qBAAqB,UAAU;AACrC,UAAM,QAAQ,mBAAmB;AAEjC,aAAS,QAAQ,GAAG,QAAQ,OAAO,EAAE,OAAO;AAC1C,YAAM,WAAW,mBAAmB;AACpC,YAAM,WAAW,SAAS;AAC1B,YAAM,YAAY,SAAS;AAC3B,UAAI,QACC,UAAU,UAAU;AAGzB,UAAI,OAAO;AACT,cAAM,oBAAoB,SAAS;AAEnC,cAAM,QAAQ,UAAU;AAExB,YAAI,CAAC,mBAAmB;AACtB,gBAAM,SAAS,UAAU;AAAA;AAAA,aAEtB;AACL,gBAAQ,IAAI,4BAA4B,UAAW,UAAU;AAE7D,YAAI,aAAa,WAAW;AAE1B,gBAAM,OAAO,UAAU;AACvB,gBAAM,QAAQ,UAAU;AAAA;AAG1B,kBAAU,YAAY;AAAA;AAGxB,YAAM,SAAS,SAAS;AACxB,UAAI,UAAU,OAAO,QAAQ;AAC3B,iBAAS,WAAW;AACpB,YAAI,CAAC,MAAM,oBAAoB;AAC7B,gBAAM,qBAAqB;AAAA;AAE7B,cAAM,mBAAmB,KAAK;AAAA;AAAA;AAIlC,WAAO,UAAU;AAAA;AAAA,EAGnB,sCAAsC,qBAAgD;AACpF,SAAK;AACL,SAAK,OAAO,oBAAoB;AAChC,SAAK,QAAQ,oBAAoB;AAAA;AAAA,EAMnC,cAAc,OAAkC;AAC9C,SAAK;AAEL,SAAK;AACL,SAAK,YAAY;AAAA;AAAA,EAGnB,QAAQ,UAAwB;AAC9B,QAAI,KAAK,oBAAoB;AAC3B,WAAK;AAAA;AAGP,SAAK;AAEL,UAAM,WAAW,KAAK;AACtB,QAAI,QAAQ,KAAK,SAAS;AAE1B,WAAO,SAAS;AACd,MAAC,SAAS,OAAuC,QAAQ;AAAA;AAG3D,UAAM,QAAQ,KAAK,kBAAkB,IAAI;AAEzC,QAAI,OAAO;AACT,WAAK,MAAM,OAAO;AAAA;AAAA;AAAA,EAItB,UAAgB;AACd,UAAM;AAEN,QAAI,CAAC,KAAK,SAAS,QAAQ;AACzB,WAAK,eAAe,KAAK,iBAAiB,KAAK;AAAA;AAAA;AAAA,EAInD,MAAM,OAA4B,cAA6B;AAC7D,SAAK,QAAQ,MAAM;AACnB,UAAM,MAAM,OAAO;AAAA;AAAA,EAGrB,mBAAyB;AACvB,gCAA4B,eAAe;AAAA;AAAA,EAG7C,iBAAiB,aAAwD;AAGvE,WAAO,QAAQ,YAAY,UAAU,YAAY,OAAO;AAAA;AAAA;AAIrD,iDAA0C,oBAAoB;AAAA,EACnE;AAAA,EACA;AAAA,EAEA,YACI,WAAsB,gBACtB,iBAAmD,OAAe;AACpE,UAAM,WAAW,gBAAgB;AACjC,SAAK,aAAa;AAGlB,QAAI,kBAAkB;AACtB,UAAM,oBAAoB,CAAC,IAAI,CAAC;AAChC,UAAM,gCAAgC,oBAAI;AAE1C,SAAK,qBAAqB;AAE1B,aAAS,wBAAwB,GAAG,wBAAwB,kBAAkB,QAAQ,EAAE,uBAAuB;AAC7G,YAAM,qBAAqB,kBAAkB;AAC7C,YAAM,eAAe,kBAAkB,EAAE;AACzC,YAAM,QAAQ,aAAa;AAE3B,YAAM,uBAAuB,oBAAI;AAEjC,eAAS,QAAQ,GAAG,QAAQ,OAAO,EAAE,OAAO;AAC1C,cAAM,cAAc,aAAa;AAEjC,YAAI,CAAC,qBAAqB,IAAI,cAAc;AAC1C,+BAAqB,IAAI,aAAa,EAAE;AAAA;AAG1C,YAAI,YAAY,QAAQ;AAEtB,cAAI,eAAe,8BAA8B,IAAI,YAAY;AACjE,cAAI,oBAAoB;AAExB,cAAI,CAAC,cAAc;AACjB,2BAAe,oBAAI;AACnB,0CAA8B,IAAI,YAAY,SAAS;AAAA,iBAClD;AAGL,kBAAM,cAAc,mBAAmB;AACvC,qBAAS,cAAc,GAAG,cAAc,aAAa,EAAE,aAAa;AAClE,oBAAM,YAAY,qBAAqB,IAAI,mBAAmB;AAC9D,kBAAI,aAAa,aAAa,IAAI,YAAY;AAC5C,oCAAoB;AACpB;AAAA;AAAA;AAAA;AAKN,gBAAM,MAAM,qBAAqB,IAAI;AACrC,cAAI,KAAK;AACP,yBAAa,IAAI;AAAA;AAGnB,eAAK,mBAAmB,KACpB,EAAC,UAAU,aAAa,WAAW,aAAa;AAAA;AAGtD,cAAM,WAAW,YAAY;AAC7B,YAAI,SAAS,QAAQ;AACnB,4BAAkB,KAAK,mBAAmB,OAAO,CAAC;AAClD,4BAAkB,KAAK;AAAA;AAAA;AAAA;AAM7B,wBAAoB,SAAS;AAE7B,WAAO;AAAA;AAAA,EAMT,MAAM,qBAAgD;AACpD,QAAI,CAAC,qBAAqB;AACxB;AAAA;AAGF,SAAK;AAEL,QAAI,cAAmC;AACvC,QAAI,YAAmF;AAEvF,WAAO,YAAY,UAAW,uBAAuB,6BAA8B;AACjF,kBAAY,sCAAsC;AAElD,kBAAY;AACZ,oBAAe,YAAY;AAE3B,UAAI,uBAAuB,6BAA6B;AACtD,oBAAY,cAAc;AAAA;AAAA;AAI9B,SAAK,WAAW,CAAC;AACjB,SAAK,QAAQ,oBAAoB;AAAA;AAAA,EAGnC,QAAQ,qBAAgD;AACtD,QAAI,CAAC,qBAAqB;AACxB;AAAA;AAGF,SAAK;AAEL,UAAM,kBAAkB,oBAAoB;AAC5C,UAAM,wBAAwB,KAAK,kBAAkB,IAAI;AAIzD,QAAI,uBAAuB;AACzB,eAAS,eAAe,cAAc,KAAK,UAAU;AAAA;AAGvD,UAAM,WAAW,KAAK;AACtB,UAAM,QAAQ,SAAS;AAEvB,aAAS,QAAQ,GAAG,QAAQ,OAAO,EAAE,OAAO;AAC1C,MAAC,SAAS,OAAuC,QAAQ;AAAA;AAG3D,QAAI,KAAK,gBAAgB;AACvB,WAAK,KAAK,KAAK,gBAAgB;AAAA;AAAA;AAAA,EAInC,mBAAyB;AACvB,gCAA4B,eAAe;AAAA;AAAA;",
  "names": []
}
