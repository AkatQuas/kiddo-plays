{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/profiler/HeapSnapshotDataGrids.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Common from '../../core/common/common.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\nimport * as DataGrid from '../../ui/legacy/components/data_grid/data_grid.js';\nimport * as Components from '../../ui/legacy/components/utils/utils.js';\n\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport type {HeapSnapshotGridNode} from './HeapSnapshotGridNodes.js';\nimport {\n  AllocationGridNode,\n  HeapSnapshotConstructorNode,\n  HeapSnapshotGenericObjectNode,\n  HeapSnapshotRetainingObjectNode,\n  HeapSnapshotObjectNode,\n  HeapSnapshotDiffNode,\n} from './HeapSnapshotGridNodes.js';\nimport type {HeapSnapshotProxy} from './HeapSnapshotProxy.js';\nimport type {HeapProfileHeader} from './HeapSnapshotView.js';\nimport type {DataDisplayDelegate} from './ProfileHeader.js';\n\nconst UIStrings = {\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  distanceFromWindowObject: 'Distance from window object',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  sizeOfTheObjectItselfInBytes: 'Size of the object itself in bytes',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  sizeOfTheObjectPlusTheGraphIt: 'Size of the object plus the graph it retains in bytes',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  object: 'Object',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  distance: 'Distance',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool. Shallow size is the size of just this node, not including children/retained size.\n  */\n  shallowSize: 'Shallow Size',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  retainedSize: 'Retained Size',\n  /**\n  * @description Title for a section in the Heap Snapshot view. This title is for a table which\n  * shows retaining relationships between JavaScript objects. One object retains another if it holds\n  * a reference to it, keeping it alive.\n  */\n  heapSnapshotRetainment: 'Heap Snapshot Retainment',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  constructorString: 'Constructor',\n  /**\n  *@description Data grid name for Heap Snapshot Constructors data grids\n  */\n  heapSnapshotConstructors: 'Heap Snapshot Constructors',\n  /**\n  *@description Column header in a table displaying the diff between two Heap Snapshots. This\n  * column is number of new objects in snapshot #2 compared to snapshot #1.\n  */\n  New: '# New',\n  /**\n  *@description Column header in a table displaying the diff between two Heap Snapshots. This\n  * column is number of deleted objects in snapshot #2 compared to snapshot #1.\n  */\n  Deleted: '# Deleted',\n  /**\n  * @description Column header in a table displaying the diff between two Heap Snapshots. This\n  * column is the difference (delta) between the # New and # Deleted objects in the snapshot.\n  */\n  Delta: '# Delta',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  allocSize: 'Alloc. Size',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  freedSize: 'Freed Size',\n  /**\n  * @description Title of a column in a table in the Heap Snapshot tool. 'Delta' here means\n  * difference, so the whole string means 'difference in size'.\n  */\n  sizeDelta: 'Size Delta',\n  /**\n  *@description Data grid name for Heap Snapshot Diff data grids\n  */\n  heapSnapshotDiff: 'Heap Snapshot Diff',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  liveCount: 'Live Count',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  count: 'Count',\n  /**\n  *@description Text in Heap Snapshot Data Grids of a profiler tool\n  */\n  liveSize: 'Live Size',\n  /**\n  *@description Text for the size of something\n  */\n  size: 'Size',\n  /**\n  *@description Text for a programming function\n  */\n  function: 'Function',\n  /**\n  *@description Text in Heap Snapshot View of a profiler tool\n  */\n  allocation: 'Allocation',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/profiler/HeapSnapshotDataGrids.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst adjacencyMap = new WeakMap<DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>, HeapSnapshotGridNode[]>();\n\nclass HeapSnapshotSortableDataGridBase extends DataGrid.DataGrid.DataGridImpl<HeapSnapshotGridNode> {}\n\nexport class HeapSnapshotSortableDataGrid extends\n    Common.ObjectWrapper.eventMixin<EventTypes, typeof HeapSnapshotSortableDataGridBase>(\n        HeapSnapshotSortableDataGridBase) {\n  snapshot: HeapSnapshotProxy|null;\n  selectedNode: HeapSnapshotGridNode|null;\n  readonly heapProfilerModelInternal: SDK.HeapProfilerModel.HeapProfilerModel|null;\n  readonly dataDisplayDelegateInternal: DataDisplayDelegate;\n  recursiveSortingDepth: number;\n  populatedAndSorted: boolean;\n  nameFilter: UI.Toolbar.ToolbarInput|null;\n  nodeFilterInternal: HeapSnapshotModel.HeapSnapshotModel.NodeFilter|undefined;\n  lastSortColumnId?: string|null;\n  lastSortAscending?: boolean;\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate,\n      dataGridParameters: DataGrid.DataGrid.Parameters) {\n    // TODO(allada) This entire class needs to be converted to use the templates in DataGridNode.\n    super(dataGridParameters);\n    this.snapshot = null;\n    this.selectedNode = null;\n    this.heapProfilerModelInternal = heapProfilerModel;\n    this.dataDisplayDelegateInternal = dataDisplayDelegate;\n    const tooltips = [\n      ['distance', i18nString(UIStrings.distanceFromWindowObject)],\n      ['shallowSize', i18nString(UIStrings.sizeOfTheObjectItselfInBytes)],\n      ['retainedSize', i18nString(UIStrings.sizeOfTheObjectPlusTheGraphIt)],\n    ];\n    for (const info of tooltips) {\n      const headerCell = this.headerTableHeader(info[0]);\n      if (headerCell) {\n        headerCell.setAttribute('title', info[1]);\n      }\n    }\n\n    this.recursiveSortingDepth = 0;\n    this.populatedAndSorted = false;\n    this.nameFilter = null;\n    this.nodeFilterInternal = new HeapSnapshotModel.HeapSnapshotModel.NodeFilter();\n    this.addEventListener(HeapSnapshotSortableDataGridEvents.SortingComplete, this.sortingComplete, this);\n    this.addEventListener(DataGrid.DataGrid.Events.SortingChanged, this.sortingChanged, this);\n    this.setRowContextMenuCallback(this.populateContextMenu.bind(this));\n  }\n\n  async setDataSource(_snapshot: HeapSnapshotProxy, _nodeIndex: number): Promise<void> {\n  }\n\n  isFilteredOut(node: HeapSnapshotGridNode): boolean {\n    const nameFilterValue = this.nameFilter ? this.nameFilter.value().toLowerCase() : '';\n    if (nameFilterValue && (node instanceof HeapSnapshotDiffNode || node instanceof HeapSnapshotConstructorNode) &&\n        node.filteredOut(nameFilterValue)) {\n      return true;\n    }\n    return false;\n  }\n\n  heapProfilerModel(): SDK.HeapProfilerModel.HeapProfilerModel|null {\n    return this.heapProfilerModelInternal;\n  }\n\n  dataDisplayDelegate(): DataDisplayDelegate {\n    return this.dataDisplayDelegateInternal;\n  }\n\n  nodeFilter(): HeapSnapshotModel.HeapSnapshotModel.NodeFilter|undefined {\n    return this.nodeFilterInternal;\n  }\n\n  setNameFilter(nameFilter: UI.Toolbar.ToolbarInput): void {\n    this.nameFilter = nameFilter;\n  }\n\n  defaultPopulateCount(): number {\n    return 100;\n  }\n\n  disposeAllNodes(): void {\n    const children = this.topLevelNodes();\n    for (let i = 0, l = children.length; i < l; ++i) {\n      children[i].dispose();\n    }\n  }\n\n  wasShown(): void {\n    if (this.nameFilter) {\n      this.nameFilter.addEventListener(UI.Toolbar.ToolbarInput.Event.TextChanged, this.onNameFilterChanged, this);\n      this.updateVisibleNodes(true);\n    }\n    if (this.populatedAndSorted) {\n      this.dispatchEventToListeners(HeapSnapshotSortableDataGridEvents.ContentShown, this);\n    }\n  }\n\n  sortingComplete(): void {\n    this.removeEventListener(HeapSnapshotSortableDataGridEvents.SortingComplete, this.sortingComplete, this);\n    this.populatedAndSorted = true;\n    this.dispatchEventToListeners(HeapSnapshotSortableDataGridEvents.ContentShown, this);\n  }\n\n  willHide(): void {\n    if (this.nameFilter) {\n      this.nameFilter.removeEventListener(UI.Toolbar.ToolbarInput.Event.TextChanged, this.onNameFilterChanged, this);\n    }\n  }\n\n  populateContextMenu(\n      contextMenu: UI.ContextMenu.ContextMenu, gridNode: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>): void {\n    const node = (gridNode as HeapSnapshotGridNode);\n    node.populateContextMenu(contextMenu, this.dataDisplayDelegateInternal, this.heapProfilerModel());\n\n    if (node instanceof HeapSnapshotGenericObjectNode && node.linkElement &&\n        !contextMenu.containsTarget(node.linkElement)) {\n      contextMenu.appendApplicableItems(node.linkElement);\n    }\n  }\n\n  resetSortingCache(): void {\n    delete this.lastSortColumnId;\n    delete this.lastSortAscending;\n  }\n\n  topLevelNodes(): HeapSnapshotGridNode[] {\n    return this.rootNode().children as HeapSnapshotGridNode[];\n  }\n\n  revealObjectByHeapSnapshotId(_heapSnapshotObjectId: string): Promise<HeapSnapshotGridNode|null> {\n    return Promise.resolve((null as HeapSnapshotGridNode | null));\n  }\n\n  resetNameFilter(): void {\n    if (this.nameFilter) {\n      this.nameFilter.setValue('');\n    }\n  }\n\n  onNameFilterChanged(): void {\n    this.updateVisibleNodes(true);\n    this.deselectFilteredNodes();\n  }\n\n  deselectFilteredNodes(): void {\n    let currentNode: (HeapSnapshotGridNode|null) = this.selectedNode;\n    while (currentNode) {\n      if (this.selectedNode && this.isFilteredOut((currentNode as HeapSnapshotGridNode))) {\n        this.selectedNode.deselect();\n        this.selectedNode = null;\n        return;\n      }\n      currentNode = (currentNode.parent as HeapSnapshotGridNode | null);\n    }\n  }\n\n  sortFields(_sortColumnId: string, _ascending: boolean): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    throw new Error('Not implemented');\n  }\n\n  sortingChanged(): void {\n    const sortAscending = this.isSortOrderAscending();\n    const sortColumnId = this.sortColumnId();\n    if (this.lastSortColumnId === sortColumnId && this.lastSortAscending === sortAscending) {\n      return;\n    }\n    this.lastSortColumnId = sortColumnId;\n    this.lastSortAscending = sortAscending;\n    const sortFields = this.sortFields(sortColumnId || '', sortAscending);\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    function SortByTwoFields(\n        nodeA: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>,\n        nodeB: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>): number {\n      // @ts-ignore\n      let field1 = nodeA[sortFields.fieldName1];\n      // @ts-ignore\n      let field2 = nodeB[sortFields.fieldName1];\n      let result: number|(0 | 1 | -1) = field1 < field2 ? -1 : (field1 > field2 ? 1 : 0);\n      if (!sortFields.ascending1) {\n        result = -result;\n      }\n      if (result !== 0) {\n        return result;\n      }\n      // @ts-ignore\n      field1 = nodeA[sortFields.fieldName2];\n      // @ts-ignore\n      field2 = nodeB[sortFields.fieldName2];\n      result = field1 < field2 ? -1 : (field1 > field2 ? 1 : 0);\n      if (!sortFields.ascending2) {\n        result = -result;\n      }\n      return result;\n    }\n    this.performSorting(SortByTwoFields);\n  }\n\n  performSorting(\n      sortFunction:\n          (arg0: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>,\n           arg1: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>) => number): void {\n    this.recursiveSortingEnter();\n    const children = this.allChildren(this.rootNode());\n    this.rootNode().removeChildren();\n    children.sort(sortFunction);\n    for (let i = 0, l = children.length; i < l; ++i) {\n      const child = (children[i] as HeapSnapshotGridNode);\n      this.appendChildAfterSorting(child);\n      if (child.expanded) {\n        void child.sort();\n      }\n    }\n    this.recursiveSortingLeave();\n  }\n\n  appendChildAfterSorting(child: HeapSnapshotGridNode): void {\n    const revealed = child.revealed;\n    this.rootNode().appendChild(child);\n    child.revealed = revealed;\n  }\n\n  recursiveSortingEnter(): void {\n    ++this.recursiveSortingDepth;\n  }\n\n  recursiveSortingLeave(): void {\n    if (!this.recursiveSortingDepth) {\n      return;\n    }\n    if (--this.recursiveSortingDepth) {\n      return;\n    }\n    this.updateVisibleNodes(true);\n    this.dispatchEventToListeners(HeapSnapshotSortableDataGridEvents.SortingComplete);\n  }\n\n  updateVisibleNodes(_force: boolean): void {\n  }\n\n  allChildren(parent: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>):\n      DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>[] {\n    return parent.children;\n  }\n\n  insertChild(parent: HeapSnapshotGridNode, node: HeapSnapshotGridNode, index: number): void {\n    parent.insertChild(node, index);\n  }\n\n  removeChildByIndex(parent: HeapSnapshotGridNode, index: number): void {\n    parent.removeChild(parent.children[index]);\n  }\n\n  removeAllChildren(parent: HeapSnapshotGridNode): void {\n    parent.removeChildren();\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum HeapSnapshotSortableDataGridEvents {\n  ContentShown = 'ContentShown',\n  SortingComplete = 'SortingComplete',\n  ExpandRetainersComplete = 'ExpandRetainersComplete',\n}\n\nexport type EventTypes = {\n  [HeapSnapshotSortableDataGridEvents.ContentShown]: HeapSnapshotSortableDataGrid,\n  [HeapSnapshotSortableDataGridEvents.SortingComplete]: void,\n  [HeapSnapshotSortableDataGridEvents.ExpandRetainersComplete]: void,\n};\n\nexport class HeapSnapshotViewportDataGrid extends HeapSnapshotSortableDataGrid {\n  topPaddingHeight: number;\n  bottomPaddingHeight: number;\n  selectedNode: HeapSnapshotGridNode|null;\n  scrollToResolveCallback?: (() => void)|null;\n\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate,\n      dataGridParameters: DataGrid.DataGrid.Parameters) {\n    super(heapProfilerModel, dataDisplayDelegate, dataGridParameters);\n    this.scrollContainer.addEventListener('scroll', this.onScroll.bind(this), true);\n    this.topPaddingHeight = 0;\n    this.bottomPaddingHeight = 0;\n    this.selectedNode = null;\n  }\n\n  topLevelNodes(): HeapSnapshotGridNode[] {\n    return this.allChildren(this.rootNode());\n  }\n\n  appendChildAfterSorting(_child: HeapSnapshotGridNode): void {\n    // Do nothing here, it will be added in updateVisibleNodes.\n  }\n\n  updateVisibleNodes(force: boolean): void {\n    // Guard zone is used to ensure there are always some extra items\n    // above and below the viewport to support keyboard navigation.\n    const guardZoneHeight = 40;\n    const scrollHeight = this.scrollContainer.scrollHeight;\n    let scrollTop: number = this.scrollContainer.scrollTop;\n    let scrollBottom: number = scrollHeight - scrollTop - this.scrollContainer.offsetHeight;\n    scrollTop = Math.max(0, scrollTop - guardZoneHeight);\n    scrollBottom = Math.max(0, scrollBottom - guardZoneHeight);\n    let viewPortHeight = scrollHeight - scrollTop - scrollBottom;\n    // Do nothing if populated nodes still fit the viewport.\n    if (!force && scrollTop >= this.topPaddingHeight && scrollBottom >= this.bottomPaddingHeight) {\n      return;\n    }\n    const hysteresisHeight = 500;\n    scrollTop -= hysteresisHeight;\n    viewPortHeight += 2 * hysteresisHeight;\n    const selectedNode = this.selectedNode;\n    this.rootNode().removeChildren();\n\n    this.topPaddingHeight = 0;\n    this.bottomPaddingHeight = 0;\n\n    this.addVisibleNodes(this.rootNode(), scrollTop, scrollTop + viewPortHeight);\n\n    this.setVerticalPadding(this.topPaddingHeight, this.bottomPaddingHeight);\n\n    if (selectedNode) {\n      // Keep selection even if the node is not in the current viewport.\n      if (selectedNode.parent) {\n        selectedNode.select(true);\n      } else {\n        this.selectedNode = selectedNode;\n      }\n    }\n  }\n\n  addVisibleNodes(\n      parentNode: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>, topBound: number, bottomBound: number): number {\n    if (!parentNode.expanded) {\n      return 0;\n    }\n\n    const children = this.allChildren((parentNode as HeapSnapshotGridNode));\n    let topPadding = 0;\n    // Iterate over invisible nodes beyond the upper bound of viewport.\n    // Do not insert them into the grid, but count their total height.\n    let i = 0;\n    for (; i < children.length; ++i) {\n      const child = children[i];\n      if (this.isFilteredOut(child)) {\n        continue;\n      }\n      const newTop = topPadding + this.nodeHeight(child);\n      if (newTop > topBound) {\n        break;\n      }\n      topPadding = newTop;\n    }\n\n    // Put visible nodes into the data grid.\n    let position = topPadding;\n    for (; i < children.length && position < bottomBound; ++i) {\n      const child = children[i];\n      if (this.isFilteredOut(child)) {\n        continue;\n      }\n      const hasChildren = child.hasChildren();\n      child.removeChildren();\n      child.setHasChildren(hasChildren);\n      parentNode.appendChild(child);\n      position += child.nodeSelfHeight();\n      position += this.addVisibleNodes(child, topBound - position, bottomBound - position);\n    }\n\n    // Count the invisible nodes beyond the bottom bound of the viewport.\n    let bottomPadding = 0;\n    for (; i < children.length; ++i) {\n      const child = children[i];\n      if (this.isFilteredOut(child)) {\n        continue;\n      }\n      bottomPadding += this.nodeHeight(child);\n    }\n\n    this.topPaddingHeight += topPadding;\n    this.bottomPaddingHeight += bottomPadding;\n    return position + bottomPadding;\n  }\n\n  nodeHeight(node: HeapSnapshotGridNode): number {\n    let result = node.nodeSelfHeight();\n    if (!node.expanded) {\n      return result;\n    }\n    const children = this.allChildren(node);\n    for (let i = 0; i < children.length; i++) {\n      result += this.nodeHeight(children[i]);\n    }\n    return result;\n  }\n\n  revealTreeNode(pathToReveal: HeapSnapshotGridNode[]): Promise<HeapSnapshotGridNode> {\n    const height = this.calculateOffset(pathToReveal);\n    const node = (pathToReveal[pathToReveal.length - 1] as HeapSnapshotGridNode);\n    const scrollTop = this.scrollContainer.scrollTop;\n    const scrollBottom = scrollTop + this.scrollContainer.offsetHeight;\n    if (height >= scrollTop && height < scrollBottom) {\n      return Promise.resolve(node);\n    }\n\n    const scrollGap = 40;\n    this.scrollContainer.scrollTop = Math.max(0, height - scrollGap);\n    return new Promise(resolve => {\n      console.assert(!this.scrollToResolveCallback);\n      this.scrollToResolveCallback = resolve.bind(null, node);\n      // Still resolve the promise if it does not scroll for some reason.\n      this.scrollContainer.window().requestAnimationFrame(() => {\n        if (!this.scrollToResolveCallback) {\n          return;\n        }\n        this.scrollToResolveCallback();\n        this.scrollToResolveCallback = null;\n      });\n    });\n  }\n\n  calculateOffset(pathToReveal: HeapSnapshotGridNode[]): number {\n    let parentNode = this.rootNode();\n    let height = 0;\n    if (pathToReveal.length === 0) {\n      return 0;\n    }\n    for (let i = 0; i < pathToReveal.length; ++i) {\n      const node = pathToReveal[i];\n      const children = this.allChildren(parentNode);\n      for (let j = 0; j < children.length; ++j) {\n        const child = children[j];\n        if (node === child) {\n          height += node.nodeSelfHeight();\n          break;\n        }\n        height += this.nodeHeight(child);\n      }\n      parentNode = node;\n    }\n    return height - (pathToReveal[pathToReveal.length - 1] as HeapSnapshotGridNode).nodeSelfHeight();\n  }\n\n  allChildren(parent: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>): HeapSnapshotGridNode[] {\n    const children = adjacencyMap.get(parent) || [];\n    if (!adjacencyMap.has(parent)) {\n      adjacencyMap.set(parent, children);\n    }\n    return children;\n  }\n\n  appendNode(parent: DataGrid.DataGrid.DataGridNode<HeapSnapshotGridNode>, node: HeapSnapshotGridNode): void {\n    this.allChildren(parent).push(node);\n  }\n\n  insertChild(parent: HeapSnapshotGridNode, node: HeapSnapshotGridNode, index: number): void {\n    this.allChildren(parent).splice(index, 0, (node as HeapSnapshotGridNode));\n  }\n\n  removeChildByIndex(parent: HeapSnapshotGridNode, index: number): void {\n    this.allChildren(parent).splice(index, 1);\n  }\n\n  removeAllChildren(parent: HeapSnapshotGridNode): void {\n    adjacencyMap.delete(parent);\n  }\n\n  removeTopLevelNodes(): void {\n    this.disposeAllNodes();\n    this.rootNode().removeChildren();\n    this.removeAllChildren((this.rootNode() as HeapSnapshotGridNode));\n  }\n\n  isScrolledIntoView(element: HTMLElement): boolean {\n    const viewportTop = this.scrollContainer.scrollTop;\n    const viewportBottom = viewportTop + this.scrollContainer.clientHeight;\n    const elemTop = element.offsetTop;\n    const elemBottom = elemTop + element.offsetHeight;\n    return elemBottom <= viewportBottom && elemTop >= viewportTop;\n  }\n\n  onResize(): void {\n    super.onResize();\n    this.updateVisibleNodes(false);\n  }\n\n  onScroll(_event: Event): void {\n    this.updateVisibleNodes(false);\n\n    if (this.scrollToResolveCallback) {\n      this.scrollToResolveCallback();\n      this.scrollToResolveCallback = null;\n    }\n  }\n}\n\nexport class HeapSnapshotContainmentDataGrid extends HeapSnapshotSortableDataGrid {\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate,\n      displayName: string, columns?: DataGrid.DataGrid.ColumnDescriptor[]) {\n    columns =\n        columns || ([\n          {id: 'object', title: i18nString(UIStrings.object), disclosure: true, sortable: true},\n          {id: 'distance', title: i18nString(UIStrings.distance), width: '70px', sortable: true, fixedWidth: true},\n          {\n            id: 'shallowSize',\n            title: i18nString(UIStrings.shallowSize),\n            width: '110px',\n            sortable: true,\n            fixedWidth: true,\n          },\n          {\n            id: 'retainedSize',\n            title: i18nString(UIStrings.retainedSize),\n            width: '110px',\n            sortable: true,\n            fixedWidth: true,\n            sort: DataGrid.DataGrid.Order.Descending,\n          },\n        ] as DataGrid.DataGrid.ColumnDescriptor[]);\n    const dataGridParameters = ({displayName, columns} as DataGrid.DataGrid.Parameters);\n    super(heapProfilerModel, dataDisplayDelegate, dataGridParameters);\n  }\n\n  async setDataSource(snapshot: HeapSnapshotProxy, nodeIndex: number): Promise<void> {\n    this.snapshot = snapshot;\n    const node =\n        new HeapSnapshotModel.HeapSnapshotModel.Node(-1, 'root', 0, nodeIndex || snapshot.rootNodeIndex, 0, 0, '');\n    this.setRootNode(this.createRootNode(snapshot, node));\n    void (this.rootNode() as HeapSnapshotGridNode).sort();\n  }\n\n  createRootNode(snapshot: HeapSnapshotProxy, node: HeapSnapshotModel.HeapSnapshotModel.Node): HeapSnapshotObjectNode {\n    const fakeEdge = new HeapSnapshotModel.HeapSnapshotModel.Edge('', node, '', -1);\n    return new HeapSnapshotObjectNode(this, snapshot, fakeEdge, null);\n  }\n\n  sortingChanged(): void {\n    const rootNode = this.rootNode();\n    if (rootNode.hasChildren()) {\n      void (rootNode as HeapSnapshotGridNode).sort();\n    }\n  }\n}\n\nexport class HeapSnapshotRetainmentDataGrid extends HeapSnapshotContainmentDataGrid {\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate) {\n    const columns = ([\n      {id: 'object', title: i18nString(UIStrings.object), disclosure: true, sortable: true},\n      {\n        id: 'distance',\n        title: i18nString(UIStrings.distance),\n        width: '70px',\n        sortable: true,\n        fixedWidth: true,\n        sort: DataGrid.DataGrid.Order.Ascending,\n      },\n      {id: 'shallowSize', title: i18nString(UIStrings.shallowSize), width: '110px', sortable: true, fixedWidth: true},\n      {id: 'retainedSize', title: i18nString(UIStrings.retainedSize), width: '110px', sortable: true, fixedWidth: true},\n    ] as DataGrid.DataGrid.ColumnDescriptor[]);\n    super(heapProfilerModel, dataDisplayDelegate, i18nString(UIStrings.heapSnapshotRetainment), columns);\n  }\n\n  createRootNode(snapshot: HeapSnapshotProxy, node: HeapSnapshotModel.HeapSnapshotModel.Node):\n      HeapSnapshotRetainingObjectNode {\n    const fakeEdge = new HeapSnapshotModel.HeapSnapshotModel.Edge('', node, '', -1);\n    return new HeapSnapshotRetainingObjectNode(this, snapshot, fakeEdge, null);\n  }\n\n  sortFields(sortColumn: string, sortAscending: boolean): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    switch (sortColumn) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', sortAscending, 'count', false);\n      case 'count':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('count', sortAscending, 'name', true);\n      case 'shallowSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('shallowSize', sortAscending, 'name', true);\n      case 'retainedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('retainedSize', sortAscending, 'name', true);\n      case 'distance':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('distance', sortAscending, 'name', true);\n      default:\n        throw new Error(`Unknown column ${sortColumn}`);\n    }\n  }\n\n  reset(): void {\n    this.rootNode().removeChildren();\n    this.resetSortingCache();\n  }\n\n  async setDataSource(snapshot: HeapSnapshotProxy, nodeIndex: number): Promise<void> {\n    await super.setDataSource(snapshot, nodeIndex);\n    this.rootNode().expand();\n  }\n}\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// TODO(crbug.com/1228674): Remove this enum, it is only used in web tests.\n// eslint-disable-next-line rulesdir/const_enum\nexport enum HeapSnapshotRetainmentDataGridEvents {\n  ExpandRetainersComplete = 'ExpandRetainersComplete',\n}\n\nexport class HeapSnapshotConstructorsDataGrid extends HeapSnapshotViewportDataGrid {\n  profileIndex: number;\n  objectIdToSelect: string|null;\n  nextRequestedFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter|null;\n  lastFilter?: HeapSnapshotModel.HeapSnapshotModel.NodeFilter|null;\n  filterInProgress?: HeapSnapshotModel.HeapSnapshotModel.NodeFilter|null;\n\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate) {\n    const columns = ([\n      {id: 'object', title: i18nString(UIStrings.constructorString), disclosure: true, sortable: true},\n      {id: 'distance', title: i18nString(UIStrings.distance), width: '70px', sortable: true, fixedWidth: true},\n      {id: 'shallowSize', title: i18nString(UIStrings.shallowSize), width: '110px', sortable: true, fixedWidth: true},\n      {\n        id: 'retainedSize',\n        title: i18nString(UIStrings.retainedSize),\n        width: '110px',\n        sort: DataGrid.DataGrid.Order.Descending,\n        sortable: true,\n        fixedWidth: true,\n      },\n    ] as DataGrid.DataGrid.ColumnDescriptor[]);\n    super(\n        heapProfilerModel, dataDisplayDelegate,\n        ({displayName: i18nString(UIStrings.heapSnapshotConstructors).toString(), columns} as\n         DataGrid.DataGrid.Parameters));\n    // clang-format on\n    this.profileIndex = -1;\n    this.objectIdToSelect = null;\n\n    this.nextRequestedFilter = null;\n  }\n\n  sortFields(sortColumn: string, sortAscending: boolean): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    switch (sortColumn) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', sortAscending, 'retainedSize', false);\n      case 'distance':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig(\n            'distance', sortAscending, 'retainedSize', false);\n      case 'shallowSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('shallowSize', sortAscending, 'name', true);\n      case 'retainedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('retainedSize', sortAscending, 'name', true);\n      default:\n        throw new Error(`Unknown column ${sortColumn}`);\n    }\n  }\n\n  async revealObjectByHeapSnapshotId(id: string): Promise<HeapSnapshotGridNode|null> {\n    if (!this.snapshot) {\n      this.objectIdToSelect = id;\n      return null;\n    }\n\n    const className = await this.snapshot.nodeClassName(parseInt(id, 10));\n    if (!className) {\n      return null;\n    }\n\n    const parent = this.topLevelNodes().find(classNode => classNode.name === className);\n    if (!parent) {\n      return null;\n    }\n\n    const nodes = await (parent as HeapSnapshotConstructorNode).populateNodeBySnapshotObjectId(parseInt(id, 10));\n    return nodes.length ? this.revealTreeNode(nodes) : null;\n  }\n\n  clear(): void {\n    this.nextRequestedFilter = null;\n    this.lastFilter = null;\n    this.removeTopLevelNodes();\n  }\n\n  async setDataSource(snapshot: HeapSnapshotProxy, _nodeIndex: number): Promise<void> {\n    this.snapshot = snapshot;\n    if (this.profileIndex === -1) {\n      void this.populateChildren();\n    }\n\n    if (this.objectIdToSelect) {\n      void this.revealObjectByHeapSnapshotId(this.objectIdToSelect);\n      this.objectIdToSelect = null;\n    }\n  }\n\n  setSelectionRange(minNodeId: number, maxNodeId: number): void {\n    this.nodeFilterInternal = new HeapSnapshotModel.HeapSnapshotModel.NodeFilter(minNodeId, maxNodeId);\n    void this.populateChildren(this.nodeFilterInternal);\n  }\n\n  setAllocationNodeId(allocationNodeId: number): void {\n    this.nodeFilterInternal = new HeapSnapshotModel.HeapSnapshotModel.NodeFilter();\n    this.nodeFilterInternal.allocationNodeId = allocationNodeId;\n    void this.populateChildren(this.nodeFilterInternal);\n  }\n\n  aggregatesReceived(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter, aggregates: {\n    [x: string]: HeapSnapshotModel.HeapSnapshotModel.Aggregate,\n  }): void {\n    this.filterInProgress = null;\n    if (this.nextRequestedFilter && this.snapshot) {\n      void this.snapshot.aggregatesWithFilter(this.nextRequestedFilter)\n          .then(this.aggregatesReceived.bind(this, this.nextRequestedFilter));\n      this.filterInProgress = this.nextRequestedFilter;\n      this.nextRequestedFilter = null;\n    }\n    this.removeTopLevelNodes();\n    this.resetSortingCache();\n    for (const constructor in aggregates) {\n      this.appendNode(\n          (this.rootNode() as HeapSnapshotGridNode),\n          new HeapSnapshotConstructorNode(this, constructor, aggregates[constructor], nodeFilter));\n    }\n    this.sortingChanged();\n    this.lastFilter = nodeFilter;\n  }\n\n  async populateChildren(maybeNodeFilter?: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): Promise<void> {\n    const nodeFilter = maybeNodeFilter || new HeapSnapshotModel.HeapSnapshotModel.NodeFilter();\n\n    if (this.filterInProgress) {\n      this.nextRequestedFilter = this.filterInProgress.equals(nodeFilter) ? null : nodeFilter;\n      return;\n    }\n    if (this.lastFilter && this.lastFilter.equals(nodeFilter)) {\n      return;\n    }\n    this.filterInProgress = nodeFilter;\n\n    if (this.snapshot) {\n      const aggregates = await this.snapshot.aggregatesWithFilter(nodeFilter);\n      this.aggregatesReceived(nodeFilter, aggregates);\n    }\n  }\n\n  filterSelectIndexChanged(profiles: HeapProfileHeader[], profileIndex: number): void {\n    this.profileIndex = profileIndex;\n    this.nodeFilterInternal = undefined;\n    if (profileIndex !== -1) {\n      const minNodeId = profileIndex > 0 ? profiles[profileIndex - 1].maxJSObjectId : 0;\n      const maxNodeId = profiles[profileIndex].maxJSObjectId;\n      this.nodeFilterInternal = new HeapSnapshotModel.HeapSnapshotModel.NodeFilter(minNodeId, maxNodeId);\n    }\n\n    void this.populateChildren(this.nodeFilterInternal);\n  }\n}\n\nexport class HeapSnapshotDiffDataGrid extends HeapSnapshotViewportDataGrid {\n  baseSnapshot?: HeapSnapshotProxy;\n\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate) {\n    const columns = ([\n      {id: 'object', title: i18nString(UIStrings.constructorString), disclosure: true, sortable: true},\n      {id: 'addedCount', title: i18nString(UIStrings.New), width: '75px', sortable: true, fixedWidth: true},\n      {id: 'removedCount', title: i18nString(UIStrings.Deleted), width: '75px', sortable: true, fixedWidth: true},\n      {id: 'countDelta', title: i18nString(UIStrings.Delta), width: '65px', sortable: true, fixedWidth: true},\n      {\n        id: 'addedSize',\n        title: i18nString(UIStrings.allocSize),\n        width: '75px',\n        sortable: true,\n        fixedWidth: true,\n        sort: DataGrid.DataGrid.Order.Descending,\n      },\n      {id: 'removedSize', title: i18nString(UIStrings.freedSize), width: '75px', sortable: true, fixedWidth: true},\n      {id: 'sizeDelta', title: i18nString(UIStrings.sizeDelta), width: '75px', sortable: true, fixedWidth: true},\n    ] as DataGrid.DataGrid.ColumnDescriptor[]);\n    super(\n        heapProfilerModel, dataDisplayDelegate,\n        ({displayName: i18nString(UIStrings.heapSnapshotDiff).toString(), columns} as DataGrid.DataGrid.Parameters));\n  }\n\n  defaultPopulateCount(): number {\n    return 50;\n  }\n\n  sortFields(sortColumn: string, sortAscending: boolean): HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig {\n    switch (sortColumn) {\n      case 'object':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('name', sortAscending, 'count', false);\n      case 'addedCount':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('addedCount', sortAscending, 'name', true);\n      case 'removedCount':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('removedCount', sortAscending, 'name', true);\n      case 'countDelta':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('countDelta', sortAscending, 'name', true);\n      case 'addedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('addedSize', sortAscending, 'name', true);\n      case 'removedSize':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('removedSize', sortAscending, 'name', true);\n      case 'sizeDelta':\n        return new HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig('sizeDelta', sortAscending, 'name', true);\n      default:\n        throw new Error(`Unknown column ${sortColumn}`);\n    }\n  }\n\n  async setDataSource(snapshot: HeapSnapshotProxy, _nodeIndex: number): Promise<void> {\n    this.snapshot = snapshot;\n  }\n\n  setBaseDataSource(baseSnapshot: HeapSnapshotProxy): void {\n    this.baseSnapshot = baseSnapshot;\n    this.removeTopLevelNodes();\n    this.resetSortingCache();\n    if (this.baseSnapshot === this.snapshot) {\n      this.dispatchEventToListeners(HeapSnapshotSortableDataGridEvents.SortingComplete);\n      return;\n    }\n    void this.populateChildren();\n  }\n\n  async populateChildren(): Promise<void> {\n    if (this.snapshot === null || this.baseSnapshot === undefined || this.baseSnapshot.uid === undefined) {\n      throw new Error('Data sources have not been set correctly');\n    }\n    // Two snapshots live in different workers isolated from each other. That is why\n    // we first need to collect information about the nodes in the first snapshot and\n    // then pass it to the second snapshot to calclulate the diff.\n    const aggregatesForDiff = await this.baseSnapshot.aggregatesForDiff();\n    const diffByClassName = await this.snapshot.calculateSnapshotDiff(this.baseSnapshot.uid, aggregatesForDiff);\n\n    for (const className in diffByClassName) {\n      const diff = diffByClassName[className];\n      this.appendNode(this.rootNode(), new HeapSnapshotDiffNode(this, className, diff));\n    }\n    this.sortingChanged();\n  }\n}\n\nexport class AllocationDataGrid extends HeapSnapshotViewportDataGrid {\n  readonly linkifierInternal: Components.Linkifier.Linkifier;\n  topNodes?: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[];\n\n  constructor(\n      heapProfilerModel: SDK.HeapProfilerModel.HeapProfilerModel|null, dataDisplayDelegate: DataDisplayDelegate) {\n    const columns = ([\n      {id: 'liveCount', title: i18nString(UIStrings.liveCount), width: '75px', sortable: true, fixedWidth: true},\n      {id: 'count', title: i18nString(UIStrings.count), width: '65px', sortable: true, fixedWidth: true},\n      {id: 'liveSize', title: i18nString(UIStrings.liveSize), width: '75px', sortable: true, fixedWidth: true},\n      {\n        id: 'size',\n        title: i18nString(UIStrings.size),\n        width: '75px',\n        sortable: true,\n        fixedWidth: true,\n        sort: DataGrid.DataGrid.Order.Descending,\n      },\n      {id: 'name', title: i18nString(UIStrings.function), disclosure: true, sortable: true},\n    ] as DataGrid.DataGrid.ColumnDescriptor[]);\n    super(\n        heapProfilerModel, dataDisplayDelegate,\n        ({displayName: i18nString(UIStrings.allocation).toString(), columns} as DataGrid.DataGrid.Parameters));\n    // clang-format on\n    this.linkifierInternal = new Components.Linkifier.Linkifier();\n  }\n\n  get linkifier(): Components.Linkifier.Linkifier {\n    return this.linkifierInternal;\n  }\n\n  dispose(): void {\n    this.linkifierInternal.reset();\n  }\n\n  async setDataSource(snapshot: HeapSnapshotProxy, _nodeIndex: number): Promise<void> {\n    this.snapshot = snapshot;\n    this.topNodes = await this.snapshot.allocationTracesTops();\n    this.populateChildren();\n  }\n\n  populateChildren(): void {\n    this.removeTopLevelNodes();\n    const root = this.rootNode();\n    const tops = this.topNodes || [];\n    for (const top of tops) {\n      this.appendNode(root, new AllocationGridNode(this, top));\n    }\n    this.updateVisibleNodes(true);\n  }\n\n  sortingChanged(): void {\n    if (this.topNodes !== undefined) {\n      this.topNodes.sort(this.createComparator());\n      this.rootNode().removeChildren();\n      this.populateChildren();\n    }\n  }\n\n  createComparator(): (arg0: Object, arg1: Object) => number {\n    const fieldName = this.sortColumnId();\n    const compareResult = (this.sortOrder() === DataGrid.DataGrid.Order.Ascending) ? +1 : -1;\n    function compare(a: Object, b: Object): number {\n      // @ts-ignore\n      if (a[fieldName] > b[fieldName]) {\n        return compareResult;\n      }\n      // @ts-ignore\n      if (a[fieldName] < b[fieldName]) {\n        return -compareResult;\n      }\n      return 0;\n    }\n    return compare;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
