{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/console/ConsolePrompt.ts"],
  "sourcesContent": ["// Copyright 2016 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Host from '../../core/host/host.js';\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Root from '../../core/root/root.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Formatter from '../../models/formatter/formatter.js';\nimport * as SourceMapScopes from '../../models/source_map_scopes/source_map_scopes.js';\nimport * as CodeMirror from '../../third_party/codemirror.next/codemirror.next.js';\nimport * as TextEditor from '../../ui/components/text_editor/text_editor.js';\nimport * as ObjectUI from '../../ui/legacy/components/object_ui/object_ui.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport {ConsolePanel} from './ConsolePanel.js';\nimport consolePromptStyles from './consolePrompt.css.js';\n\nconst UIStrings = {\n  /**\n  *@description Text in Console Prompt of the Console panel\n  */\n  consolePrompt: 'Console prompt',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/console/ConsolePrompt.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nexport class ConsolePrompt extends Common.ObjectWrapper.eventMixin<EventTypes, typeof UI.Widget.Widget>(\n    UI.Widget.Widget) {\n  private addCompletionsFromHistory: boolean;\n  private historyInternal: ConsoleHistoryManager;\n  private initialText: string;\n  private editor: TextEditor.TextEditor.TextEditor;\n  private readonly eagerPreviewElement: HTMLDivElement;\n  private textChangeThrottler: Common.Throttler.Throttler;\n  private readonly formatter: ObjectUI.RemoteObjectPreviewFormatter.RemoteObjectPreviewFormatter;\n  private requestPreviewBound: () => Promise<void>;\n  private requestPreviewCurrent = 0;\n  private readonly innerPreviewElement: HTMLElement;\n  private readonly promptIcon: UI.Icon.Icon;\n  private readonly iconThrottler: Common.Throttler.Throttler;\n  private readonly eagerEvalSetting: Common.Settings.Setting<boolean>;\n  private previewRequestForTest: Promise<void>|null;\n  private highlightingNode: boolean;\n  // The CodeMirror state field that controls whether the argument hints are showing.\n  // If they are, the escape key will clear them. However, if they aren't, then the\n  // console drawer should be hidden as a whole.\n  #argumentHintsState: CodeMirror.StateField<CodeMirror.Tooltip|null>;\n\n  constructor() {\n    super();\n    this.addCompletionsFromHistory = true;\n    this.historyInternal = new ConsoleHistoryManager();\n\n    this.initialText = '';\n    this.eagerPreviewElement = document.createElement('div');\n    this.eagerPreviewElement.classList.add('console-eager-preview');\n    this.textChangeThrottler = new Common.Throttler.Throttler(150);\n    this.formatter = new ObjectUI.RemoteObjectPreviewFormatter.RemoteObjectPreviewFormatter();\n    this.requestPreviewBound = this.requestPreview.bind(this);\n    this.innerPreviewElement = this.eagerPreviewElement.createChild('div', 'console-eager-inner-preview');\n    this.eagerPreviewElement.appendChild(UI.Icon.Icon.create('smallicon-command-result', 'preview-result-icon'));\n\n    const editorContainerElement = this.element.createChild('div', 'console-prompt-editor-container');\n    this.element.appendChild(this.eagerPreviewElement);\n\n    this.promptIcon = UI.Icon.Icon.create('smallicon-text-prompt', 'console-prompt-icon');\n    this.element.appendChild(this.promptIcon);\n    this.iconThrottler = new Common.Throttler.Throttler(0);\n\n    this.eagerEvalSetting = Common.Settings.Settings.instance().moduleSetting('consoleEagerEval');\n    this.eagerEvalSetting.addChangeListener(this.eagerSettingChanged.bind(this));\n    this.eagerPreviewElement.classList.toggle('hidden', !this.eagerEvalSetting.get());\n\n    this.element.tabIndex = 0;\n    this.previewRequestForTest = null;\n    this.highlightingNode = false;\n    const argumentHints = TextEditor.JavaScript.argumentHints();\n    this.#argumentHintsState = argumentHints[0];\n\n    const editorState = CodeMirror.EditorState.create({\n      doc: this.initialText,\n      extensions: [\n        CodeMirror.keymap.of(this.editorKeymap()),\n        CodeMirror.EditorView.updateListener.of(update => this.editorUpdate(update)),\n        argumentHints,\n        TextEditor.JavaScript.completion(),\n        TextEditor.Config.showCompletionHint,\n        CodeMirror.javascript.javascript(),\n        TextEditor.Config.baseConfiguration(this.initialText),\n        TextEditor.Config.autocompletion,\n        CodeMirror.javascript.javascriptLanguage.data.of({\n          autocomplete: (context: CodeMirror.CompletionContext): CodeMirror.CompletionResult | null =>\n              this.historyCompletions(context),\n        }),\n        CodeMirror.EditorView.contentAttributes.of({'aria-label': i18nString(UIStrings.consolePrompt)}),\n        CodeMirror.EditorView.lineWrapping,\n        CodeMirror.autocompletion({aboveCursor: true}),\n      ],\n    });\n\n    this.editor = new TextEditor.TextEditor.TextEditor(editorState);\n    this.editor.addEventListener('keydown', (event): void => {\n      if (event.defaultPrevented) {\n        event.stopPropagation();\n      }\n    });\n    editorContainerElement.appendChild(this.editor);\n\n    if (this.hasFocus()) {\n      this.focus();\n    }\n    this.element.removeAttribute('tabindex');\n\n    this.editorSetForTest();\n\n    // Record the console tool load time after the console prompt constructor is complete.\n    Host.userMetrics.panelLoaded('console', 'DevTools.Launch.Console');\n  }\n\n  private eagerSettingChanged(): void {\n    const enabled = this.eagerEvalSetting.get();\n    this.eagerPreviewElement.classList.toggle('hidden', !enabled);\n    if (enabled) {\n      void this.requestPreview();\n    }\n  }\n\n  belowEditorElement(): Element {\n    return this.eagerPreviewElement;\n  }\n\n  private onTextChanged(): void {\n    // ConsoleView and prompt both use a throttler, so we clear the preview\n    // ASAP to avoid inconsistency between a fresh viewport and stale preview.\n    if (this.eagerEvalSetting.get()) {\n      const asSoonAsPossible = !TextEditor.Config.contentIncludingHint(this.editor.editor);\n      this.previewRequestForTest = this.textChangeThrottler.schedule(this.requestPreviewBound, asSoonAsPossible);\n    }\n    this.updatePromptIcon();\n    this.dispatchEventToListeners(Events.TextChanged);\n  }\n\n  private async requestPreview(): Promise<void> {\n    const id = ++this.requestPreviewCurrent;\n    const text = TextEditor.Config.contentIncludingHint(this.editor.editor).trim();\n    const executionContext = UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n    const {preview, result} = await ObjectUI.JavaScriptREPL.JavaScriptREPL.evaluateAndBuildPreview(\n        text, true /* throwOnSideEffect */, true /* replMode */, 500 /* timeout */);\n    if (this.requestPreviewCurrent !== id) {\n      return;\n    }\n    this.innerPreviewElement.removeChildren();\n    if (preview.deepTextContent() !== TextEditor.Config.contentIncludingHint(this.editor.editor).trim()) {\n      this.innerPreviewElement.appendChild(preview);\n    }\n    if (result && 'object' in result && result.object && result.object.subtype === 'node') {\n      this.highlightingNode = true;\n      SDK.OverlayModel.OverlayModel.highlightObjectAsDOMNode(result.object);\n    } else if (this.highlightingNode) {\n      this.highlightingNode = false;\n      SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n    }\n    if (result && executionContext) {\n      executionContext.runtimeModel.releaseEvaluationResult(result);\n    }\n  }\n\n  wasShown(): void {\n    super.wasShown();\n    this.registerCSSFiles([consolePromptStyles]);\n  }\n\n  willHide(): void {\n    if (this.highlightingNode) {\n      this.highlightingNode = false;\n      SDK.OverlayModel.OverlayModel.hideDOMNodeHighlight();\n    }\n  }\n\n  history(): ConsoleHistoryManager {\n    return this.historyInternal;\n  }\n\n  clearAutocomplete(): void {\n    CodeMirror.closeCompletion(this.editor.editor);\n  }\n\n  private isCaretAtEndOfPrompt(): boolean {\n    return this.editor.state.selection.main.head === this.editor.state.doc.length;\n  }\n\n  moveCaretToEndOfPrompt(): void {\n    this.editor.dispatch({\n      selection: CodeMirror.EditorSelection.cursor(this.editor.state.doc.length),\n    });\n  }\n\n  clear(): void {\n    this.editor.dispatch({\n      changes: {from: 0, to: this.editor.state.doc.length},\n    });\n  }\n\n  text(): string {\n    return this.editor.state.doc.toString();\n  }\n\n  setAddCompletionsFromHistory(value: boolean): void {\n    this.addCompletionsFromHistory = value;\n  }\n\n  private editorKeymap(): readonly CodeMirror.KeyBinding[] {\n    return [\n      {key: 'ArrowUp', run: (): boolean => this.moveHistory(-1)},\n      {key: 'ArrowDown', run: (): boolean => this.moveHistory(1)},\n      {mac: 'Ctrl-p', run: (): boolean => this.moveHistory(-1, true)},\n      {mac: 'Ctrl-n', run: (): boolean => this.moveHistory(1, true)},\n      {\n        key: 'Escape',\n        run: (): boolean => {\n          return TextEditor.JavaScript.closeArgumentsHintsTooltip(this.editor.editor, this.#argumentHintsState);\n        },\n      },\n      {\n        key: 'Enter',\n        run: (): boolean => {\n          void this.handleEnter();\n          return true;\n        },\n        shift: CodeMirror.insertNewlineAndIndent,\n      },\n    ];\n  }\n\n  private moveHistory(dir: -1|1, force = false): boolean {\n    const {editor} = this.editor, {main} = editor.state.selection;\n    if (!force) {\n      if (!main.empty) {\n        return false;\n      }\n      const cursorCoords = editor.coordsAtPos(main.head);\n      const endCoords = editor.coordsAtPos(dir < 0 ? 0 : editor.state.doc.length);\n      // Check if there are wrapped lines in this direction, and let\n      // the cursor move normally if there are.\n      if (cursorCoords && endCoords &&\n          (dir < 0 ? cursorCoords.top > endCoords.top + 5 : cursorCoords.bottom < endCoords.bottom - 5)) {\n        return false;\n      }\n    }\n\n    const history = this.historyInternal;\n    const newText = dir < 0 ? history.previous(this.text()) : history.next();\n    if (newText === undefined) {\n      return false;\n    }\n\n    // Change the prompt input to the history content, and scroll to the end to\n    // bring the full content (potentially multiple lines) into view.\n    const cursorPos = newText.length;\n    this.editor.dispatch({\n      changes: {from: 0, to: this.editor.state.doc.length, insert: newText},\n      selection: CodeMirror.EditorSelection.cursor(cursorPos),\n      scrollIntoView: true,\n    });\n    if (dir < 0) {\n      // If we are going back in history, put the cursor to the end of the first line\n      // so that the user can quickly go further back in history.\n      const firstLineBreak = newText.search(/\\n|$/);\n      this.editor.dispatch({\n        selection: CodeMirror.EditorSelection.cursor(firstLineBreak),\n      });\n    }\n    return true;\n  }\n\n  private async enterWillEvaluate(): Promise<boolean> {\n    const {state} = this.editor;\n    return state.doc.length > 0 && await TextEditor.JavaScript.isExpressionComplete(state.doc.toString());\n  }\n\n  private async handleEnter(): Promise<void> {\n    if (await this.enterWillEvaluate()) {\n      this.appendCommand(this.text(), true);\n      TextEditor.JavaScript.closeArgumentsHintsTooltip(this.editor.editor, this.#argumentHintsState);\n      this.editor.dispatch({\n        changes: {from: 0, to: this.editor.state.doc.length},\n        scrollIntoView: true,\n      });\n    } else if (this.editor.state.doc.length) {\n      CodeMirror.insertNewlineAndIndent(this.editor.editor);\n    } else {\n      this.editor.dispatch({scrollIntoView: true});\n    }\n  }\n\n  private updatePromptIcon(): void {\n    void this.iconThrottler.schedule(async () => {\n      this.promptIcon.classList.toggle('console-prompt-incomplete', !(await this.enterWillEvaluate()));\n    });\n  }\n\n  private appendCommand(text: string, useCommandLineAPI: boolean): void {\n    const currentExecutionContext = UI.Context.Context.instance().flavor(SDK.RuntimeModel.ExecutionContext);\n    if (currentExecutionContext) {\n      const executionContext = currentExecutionContext;\n      const message = SDK.ConsoleModel.ConsoleModel.instance().addCommandMessage(executionContext, text);\n      const expression = ObjectUI.JavaScriptREPL.JavaScriptREPL.preprocessExpression(text);\n      void this.evaluateCommandInConsole(executionContext, message, expression, useCommandLineAPI);\n      if (ConsolePanel.instance().isShowing()) {\n        Host.userMetrics.actionTaken(Host.UserMetrics.Action.CommandEvaluatedInConsolePanel);\n      }\n    }\n  }\n\n  private async evaluateCommandInConsole(\n      executionContext: SDK.RuntimeModel.ExecutionContext, message: SDK.ConsoleModel.ConsoleMessage, expression: string,\n      useCommandLineAPI: boolean): Promise<void> {\n    if (Root.Runtime.experiments.isEnabled('evaluateExpressionsWithSourceMaps')) {\n      const callFrame = executionContext.debuggerModel.selectedCallFrame();\n      if (callFrame) {\n        const nameMap = await SourceMapScopes.NamesResolver.allVariablesInCallFrame(callFrame);\n        expression = await this.substituteNames(expression, nameMap);\n      }\n    }\n\n    await SDK.ConsoleModel.ConsoleModel.instance().evaluateCommandInConsole(\n        executionContext, message, expression, useCommandLineAPI);\n  }\n\n  private async substituteNames(expression: string, mapping: Map<string, string>): Promise<string> {\n    try {\n      return await Formatter.FormatterWorkerPool.formatterWorkerPool().javaScriptSubstitute(expression, mapping);\n    } catch {\n      return expression;\n    }\n  }\n\n  private editorUpdate(update: CodeMirror.ViewUpdate): void {\n    if (update.docChanged ||\n        CodeMirror.selectedCompletion(update.state) !== CodeMirror.selectedCompletion(update.startState)) {\n      this.onTextChanged();\n    } else if (update.selectionSet) {\n      this.updatePromptIcon();\n    }\n  }\n\n  private historyCompletions(context: CodeMirror.CompletionContext): CodeMirror.CompletionResult|null {\n    const text = this.text();\n    if (!this.addCompletionsFromHistory || !this.isCaretAtEndOfPrompt() || (!text.length && !context.explicit)) {\n      return null;\n    }\n    const result = [];\n    const set = new Set<string>();\n    const data = this.historyInternal.historyData();\n    for (let i = data.length - 1; i >= 0 && result.length < 50; --i) {\n      const item = data[i];\n      if (!item.startsWith(text)) {\n        continue;\n      }\n      if (set.has(item)) {\n        continue;\n      }\n      set.add(item);\n      result.push({label: item, type: 'secondary', boost: -1e5});\n    }\n    return result.length ? {\n      from: 0,\n      to: text.length,\n      options: result,\n    } :\n                           null;\n  }\n\n  focus(): void {\n    this.editor.focus();\n  }\n\n  private editorSetForTest(): void {\n  }\n}\n\nexport class ConsoleHistoryManager {\n  private data: string[];\n  private historyOffset: number;\n  private uncommittedIsTop?: boolean;\n  constructor() {\n    this.data = [];\n\n    /**\n     * 1-based entry in the history stack.\n     */\n    this.historyOffset = 1;\n  }\n\n  historyData(): string[] {\n    return this.data;\n  }\n\n  setHistoryData(data: string[]): void {\n    this.data = data.slice();\n    this.historyOffset = 1;\n  }\n\n  /**\n   * Pushes a committed text into the history.\n   */\n  pushHistoryItem(text: string): void {\n    if (this.uncommittedIsTop) {\n      this.data.pop();\n      delete this.uncommittedIsTop;\n    }\n\n    this.historyOffset = 1;\n    if (text === this.currentHistoryItem()) {\n      return;\n    }\n    this.data.push(text);\n  }\n\n  /**\n   * Pushes the current (uncommitted) text into the history.\n   */\n  private pushCurrentText(currentText: string): void {\n    if (this.uncommittedIsTop) {\n      this.data.pop();\n    }  // Throw away obsolete uncommitted text.\n    this.uncommittedIsTop = true;\n    this.data.push(currentText);\n  }\n\n  previous(currentText: string): string|undefined {\n    if (this.historyOffset > this.data.length) {\n      return undefined;\n    }\n    if (this.historyOffset === 1) {\n      this.pushCurrentText(currentText);\n    }\n    ++this.historyOffset;\n    return this.currentHistoryItem();\n  }\n\n  next(): string|undefined {\n    if (this.historyOffset === 1) {\n      return undefined;\n    }\n    --this.historyOffset;\n    return this.currentHistoryItem();\n  }\n\n  private currentHistoryItem(): string|undefined {\n    return this.data[this.data.length - this.historyOffset];\n  }\n}\n\nexport const enum Events {\n  TextChanged = 'TextChanged',\n}\n\nexport type EventTypes = {\n  [Events.TextChanged]: void,\n};\n"],
  "mappings": "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",
  "names": []
}
