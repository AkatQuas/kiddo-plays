{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/console/ConsoleViewport.ts"],
  "sourcesContent": ["/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as Components from '../../ui/legacy/components/utils/utils.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport type {ConsoleViewMessage} from './ConsoleViewMessage.js';\n\ninterface SelectionModel {\n  item: number;\n  node: Node;\n  offset: number;\n}\n\nexport class ConsoleViewport {\n  element: HTMLElement;\n  private topGapElement: HTMLElement;\n  private topGapElementActive: boolean;\n  private contentElementInternal: HTMLElement;\n  private bottomGapElement: HTMLElement;\n  private bottomGapElementActive: boolean;\n  private provider: ConsoleViewportProvider;\n  private virtualSelectedIndex: number;\n  private firstActiveIndex: number;\n  private lastActiveIndex: number;\n  private renderedItems: ConsoleViewportElement[];\n  private anchorSelection: SelectionModel|null;\n  private headSelection: SelectionModel|null;\n  private itemCount: number;\n  private cumulativeHeights: Int32Array;\n  private muteCopyHandler: boolean;\n  private readonly observer: MutationObserver;\n  private readonly observerConfig: {\n    childList: boolean,\n    subtree: boolean,\n  };\n  private stickToBottomInternal: boolean;\n  private selectionIsBackward: boolean;\n  private lastSelectedElement?: HTMLElement|null;\n  private cachedProviderElements?: (ConsoleViewportElement|null)[];\n\n  constructor(provider: ConsoleViewportProvider) {\n    this.element = document.createElement('div');\n    this.element.style.overflow = 'auto';\n    this.topGapElement = this.element.createChild('div');\n    this.topGapElement.style.height = '0px';\n    this.topGapElement.style.color = 'transparent';\n    this.topGapElementActive = false;\n    this.contentElementInternal = this.element.createChild('div');\n    this.bottomGapElement = this.element.createChild('div');\n    this.bottomGapElement.style.height = '0px';\n    this.bottomGapElement.style.color = 'transparent';\n    this.bottomGapElementActive = false;\n\n    // Text content needed for range intersection checks in updateSelectionModel.\n    // Use Unicode ZERO WIDTH NO-BREAK SPACE, which avoids contributing any height to the element's layout overflow.\n    this.topGapElement.textContent = '\\uFEFF';\n    this.bottomGapElement.textContent = '\\uFEFF';\n\n    UI.ARIAUtils.markAsHidden(this.topGapElement);\n    UI.ARIAUtils.markAsHidden(this.bottomGapElement);\n\n    this.provider = provider;\n    this.element.addEventListener('scroll', this.onScroll.bind(this), false);\n    this.element.addEventListener('copy', (this.onCopy.bind(this) as EventListener), false);\n    this.element.addEventListener('dragstart', (this.onDragStart.bind(this) as (arg0: Event) => unknown), false);\n    this.contentElementInternal.addEventListener('focusin', (this.onFocusIn.bind(this) as EventListener), false);\n    this.contentElementInternal.addEventListener('focusout', (this.onFocusOut.bind(this) as EventListener), false);\n    this.contentElementInternal.addEventListener('keydown', (this.onKeyDown.bind(this) as EventListener), false);\n    this.virtualSelectedIndex = -1;\n    this.contentElementInternal.tabIndex = -1;\n\n    this.firstActiveIndex = -1;\n    this.lastActiveIndex = -1;\n    this.renderedItems = [];\n    this.anchorSelection = null;\n    this.headSelection = null;\n    this.itemCount = 0;\n    this.cumulativeHeights = new Int32Array(0);\n    this.muteCopyHandler = false;\n\n    // Listen for any changes to descendants and trigger a refresh. This ensures\n    // that items updated asynchronously will not break stick-to-bottom behavior\n    // if they change the scroll height.\n    this.observer = new MutationObserver(this.refresh.bind(this));\n    this.observerConfig = {childList: true, subtree: true};\n    this.stickToBottomInternal = false;\n    this.selectionIsBackward = false;\n  }\n\n  stickToBottom(): boolean {\n    return this.stickToBottomInternal;\n  }\n\n  setStickToBottom(value: boolean): void {\n    this.stickToBottomInternal = value;\n    if (this.stickToBottomInternal) {\n      this.observer.observe(this.contentElementInternal, this.observerConfig);\n    } else {\n      this.observer.disconnect();\n    }\n  }\n\n  hasVirtualSelection(): boolean {\n    return this.virtualSelectedIndex !== -1;\n  }\n\n  copyWithStyles(): void {\n    this.muteCopyHandler = true;\n    this.element.ownerDocument.execCommand('copy');\n    this.muteCopyHandler = false;\n  }\n\n  private onCopy(event: ClipboardEvent): void {\n    if (this.muteCopyHandler) {\n      return;\n    }\n\n    const text = this.selectedText();\n    if (!text) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (this.selectionContainsTable()) {\n      this.copyWithStyles();\n    } else if (event.clipboardData) {\n      event.clipboardData.setData('text/plain', text);\n    }\n  }\n\n  private onFocusIn(event: FocusEvent): void {\n    const renderedIndex =\n        this.renderedItems.findIndex(item => item.element().isSelfOrAncestor((event.target as Node | null)));\n    if (renderedIndex !== -1) {\n      this.virtualSelectedIndex = this.firstActiveIndex + renderedIndex;\n    }\n    let focusLastChild = false;\n    // Make default selection when moving from external (e.g. prompt) to the container.\n    if (this.virtualSelectedIndex === -1 && this.isOutsideViewport((event.relatedTarget as Element | null)) &&\n        event.target === this.contentElementInternal && this.itemCount) {\n      focusLastChild = true;\n      this.virtualSelectedIndex = this.itemCount - 1;\n\n      // Update stick to bottom before scrolling into view.\n      this.refresh();\n      this.scrollItemIntoView(this.virtualSelectedIndex);\n    }\n    this.updateFocusedItem(focusLastChild);\n  }\n\n  private onFocusOut(event: FocusEvent): void {\n    if (this.isOutsideViewport((event.relatedTarget as Element | null))) {\n      this.virtualSelectedIndex = -1;\n    }\n    this.updateFocusedItem();\n  }\n\n  private isOutsideViewport(element: Element|null): boolean {\n    return element !== null && !element.isSelfOrDescendant(this.contentElementInternal);\n  }\n\n  private onDragStart(event: DragEvent): boolean {\n    const text = this.selectedText();\n    if (!text) {\n      return false;\n    }\n    if (event.dataTransfer) {\n      event.dataTransfer.clearData();\n      event.dataTransfer.setData('text/plain', text);\n      event.dataTransfer.effectAllowed = 'copy';\n    }\n    return true;\n  }\n\n  private onKeyDown(event: KeyboardEvent): void {\n    if (UI.UIUtils.isEditing() || !this.itemCount || event.shiftKey) {\n      return;\n    }\n    let isArrowUp = false;\n    switch (event.key) {\n      case 'ArrowUp':\n        if (this.virtualSelectedIndex > 0) {\n          isArrowUp = true;\n          this.virtualSelectedIndex--;\n        } else {\n          return;\n        }\n        break;\n      case 'ArrowDown':\n        if (this.virtualSelectedIndex < this.itemCount - 1) {\n          this.virtualSelectedIndex++;\n        } else {\n          return;\n        }\n        break;\n      case 'Home':\n        this.virtualSelectedIndex = 0;\n        break;\n      case 'End':\n        this.virtualSelectedIndex = this.itemCount - 1;\n        break;\n      default:\n        return;\n    }\n    event.consume(true);\n    this.scrollItemIntoView(this.virtualSelectedIndex);\n    this.updateFocusedItem(isArrowUp);\n  }\n\n  private updateFocusedItem(focusLastChild?: boolean): void {\n    const selectedElement = this.renderedElementAt(this.virtualSelectedIndex);\n    const changed = this.lastSelectedElement !== selectedElement;\n    const containerHasFocus =\n        this.contentElementInternal === Platform.DOMUtilities.deepActiveElement(this.element.ownerDocument);\n    if (this.lastSelectedElement && changed) {\n      this.lastSelectedElement.classList.remove('console-selected');\n    }\n    if (selectedElement && (focusLastChild || changed || containerHasFocus) && this.element.hasFocus()) {\n      selectedElement.classList.add('console-selected');\n      // Do not focus the message if something within holds focus (e.g. object).\n      if (focusLastChild) {\n        this.setStickToBottom(false);\n        this.renderedItems[this.virtualSelectedIndex - this.firstActiveIndex].focusLastChildOrSelf();\n      } else if (!selectedElement.hasFocus()) {\n        selectedElement.focus({preventScroll: true});\n      }\n    }\n    if (this.itemCount && !this.contentElementInternal.hasFocus()) {\n      this.contentElementInternal.tabIndex = 0;\n    } else {\n      this.contentElementInternal.tabIndex = -1;\n    }\n    this.lastSelectedElement = selectedElement;\n  }\n\n  contentElement(): Element {\n    return this.contentElementInternal;\n  }\n\n  invalidate(): void {\n    delete this.cachedProviderElements;\n    this.itemCount = this.provider.itemCount();\n    if (this.virtualSelectedIndex > this.itemCount - 1) {\n      this.virtualSelectedIndex = this.itemCount - 1;\n    }\n    this.rebuildCumulativeHeights();\n    this.refresh();\n  }\n\n  private providerElement(index: number): ConsoleViewportElement|null {\n    if (!this.cachedProviderElements) {\n      this.cachedProviderElements = new Array(this.itemCount);\n    }\n    let element = this.cachedProviderElements[index];\n    if (!element) {\n      element = this.provider.itemElement(index);\n      this.cachedProviderElements[index] = element;\n    }\n    return element;\n  }\n\n  private rebuildCumulativeHeights(): void {\n    const firstActiveIndex = this.firstActiveIndex;\n    const lastActiveIndex = this.lastActiveIndex;\n    let height = 0;\n    this.cumulativeHeights = new Int32Array(this.itemCount);\n    for (let i = 0; i < this.itemCount; ++i) {\n      if (firstActiveIndex <= i && i - firstActiveIndex < this.renderedItems.length && i <= lastActiveIndex) {\n        height += this.renderedItems[i - firstActiveIndex].element().offsetHeight;\n      } else {\n        height += this.provider.fastHeight(i);\n      }\n      this.cumulativeHeights[i] = height;\n    }\n  }\n\n  private rebuildCumulativeHeightsIfNeeded(): void {\n    let totalCachedHeight = 0;\n    let totalMeasuredHeight = 0;\n    // Check whether current items in DOM have changed heights. Tolerate 1-pixel\n    // error due to double-to-integer rounding errors.\n    for (let i = 0; i < this.renderedItems.length; ++i) {\n      const cachedItemHeight = this.cachedItemHeight(this.firstActiveIndex + i);\n      const measuredHeight = this.renderedItems[i].element().offsetHeight;\n      if (Math.abs(cachedItemHeight - measuredHeight) > 1) {\n        this.rebuildCumulativeHeights();\n        return;\n      }\n      totalMeasuredHeight += measuredHeight;\n      totalCachedHeight += cachedItemHeight;\n      if (Math.abs(totalCachedHeight - totalMeasuredHeight) > 1) {\n        this.rebuildCumulativeHeights();\n        return;\n      }\n    }\n  }\n\n  private cachedItemHeight(index: number): number {\n    return index === 0 ? this.cumulativeHeights[0] : this.cumulativeHeights[index] - this.cumulativeHeights[index - 1];\n  }\n\n  private isSelectionBackwards(selection: Selection|null): boolean {\n    if (!selection || !selection.rangeCount || !selection.anchorNode || !selection.focusNode) {\n      return false;\n    }\n    const range = document.createRange();\n    range.setStart(selection.anchorNode, selection.anchorOffset);\n    range.setEnd(selection.focusNode, selection.focusOffset);\n    return range.collapsed;\n  }\n\n  private createSelectionModel(itemIndex: number, node: Node, offset: number): {\n    item: number,\n    node: Node,\n    offset: number,\n  } {\n    return {item: itemIndex, node: node, offset: offset};\n  }\n\n  private updateSelectionModel(selection: Selection|null): boolean {\n    const range = selection && selection.rangeCount ? selection.getRangeAt(0) : null;\n    if (!range || (!selection || selection.isCollapsed) || !this.element.hasSelection()) {\n      this.headSelection = null;\n      this.anchorSelection = null;\n      return false;\n    }\n\n    let firstSelectedIndex: number = Number.MAX_VALUE;\n    let lastSelectedIndex = -1;\n\n    let hasVisibleSelection = false;\n    for (let i = 0; i < this.renderedItems.length; ++i) {\n      if (range.intersectsNode(this.renderedItems[i].element())) {\n        const index = i + this.firstActiveIndex;\n        firstSelectedIndex = Math.min(firstSelectedIndex, index);\n        lastSelectedIndex = Math.max(lastSelectedIndex, index);\n        hasVisibleSelection = true;\n      }\n    }\n    const topOverlap = range.intersectsNode(this.topGapElement) && this.topGapElementActive;\n    const bottomOverlap = range.intersectsNode(this.bottomGapElement) && this.bottomGapElementActive;\n    if (!topOverlap && !bottomOverlap && !hasVisibleSelection) {\n      this.headSelection = null;\n      this.anchorSelection = null;\n      return false;\n    }\n\n    if (!this.anchorSelection || !this.headSelection) {\n      this.anchorSelection = this.createSelectionModel(0, this.element, 0);\n      this.headSelection = this.createSelectionModel(this.itemCount - 1, this.element, this.element.children.length);\n      this.selectionIsBackward = false;\n    }\n\n    const isBackward = this.isSelectionBackwards(selection);\n    const startSelection = this.selectionIsBackward ? this.headSelection : this.anchorSelection;\n    const endSelection = this.selectionIsBackward ? this.anchorSelection : this.headSelection;\n    let firstSelected: SelectionModel|null = null;\n    let lastSelected: SelectionModel|null = null;\n    if (hasVisibleSelection) {\n      firstSelected = this.createSelectionModel(firstSelectedIndex, (range.startContainer as Node), range.startOffset);\n      lastSelected = this.createSelectionModel(lastSelectedIndex, (range.endContainer as Node), range.endOffset);\n    }\n    if (topOverlap && bottomOverlap && hasVisibleSelection) {\n      firstSelected = (firstSelected && firstSelected.item < startSelection.item) ? firstSelected : startSelection;\n      lastSelected = (lastSelected && lastSelected.item > endSelection.item) ? lastSelected : endSelection;\n    } else if (!hasVisibleSelection) {\n      firstSelected = startSelection;\n      lastSelected = endSelection;\n    } else if (topOverlap) {\n      firstSelected = isBackward ? this.headSelection : this.anchorSelection;\n    } else if (bottomOverlap) {\n      lastSelected = isBackward ? this.anchorSelection : this.headSelection;\n    }\n\n    if (isBackward) {\n      this.anchorSelection = lastSelected;\n      this.headSelection = firstSelected;\n    } else {\n      this.anchorSelection = firstSelected;\n      this.headSelection = lastSelected;\n    }\n    this.selectionIsBackward = isBackward;\n    return true;\n  }\n\n  private restoreSelection(selection: Selection|null): void {\n    if (!selection || !this.anchorSelection || !this.headSelection) {\n      return;\n    }\n\n    const clampSelection = (selection: SelectionModel, isSelectionBackwards: boolean): {\n      element: Node,\n      offset: number,\n    } => {\n      if (this.firstActiveIndex <= selection.item && selection.item <= this.lastActiveIndex) {\n        return {element: selection.node, offset: selection.offset};\n      }\n\n      const element = selection.item < this.firstActiveIndex ? this.topGapElement : this.bottomGapElement;\n      return {element, offset: isSelectionBackwards ? 1 : 0};\n    };\n\n    const {element: anchorElement, offset: anchorOffset} =\n        clampSelection(this.anchorSelection, Boolean(this.selectionIsBackward));\n    const {element: headElement, offset: headOffset} = clampSelection(this.headSelection, !this.selectionIsBackward);\n    selection.setBaseAndExtent(anchorElement, anchorOffset, headElement, headOffset);\n  }\n\n  private selectionContainsTable(): boolean {\n    if (!this.anchorSelection || !this.headSelection) {\n      return false;\n    }\n\n    const start = this.selectionIsBackward ? this.headSelection.item : this.anchorSelection.item;\n    const end = this.selectionIsBackward ? this.anchorSelection.item : this.headSelection.item;\n\n    for (let i = start; i <= end; i++) {\n      const element = (this.providerElement(i) as ConsoleViewMessage);\n      if (element && element.consoleMessage().type === 'table') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  refresh(): void {\n    this.observer.disconnect();\n    this.innerRefresh();\n    if (this.stickToBottomInternal) {\n      this.observer.observe(this.contentElementInternal, this.observerConfig);\n    }\n  }\n\n  private innerRefresh(): void {\n    if (!this.visibleHeight()) {\n      return;\n    }  // Do nothing for invisible controls.\n\n    if (!this.itemCount) {\n      for (let i = 0; i < this.renderedItems.length; ++i) {\n        this.renderedItems[i].willHide();\n      }\n      this.renderedItems = [];\n      this.contentElementInternal.removeChildren();\n      this.topGapElement.style.height = '0px';\n      this.bottomGapElement.style.height = '0px';\n      this.firstActiveIndex = -1;\n      this.lastActiveIndex = -1;\n      this.updateFocusedItem();\n      return;\n    }\n\n    const selection = this.element.getComponentSelection();\n    const shouldRestoreSelection = this.updateSelectionModel(selection);\n\n    const visibleFrom = this.element.scrollTop;\n    const visibleHeight = this.visibleHeight();\n    const activeHeight = visibleHeight * 2;\n    this.rebuildCumulativeHeightsIfNeeded();\n\n    // When the viewport is scrolled to the bottom, using the cumulative heights estimate is not\n    // precise enough to determine next visible indices. This stickToBottom check avoids extra\n    // calls to refresh in those cases.\n    if (this.stickToBottomInternal) {\n      this.firstActiveIndex = Math.max(this.itemCount - Math.ceil(activeHeight / this.provider.minimumRowHeight()), 0);\n      this.lastActiveIndex = this.itemCount - 1;\n    } else {\n      this.firstActiveIndex = Math.max(\n          Platform.ArrayUtilities.lowerBound(\n              this.cumulativeHeights, visibleFrom + 1 - (activeHeight - visibleHeight) / 2,\n              Platform.ArrayUtilities.DEFAULT_COMPARATOR),\n          0);\n      // Proactively render more rows in case some of them will be collapsed without triggering refresh. @see crbug.com/390169\n      this.lastActiveIndex = this.firstActiveIndex + Math.ceil(activeHeight / this.provider.minimumRowHeight()) - 1;\n      this.lastActiveIndex = Math.min(this.lastActiveIndex, this.itemCount - 1);\n    }\n\n    const topGapHeight = this.cumulativeHeights[this.firstActiveIndex - 1] || 0;\n    const bottomGapHeight =\n        this.cumulativeHeights[this.cumulativeHeights.length - 1] - this.cumulativeHeights[this.lastActiveIndex];\n\n    function prepare(this: ConsoleViewport): void {\n      this.topGapElement.style.height = topGapHeight + 'px';\n      this.bottomGapElement.style.height = bottomGapHeight + 'px';\n      this.topGapElementActive = Boolean(topGapHeight);\n      this.bottomGapElementActive = Boolean(bottomGapHeight);\n      this.contentElementInternal.style.setProperty('height', '10000000px');\n    }\n\n    this.partialViewportUpdate(prepare.bind(this));\n    this.contentElementInternal.style.removeProperty('height');\n    // Should be the last call in the method as it might force layout.\n    if (shouldRestoreSelection) {\n      this.restoreSelection(selection);\n    }\n    if (this.stickToBottomInternal) {\n      this.element.scrollTop = 10000000;\n    }\n  }\n\n  private partialViewportUpdate(prepare: () => void): void {\n    const itemsToRender = new Set<ConsoleViewportElement>();\n    for (let i = this.firstActiveIndex; i <= this.lastActiveIndex; ++i) {\n      const providerElement = this.providerElement(i);\n      console.assert(Boolean(providerElement), 'Expected provider element to be defined');\n      if (providerElement) {\n        itemsToRender.add(providerElement);\n      }\n    }\n    const willBeHidden = this.renderedItems.filter(item => !itemsToRender.has(item));\n    for (let i = 0; i < willBeHidden.length; ++i) {\n      willBeHidden[i].willHide();\n    }\n    prepare();\n    let hadFocus = false;\n    for (let i = 0; i < willBeHidden.length; ++i) {\n      hadFocus = hadFocus || willBeHidden[i].element().hasFocus();\n      willBeHidden[i].element().remove();\n    }\n\n    const wasShown = [];\n    let anchor: (ChildNode|null) = this.contentElementInternal.firstChild;\n    for (const viewportElement of itemsToRender) {\n      const element = viewportElement.element();\n      if (element !== anchor) {\n        const shouldCallWasShown = !element.parentElement;\n        if (shouldCallWasShown) {\n          wasShown.push(viewportElement);\n        }\n        this.contentElementInternal.insertBefore(element, anchor);\n      } else {\n        anchor = anchor.nextSibling;\n      }\n    }\n    for (let i = 0; i < wasShown.length; ++i) {\n      wasShown[i].wasShown();\n    }\n    this.renderedItems = Array.from(itemsToRender);\n\n    if (hadFocus) {\n      this.contentElementInternal.focus();\n    }\n    this.updateFocusedItem();\n  }\n\n  private selectedText(): string|null {\n    this.updateSelectionModel(this.element.getComponentSelection());\n    if (!this.headSelection || !this.anchorSelection) {\n      return null;\n    }\n\n    let startSelection: SelectionModel|null = null;\n    let endSelection: SelectionModel|null = null;\n    if (this.selectionIsBackward) {\n      startSelection = this.headSelection;\n      endSelection = this.anchorSelection;\n    } else {\n      startSelection = this.anchorSelection;\n      endSelection = this.headSelection;\n    }\n\n    const textLines = [];\n    for (let i = startSelection.item; i <= endSelection.item; ++i) {\n      const providerElement = this.providerElement(i);\n      console.assert(Boolean(providerElement));\n      if (!providerElement) {\n        continue;\n      }\n      const element = providerElement.element();\n      const lineContent = element.childTextNodes().map(Components.Linkifier.Linkifier.untruncatedNodeText).join('');\n      textLines.push(lineContent);\n    }\n\n    const endProviderElement = this.providerElement(endSelection.item);\n    const endSelectionElement = endProviderElement && endProviderElement.element();\n    if (endSelectionElement && endSelection.node && endSelection.node.isSelfOrDescendant(endSelectionElement)) {\n      const itemTextOffset = this.textOffsetInNode(endSelectionElement, endSelection.node, endSelection.offset);\n      if (textLines.length > 0) {\n        textLines[textLines.length - 1] = textLines[textLines.length - 1].substring(0, itemTextOffset);\n      }\n    }\n\n    const startProviderElement = this.providerElement(startSelection.item);\n    const startSelectionElement = startProviderElement && startProviderElement.element();\n    if (startSelectionElement && startSelection.node && startSelection.node.isSelfOrDescendant(startSelectionElement)) {\n      const itemTextOffset = this.textOffsetInNode(startSelectionElement, startSelection.node, startSelection.offset);\n      textLines[0] = textLines[0].substring(itemTextOffset);\n    }\n\n    return textLines.join('\\n');\n  }\n\n  private textOffsetInNode(itemElement: Element, selectionNode: Node, offset: number): number {\n    // If the selectionNode is not a TextNode, we may need to convert a child offset into a character offset.\n    const textContentLength = selectionNode.textContent ? selectionNode.textContent.length : 0;\n    if (selectionNode.nodeType !== Node.TEXT_NODE) {\n      if (offset < selectionNode.childNodes.length) {\n        selectionNode = (selectionNode.childNodes.item(offset) as Node);\n        offset = 0;\n      } else {\n        offset = textContentLength;\n      }\n    }\n\n    let chars = 0;\n    let node: Node|null = itemElement;\n    while ((node = node.traverseNextNode(itemElement)) && node !== selectionNode) {\n      if (node.nodeType !== Node.TEXT_NODE ||\n          (node.parentElement &&\n           (node.parentElement.nodeName === 'STYLE' || node.parentElement.nodeName === 'SCRIPT'))) {\n        continue;\n      }\n      chars += Components.Linkifier.Linkifier.untruncatedNodeText(node).length;\n    }\n    // If the selected node text was truncated, treat any non-zero offset as the full length.\n    const untruncatedContainerLength = Components.Linkifier.Linkifier.untruncatedNodeText(selectionNode).length;\n    if (offset > 0 && untruncatedContainerLength !== textContentLength) {\n      offset = untruncatedContainerLength;\n    }\n    return chars + offset;\n  }\n\n  private onScroll(_event: Event): void {\n    this.refresh();\n  }\n\n  firstVisibleIndex(): number {\n    if (!this.cumulativeHeights.length) {\n      return -1;\n    }\n    this.rebuildCumulativeHeightsIfNeeded();\n    return Platform.ArrayUtilities.lowerBound(\n        this.cumulativeHeights, this.element.scrollTop + 1, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n  }\n\n  lastVisibleIndex(): number {\n    if (!this.cumulativeHeights.length) {\n      return -1;\n    }\n    this.rebuildCumulativeHeightsIfNeeded();\n    const scrollBottom = this.element.scrollTop + this.element.clientHeight;\n    const right = this.itemCount - 1;\n    return Platform.ArrayUtilities.lowerBound(\n        this.cumulativeHeights, scrollBottom, Platform.ArrayUtilities.DEFAULT_COMPARATOR, undefined, right);\n  }\n\n  renderedElementAt(index: number): HTMLElement|null {\n    if (index === -1 || index < this.firstActiveIndex || index > this.lastActiveIndex) {\n      return null;\n    }\n    return this.renderedItems[index - this.firstActiveIndex].element();\n  }\n\n  scrollItemIntoView(index: number, makeLast?: boolean): void {\n    const firstVisibleIndex = this.firstVisibleIndex();\n    const lastVisibleIndex = this.lastVisibleIndex();\n    if (index > firstVisibleIndex && index < lastVisibleIndex) {\n      return;\n    }\n    // If the prompt is visible, then the last item must be fully on screen.\n    if (index === lastVisibleIndex && this.cumulativeHeights[index] <= this.element.scrollTop + this.visibleHeight()) {\n      return;\n    }\n    if (makeLast) {\n      this.forceScrollItemToBeLast(index);\n    } else if (index <= firstVisibleIndex) {\n      this.forceScrollItemToBeFirst(index);\n    } else if (index >= lastVisibleIndex) {\n      this.forceScrollItemToBeLast(index);\n    }\n  }\n\n  forceScrollItemToBeFirst(index: number): void {\n    console.assert(index >= 0 && index < this.itemCount, 'Cannot scroll item at invalid index');\n    this.setStickToBottom(false);\n    this.rebuildCumulativeHeightsIfNeeded();\n    this.element.scrollTop = index > 0 ? this.cumulativeHeights[index - 1] : 0;\n    if (UI.UIUtils.isScrolledToBottom(this.element)) {\n      this.setStickToBottom(true);\n    }\n    this.refresh();\n    // After refresh, the item is in DOM, but may not be visible (items above were larger than expected).\n    const renderedElement = this.renderedElementAt(index);\n    if (renderedElement) {\n      renderedElement.scrollIntoView(true /* alignTop */);\n    }\n  }\n\n  forceScrollItemToBeLast(index: number): void {\n    console.assert(index >= 0 && index < this.itemCount, 'Cannot scroll item at invalid index');\n    this.setStickToBottom(false);\n    this.rebuildCumulativeHeightsIfNeeded();\n    this.element.scrollTop = this.cumulativeHeights[index] - this.visibleHeight();\n    if (UI.UIUtils.isScrolledToBottom(this.element)) {\n      this.setStickToBottom(true);\n    }\n    this.refresh();\n    // After refresh, the item is in DOM, but may not be visible (items above were larger than expected).\n    const renderedElement = this.renderedElementAt(index);\n    if (renderedElement) {\n      renderedElement.scrollIntoView(false /* alignTop */);\n    }\n  }\n\n  private visibleHeight(): number {\n    // Use offsetHeight instead of clientHeight to avoid being affected by horizontal scroll.\n    return this.element.offsetHeight;\n  }\n}\n\nexport interface ConsoleViewportProvider {\n  fastHeight(index: number): number;\n  itemCount(): number;\n  minimumRowHeight(): number;\n  itemElement(index: number): ConsoleViewportElement|null;\n}\n\nexport interface ConsoleViewportElement {\n  willHide(): void;\n  wasShown(): void;\n  element(): HTMLElement;\n  focusLastChildOrSelf(): void;\n}\n"],
  "mappings": "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",
  "names": []
}
