{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/console/ErrorStackParser.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport type * as Platform from '../../core/platform/platform.js';\nimport type * as SDK from '../../core/sdk/sdk.js';\nimport type * as Protocol from '../../generated/protocol.js';\n\nexport interface ParsedErrorFrame {\n  line: string;\n  link?: {\n    url: Platform.DevToolsPath.UrlString,\n    prefix: string,\n    suffix: string,\n    lineNumber?: number,\n    columnNumber?: number, enclosedInBraces: boolean,\n    scriptId?: Protocol.Runtime.ScriptId,\n  };\n}\n\n/**\n * Takes a V8 Error#stack string and extracts source position information.\n *\n * The result includes the url, line and column number, as well as where\n * the url is found in the raw line.\n *\n * @returns Null if the provided string has an unexpected format. A\n *          populated `ParsedErrorFrame[]` otherwise.\n */\nexport function parseSourcePositionsFromErrorStack(\n    runtimeModel: SDK.RuntimeModel.RuntimeModel, stack: string): ParsedErrorFrame[]|null {\n  if (!/^[\\w.]*Error\\b/.test(stack)) {\n    return null;\n  }\n  const debuggerModel = runtimeModel.debuggerModel();\n  const baseURL = runtimeModel.target().inspectedURL();\n\n  const lines = stack.split('\\n');\n  const linkInfos = [];\n  for (const line of lines) {\n    const isCallFrameLine = /^\\s*at\\s/.test(line);\n    if (!isCallFrameLine && linkInfos.length && linkInfos[linkInfos.length - 1].link) {\n      return null;\n    }\n\n    if (!isCallFrameLine) {\n      linkInfos.push({line});\n      continue;\n    }\n\n    let openBracketIndex = -1;\n    let closeBracketIndex = -1;\n    const inBracketsWithLineAndColumn = /\\([^\\)\\(]+:\\d+:\\d+\\)/g;\n    const inBrackets = /\\([^\\)\\(]+\\)/g;\n    let lastMatch: RegExpExecArray|null = null;\n    let currentMatch;\n    while ((currentMatch = inBracketsWithLineAndColumn.exec(line))) {\n      lastMatch = currentMatch;\n    }\n    if (!lastMatch) {\n      while ((currentMatch = inBrackets.exec(line))) {\n        lastMatch = currentMatch;\n      }\n    }\n    if (lastMatch) {\n      openBracketIndex = lastMatch.index;\n      closeBracketIndex = lastMatch.index + lastMatch[0].length - 1;\n    }\n    const hasOpenBracket = openBracketIndex !== -1;\n    let left = hasOpenBracket ? openBracketIndex + 1 : line.indexOf('at') + 3;\n    if (!hasOpenBracket && line.indexOf('async ') === left) {\n      left += 6;\n    }\n    const right = hasOpenBracket ? closeBracketIndex : line.length;\n    const linkCandidate = line.substring(left, right);\n    const splitResult = Common.ParsedURL.ParsedURL.splitLineAndColumn(linkCandidate);\n    if (splitResult.url === '<anonymous>') {\n      linkInfos.push({line});\n      continue;\n    }\n    let url = parseOrScriptMatch(debuggerModel, splitResult.url);\n    if (!url && Common.ParsedURL.ParsedURL.isRelativeURL(splitResult.url)) {\n      url = parseOrScriptMatch(debuggerModel, Common.ParsedURL.ParsedURL.completeURL(baseURL, splitResult.url));\n    }\n    if (!url) {\n      return null;\n    }\n\n    linkInfos.push({\n      line,\n      link: {\n        url,\n        prefix: line.substring(0, left),\n        suffix: line.substring(right),\n        enclosedInBraces: hasOpenBracket,\n        lineNumber: splitResult.lineNumber,\n        columnNumber: splitResult.columnNumber,\n      },\n    });\n  }\n  return linkInfos;\n}\n\nfunction parseOrScriptMatch(debuggerModel: SDK.DebuggerModel.DebuggerModel, url: Platform.DevToolsPath.UrlString|null):\n    Platform.DevToolsPath.UrlString|null {\n  if (!url) {\n    return null;\n  }\n  if (Common.ParsedURL.ParsedURL.isValidUrlString(url)) {\n    return url;\n  }\n  if (debuggerModel.scriptsForSourceURL(url).length) {\n    return url;\n  }\n  // nodejs stack traces contain (absolute) file paths, but v8 reports them as file: urls.\n  const fileUrl = new URL(url, 'file://');\n  if (debuggerModel.scriptsForSourceURL(fileUrl.href).length) {\n    return fileUrl.href as Platform.DevToolsPath.UrlString;\n  }\n  return null;\n}\n\n/**\n * Error#stack output only contains script URLs. In some cases we are able to\n * retrieve additional exception details from V8 that we can use to augment\n * the parsed Error#stack with script IDs.\n * This function sets the `scriptId` field in `ParsedErrorFrame` when it finds\n * the corresponding info in `Protocol.Runtime.StackTrace`.\n */\nexport function augmentErrorStackWithScriptIds(\n    parsedFrames: ParsedErrorFrame[], protocolStackTrace: Protocol.Runtime.StackTrace): void {\n  // Note that the number of frames between the two stack traces can differ. The\n  // parsed Error#stack can contain Builtin frames which are not present in the protocol\n  // stack. This means its easier to always search the whole protocol stack for a matching\n  // frame rather then trying to detect the Builtin frames and skipping them.\n  for (const parsedFrame of parsedFrames) {\n    const protocolFrame = protocolStackTrace.callFrames.find(frame => framesMatch(parsedFrame, frame));\n    if (protocolFrame && parsedFrame.link) {\n      parsedFrame.link.scriptId = protocolFrame.scriptId;\n    }\n  }\n}\n\n/** Returns true iff both stack frames have the same url and line/column numbers. The function name is ignored */\nfunction framesMatch(parsedFrame: ParsedErrorFrame, protocolFrame: Protocol.Runtime.CallFrame): boolean {\n  if (!parsedFrame.link) {\n    return false;\n  }\n\n  const {url, lineNumber, columnNumber} = parsedFrame.link;\n  return url === protocolFrame.url && lineNumber === protocolFrame.lineNumber &&\n      columnNumber === protocolFrame.columnNumber;\n}\n"],
  "mappings": "AAIA;AA0BO,mDACH,cAA6C,OAAwC;AACvF,MAAI,CAAC,iBAAiB,KAAK,QAAQ;AACjC,WAAO;AAAA;AAET,QAAM,gBAAgB,aAAa;AACnC,QAAM,UAAU,aAAa,SAAS;AAEtC,QAAM,QAAQ,MAAM,MAAM;AAC1B,QAAM,YAAY;AAClB,aAAW,QAAQ,OAAO;AACxB,UAAM,kBAAkB,WAAW,KAAK;AACxC,QAAI,CAAC,mBAAmB,UAAU,UAAU,UAAU,UAAU,SAAS,GAAG,MAAM;AAChF,aAAO;AAAA;AAGT,QAAI,CAAC,iBAAiB;AACpB,gBAAU,KAAK,EAAC;AAChB;AAAA;AAGF,QAAI,mBAAmB;AACvB,QAAI,oBAAoB;AACxB,UAAM,8BAA8B;AACpC,UAAM,aAAa;AACnB,QAAI,YAAkC;AACtC,QAAI;AACJ,WAAQ,eAAe,4BAA4B,KAAK,OAAQ;AAC9D,kBAAY;AAAA;AAEd,QAAI,CAAC,WAAW;AACd,aAAQ,eAAe,WAAW,KAAK,OAAQ;AAC7C,oBAAY;AAAA;AAAA;AAGhB,QAAI,WAAW;AACb,yBAAmB,UAAU;AAC7B,0BAAoB,UAAU,QAAQ,UAAU,GAAG,SAAS;AAAA;AAE9D,UAAM,iBAAiB,qBAAqB;AAC5C,QAAI,OAAO,iBAAiB,mBAAmB,IAAI,KAAK,QAAQ,QAAQ;AACxE,QAAI,CAAC,kBAAkB,KAAK,QAAQ,cAAc,MAAM;AACtD,cAAQ;AAAA;AAEV,UAAM,QAAQ,iBAAiB,oBAAoB,KAAK;AACxD,UAAM,gBAAgB,KAAK,UAAU,MAAM;AAC3C,UAAM,cAAc,OAAO,UAAU,UAAU,mBAAmB;AAClE,QAAI,YAAY,QAAQ,eAAe;AACrC,gBAAU,KAAK,EAAC;AAChB;AAAA;AAEF,QAAI,MAAM,mBAAmB,eAAe,YAAY;AACxD,QAAI,CAAC,OAAO,OAAO,UAAU,UAAU,cAAc,YAAY,MAAM;AACrE,YAAM,mBAAmB,eAAe,OAAO,UAAU,UAAU,YAAY,SAAS,YAAY;AAAA;AAEtG,QAAI,CAAC,KAAK;AACR,aAAO;AAAA;AAGT,cAAU,KAAK;AAAA,MACb;AAAA,MACA,MAAM;AAAA,QACJ;AAAA,QACA,QAAQ,KAAK,UAAU,GAAG;AAAA,QAC1B,QAAQ,KAAK,UAAU;AAAA,QACvB,kBAAkB;AAAA,QAClB,YAAY,YAAY;AAAA,QACxB,cAAc,YAAY;AAAA;AAAA;AAAA;AAIhC,SAAO;AAAA;AAGT,4BAA4B,eAAgD,KACnC;AACvC,MAAI,CAAC,KAAK;AACR,WAAO;AAAA;AAET,MAAI,OAAO,UAAU,UAAU,iBAAiB,MAAM;AACpD,WAAO;AAAA;AAET,MAAI,cAAc,oBAAoB,KAAK,QAAQ;AACjD,WAAO;AAAA;AAGT,QAAM,UAAU,IAAI,IAAI,KAAK;AAC7B,MAAI,cAAc,oBAAoB,QAAQ,MAAM,QAAQ;AAC1D,WAAO,QAAQ;AAAA;AAEjB,SAAO;AAAA;AAUF,+CACH,cAAkC,oBAAuD;AAK3F,aAAW,eAAe,cAAc;AACtC,UAAM,gBAAgB,mBAAmB,WAAW,KAAK,WAAS,YAAY,aAAa;AAC3F,QAAI,iBAAiB,YAAY,MAAM;AACrC,kBAAY,KAAK,WAAW,cAAc;AAAA;AAAA;AAAA;AAMhD,qBAAqB,aAA+B,eAAoD;AACtG,MAAI,CAAC,YAAY,MAAM;AACrB,WAAO;AAAA;AAGT,QAAM,EAAC,KAAK,YAAY,iBAAgB,YAAY;AACpD,SAAO,QAAQ,cAAc,OAAO,eAAe,cAAc,cAC7D,iBAAiB,cAAc;AAAA;",
  "names": []
}
