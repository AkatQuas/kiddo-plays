import { app, BrowserWindow, dialog, ipcMain } from 'electron';
import { writeFileSync } from 'fs';
import {
  createMarkwonContextMenu,
  updateApplicationMenu,
} from './application-menu';
import {
  CREATE_NEW_WINDOW,
  OPEN_CONTEXT_MENU,
  OPEN_FILE,
  OPEN_FILE_DIALOG,
  SAVE_FILE,
  SAVE_HTML,
  UPDATE_WINDOW_TITLE,
} from './constants';
import './crash-reporter';
import { initializeTray, updateTrayMenu } from './tray';
import {
  getFileFromUserCaution,
  getFocusedWindowPosition,
  openFileForWindow,
  stopWatchingFile,
} from './utils';
// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const windows = new Set<BrowserWindow>();

export function createWindow(): BrowserWindow {
  const { x, y } = getFocusedWindowPosition();
  let newWindow = new BrowserWindow({
    x,
    y,
    height: 600,
    width: 800,
    show: false,
    webPreferences: {
      /* it works on start, but NOT in production */
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
    },
  });

  newWindow.webContents.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  newWindow.on('focus', updateApplicationMenu);
  newWindow.on('ready-to-show', () => {
    newWindow.show();
  });
  newWindow.on('close', (event) => {
    if (newWindow.isDocumentEdited()) {
      event.preventDefault();
      dialog
        .showMessageBox(newWindow, {
          type: 'warning',
          title: 'Quit with Unsaved Changes?',
          message: 'Your changes might be lost.',
          buttons: ['Quit Anyway', 'Whatever', 'Cancel'],
          defaultId: 0,
          cancelId: 2,
        })
        .then(({ response }) => {
          if (response === 0) {
            newWindow.destroy();
          }
          if (response === 1) {
            dialog.showMessageBox(newWindow, {
              type: 'question',
              message: 'What is the matter with you ??',
              buttons: ['Leave!'],
            });
          }
        });
    }
  });
  newWindow.on('closed', () => {
    windows.delete(newWindow);
    stopWatchingFile(newWindow);
    newWindow = null;
    updateApplicationMenu();
  });

  // Open the DevTools.
  newWindow.webContents.openDevTools();

  windows.add(newWindow);
  return newWindow;
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  if (app.dock) {
    app.dock.hide();
  }
  updateApplicationMenu();
  createWindow();
  initializeTray().then(() => {
    updateTrayMenu();
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform === 'darwin') {
    return;
  }
  app.quit();
});

app.on('activate', (event, hasVisibleWindows) => {
  //
  // console.log(`event`, event);
  // console.log(`hasVisibleWindows`, hasVisibleWindows);
  //
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.once('will-finish-launching', () => {
  app.on('open-file', (event, filePath) => {
    const win = createWindow();
    win.once('ready-to-show', () => {
      openFileForWindow(win, filePath);
    });
  });
});

ipcMain.on(CREATE_NEW_WINDOW, () => {
  createWindow();
});

/**
 * renderer got drag&drop file
 * so main render the file content to currentWindow
 */
ipcMain.on(OPEN_FILE, (event, filePath) => {
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (!currentWindow) {
    return;
  }
  openFileForWindow(currentWindow, filePath);
});

/**
 * renderer ask to open file dialog
 */
ipcMain.on(OPEN_FILE_DIALOG, async () => {
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (!currentWindow) {
    return;
  }
  getFileFromUserCaution(currentWindow);
});

/**
 * renderer ask to update window title
 */
ipcMain.on(UPDATE_WINDOW_TITLE, (event, title: string, isEdited: boolean) => {
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (!currentWindow) {
    return;
  }
  currentWindow.setTitle(title);
  currentWindow.setDocumentEdited(isEdited);
});

/**
 * renderer ask to save file as markdown
 */
ipcMain.on(SAVE_FILE, async (event, filePath, content) => {
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (!currentWindow) {
    return;
  }
  let file = filePath;
  if (!file) {
    file = await dialog.showSaveDialog(currentWindow, {
      title: 'Save Markdown',
      defaultPath: app.getPath('documents'),
      buttonLabel: 'save2html',
      filters: [{ name: 'Markdown Files', extensions: ['md', 'markdown'] }],
    });
  }
  if (!file) {
    return;
  }
  writeFileSync(file, content);
  openFileForWindow(currentWindow, file);
});

/**
 * renderer ask save as html file
 */
ipcMain.on(SAVE_HTML, (event, content: string) => {
  const currentWindow = BrowserWindow.getFocusedWindow();
  if (!currentWindow) {
    return;
  }
  dialog
    .showSaveDialog(currentWindow, {
      title: 'Save HTML',
      defaultPath: app.getPath('documents'),
      buttonLabel: 'save2html',
      filters: [{ name: 'HTML Files', extensions: ['html', 'htm'] }],
    })
    .then(({ filePath }) => {
      if (!filePath) {
        return;
      }
      writeFileSync(filePath, content);
    });
});

/**
 * renderer with context menu popup
 */
ipcMain.on(OPEN_CONTEXT_MENU, (event, filePath: string) => {
  createMarkwonContextMenu(filePath).popup();
});
